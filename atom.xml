<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benny Huo</title>
  
  <subtitle>学海无涯，其乐无穷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2024-07-21T13:13:12.821Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Benny Huo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023 年总结</title>
    <link href="https://www.bennyhuo.com//2024/01/01/summary-2023/"/>
    <id>https://www.bennyhuo.com//2024/01/01/summary-2023/</id>
    <published>2024-01-01T22:01:01.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2023 年也是充实的一年。 </p></blockquote><span id="more"></span><p>全民制作人们大家好，又到了一年一度的汇报时间。</p><h2 id="账号更名为“霍丙乾-bennyhuo”"><a href="#账号更名为“霍丙乾-bennyhuo”" class="headerlink" title="账号更名为“霍丙乾 bennyhuo”"></a>账号更名为“霍丙乾 bennyhuo”</h2><p>年初做了一件比较重要的事情，就是账号更名，主要涉及到以下几个平台：</p><ul><li>Bilibili、YouTube、掘金、抖音等：从 “bennyhuo 不是算命的” 改为 “霍丙乾 bennyhuo”</li><li>微信公众号：从 “Kotlin” 改为 “霍丙乾 bennyhuo”</li></ul><p>这其中涉及到几个小问题，为了不给大家造成困扰，我简单再做下解释。</p><h3 id="1-我的微信公众号为什么叫-“Kotlin”？"><a href="#1-我的微信公众号为什么叫-“Kotlin”？" class="headerlink" title="1. 我的微信公众号为什么叫 “Kotlin”？"></a>1. 我的微信公众号为什么叫 “Kotlin”？</h3><p>2016 年，我注册了一个名为“Kotlin”的微信公众号，用来发布 Kotlin 的推广视频。2020 年前后，JetBrains 开始在国内投入专人负责社区的建设和运营，微信公众号 “Kotlin” 则主要用于转发官方文章。当时我的主要精力 B 站账号的建设上，输出形式也以视频为主。2023 年，有一些朋友问我为什么视频不发公众号，因为我很少会将与 Kotlin 无关的视频同步到微信公众号 “Kotlin” 上。</p><p>思考再三，我跟 JetBrains 的朋友提了一下我的想法：我们可能需要一个真正意义上的 Kotlin 官方号。这就是我的所有账号更名的由来。</p><p>如果大家希望持续关注 Kotlin 的发展，强烈建议大家关注官方微信公众号 <strong>Kotlin 开发者</strong>。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101171220.png"></p><p>如果你平常也喜欢在 Bilibili 上看视频，也建议关注 JetBrains 的官方账号 <strong>JetBrains中国</strong>：</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101171708.png"></p><p>我个人也会持续关注 Kotlin 的发展，并且在 Kotlin 发布新版本之后，也会以视频的形式为大家介绍其中的新特性。</p><h3 id="2-为什么不统一更名为-“bennyhuo-不是算命的”？"><a href="#2-为什么不统一更名为-“bennyhuo-不是算命的”？" class="headerlink" title="2. 为什么不统一更名为 “bennyhuo 不是算命的”？"></a>2. 为什么不统一更名为 “bennyhuo 不是算命的”？</h3><p>我最初确实想统一成 “bennyhuo 不是算命的”，但微信公众号的名称中禁止出现“算命”，因此只好再选一个名字。想来想去，干脆用自己的真名好了，省事儿。</p><p>顺便提一句，“bennyhuo” 是我在腾讯打工的时候的“代号”。</p><h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><p>今年在 B 站、YouTube、抖音、微信公众号同步发视频，欢迎在你喜欢的平台搜索：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a> 并持续关注。</p><p>其中，B 站仍然是我视频发布的最主要的平台。2023 年全年发布视频 127 个，总计播放 60 万次。其中，所有视频累计播放在 6 月份突破了 100 万次，单稿播放最高纪录靠鸿蒙刷到了 7 万+。订阅量从年初的 17500 左右增长到接近 23500，平均每天净增长 15，<strong>谢谢大家的关注和一键三连</strong>。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20231231224603.png"></p><p>2023 年的视频仍然以读书视频为主。</p><ul><li><a href="https://www.bilibili.com/video/BV13T4y1k7qQ/">《现代 C++ 特性解析》更新至第十二章，共 18 集</a></li><li><a href="https://www.bilibili.com/video/BV1NR4y1A7Tk/">《Rust 程序设计语言》更新至第十六章，共 33 集</a></li><li><a href="https://www.bilibili.com/video/BV1454y1g7Lx/">《Java 核心技术》更新至 3.6，共 35 集</a></li></ul><p>此外，还有一些编程语言版本新特性的视频：</p><ol><li>Kotlin 版本更新的视频：<ul><li><a href="https://www.bilibili.com/video/BV16s4y147m1/">Kotlin 1.8 共 5 期</a></li><li><a href="https://www.bilibili.com/video/BV1DP411k7xs/">Kotlin 1.9 共 1 期</a></li></ul></li><li>Java 版本更新的视频：<ul><li><a href="https://www.bilibili.com/video/BV1MB4y1f73i/">Java 21 共 8 期</a></li></ul></li></ol><p>年底的时候新开<a href="https://www.bilibili.com/video/BV18a4y1S7Em/">鸿蒙的坑，共计发布视频 6 个</a>：</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20231231230412.png"></p><p>2024 年计划将《Rust 程序设计语言》按照现在的形式继续更完。而《现代 C++ 特性解析》《Java 核心技术》就不再按照现有的形式继续读下去了，因为这几本书的内容都很多，想要更完并不容易。C++ 和 Java 相关的视频将会参考这些书籍，以一种更加紧凑的形式更新下去。至于为什么要坚持更完 Rust 那本，显然，它最简单，内容也最少。</p><p>后面会有鸿蒙开发教程吗？答案是：不会。成体系的内容做起来费时费力，时间精力跟不上。不过，不出意外的话，我大概率会在 2024 年投入很大的精力参与鸿蒙 NEXT 的适配工作，因此遇到一些有意思的内容还是会不断与大家分享的。</p><p>还会开新坑吗？答案是：可能会有，但可能不会有类似于 Rust 读书这种成体系的视频了。因为我自己的想法天天变，也实在是不太想被自己挖的坑束缚了。</p><p>其实核心就一个：更新视频是一件令人<strong>开心</strong>的事儿，它不能成为我的负担。</p><h2 id="文字内容"><a href="#文字内容" class="headerlink" title="文字内容"></a>文字内容</h2><p>今年文章写得不多，笑死，因为根本就没写。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094139.png"></p><p>好消息是 <strong><a href="https://item.jd.com/10081757341486.html">《深入实践 Kotlin 元编程》</a></strong> 在 2023 年 8 月出版了。这是我的第二本书，内容有一定的难度，适合有进阶需求的 Kotlin 开发者。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094107.png"></p><h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>今年的社区活动，一共有八次，分享了六个不同的主题。其中线上活动五次，线下活动三次。顺便提一句，12 月参加完天津 GDG 的活动之后自驾去海边吹冷风，特别爽。</p><ul><li>2023.12 机械工业出版社: <strong><a href="https://www.bilibili.com/video/BV14e41167CM/">我们对 Java 有哪些常见的误区？</a></strong></li><li>2023.11、12 GDG DevFest: <strong><a href="https://www.bilibili.com/video/BV1mN411j7tp/">使用 Kotlin 元编程技术提升开发效率</a></strong></li><li>2023.09 JetBrains 码上道: <strong><a href="https://www.bilibili.com/video/BV1yg4y1d7P6/">Kotlin 开发者的首“锈”:Rust 到底香不香?</a></strong></li><li>2023.05、06 Java 核心技术大会: <strong><a href="https://www.bilibili.com/video/BV1j8411S779/">Java 的现代化 - 包袱、挑战和革新</a></strong></li><li>2023.05 北京 KUG: <strong><a href="https://www.bilibili.com/video/BV1ck4y1j7Pa/">你想知道的 Jetpack Compose 的编译器黑魔法</a></strong></li><li>2023.04 GDG 社区说: <strong><a href="https://www.bilibili.com/video/BV1Rm4y127hj/">如何开发一款 Kotlin 编译器插件？</a></strong></li></ul><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101215333.png"></p><p>在天津 GDG 的活动上，有位现场的朋友提问，K2 编译器中还会有 PSI 吗？我当时一时没有反应过来，就说回去查证一下再来答复，结果忘了留他的联系方式，只好在这里做一下回答。</p><p>其实 FIR 的所有语法节点都有一个 source 的字段用来获取原始的 PSI，如果我们想要分析代码的注释，还是需要通过 PSI 来获取的。所以 PSI 不能说完全去掉了，只是被降级了。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>2023 年在开源项目上的投入不大，主要还是以维护之前的项目为主。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094759.png"></p><p>其中新开源项目 <a href="https://github.com/kanyun-inc/Kudos">kanyun-inc/Kudos</a>，解决了 Gson 等 JSON 框架在反序列化时不支持 Kotlin 类型空安全、构造器参数默认值等问题。</p><p>最近在适配鸿蒙时，还尝试为 Ktor 提供了鸿蒙的 Client 实现，参见：<a href="https://github.com/kotlin-for-ohos/ktor">kotlin-for-ohos/ktor</a>。</p><p>全年的统计数据可以参考：</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094655.png"></p><h2 id="知识星球"><a href="#知识星球" class="headerlink" title="知识星球"></a>知识星球</h2><p>知识星球试运营一年，发布了一些会员视频，包括：</p><ul><li>《深入实践 Kotlin 元编程》的读书视频，共 12 期</li><li>会员月刊 共 13 期</li></ul><p>之前想开个新栏目，会员朋友们建议更新一些 LeetCode 的刷题视频。结果因为年底事儿太多，一直拖更，隔壁 AB 老师都已经更到停更了，我还没开始。这个专栏争取要在 2024 年更起来。</p><p>感谢各位星球会员朋友们的支持。</p><h2 id="初心与愿景"><a href="#初心与愿景" class="headerlink" title="初心与愿景"></a>初心与愿景</h2><h3 id="为什么做技术分享"><a href="#为什么做技术分享" class="headerlink" title="为什么做技术分享"></a>为什么做技术分享</h3><p>十多年前，我刚开始学习编程的时候，网传的各类视频教程给予了我非常大的帮助。我并不是天赋型选手，花了很长时间才学会如何通过翻阅文档和源码来学习新知识。正因为如此，我觉得技术分享是非常有意义的，对于一部分人来说会有很大的帮助。</p><p>当然，做技术分享也是有很多好处的，我自己也非常乐于分享。</p><ol><li>对于一个几乎没有社交活动的人来说，做技术分享是我认识一些很纯粹的朋友的重要渠道。</li><li>做技术分享还可以不断让自己反复对知识进行求证，反复摔打自己的知识体系，促进自己的技术成长。</li><li>做分享还可以锻炼自己的表达能力，让自己逐渐适应更大的舞台。</li><li>做分享可以提升自己的影响力，这实际上也是一种非常奇妙的体验。</li></ol><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101221536.png"></p><p>因此，我也非常建议大家尝试一下做一些分享，这仍然是一个自媒体的时代，镜头和舞台可以给到每一个人。</p><h3 id="什么时候开始“恰饭”？"><a href="#什么时候开始“恰饭”？" class="headerlink" title="什么时候开始“恰饭”？"></a>什么时候开始“恰饭”？</h3><p>我看视频评论的时候遇到好几次，“听声音好熟悉，跟慕课网讲 C 语言的老师是同一个人吗” 的疑问。其实之前我在慕课网发布过几门课程，不过因为个人精力和身体原因，我已经决定不再慕课网继续发布新课了。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101181024.png"></p><p>说起来，今年还花时间更新了一下 C 语言课，优化了一下视频的内容，增加了常见问题的答疑，之前学习过这门课的朋友可以回去看一下更新的内容是否有帮助。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101181506.png"></p><p>如果有朋友有兴趣在慕课网做讲师，我可以帮忙推荐给慕课网。</p><p>说回 B 站，我在 2023 年把视频的收益关掉了，因为实在太少了，指望靠这个买 mac studio，我估计差不多都可以买到 M10 MAX 了。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101180402.png"></p><p>细心的朋友们可能还会发现，我的视频里面几乎都没有明示或暗示过大家投币三连，早期还有一个统一的求关注的结尾，后来我也干脆去掉了。</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101180642.png" alt="早期的视频结尾，现在的视频已经没有了"></p><p>我希望被更多人关注吗？当然。</p><p>我希望我的视频播放量上涨吗？当然。</p><p>不过，我更希望我的视频纯粹一些。因此我应该不会在视频里面添加视频内容无关的引导。希望大家通过我的视频有所收获，大家投币点赞也是因为觉得这些视频值得。</p><p>至于后面怎么恰饭，如果真的到了需要向生活低头的时候，我大概会把我的知识星球发出来。</p><h3 id="微信群群规"><a href="#微信群群规" class="headerlink" title="微信群群规"></a>微信群群规</h3><p>为了方便交流，我也拉了一些微信群。熟悉的朋友们知道，我一直坚持要求大家在群里做技术交流，不要高屋建瓴的关心世界，更不要输出负能量。</p><p>为什么呢？因为我们的眼界有限，很多见解自以为精妙绝伦，实际上无比稚嫩；退一步讲，就算我们能讨论出有建设性的意见，我们又有什么渠道能够让意见落实呢？更多的，往往是群友们互相断章取义，发展到对人口诛笔伐，最终搞得群里乌烟瘴气。</p><p>技术群是为了交流技术，哪怕交流如何跟无良领导作斗争我觉得都可以接受，我甚至会帮忙出出主意，但如果只是想要宣泄不满，建议换个地方。我们都难免遭遇不公，也都难免经历委屈，除非你成为强者，否则谁又愿意听你哭诉呢？</p><p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101221041.png"></p><p>先想办法成为强者，再想怎么改变世界。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望大家在 2024 年身体健康，工作顺心。</p><p>2024 继续加油。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2023 年也是充实的一年。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="2023" scheme="https://www.bennyhuo.com/tags/2023/"/>
    
      <category term="总结" scheme="https://www.bennyhuo.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>现代 Java（1）：Java 也支持类型推断了？</title>
    <link href="https://www.bennyhuo.com//2023/09/23/Java-New-01-var/"/>
    <id>https://www.bennyhuo.com//2023/09/23/Java-New-01-var/</id>
    <published>2023-09-23T20:09:03.000Z</published>
    <updated>2024-07-21T13:13:12.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2023/09/04/Java-New-00-foreword/">现代 Java（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2023/09/23/Java-New-01-var/">现代 Java（1）：Java 也支持类型推断了？</a></li></ul><p>类型推断是现代编程语言必备的能力，我们现在很少能够看到不支持类型推断的主流编程语言了。当然，C 语言是个例外。</p><p>类型推断就是编译器根据上下文信息对类型进行推算的能力。类型推断是一个极其复杂的话题，从工程应用的角度而言，我们不用过多关注其背后的数学原理。为了方便讨论，我们将类型的推断分为变量类型推断和泛型类型推断。</p><h2 id="变量类型推断"><a href="#变量类型推断" class="headerlink" title="变量类型推断"></a>变量类型推断</h2><p>变量的类型推断就是在变量声明时省略类型，编译器通过变量的初始化来推断其类型。</p><h3 id="C-的-auto"><a href="#C-的-auto" class="headerlink" title="C++ 的 auto"></a>C++ 的 auto</h3><p>变量类型推断最典型的例子莫过于 C++ 当中的这个场景了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; values;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;&gt;::iterator i = values.<span class="built_in">begin</span>(); i &lt; values.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">  ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，for 循环中的 i 的类型非常长，写起来繁琐之外，还很难写对这一度让 C++ 的开发者极度难受。不过，从 C++ 11 开始，类型推断的引入让事情变得简单了起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = values.<span class="built_in">begin</span>(); i &lt; values.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 的类型使用 <code>auto</code> 关键字替代，这样编译器就会根据 i 的初始化表达式 <code>values.begin()</code> 的类型推断出来。</p><h3 id="Java-的-var"><a href="#Java-的-var" class="headerlink" title="Java 的 var"></a>Java 的 var</h3><p>Java 从 Java 10 开始新增了 <code>var</code> 关键字来简化变量定义时的类型。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>这里的 <code>var</code> 相当于 <code>ArrayList&lt;String&gt;</code>。</p><p><code>var</code> 只能用于局部变量的定义，不能用于类成员的定义，这一点与 C++ 的 <code>auto</code> 非常相似。</p><blockquote><p><strong>说明</strong> 在 Java 正式支持 <code>var</code> 关键字之前，著名的元编程框架 <a href="https://projectlombok.org/">Lombok</a> 就通过编译时修改 Java 语法树为 Java 添加了 <code>var</code> 关键字的支持，有兴趣的读者可以参考 Lombok 的官方文档：<a href="https://projectlombok.org/features/var">https://projectlombok.org/features/var</a>。</p></blockquote><h3 id="类型后置"><a href="#类型后置" class="headerlink" title="类型后置"></a>类型后置</h3><p>C++ 和 Java 的变量声明中类型都在变量名前面，通常又被称为类型前置的形式。这类语言的特点是在语言诞生之初并没有类型推断的语法设计。</p><p>随着开发者对类型推断的需求的日益增长，业界编程语言设计的优秀实践的不断积累，越来越多的新语言选择了类型后置的形式。</p><p>下面是 Kotlin 的变量定义语法，类型后置的形式使得类型推断变得非常自然：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整的变量定义</span></span><br><span class="line"><span class="keyword">val</span> s: String = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略类型</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>变量 <code>s</code> 的类型可以通过初始化的表达式推断出来，因此可以省略。常见的采用类型后置的语法设计的语言还包括 Scala、Swift、TypeScript、Rust 等等。</p><h3 id="全局类型推断"><a href="#全局类型推断" class="headerlink" title="全局类型推断"></a>全局类型推断</h3><p>绝大多数编程语言在对变量的类型进行推断时，都只对变量定义时的初始化表达式做了分析，Rust 就是个例外。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>;</span><br><span class="line">    </span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>Rust 允许先把变量定义出来，在后面根据对该变量的使用情况进行变量类型的推断。示例代码中变量 <code>s</code> 在定义时并没有声明类型，也没有进行初始化，Rust 编译器通过分析后面对 <code>s</code> 的赋值，推断出 <code>s</code> 的类型是 <code>&amp;str</code>。这在 Kotlin 当中是不行的。</p><p>Rust 编译器通过上下文推断类型的能力在下面的例子当中用处更大。</p><p>作为对比，我们先给出 Kotlin 版本的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiply2 = &#123; i: <span class="built_in">Int</span> -&gt; i * <span class="number">2</span> &#125;</span><br><span class="line">multiply2(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在这段 Kotlin 代码中，Lambda 表达式 <code>multiply2</code> 的参数 <code>i</code> 的类型必须显式地写出来，不然编译器就无法推断出 <code>multiply2</code> 的类型了。</p><p>接下来我们看一下等价的 Rust 代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">multiply2</span> = |i| i * <span class="number">2</span>;</span><br><span class="line"><span class="title function_ invoke__">multiply2</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>注意 <code>|i|</code> 是 Rust 的 Lambda 表达式（或者闭包）的参数列表，我们发现 <code>i</code> 的类型并不需要明确地写出来，编译器通过分析后面的实参 <code>10</code> 即可推断出 <code>i</code> 的类型为 <code>i32</code> 了。</p><h3 id="模板化的类型推断"><a href="#模板化的类型推断" class="headerlink" title="模板化的类型推断"></a>模板化的类型推断</h3><p><code>multiply2</code> 的例子还可以继续延伸。不管是 Kotlin 还是 Rust，<code>multiply2</code> 都是一个确定的类型，也就是说在上述代码之后追加一句 <code>multiply2(30.0)</code>，编译器就会抱怨说 <code>30.0</code> 是 <code>Double</code>（Kotlin）/ <code>f64</code>（Rust） 类型 ，而 <code>multiply2</code> 需要的是 <code>Int</code>（Kotlin）/<code>i32</code>（Rust）类型。不过，事情总有例外。</p><p>下面是使用 C++ 编写的等价代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply2 = [](<span class="keyword">auto</span> i) &#123; <span class="keyword">return</span> i * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="built_in">multiply2</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">multiply2</span>(<span class="number">30.0</span>);</span><br></pre></td></tr></table></figure><p><code>multiply2</code> 的参数 <code>i</code> 的类型是 <code>auto</code>，它自身的类型也是 <code>auto</code>，这意味着它们的类型需要编译器来推断。接下来我们分别把 <code>10</code> 和 <code>30.0</code> 传给 <code>multiply2</code>，然后我们就会发现，这都是合法的。这表明 <code>multiply2</code> 针对不同的类型会有不同的实现。对于 C++ 而言，<code>auto</code> 不仅仅是用于类型推断的关键字，很多时候我们把它当做模板的一种特殊形式来看待，似乎更容易理解。</p><h3 id="Java-中的-Lambda-表达式的类型推断"><a href="#Java-中的-Lambda-表达式的类型推断" class="headerlink" title="Java 中的 Lambda 表达式的类型推断"></a>Java 中的 Lambda 表达式的类型推断</h3><p>既然提到了 Lambda 表达式的类型推断，那么我们能不能用 <code>var</code> 来定义 Lambda 表达式呢？答案当然是，不能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">multiply2</span> <span class="operator">=</span> (<span class="type">int</span> i) -&gt; i * <span class="number">2</span>;</span><br><span class="line">^^^</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Error: Cannot infer type: lambda expression <span class="keyword">requires</span> an explicit target type</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>如果我们在 Java 中试图使用 <code>var</code> 来定义一个变量，并使用 Lambda 表达式来初始化，就会得到上面的错误。不过，这个错误并不是 <code>var</code> 的问题，而是 Java 对函数类型的支持问题。这个话题我们将在后面的文章中详细探讨，这里就不再展开说明了。</p><h3 id="分支表达式的类型推断"><a href="#分支表达式的类型推断" class="headerlink" title="分支表达式的类型推断"></a>分支表达式的类型推断</h3><p>分支表达式在现代编程语言中非常常见。C 语言甚至就已经有了分支表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = ...;</span><br><span class="line"><span class="type">int</span> b = ...;</span><br><span class="line"><span class="type">int</span> c = a &gt; b ? a : b;</span><br></pre></td></tr></table></figure><p>没错，<code>?:</code> 可能是最古老的分支表达式之一。</p><p>Java 当中除了 <code>?:</code> 表达式以外，还从 Java 12 开始支持了 Switch 表达式（Java 14 正式支持） ，因此 Java 中的表达式类型推断也是值得探讨的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span> -&gt; <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span> -&gt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个 switch 表达式中，四个分支表达式的值类型分别为 <code>int</code>(<code>Integer</code>)、<code>double</code>(<code>Double</code>)、<code>String</code>、<code>ArrayList&lt;String&gt;</code>。这意味着整体表达式的返回值 <code>y</code> 的类型只能是其中的一个，从数学的角度来讲，<code>y</code> 的类型为这四种类型的交集，Java 的类型系统中也确实存在交集类型的概念，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer &amp; Double &amp; String &amp; ArrayList&lt;String&gt;</span><br></pre></td></tr></table></figure><p>交集类型的计算结果其实就是这些类型的公共父类，因此 <code>y</code> 在编译时的类型为 <code>Serializable</code>。</p><p>如果没有公共父类呢？这在 Java 当中是不可能的，因为所有的类型都至少有一个公共父类是 <code>Object</code>。</p><p>顺便提一句，Kotlin 的推断方法也是类似的。作为对比，我们给出 Rust 的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="string">&quot;A&quot;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;B&quot;</span> =&gt; <span class="number">2.0</span>,</span><br><span class="line">           ^^^</span><br><span class="line">           ---------------------------------------------</span><br><span class="line">           `<span class="keyword">match</span>` arms have incompatible types [E0308]</span><br><span class="line">           expected integer, found floating-point number</span><br><span class="line">           ---------------------------------------------</span><br><span class="line">    <span class="string">&quot;C&quot;</span> =&gt; <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="built_in">vec!</span>[],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Rust 编译器在遇到各个分支的类型不兼容的情况时，会直接报错。实际上，C++ 的行为也是类似的。</p><p>为什么会有这样的差别呢？</p><p>我稍微做一下猜测，供大家参考。Java 和 Kotlin 的对象都是分配在堆内存上的，栈内存上只需保留一个引用，而这个引用的类型不管是什么，占用的内存大小都是固定的，因此在做分支表达式的类型推断时可以尽可能向开发者友好的方向设计。而 C++ 和 Rust 的编译器需要在编译时确定 <code>y</code> 的类型，以便于给他在栈内存上分配内存，因此遇到不兼容的类型时就只好拒绝编译了。</p><h2 id="泛型类型推断"><a href="#泛型类型推断" class="headerlink" title="泛型类型推断"></a>泛型类型推断</h2><p>除了对变量的类型进行推断以外，还有对泛型类型的推断。</p><h3 id="变量初始化表达式的泛型类型参数推断"><a href="#变量初始化表达式的泛型类型参数推断" class="headerlink" title="变量初始化表达式的泛型类型参数推断"></a>变量初始化表达式的泛型类型参数推断</h3><p>我们还是以 <code>ArrayList</code> 为例，在 Java 7 之前的版本，我们需要完整的将类型写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>从 Java 7 开始，编译器稍微为我们做一点简化，允许我们把初始化表达式中的泛型参数省略掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>理由也很简单，变量的类型已经明确，后面的泛型参数 <code>String</code> 显然是冗余的。</p><p>不得不说，这一点 Java 做得比 C# 似乎更好一些，在 C# 中定义一个类似的 <code>List</code> 时必须完整的写出泛型参数。如果省略泛型参数，那么编译器就会报告如下错误：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">                            ^^</span><br><span class="line">                            ------------------------</span><br><span class="line">                            Type argument <span class="keyword">is</span> missing</span><br><span class="line">                            ------------------------</span><br></pre></td></tr></table></figure><p>当然，C# 的设计者可能觉得这里使用 <code>var</code> 会更好（就像 Java 10 之后那样）。</p><h3 id="方法泛型类型参数的推断"><a href="#方法泛型类型参数的推断" class="headerlink" title="方法泛型类型参数的推断"></a>方法泛型类型参数的推断</h3><p>定义在方法中的泛型参数也支持类型推断，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">identity</span><span class="params">(T t)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>identity</code> 在调用时，泛型参数 <code>T</code> 可以通过函数参数 <code>t</code> 推断出来，因此无须显式写出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> identity(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个特性还有一个更为常见的使用场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>Class</code> 的泛型参数是 <code>fromJson</code> 的泛型参数 <code>T</code>，因此可以通过 <code>cls</code> 的实参类型来推断 <code>T</code> 的类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> fromJson(<span class="string">&quot;&#123;&#125;&quot;</span>, User.class);</span><br></pre></td></tr></table></figure><p>你可能会想，竟然有了泛型参数 <code>T</code>，我们是不是可以直接使用 <code>T.class</code> 而不用向 <code>fromJson</code> 中传入 <code>Class&lt;T&gt;</code> 了呢？当然不能，这是因为 Java 的泛型会在编译时擦除，也就是说 <code>T</code> 在运行时并不存在。</p><p>像绝大多数编程语言一样，Java 也可以通过方法的返回值类型来推断泛型参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> get(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>调用时，如果返回值类型已经明确，则无须显式指定泛型参数。不过，C# 却不支持通过返回值类型来推断泛型参数，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">get</span>&lt;<span class="title">T</span>&gt;(<span class="params">String key</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">              ^^^</span><br><span class="line">              -------------------------------------------------</span><br><span class="line">              The type arguments <span class="keyword">for</span> method <span class="string">&#x27;T get&lt;T&gt;(string)&#x27;</span> </span><br><span class="line">              cannot be inferred <span class="keyword">from</span> the usage. </span><br><span class="line">              Try specifying the type arguments explicitly.</span><br><span class="line">              -------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文从变量类型和泛型参数类型的推断两方面对 Java 的相关特性进行了介绍。为了方便读者对类型推断有更全面的认识，我们也列举了其他编程语言的相关特性作为参照。</p><p>综合来看，Java 在类型推断方面做得中规中矩，虽然没有像常见的现代编程语言那样能够做到极致，但也能够应对绝大多数的场景了。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.bennyhuo.com/tags/java/"/>
    
      <category term="Java17" scheme="https://www.bennyhuo.com/tags/java17/"/>
    
      <category term="Java8" scheme="https://www.bennyhuo.com/tags/java8/"/>
    
      <category term="Java21" scheme="https://www.bennyhuo.com/tags/java21/"/>
    
  </entry>
  
  <entry>
    <title>现代 Java（0）：前言</title>
    <link href="https://www.bennyhuo.com//2023/09/04/Java-New-00-foreword/"/>
    <id>https://www.bennyhuo.com//2023/09/04/Java-New-00-foreword/</id>
    <published>2023-09-04T20:09:04.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2023/09/04/Java-New-00-foreword/">现代 Java（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2023/09/23/Java-New-01-var/">现代 Java（1）：Java 也支持类型推断了？</a></li></ul><p>2014 年初 Java 8 就发布了，Java 迎来了其历史上继 5 之后的第二次史诗级更新。我们不妨列举一下 Java 5 和 Java 8 的主要特性来感受一下更新的力度。</p><p>Java 5 的主要更新：</p><ul><li>元数据，即注解（Annotation）。注解特性的引入几乎改变了 Java 开发者的开发习惯，甚至也在很大程度上影响了后来的 Kotlin。</li><li>泛型（Generics）。泛型的引入使得 Java 的类型系统实现了一次质的飞跃，对于编写类型安全的代码有着重要的意义。</li><li>并发包（java.util.concurrent）。高并发一直是 Java 开发者极其关注的话题，这也一度成为 Java 最为擅长的开发领域。Java 5 在标准库中引入并发包，极大的方便了并发程序的设计和开发，这个包甚至也成了 Java 面试中最常被问到的内容之一。</li></ul><p>Java 8 的主要更新：</p><ul><li>Lambda 表达式。这可能是 Java 迈向现代化的最为重要的一步。Lambda 表达式的支持使得开发者可以极大地简化匿名对象的使用，无论从代码可读性还是从代码简洁性上讲，都是一次质的提升。</li><li>SAM 转换。单一方法类型的匿名实例可以简化成 Lambda 表达式，尽管 Java 没有直接支持函数类型，但所有单一方法的类型都可以认为是函数类型。</li><li>流（Stream）。Java 8 的标准库中为集合类型提供了对流的支持，常见的流 API 包括 map、filter、reduce 等等。对流的支持使得 Java 更加函数化，对 Java 开发者的开发习惯和编程思维有非常大的影响，也极大的简化了数据的处理过程。</li><li>接口方法默认实现（Default Methods）。Java 8 开始允许在接口方法中提供默认无状态的实现，这对于 API 的设计者增加新功能且保持 ABI 兼容有着非常大的帮助。</li></ul><p>简单来说，Java 5 的发布使得 Java 的元编程能力和并发能力得到了极大的提升，而 Java 8 的发布又为 Java 带来全新的函数式编程能力，让 Java 再度焕发活力。</p><p>从 Java 9 开始，Java 的版本更新改为半年一次，LTS 版本则是三年一次。从 Java 17 开始，LTS 版本又改成两年一次。</p><p>非 LTS 版本的生命周期只有半年，而 LTS 的生命周期长达 8 年甚至更久。了解 Java 的 LTS 版本是有意义的，一般而言，我们在生产环境中应尽量使用更加有保障的 LTS 版本，以避免频繁地更改生产环境。</p><blockquote><p><strong>说明</strong>：事实上，Java 版本的升级除了语法特性的变化以外，还包含了运行环境及 Java 虚拟机的变化。相比之下，Java 虚拟机的变化对于生产环境的调优带来的影响更大、更抽象，这可能是 Java 开发者不愿意升级版本的一个最为重要原因。</p></blockquote><p>Java 的近几个 LTS 版本如下表所示：</p><table><thead><tr><th>版本号</th><th>发布时间</th><th>结束支持时间</th><th>核心特性</th></tr></thead><tbody><tr><td>Java 8</td><td>2014.3</td><td>2030.12</td><td>函数式</td></tr><tr><td>Java 11</td><td>2018.9</td><td>2026.9</td><td>局部变量类型推导</td></tr><tr><td>Java 17</td><td>2021.9</td><td>2029.9</td><td>模式匹配（Pattern Match）</td></tr><tr><td>Java 21</td><td>2023.9</td><td>2031.9</td><td>虚拟线程（Virtual Thread）</td></tr></tbody></table><p>需要注意的是，这里提及的核心特性也可能是该 LTS 版本之前的非 LTS 版本中引入的。例如，局部变量类型推导指使用 var 来定义变量，变量的类型通过初始化表达式来推导。该特性在 Java 10 引入，Java 11 中只是对 Lambda 表达式的参数做了支持。</p><p>从语法特性的角度来看，Java 17 是非常有诱惑力的。不过，相较难以量化的开发效率上的提升，架构师们往往更看重程序运行效率的提升。我们有理由相信，携带了虚拟线程和分代 ZGC 的 Java 21 将会是一个更加有说服力的版本。</p><p>Java 最近几年的更新无疑是令人兴奋和激动的。尽管比起它的最有力的竞争者 Kotlin 而言，Java 在语法特性上仍显得非常保守，但看看 C++ 近几年的更新就可以知道，语言特性的稳健何尝又不是对现存的 Java 开发者的一种友好呢？</p><p>接下来，我准备写一系列文章来介绍一下 Java 8 以来的重要语法特性更新，希望可以在一定程度上帮助大家了解现代 Java 的语法特性的发展。</p><p>当然，需要特别说明的是，尽管本系列文章的主角是 Java，但行文之处力求把涉及到的问题解释清楚，难免会经常横向对比其他常见的编程语言，读者如果对涉及到的其他语言不熟悉，只需大致了解即可，无须深究。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.bennyhuo.com/tags/java/"/>
    
      <category term="Java17" scheme="https://www.bennyhuo.com/tags/java17/"/>
    
      <category term="Java8" scheme="https://www.bennyhuo.com/tags/java8/"/>
    
      <category term="Java21" scheme="https://www.bennyhuo.com/tags/java21/"/>
    
  </entry>
  
  <entry>
    <title>什么样的开发者才能在简历上写“精通 XXX 语言”</title>
    <link href="https://www.bennyhuo.com//2023/08/29/new-book-metaprogramming/"/>
    <id>https://www.bennyhuo.com//2023/08/29/new-book-metaprogramming/</id>
    <published>2023-08-29T08:08:48.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般这么写的，都不算精通。 </p></blockquote><span id="more"></span><p>朋友们好，我是 bennyhuo。</p><p>大家肯定见过写着 “精通 XXX 语言” 的简历，我在过去几年的工作经历中就见过精通 Java、精通 C++ 甚至精通 Kotlin 的简历，这在几年前尤其流行。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215609.png"></p><p>当然，现在大家稍微做一些功课就会看到“千万不要在简历中写精通 XXX” 之类的警告，不知道大家有没有想过，为什么写精通就是不行呢？</p><h2 id="什么是精通？"><a href="#什么是精通？" class="headerlink" title="什么是精通？"></a>什么是精通？</h2><p>要搞清楚这个问题，先得搞清楚什么是精通。</p><blockquote><p><strong>精通</strong>： 透彻通晓。</p><p>晋 左思 《魏都赋》：“硕画精通，目无匪制，推锋积纪，鋩气弥鋭。” 唐 李咸用 《赠陈望尧》诗：“若説精通事艺长，词人争及孝廉郎。”《醒世恒言·刘小官雌雄兄弟》：“不过数月，经书词翰，无不精通。”如：他精通英语。</p></blockquote><p>这个解释非常清楚，但有一个很麻烦的问题，所谓精通其实是一个偏主观感性的描述，而不是一个可以量化的标准。</p><p>我举个例子，汉语是我的母语，我虽然天天说汉语，但我如果说我精通汉语，肯定有很多朋友会觉得“你不是在开玩笑吧”，但如果这话我跟火星人说，他们一定觉得没毛病。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215931.png"></p><p>“难以量化”就会让表述的结果非常主观，考虑到我们的文化背景讲究谦虚谨慎，于是说自己精通 Kotlin，精通 Java，就让人感觉这位候选人有些自大。</p><h2 id="什么样的候选人喜欢写精通？"><a href="#什么样的候选人喜欢写精通？" class="headerlink" title="什么样的候选人喜欢写精通？"></a>什么样的候选人喜欢写精通？</h2><p>从我的面试筛简历的经历来看，写精通 Kotlin、精通 Java 的候选人，无非是希望证明自己对 Kotlin 或者 Java 的掌握比较不错，能够胜任这份工作。</p><p>换个简单的说法，就是希望通过写自己精通 Kotlin 来证明自己会 Kotlin。是不是听起来有些不对劲？这不是典型的循环论证吗？就好像说，bennyhuo 的视频很不错，因为很有趣一样，本质上说的是一件事儿，而没有给出具体的论据。bennyhuo 的视频很不错，因为他的视频一不带节奏，二不贩卖焦虑，三我编不下去了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828220623.png"></p><p>总之就是要给出具体的论据来证明你的结论，而不是用一个结论来证明另一个结论，或者用一个主观的描述来证明一个客观的情况。事实上，一个无法量化的描述其实无法证明任何结论。</p><p>这道理很难懂吗？当然不是。那为什么前几年那么多人喜欢这么写呢？一方面，互联网快速发展的早期，招聘单位招人很多时候就是为了储备人才，筛选标准方面确实存在比较宽松的情况，这使得敢于自信地在简历上说自己精通 XXX 的候选人确实更容易蒙混过关；另一方面，可能也确实存在一些候选人没有能够拿得出手的项目，就是没得写，只好说自己擅长什么，熟练什么，精通什么了。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828220525.png"></p><h2 id="为什么精通成为简历上的禁忌？"><a href="#为什么精通成为简历上的禁忌？" class="headerlink" title="为什么精通成为简历上的禁忌？"></a>为什么精通成为简历上的禁忌？</h2><p>精通二字在简历中成为禁忌，除了因为这个词表述的内容难于量化以外，还有一个重要原因就是很多候选人其实甚至连普遍意义上的熟练掌握都达不到，就敢写自己精通。</p><p>举个例子，我曾经在面试过程中碰到过说自己精通 Java 的候选人，于是我问他 final 关键字有什么作用，他说修饰变量不可变，修饰类不能被继承，修饰方法不能被覆写。非常标准的八股答案是吧。</p><p>但作为一个精通 Java 的开发者，我们的回答必须融入自己的理解。修饰的变量不可变，那么</p><ol><li>我们应该在什么情况下用 final 修饰变量？</li><li>final 修饰的静态变量和非静态变量有什么区别？</li><li>final 修饰的 String 和 ArrayList 有什么区别？</li><li>有没有什么办法修改被 final 修饰的变量的值？</li><li>被 final 修饰的变量在并发中有什么作用？</li><li>为什么匿名内部类只能捕获 final 的局部变量？</li></ol><p>这些都可以聊，这绝对不是网上随便搜到的八股题目所能够涵盖的，也最能体现自己的水平。</p><p>这样的例子太多了，于是最后”精通“二字与狼来了一样，让人看到只能联想到一个字：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828221431.png"></p><h2 id="怎么证明自己确实精通？"><a href="#怎么证明自己确实精通？" class="headerlink" title="怎么证明自己确实精通？"></a>怎么证明自己确实精通？</h2><p>当然，也不排除确实有些候选人真的精通某一项技术。</p><p>讲个小故事。我之前打算从腾讯出来，找工作的时候有个面试官看了我的简历准备聊点儿 Kotlin 协程的内容，结果他犹豫了，他欲言又止最后来了一句，Kotlin 协程方面应该没啥好问的了，看你还出了一门 C 语言的课程，咱们要不聊聊 C 吧。为啥会这样呢？因为那会儿是 21 年 3 月，他看《深入理解 Kotlin 协程》这本书已经写完快一年了，而 C 语言的课程刚上线几个月，估计我已经把协程快忘光了，就别问了吧，给点儿面子。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828185307.png"></p><p>哈哈，开个玩笑。程序员的圈子里面，高手是非常多的，总有大佬是真的精通某些技术的，人家要写简历会怎么证明自己精通呢？</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828185605.png"></p><p>在讨论这个问题之前，我想先跟大家聊一下“武松打虎”的故事。武松上山前在店里吃酒，店小二说山上有只老虎非常凶狠，已经伤了多人性命，晚上千万不能上山。结果武松不听劝阻，，执意上山。作者又在武松与老虎打斗时着重描述了老虎是如何如何厉害，却很少提及武松精通什么功法。结果呢？老虎被武松打死了，武松的武力值大家瞬间就能理解，无需多言。</p><p>类似地，如果需要证明你精通什么技术，你需要列举你做过的相关的具体事情，例如想要证明自己精通 Kotlin，那就说说自己使用 Kotlin 做过哪些公司项目，做过哪些与 Kotlin 语言强有关的技术专项，参与过哪些开源的 Kotlin 项目，或者给 Kotlin 官方提过 PR 等等。通过介绍这些项目的细节，来展示你对 Kotlin 的掌握程度，让面试官自己推断出你“精通 Kotlin”的结论，而不是自己把结论说出来。</p><p>同样是那次出来找工作，有一个面试官对编译器比较感兴趣，于是问我有没有研究过 Kotlin 的编译器，我说这块儿还涉猎的比较少。不过现在不一样了，这段时间我在 GitHub 上开源了好几个 Kotlin 元编程相关的项目：</p><ul><li><a href="https://github.com/kanyun-inc/Kace">kanyun-inc/Kace</a> （公司级开源项目）</li><li><a href="https://github.com/bennyhuo/KotlinDeepCopy">KotlinDeepCopy</a></li><li><a href="https://github.com/bennyhuo/Kotlin-Trim-Indent">Kotlin-Trim-Indent</a></li><li><a href="https://github.com/bennyhuo/kotlin-compile-testing-extensions">kotlin-compile-testing-extensions</a></li><li><a href="https://github.com/bennyhuo/Klue">Klue</a></li></ul><p>不仅如此，经过两年的努力，我又写了一本书：《深入实践 Kotlin 元编程》。</p><p><a href="https://item.jd.com/10081757341486.html"><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215014.png" alt="深入实践 Kotlin 元编程"></a></p><p><a href="https://item.jd.com/10081757341486.html">&gt;&gt;&gt;点击查看详情&lt;&lt;&lt;</a></p><p>这本书的内容可以说我是躺在 Kotlin 和 Java 编译器的源码上写完的。如果几年后有机会再出去面试，不管是问我 Java、Kotlin 的反射的工作机制，还是 APT 和 KSP 的实现细节，甚至 Kotlin 编译器插件的内部原理，我都能说得头头是道。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828222941.png"></p><p>既然如此，我觉得我在简历上写个熟练掌握 Kotlin 应该问题不大，不过显然让面试官自己得出结论效果会更好，而我只会说：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/ending.png"></p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一般这么写的，都不算精通。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://www.bennyhuo.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="面试" scheme="https://www.bennyhuo.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接下来的一些想法</title>
    <link href="https://www.bennyhuo.com//2023/05/13/roadmap-2023/"/>
    <id>https://www.bennyhuo.com//2023/05/13/roadmap-2023/</id>
    <published>2023-05-13T00:05:06.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想法很多，需要慢慢花时间去落实。 </p></blockquote><span id="more"></span><p>朋友们好，我是 bennyhuo。</p><p>这篇文章我准备聊聊接下来我想做的一些事情，让关注我的朋友们能够大概知道我在公众号、B站等平台接下来会输出哪些方面的内容。</p><h2 id="内容选题"><a href="#内容选题" class="headerlink" title="内容选题"></a>内容选题</h2><p>内容选题会尽量专注于编程语言特性。</p><p>首先，最重要的就是 Kotlin 相关的专题内容。目前在考虑中的一个专题是 Kotlin 与 Swift 核心特性的对比和分析。Kotlin 方向的内容我会花比较多的时间研究，内容也会偏向于进阶。</p><p>其次，我会对 Java、C++ 的新特性保持关注，除了更新《Java 核心技术》的读书视频以外，目前计划中有一个专题是 Java 18-21 新特性介绍（Java 17 的新特性专题文章已经发布）。相比之下，C++ 的内容做起来会更耗费精力，毕竟 C++ 比 Java 的新特性更多，也更复杂，因此暂时会优先考虑把《现代 C++ 核心特性解析》的读书视频做完。</p><p>此外，《Rust 官方电子书》和 《Effective Python》 的读书视频也在持续更新。</p><p>暂时没有开新坑的计划，所以大家可以踏实地等我更新这些视频。</p><h2 id="内容形式"><a href="#内容形式" class="headerlink" title="内容形式"></a>内容形式</h2><p>前面其实已经提到了，内容的形式主要分为文章和视频。我会优先考虑视频的更新，尽量保证两天一更，不过，可能每个月会休息几天。在不适合录制视频的情况下（比如嗓子不舒服的时候），我会抽空撰写专题文章，所以文章的发布频率可能会相对低一些。</p><p>以上都是公开的内容。知识星球也会每月发布一期会员视频，会员视频的内容以学习思考、工作方法之类的方向为主，与公开的内容有一定的定位差异。我也在考虑将一部分专题文章放到知识星球作为会员专题文章，不过暂时还没有确定具体操作形式。</p><h2 id="发布平台"><a href="#发布平台" class="headerlink" title="发布平台"></a>发布平台</h2><p>在催更微信群的朋友应该知道我最近这几天一直在打磨批量发布视频的工具。这个工具目前已经支持了将视频批量发布到 B站、YouTube、抖音、微信公众号（也会同步到视频号）四个平台，因此后续的视频发布终于可以轻松实现多平台同时发布了。</p><p>不管你习惯使用哪个平台，你都可以通过搜索 “<strong>霍丙乾 bennyhuo</strong>” 找到我的账号，收看我的视频内容。近期，我会陆续将存量的视频发布到抖音和微信公众号上，尽快与 B 站和 YouTube 逐步实现同步。</p><p>文章则会按照优先级在我的个人网站（<a href="https://www.bennyhuo.com)、微信公众号和掘金发布./">https://www.bennyhuo.com）、微信公众号和掘金发布。</a></p><h2 id="一点愿景"><a href="#一点愿景" class="headerlink" title="一点愿景"></a>一点愿景</h2><p>我不是计算机专业毕业的，我学到的很多计算机相关的知识都来自于互联网上各位前辈的无私奉献。其中对我影响最大的是 <a href="https://space.bilibili.com/2884629">oeasy 老师</a>，他现在还在 B 站持续发布新的视频教程来帮助大家。我一直觉得能坚持做这样一件事实在是太酷了。</p><p>我希望把事情做得纯粹一些，因此你不会在我的公众号看到 “几年心血总结出这篇八股文”、“阿里 P8 教你面试” 之类的广告，也不会在我的视频里面看到我明示大家投币三连求关注的转场动画。</p><p>希望我现在发布的内容也能对大家有所帮助。十几年后说起来，有过这么个人曾经影响过你。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想法很多，需要慢慢花时间去落实。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="规划" scheme="https://www.bennyhuo.com/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="思考" scheme="https://www.bennyhuo.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>说一件小事</title>
    <link href="https://www.bennyhuo.com//2023/03/29/new-name-and-new-journey/"/>
    <id>https://www.bennyhuo.com//2023/03/29/new-name-and-new-journey/</id>
    <published>2023-03-29T14:03:58.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信公众号 “Kotlin” 即将更名为 “霍丙乾 bennyhuo”，作为我的个人公众号为大家分享技术内容。 </p></blockquote><span id="more"></span><h2 id="微信公众号-“Kotlin”-是怎么来的？"><a href="#微信公众号-“Kotlin”-是怎么来的？" class="headerlink" title="微信公众号 “Kotlin” 是怎么来的？"></a>微信公众号 “Kotlin” 是怎么来的？</h2><p>过去的几年里，我一直专注于研究和推广 Kotlin。从 2016 年开始，我注册了微信公众号 “Kotlin”，用来推送我录制的 Kotlin 入门视频，并且在这个号上面定期发布 Kotlin 相关的技术文章以及组织的各类活动。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330075842.png">  </p><p>最初，JetBrains 没有在国内投入专门的资源来推广 Kotlin。后来圣佑加入 Kotlin，成为 JetBrains 唯一的中文技术布道师，国内的活动、社区组织也才慢慢走上正轨。同时，在 Google 的助力下，Kotlin 成为大家熟知的现代编程语言，愿意学习 Kotlin 并且愿意输出 Kotlin 内容的开发者也越来越多。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329205933.png">  </p><p>2020 年写完书之后，我开始研究一些与 Kotlin 关联不大的内容，顺便出了一门 C 语言课。这门课的同学经常催我出一门 C++ 的课，于是我开始在 B 站发 C++ 视频，还写了一系列“渡劫 C++ 协程”的文章。随着我涉猎的内容方向就越来越广泛，这些内容与微信公众号 “Kotlin” 的名字产生了比较大的违和感。</p><p>经过两年时间的探索和思考，我终于下定决心做出一些改变。我向 JetBrains 提了一下我的想法，得到了他们的赞同，于是现在我们终于有了官方的 Kotlin 微信公众号啦！如果大家希望关注 Kotlin 官方的动态，请一定关注官方公众号 “Kotlin开发者”。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329212925.png">  </p><p>至此，以我个人名义注册的微信公众号 “Kotlin” 已经完成了它的使命。接下来，它将作为我的个人公众号，继续向关注我的朋友们推送我的个人思考和技术分享。</p><h2 id="还会推送-Kotlin-相关的内容吗？"><a href="#还会推送-Kotlin-相关的内容吗？" class="headerlink" title="还会推送 Kotlin 相关的内容吗？"></a>还会推送 Kotlin 相关的内容吗？</h2><p>当然！</p><p>毫不客气甚至有些骄傲地说，所有编程语言里面，我最擅长的就是 Kotlin。我会持续关注 Kotlin 的最新动态和发展方向，也会与 JetBrains 的朋友们保持联系，在需要的时候参与 Kotlin 相关的活动。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214234.png">  </p><p>今年，我还将出版一本 Kotlin 的新书，书名暂定为《深入实践 Kotlin 元编程》，内容主要包括注解处理器、编译器插件等。这些内容基本上是我通过反复阅读 Kotlin 编译器、Jetpack Compose 等项目的源码整理出来的。与《深入理解 Kotlin 协程》类似，这本书的内容对于知识的剖析较为深入，阅读起来有一定的挑战性，相信一定能够给读者带来一些启发。届时，公众号也会推送相关的内容作为补充，方便读者了解其中的细节。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330070944.png">  </p><p>哦对了，我还是一名 Kotlin GDE，组织上也会要求我们定期输出相关的视频、文章。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214632.png">  </p><p>除了 Kotlin 相关的内容以外，我也会输出一些 C/C++、Java、JavaScript 甚至 Rust 相关的内容。具体什么内容可能取决于我那一段时间的兴趣和投入。</p><p>之前有朋友跟我说，其实这些跟 Kotlin 都有关系，因为 Kotlin 要支持多平台嘛。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330071605.png">  </p><h2 id="目前主要在哪些平台输出内容？"><a href="#目前主要在哪些平台输出内容？" class="headerlink" title="目前主要在哪些平台输出内容？"></a>目前主要在哪些平台输出内容？</h2><p>目前我输出内容的形式主要是文章和视频，在公众号更名之后，发布的平台主要是以下几个：</p><ul><li>Bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>YouTube：<a href="https://www.youtube.com/channel/UCt47g8sEoUkI6R855ol3Gdw"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li><li>掘金：<a href="https://juejin.cn/user/1187128286120631"><strong>霍丙乾 bennyhuo</strong></a></li></ul><p>当然，也欢迎大家收藏我的个人主页和 GitHub：</p><ul><li>个人主页：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a> </li><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li></ul><p>感谢大家一如既往的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号 “Kotlin” 即将更名为 “霍丙乾 bennyhuo”，作为我的个人公众号为大家分享技术内容。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="公众号" scheme="https://www.bennyhuo.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="规划" scheme="https://www.bennyhuo.com/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2022 总结 - bennyhuo</title>
    <link href="https://www.bennyhuo.com//2022/12/31/summary-2022/"/>
    <id>https://www.bennyhuo.com//2022/12/31/summary-2022/</id>
    <published>2022-12-31T07:12:13.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>也还是闲不住的一年呢。 </p></blockquote><span id="more"></span><p>一年又过去了。这一年也还是做了很多事情的。</p><h2 id="视频内容输出"><a href="#视频内容输出" class="headerlink" title="视频内容输出"></a>视频内容输出</h2><p>今年继续在 B 站发视频，欢迎关注：<a href="https://space.bilibili.com/28615855"><strong>bennyhuo 不是算命的</strong></a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221228152123.png">  </p><p>相比去年（2021 年），今年的视频大多数是读书视频。</p><ul><li><a href="https://www.bilibili.com/video/BV1Ni4y1U714/">《深入理解 Kotlin 协程》完结 共 16 集</a></li><li><a href="https://www.bilibili.com/video/BV1vv4y1A7fX/">《渡劫 C++ 协程》完结 共 7 集</a></li><li><a href="https://www.bilibili.com/video/BV1UY4y1z7W7/">《TypeScript 入门》完结 共 10 集</a></li><li><a href="https://www.bilibili.com/video/BV1Fu411Q7af/">《Dart 开发语言概览》完结 共 17 集</a></li><li><a href="https://www.bilibili.com/video/BV13T4y1k7qQ/">《现代 C++ 特性解析》更新至第六章，共 11 集</a></li><li><a href="https://www.bilibili.com/video/BV1HB4y1C7zH/">《Effective Python》更新至第 15 条，共 14 集</a></li><li><a href="https://www.bilibili.com/video/BV1NR4y1A7Tk/">《Rust 程序设计语言》更新至第七章，共 23 集</a></li><li><a href="https://www.bilibili.com/video/BV1ZV4y1L7Kx/">《Jetpack Compose 从入门到实战》更新至第二章，共 12 集</a></li></ul><p>Kotlin 版本更新的视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1eM4y1P7cR/">Kotlin 1.6 共 6 期</a></li><li><a href="https://www.bilibili.com/video/BV1ma411E7ZU/">Kotlin 1.7 共 2 期</a></li></ul><p>还有一些散装的视频，比如<a href="https://www.bilibili.com/video/BV1pT4y1Y746/">“神奇的 C 语言”</a>系列，说起来 C 语言的视频播放量是真的高。</p><p>订阅量从年初的 5900 左右增长到接近 17500，基本达到了我年初的预期（12000），<strong>谢谢大家的关注和一键三连</strong>。不瞒各位说，我当时还定了一个挑战目标：18000，还真是恰到好处的差一点儿。</p><p>2023 年的想法，未更新完的读书视频当中，这几本是确定要更完的：</p><ul><li>《Effective Python》</li><li>《Rust 程序设计语言》</li><li>《现代 C++ 特性解析》</li></ul><p>此外应该也会有一些 Java 相关的视频。</p><p>小伙伴们问得最多的是 Flutter 不更了吗，Compose 不更了吗？统一回复：对，不更了。</p><h2 id="文字内容输出"><a href="#文字内容输出" class="headerlink" title="文字内容输出"></a>文字内容输出</h2><p>今年文章写得不多，也就两个合集：</p><ul><li><a href="https://www.bennyhuo.com/book/cpp-coroutines/">渡劫 C++ 协程</a></li><li><a href="https://www.bennyhuo.com/book/swift-coroutines/">闲话 Swift 协程</a></li></ul><p>尽管写完《深入理解 Kotlin 协程》之后我就对协程这个话题比较麻木了，不过对于其他语言的协程我还是很好奇的。C++ 和 Swift 的协程的实现与 Kotlin 协程有很多相似之处，有兴趣的朋友不妨读一下这几篇文章了解一下。</p><p>今年也在写书。“深入实践 Kotlin 元编程”（暂定书名）这本书目前底稿已经全部完成，我目前正在逐字逐句做校对，预计还需要一个多月才能全部交付到编辑侧完成第一遍审稿。参考《深入理解 Kotlin 协程》的时间，2023 年内出版是没什么问题的。</p><p>这本书的内容大概涵盖了 Kotlin 开发实践当中另一个难点。大家常听说的 APT、KSP、KCP 在这本书当中都有详细介绍。如果大家想要提前了解书的内容，可以看一下我的 GitHub 2022 年的提交记录。经常有朋友我问有没有好的 KSP 或者 KCP 的示例代码，其实我近一年维护的所有项目基本上都与之相关。</p><p>写书是一件苦差事，每次写书的时候都在心里说写完这本就再也不写了。也许明年可以尝试写一些小册子，搞轻松一些。“渡劫 C++ 协程” 这种我觉得就挺好。</p><h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>今年的社区活动，一共有三次，其中还包括一次线下活动，真是不容易。</p><ul><li><p><a href="https://www.bilibili.com/video/BV1kG411n7KH/">2022.7 Kotlin 炉边漫谈 Podcast 第二期</a>：“Kotlin 炉边漫谈” 是 Kotlin 社区推出的一款节目，每期都会邀请一些有趣的嘉宾参与闲聊。据说我是那个最不会聊天的。</p></li><li><p><a href="https://www.bilibili.com/video/BV1ye4y1Y728/">2022.9.1 使用 Kotlin 多平台特性统一 JS 调用 Native 函数的体验</a>：这期分享主要介绍了 Klue 这个项目的实现思路和细节。Klue 是 Kotlin 多平台特性的一个很好的实践场景。这个项目明年应该会继续探索下去，今年之所以搁浅，实在是因为精力有限。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231150245.png">  </p></li><li><p><a href="https://www.bilibili.com/video/BV1t14y1L7SA/">2022.10.30 小猿口算 Android 项目的优化实践</a>：这期分享主要介绍了我在猿辅导公司小猿口算团队与团队其他同学一起做的各方面的工程优化。能把有趣的技术应用到公司项目当中，也是一件快事。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231152701.png">  </p></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>2022 年还有一些开源项目在维护。比较重要的就是下面的几个：</p><ul><li><a href="https://github.com/bennyhuo/Kotlin-Trim-Indent">Kotlin-Trim-Indent</a>：处理 Kotlin 多行字符串缩进的编译器插件。</li><li><a href="https://github.com/bennyhuo/KotlinDeepCopy">KotlinDeepCopy</a>：很多年的老项目了，今年又尝试了很多想法。</li><li><a href="https://github.com/bennyhuo/kotlin-compile-testing-extensions">kotlin-compile-testing-extensions</a>：对框架 kotlin-compile-testing 做的扩展，方便做 Kotlin 编译器相关项目的单测。</li><li><a href="https://github.com/bennyhuo/Klue">Klue</a>：使用 Kotlin 多平台特性对 Android/iOS 与 WebView/React Native 的互调用进行简化。</li></ul><p>今年因为写书，一直在做 Kotlin 编译器相关的尝试。明年的重心可能会放到 Klue 上面。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家在 B 站关注我：<strong>bennyhuo 不是算命的</strong>。</p><p>也欢迎大家关注微信公众号：<strong>bennyhuo</strong>。</p><p>2023 继续加油。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;也还是闲不住的一年呢。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="2022" scheme="https://www.bennyhuo.com/tags/2022/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（10）：后记</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-10-postscript/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-10-postscript/</id>
    <published>2022-03-27T23:03:55.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><p><strong>渡劫 C++ 协程</strong>系列文章本来不在我的计划范围内。</p><p>相较于我常用的几门语言（可能是 Kotlin、Java、Python、JavaScript）来讲，我对 C++ 的熟悉程度并不是特别高。因此尽管群里的小伙伴们经常提议讲点儿 C++ 的内容（都出了一门 C 语言课了，还讲不了 C++？），考虑到精力和经验有限，我都拒绝了。</p><p>不过，人生就是那么奇妙，前不久我刚好有点儿时间，也正遇到群里有小伙伴们提到 C++ 协程，就硬着头皮看了一下午，录了一期视频 <a href="https://www.bilibili.com/video/BV1z5411Z7K5">协程上手经典案例：实现一个序列生成器</a>。既然有了第一期，那就得有第二期，结果越往后越感觉我这个讲法不太对。</p><p>过了一段时间之后，我的<a href="https://www.bennyhuo.com/book/swift-coroutines/"><strong>闲话 Swift 协程</strong></a>系列文章完结，同时我对 C++ 协程的认知也在不断加深，那么好吧，再写一系列 C++ 协程的文章吧。在学习 Swift 协程时，我可以翻阅 Swift 的语言设计文档以及源码，整个过程还算轻松，因此称为<strong>闲话 Swift 协程</strong>；C++ 的情况就不太一样了，设计文档看着令人头疼，标准库的源码又看得我眼花缭乱，于是得名<strong>渡劫 C++ 协程</strong>。</p><p>我在最初做 Kotlin 协程的介绍的时候，很多朋友都在问我协程究竟能做什么，再后来不少读者在发现 Kotlin 协程的默认调度器居然是个线程池，于是就认为 “Kotlin 协程的本质就是个线程池” —— 这真的是让人哭笑不得。</p><p>为了让读者能够更加深刻的认识协程，我在<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书当中花了整整一章的篇幅介绍了常见语言对协程的支持情况，对比彼此之间的差异，甚至用 Kotlin 协程的基本 API 来模拟其他语言的协程特性。</p><p>Kotlin 的协程和 C++ 的协程在设计分层上有着惊人的相似之处，二者在标准库当中仅仅提供了为数不多的基本 API，想要将协程运用到业务实践当中还需要有协程框架的支持。C++ 20 已经走出了第一步，这大概相当于 Kotlin 1.1 时的状态。</p><p>我当时为了让读者能够深入理解 Kotlin 协程框架的设计，干脆自己动手实现了一个简版的协程框架 <a href="https://github.com/bennyhuo/CoroutineLite">CoroutineLite</a>。而<strong>渡劫 C++ 协程</strong>的核心内容也是在尝试通过自己实现 C++ 的协程框架来深入理解 C++ 协程。按照这个思路，我们还可以继续深入探索，例如实现 <code>Task</code> 的取消，为 <code>Task</code> 添加父子关系以实现结构化并发等等能力，只是受限于时间和精力，我决定暂时停止这一次奇妙的探索历程。</p><p>如果想要在生产环境当中使用 C++ 20 提供的协程，我们可能还需要持续关注 C++ 委员会后续对协程的规划和设计。让我们期待将来 C++ 新标准对协程提供更多的支持吧。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（9）：一个简单的示例</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-09-http/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-09-http/</id>
    <published>2022-03-26T14:03:52.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在本文当中，我将使用前文实现好的 <code>Task</code> 来发起一个简单的网络请求。</p><p>我会借助一些已有的框架来完成这次的目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpp-httplib/0.10.4</span><br><span class="line">openssl/3.0.2</span><br><span class="line">nlohmann_json/3.10.5</span><br></pre></td></tr></table></figure><p>这些框架可以通过 <a href="https://www.bilibili.com/video/BV1wL411u74B/">conan</a> 很轻松的完成安装。</p><h3 id="示例实现"><a href="#示例实现" class="headerlink" title="示例实现"></a>示例实现</h3><p>首先我们给出发起网络请求的核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用协程包装网络请求，请求的处理调度到 std::async 上</span></span><br><span class="line"><span class="function">Task&lt;std::string, AsyncExecutor&gt; <span class="title">http_get</span><span class="params">(std::string host, std::string path)</span> </span>&#123;</span><br><span class="line">  <span class="function">httplib::Client <span class="title">cli</span><span class="params">(host)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞地发起网络请求</span></span><br><span class="line">  <span class="keyword">auto</span> res = cli.<span class="built_in">Get</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="comment">// 返回响应内容，类型为 std::string</span></span><br><span class="line">    <span class="keyword">co_return</span> res-&gt;body;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">co_return</span> httplib::<span class="built_in">to_string</span>(res.<span class="built_in">error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 httplib 来完成网络请求的处理非常简单直接，我们只需要把 url 传入即可。通常我们的网络请求都会在 io 线程当中发起，因此我们将其调度到 <code>AsyncExecutor</code> 上。</p><p>接下来，我们再定义一个协程来调用 <code>http_get</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">test_http</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send request...&quot;</span>); <span class="comment">// Looper 线程上执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起网络请求，切换线程，当前协程挂起，Looper 线程被释放（此时 Looper 线程可以去调度其他任务）</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">http_get</span>(<span class="string">&quot;https://api.github.com&quot;</span>, <span class="string">&quot;/users/bennyhuo&quot;</span>);</span><br><span class="line">    <span class="comment">// 请求返回，当前协程接着在 Looper 线程上调度执行</span></span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑处理，解析 json</span></span><br><span class="line">    <span class="keyword">auto</span> json = nlohmann::json::<span class="built_in">parse</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印 json 内容</span></span><br><span class="line">    <span class="built_in">debug</span>(json.<span class="built_in">dump</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 假装这是其他业务处理</span></span><br><span class="line">    <span class="built_in">debug</span>(json[<span class="string">&quot;login&quot;</span>], json[<span class="string">&quot;url&quot;</span>]);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">22:10:54.046 [Thread-08056] (main.cpp:27) test_http: send request...</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:29) test_http: done.</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:31) test_http: &#123;</span><br><span class="line">  &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6336960?v=4&quot;,</span><br><span class="line">  &quot;bio&quot;: &quot;Google Developer Expert @Kotlin&quot;,</span><br><span class="line">  &quot;blog&quot;: &quot;https://www.bennyhuo.com&quot;,</span><br><span class="line">  ...  中间内容很多，省略掉 ...</span><br><span class="line">  &quot;updated_at&quot;: &quot;2022-03-23T13:51:26Z&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">&#125;</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:32) test_http: &quot;bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:33) test_http: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:34) test_http: &quot;Google Developer Expert @Kotlin&quot;</span><br></pre></td></tr></table></figure><p>在这个示例当中，我们没有使用协程来解决阻塞的问题，而是将一个异步的请求封装成同步的代码。<code>test_http</code> 当中的代码全程在 Looper 线程当中执行，尽管中间穿插了一个异步网络请求，但这看上去丝毫没有影响程序的连贯性和简洁性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的内容相对轻松，因为我们终于停止了基于协程的基础 API 的探索。</p><p>实际上，如果你发现你用到的某些 API 提供了异步回调，你完全可以使用 <code>Awaiter</code> 对其提供 <code>co_await</code> 的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（8）：通用 Awaiter</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-08-awaiter/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-08-awaiter/</id>
    <published>2022-03-25T14:03:52.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每次我们新增功能时，都需要修改 TaskPromise 增加对应的 await_transform 函数，这显然是个设计问题。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们前面在实现无阻塞 sleep 和 Channel 的时候都需要专门实现对应的 Awaiter 类型，并且在 TaskPromise 当中添加相应的 <code>await_transform</code> 函数。增加新类型这没什么问题，但如果每增加一个新功能就要对原有的 <code>TaskPromise</code> 类型做修改，这说明 <code>TaskPromise</code> 的扩展性不够好。</p><p>当然，有读者会说，如果我们把所有的 <code>await_transform</code> 函数都去掉，改成给对应的类型实现 <code>operator co_await</code> 来获取 Awaiter（例如 sleep 的例子当中通过 duration 转 Awaiter） 或者干脆就自己就定义成 Awaiter（例如 <code>Channel</code> 当中的 <code>ReadAwaiter</code>），这样我们就不用总是修改 <code>TaskPromise</code> 了。话虽如此，但完全由外部定义 Awaiter 对象的获取会使得调度器无法被包装正确使用，甚至我们在定义 <code>TaskPromise</code> 的时候把调度器定义成私有成员，因为我们根本不希望外部能够轻易获取到调度器的实例。</p><p>使用 <code>await_transform</code> 本质上就是为了保证调度器的正确应用，却带来了扩展上的问题，那这是说 C++ 协程的设计有问题吗？当然也不是。我们完全可以定义一个 Awaiter 类型，外部只需要继承这个 Awaiter 在受限的范围内自定义逻辑，完成自己的需求同时也能保证调度器的调度。</p><h2 id="通用的-await-transform"><a href="#通用的-await-transform" class="headerlink" title="通用的 await_transform"></a>通用的 await_transform</h2><p>了解了需求背景之后，我们只需要在 <code>TaskPromise</code> 当中定义一个更加通用版本的 <code>await_transform</code>，来为 Awaiter 提供调度器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">  AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">    awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看得没错，我们真的只是给这个通用的 <code>Awaiter</code> 添加了当前协程的调度器。</p><h2 id="Awaiter-的定义"><a href="#Awaiter-的定义" class="headerlink" title="Awaiter 的定义"></a>Awaiter 的定义</h2><p>既然 <code>Awaiter</code> 的核心是调度器，我们可以直接给出它的基本定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *executor)</span> </span>&#123;</span><br><span class="line">    _executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方便用调度器调度任意逻辑，这里也处理了调度器为空的情况</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_executor) &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>(std::<span class="built_in">move</span>(f));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为 Awaiter 本身，当然也得有标准当中定义的基本的三个函数要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单处理，永远挂起，当然这也是协程调度的一个潜在的优化点</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前协程的 handle，方面后面恢复</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回 co_await 的结果，当然对于 void 的情况，我们也会有特化版本</span></span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 结果对子类可见，方便灵活操作</span></span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 保存协程的 handle，恢复时会用到，私有化这个成员目的是将其逻辑封装，避免滥用</span></span><br><span class="line">  std::coroutine_handle&lt;&gt; _handle = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数是协程在挂起和恢复时调用的。我们将协程 <code>handle</code> 的保存和结果的返回逻辑固化，因为几乎所有的 Awaiter 都有这样的需求。不过协程的挂起后和恢复前是两个非常重要的时间点，扩展 Awaiter 时经常需要在这两个时间点实现定义化的业务逻辑，因此我们需要定义两个虚函数让子类按需实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    <span class="comment">// 调用 after_suspend，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">after_suspend</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 before_resume，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">before_resume</span>();</span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是协程的恢复了，这时候我们要求必须使用调度器进行调度。为了防止外部不按要求处理调度逻辑，我们将调度器和协程的 <code>handle</code> 都定义为私有成员，因此我们也需要提供相应的函数来封装协程恢复的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复时，co_await 表达式返回 value</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(R value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, value]() &#123;</span><br><span class="line">      <span class="comment">// 将 value 封装到 _result 当中，await_resume 时会返回 value</span></span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;R&gt;(value));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不提供 value，但也要恢复协程，这种情况需要子类在 before_resume 当中写入 _result，或者抛出异常</span></span><br><span class="line">  <span class="comment">// 我们将会在 Channel 关闭时用到这个函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>]() &#123; _handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂起点出现异常，用异常来恢复协程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_exception</span><span class="params">(std::exception_ptr &amp;&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, e]() &#123;</span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;std::exception_ptr&gt;(e));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，如果我们想要扩展新功能，只需要继承 <code>Awaiter</code>，在 <code>after_suspend</code> 当中或者之后找个合适的时机调用 <code>resume/resume_unsafe/resume_exception</code> 三个函数当中的任意一个来恢复协程即可。如果在恢复前有其他逻辑需要处理，也可以覆写 <code>before_resume</code> 来实现。</p><h2 id="Awaiter-的应用"><a href="#Awaiter-的应用" class="headerlink" title="Awaiter 的应用"></a>Awaiter 的应用</h2><p>接下来我们使用 <code>Awaiter</code> 对现有的几个 awaiter 类型做重构，之后再尝试基于 <code>Awaiter</code> 做一点小小的扩展。</p><h3 id="重构-SleepAwaiter"><a href="#重构-SleepAwaiter" class="headerlink" title="重构 SleepAwaiter"></a>重构 SleepAwaiter</h3><p><code>SleepAwaiter</code> 是最简单的一个。我们当初为了让无阻塞的 sleep 看上去更加自然，直接对 <code>duration</code> 做了支持，于是可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>duration</code> 的支持源自于在 <code>TaskPromise</code> 当中添加了 <code>duration</code> 转 <code>SleepAwaiter</code> 的 <code>awaiter_transform</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不要求对 <code>duration</code> 直接支持的话，我们其实也可以这么设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(SleepAwaiter awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保存调度器，后面调度用</span></span><br><span class="line">  awaiter._executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与我们前面给出的通用 <code>Awaiter</code> 版本的  <code>await_transform</code> 如出一辙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传入调度器，后面调度用</span></span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以使用通用的 <code>Awaiter</code> 重构 <code>SleepAwaiter</code>，下面我们给出重构前和重构后的对比：</p><p><strong>重构前</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重构后</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> : Awaiter&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增一个支持 duration 的构造器，方便外部使用</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这部分逻辑以前写在 await_suspend 当中</span></span><br><span class="line">    <span class="comment">// 现在我们写在覆写的 after_suspend 当中</span></span><br><span class="line">    <span class="comment">// 调用位置实际上没有变化，但我们不用再关心 handle 和 调度器了</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>] &#123; <span class="built_in">resume</span>(); &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重构之后，我们无需单独为 <code>SleepAwaiter</code> 添加 <code>await_transform</code> 的支持，就可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得不够美观，也可以定义一个协程版本的函数 sleep_for：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">sleep_for</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写出来的代码就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">sleep_for</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重构-Channel-的-Awaiter"><a href="#重构-Channel-的-Awaiter" class="headerlink" title="重构 Channel 的 Awaiter"></a>重构 Channel 的 Awaiter</h3><p>Channel 有两个 Awaiter，分别是 <code>ReaderAwaiter</code>、<code>WriterAwaiter</code>，以前者为例：</p><p><strong>重构前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这代码大家已经见过，这里同样贴出来只是为了让大家能够直接对比：</p><p><strong>重构后</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;ValueType&gt; &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : Awaiter&lt;ValueType&gt;(), channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;ValueType&gt;(other),</span><br><span class="line">        <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = <span class="keyword">this</span>-&gt;_result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，调度的逻辑统一抽象到父类 <code>Awaiter</code> 当中，代码的逻辑更加紧凑了。不仅如此，之前在 <code>TaskPromise</code> 当中定义的 <code>await_transform</code> 也不需要了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不再需要</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">  reader_awaiter.executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriterAwaiter</code> 同理，不再赘述。</p><h3 id="重构-TaskAwaiter"><a href="#重构-TaskAwaiter" class="headerlink" title="重构 TaskAwaiter"></a>重构 TaskAwaiter</h3><p><code>TaskAwaiter</code> 是用来等待其他 <code>Task</code> 的执行完成的。它同样可以用前面的通用 <code>Awaiter</code> 改造：</p><p><strong>重构前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : _executor(completion._executor), <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为对比，重构后的代码同样变得简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), <span class="built_in">task</span>(std::<span class="built_in">move</span>(awaiter.task)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 先不去获取结果，原因是除了正常的返回值以外，还可能是异常</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume_unsafe</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有返回值，则赋值给 _result，否则直接抛异常</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_result = <span class="built_in">Result</span>(task.<span class="built_in">get_result</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R, Executor&gt; task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改造完成之后，如果不希望为 <code>Task</code> 增加特权支持的话，之前对 <code>TaskAwaiter</code> 的 <code>await_transform</code> 同样可以删除掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接删掉</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为 <code>Task</code> 类型增加一个函数来获取 <code>TaskAwaiter</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NoopExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">as_awaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;ResultType, Executor&gt;(std::<span class="built_in">move</span>(*<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦调用 <code>as_awaiter</code>，我们就会将 <code>Task</code> 的内容全部转移到新创建的 <code>TaskAwaiter</code> 当中，并且返回给外部使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除 TaskAwaiter&lt;&gt; await_transform(Task&lt;&gt;)</span></span><br><span class="line">  <span class="comment">// 可以采用以下方式在外部将 Task 转成 TaskAwaiter，然后再 co_await</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>().<span class="built_in">as_awaiter</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在我们自己实现的这套 <code>Task</code> 框架当中，<code>Task</code> 自然是“特权阶层”，我们不会真的删除为 <code>Task</code> 定制的 <code>await_transform</code>。但也不难看出，经过改造的 <code>Awaiter</code> 的子类代码量和复杂度都有降低；同时也不再需要定义专门的 <code>await_transform</code> 函数来明确支持 <code>TaskAwaiter</code>，避免了扩展性不强的尴尬。</p><h3 id="添加对-std-future-的扩展支持"><a href="#添加对-std-future-的扩展支持" class="headerlink" title="添加对 std::future 的扩展支持"></a>添加对 std::future 的扩展支持</h3><p>按照 C++ 标准的发展趋势来看，<code>std::future</code> 应该在将来会支持类似于 <code>Task::then</code> 这样的函数回调，那时候我们完全不需要自己独立定义一套 <code>Task</code>，只需要基于 <code>std::future</code> 进行扩展即可。</p><p>当然这都是后话了。现在 <code>std::future</code> 还不支持回调，我们可以另起一个线程来阻塞得等待它的结果，并在结果返回之后恢复协程的执行，这样一来，我们的 <code>Task</code> 框架也就能够支持形如 <code>co_await as_awaiter(future)</code> 这样的写法了。</p><p>想要做到这一点，我们只需要基于前面的 <code>Awaiter</code> 来依样画葫芦：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FutureAwaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _future(std::move(future)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), _future(std::<span class="built_in">move</span>(awaiter._future)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  FutureAwaiter &amp;<span class="keyword">operator</span>=(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::future::get 会阻塞等待结果的返回，因此我们新起一个线程等待结果的返回</span></span><br><span class="line">    <span class="comment">// 如果后续 std::future 增加了回调，这里直接注册回调即可</span></span><br><span class="line">    std::<span class="built_in">thread</span>([<span class="keyword">this</span>]()&#123;</span><br><span class="line">      <span class="comment">// 获取结果，并恢复协程</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume</span>(<span class="keyword">this</span>-&gt;_future.<span class="built_in">get</span>());</span><br><span class="line">    &#125;).<span class="built_in">detach</span>(); </span><br><span class="line">    <span class="comment">// std::thread 必须 detach 或者 join 二选一</span></span><br><span class="line">    <span class="comment">// 也可以使用 std::jthread </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::future&lt;R&gt; _future;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>FutureAwaiter</code> 与 <code>TaskAwaiter</code> 除了 <code>after_suspend</code> 和 <code>before_resume</code> 处有些不同之外，几乎完全一样（当然除了这俩函数以外也基本上没有其他逻辑了）。</p><p>如果你愿意，你也可以定义一个 <code>as_awaiter</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span></span><br><span class="line"><span class="function">FutureAwaiter&lt;R&gt; <span class="title">as_awaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FutureAwaiter</span>(std::<span class="built_in">move</span>(future));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在协程当中就可以使用 <code>co_await</code> 来等待 <code>std::future</code> 的返回了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">as_awaiter</span>(std::<span class="built_in">async</span>([]() &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">  &#125;));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AwaiterImpl-的类型约束"><a href="#AwaiterImpl-的类型约束" class="headerlink" title="AwaiterImpl 的类型约束"></a>AwaiterImpl 的类型约束</h2><p>本文给出的通用的 <code>await_transform</code> 有个小小的漏洞，我们不妨再次观察一下这个函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，只要 <code>AwaiterImpl</code> 类型定义了协程的 <code>Awaiter</code> 类型的三个函数，并且定义有 <code>install_executor</code> 函数，在这里就可以蒙混过关，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FakeAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">co_await</span> <span class="title">FakeAwaiter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>FakeAwaiter</code> 的定义符合前面的模板类型 <code>AwaiteImpl</code> 的要求，但却不符合我们的预期。为了避免这种情况发生，我们必须想办法要求 <code>AwaiterImpl</code> 只能是 <code>Awaiter</code> 或者它的子类。</p><p>这如果是在 Java 当中，我们可以很轻松地指定泛型的上界来达到目的。但 C++ 的模板显然与 Java 泛型的设计相差较大，不能直接在定义模板参数时指定上界。不过 C++ 20 的 concept 可以用来为模板参数限定父类。</p><p>我们需要定义一个用来检查类关系的 concept：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">concept</span> AwaiterImplRestriction = std::is_base_of&lt;Awaiter&lt;R&gt;, AwaiterImpl&gt;::value;</span><br></pre></td></tr></table></figure><p>接下来我们只需要在 <code>await_transform</code> 的模板声明后面加上这个 concept 即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span><br><span class="line"><span class="comment">// ??? 是 AwaiterImpl 继承父类 Awaiter 时传入的模板参数，但我们现在还不知道是什么</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, ???&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;  ...  &#125;</span><br></pre></td></tr></table></figure><p>不过这里有个问题，我们其实并不知道 <code>AwaiterImpl</code> 的实际类型在继承 <code>Awaiter</code> 时到底用了什么类型的模板参数，这怎么办呢？</p><p>有一个简单的办法，那就是为 <code>Awaiter</code> 声明一个内部类型 <code>ResultType</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ResultType = R;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用 <code>Awaiter::ResultType</code> 来获取这个类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, <span class="keyword">typename</span> AwaiterImpl::ResultType&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样像前面提到的 <code>FakeAwaiter</code> 那样的类型，就不能作为 <code>co_await</code> 表达式的参数了。即便我们为 <code>FakeAwaiter</code> 声明 <code>ResultType</code> 也不行，<code>co_await FakeAwaiter()</code> 的报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidate template ignored: constraints not satisfied [with AwaiterImpl = FakeAwaiter] </span><br><span class="line">because &#x27;AwaiterImplRestriction&lt;FakeAwaiter, typename FakeAwaiter::ResultType&gt;&#x27; evaluated to false </span><br><span class="line">because &#x27;std::is_base_of&lt;Awaiter&lt;void&gt;, FakeAwaiter&gt;::value&#x27; evaluated to false call to &#x27;await_transform&#x27; implicitly required by &#x27;co_await&#x27; here</span><br></pre></td></tr></table></figure><p>可见 <code>FakeAwaiter</code> 并不能满足与 <code>Awaiter</code> 的父子类关系，因此无法作为 <code>AwaiterImpl</code> 的模板实参。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了一种实现较为通用的 Awaiter 的方法，目的在于增加现有 <code>Task</code> 框架的扩展性，避免通过频繁改动 <code>TaskPromise</code> 来新增功能。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每次我们新增功能时，都需要修改 TaskPromise 增加对应的 await_transform 函数，这显然是个设计问题。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</title>
    <link href="https://www.bennyhuo.com//2022/03/22/cpp-coroutines-07-channel/"/>
    <id>https://www.bennyhuo.com//2022/03/22/cpp-coroutines-07-channel/</id>
    <published>2022-03-22T22:03:14.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前我们主要关注的是协程与外部调用者的交互，这次我们也关注一下对等的协程之间的通信。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1oA4y1R7jn&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><h3 id="Go-routine-的-Channel"><a href="#Go-routine-的-Channel" class="headerlink" title="Go routine 的 Channel"></a>Go routine 的 Channel</h3><p>Go routine 当中有一个重要的特性就是 Channel。我们可以向 Channel 当中写数据，也可以从中读数据。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Channel 实例</span></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line"><span class="comment">// 创建只读 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="type">int</span> = channel</span><br><span class="line"><span class="comment">// 创建只写 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="type">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">  <span class="comment">// 遍历 Channel</span></span><br><span class="line">  <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// 读取 Channel，值存入 i，状态存入 ok 当中</span></span><br><span class="line">    i, ok := &lt;-readChannel</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Channel 被关闭时，ok 为 false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">    <span class="comment">// 向 Channel 当中写数据</span></span><br><span class="line">    writeChannel &lt;- i</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这个例子是我写 <a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书时用到过的一个非常简单的 Go routine 的例子，它的运行输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>Go 当中的 Channel 默认是没有 buffer 的，我们也可以通过 <code>make chan</code> 在初始化 Channel 的时候指定 buffer。在 buffer 已满的情况下，写入者会先挂起等待读取者后再恢复执行，反之亦然。等待的过程中，所处的协程会挂起，执行调度的线程自然也会被释放用于调度其他逻辑。</p><h3 id="C-协程的-Channel-实现设计"><a href="#C-协程的-Channel-实现设计" class="headerlink" title="C++ 协程的 Channel 实现设计"></a>C++ 协程的 Channel 实现设计</h3><p>Kotlin 协程当中也有 Channel，与 Go 的不同之处在于 Kotlin 的 Channel 其实是基于协程最基本的 API 在框架层面实现的，并非语言原生提供的能力。C++ 的协程显然也可以采用这个思路，实际上整个这一系列 C++ 协程的文章都是在介绍如何使用 C++ 20 标准当中提供的基本的协程 API 在构建更复杂的框架支持。</p><p>我们来看一下我们最终的 Channel 的用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 写入时调用 write 函数</span></span><br><span class="line">    <span class="keyword">co_await</span> channel.<span class="built_in">write</span>(i++);</span><br><span class="line">    <span class="comment">// 或者使用 &lt;&lt; 运算符</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持关闭</span></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取时使用 read 函数，表达式的值就是读取的值</span></span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="comment">// 或者使用 &gt;&gt; 运算符将读取的值写入变量当中</span></span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="comment">// 捕获 Channel 关闭时抛出的异常</span></span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 Channel 也可以在构造的时候传入 buffer 的大小，默认没有 buffer。</p><h2 id="co-await-表达式的支持"><a href="#co-await-表达式的支持" class="headerlink" title="co_await 表达式的支持"></a>co_await 表达式的支持</h2><p>想要支持 <code>co_await</code> 表达式，只需要为 Channel 读写函数返回的 Awaiter 类型添加相应的 <code>await_transform</code> 函数。我们姑且认为 <code>read</code> 和 <code>write</code> 两个函数的返回值类型 <code>ReaderAwaiter</code> 和 <code>WriterAwaiter</code>，接下来就添加一个非常简单的 <code>await_transform</code> 的支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 void 的实例化版本也是一样的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">    reader_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(WriterAwaiter&lt;_ValueType&gt; writer_awaiter)</span> </span>&#123;</span><br><span class="line">    writer_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> writer_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Channel</code> 的 buffer 和对 <code>Channel</code> 的读写本身会决定协程是否挂起或恢复，因此这些逻辑我们都将在 <code>Channel</code> 当中给出，<code>TaskPromise</code> 能做的就是把调度器传过去，当协程恢复时使用。</p><h2 id="Awaiter-的实现"><a href="#Awaiter-的实现" class="headerlink" title="Awaiter 的实现"></a>Awaiter 的实现</h2><p>Awaiter 负责在挂起时将自己存入 <code>Channel</code>，并且在需要时恢复协程。因此除了前面看到需要在恢复执行协程时的调度器之外，Awaiter 还需要持有 <code>Channel</code>、需要读写的值。</p><p>下面是 <code>WriterAwaiter</code> 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriterAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  <span class="comment">// 调度器不是必须的，如果没有，则直接在当前线程执行（等价于 NoopExecutor）</span></span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 写入 Channel 的值</span></span><br><span class="line">  ValueType _value;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriterAwaiter</span>(Channel&lt;ValueType&gt; *channel, ValueType value)</span><br><span class="line">    : <span class="built_in">channel</span>(channel), _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录协程 handle，恢复时用</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_writer</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中恢复该协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们将调度器调度的逻辑封装在这里</span></span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对应的，还有 <code>ReaderAwaiter</code>，实现类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  <span class="comment">// 用于 channel &gt;&gt; received; 这种情况</span></span><br><span class="line">  <span class="comment">// 需要将变量的地址传入，协程恢复时写入变量内存</span></span><br><span class="line">  ValueType* p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中正常恢复读协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 关闭时调用 resume() 函数来恢复该协程</span></span><br><span class="line">  <span class="comment">// 在 await_resume 当中，如果 Channel 关闭，会抛出 Channel 关闭异常</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单说来，Awaiter 的功能就是：</p><ol><li>负责用协程的调度器在需要时恢复协程</li><li>处理读写的值的传递</li></ol><h2 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h2><p>接下来我们给出 <code>Channel</code> 当中根据 buffer 的情况来处理读写两端的挂起和恢复的逻辑。</p><h3 id="Channel-的基本结构"><a href="#Channel-的基本结构" class="headerlink" title="Channel 的基本结构"></a>Channel 的基本结构</h3><p>我们先来看一下 <code>Channel</code> 的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ChannelClosedException</span> : std::exception &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Channel is closed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_closed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经关闭，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!_is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ChannelClosedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(<span class="type">int</span> capacity = <span class="number">0</span>)</span> : buffer_capacity(capacity) &#123;</span></span><br><span class="line">    _is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 表示 Channel 尚未关闭</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _is_active.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 Channel</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> expect = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 判断如果已经关闭，则不再重复操作</span></span><br><span class="line">    <span class="comment">// 比较 _is_active 为 true 时才会完成设置操作，并且返回 true</span></span><br><span class="line">    <span class="keyword">if</span>(_is_active.<span class="built_in">compare_exchange_strong</span>(expect, <span class="literal">false</span>, std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 清理资源</span></span><br><span class="line">      <span class="built_in">clean_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不希望 Channel 被移动或者复制</span></span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;&amp;channel) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Channel &amp;<span class="keyword">operator</span>=(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁时关闭</span></span><br><span class="line">  ~<span class="built_in">Channel</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// buffer 的容量</span></span><br><span class="line">  <span class="type">int</span> buffer_capacity;</span><br><span class="line">  std::queue&lt;ValueType&gt; buffer;</span><br><span class="line">  <span class="comment">// buffer 已满时，新来的写入者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;WriterAwaiter&lt;ValueType&gt; *&gt; writer_list;</span><br><span class="line">  <span class="comment">// buffer 为空时，新来的读取者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;ReaderAwaiter&lt;ValueType&gt; *&gt; reader_list;</span><br><span class="line">  <span class="comment">// Channel 的状态标识</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; _is_active;</span><br><span class="line"></span><br><span class="line">  std::mutex channel_lock;</span><br><span class="line">  std::condition_variable channel_condition;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clean_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要对已经挂起等待的协程予以恢复执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> writer : writer_list) &#123;</span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    writer_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> reader : reader_list) &#123;</span><br><span class="line">      reader-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    reader_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 buffer</span></span><br><span class="line">    <span class="keyword">decltype</span>(buffer) empty_buffer;</span><br><span class="line">    std::<span class="built_in">swap</span>(buffer, empty_buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过了解 <code>Channel</code> 的基本结构，我们已经知道了 <code>Channel</code> 当中存了哪些信息。接下来我们就要填之前埋下的坑了：分别是在协程当中读写值用到的 <code>read</code> 和 <code>write</code> 函数，以及在挂起协程时 Awaiter 当中调用的 <code>try_push_writer</code> 和 <code>try_push_reader</code>。</p><h3 id="read-和-write"><a href="#read-和-write" class="headerlink" title="read 和 write"></a>read 和 write</h3><p>这两个函数也没什么实质的功能，就是把 Awaiter 创建出来，然后填充信息再返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">write</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WriterAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;&lt;(ValueType value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReaderAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&gt;&gt;(ValueType &amp;value_ref) &#123;</span><br><span class="line">    <span class="keyword">auto</span> awaiter =  <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// 保存待赋值的变量的地址，方便后续写入</span></span><br><span class="line">    awaiter.p_value = &amp;value_ref;</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当中除了 <code>operator&gt;&gt;</code> 的实现需要多保存一个变量的地址以外，大家只需要注意一下对于 <code>check_closed</code> 的调用即可，它的功能很简单：在 <code>Channel</code> 关闭之后调用它会抛出 <code>ChannelClosedException</code>。</p><h3 id="try-push-writer-和-try-push-reader"><a href="#try-push-writer-和-try-push-reader" class="headerlink" title="try_push_writer 和 try_push_reader"></a><code>try_push_writer</code> 和 <code>try_push_reader</code></h3><p>这是 <code>Channel</code> 当中最为核心的两个函数了，他们的功能正好相反。</p><p><code>try_push_writer</code> 调用时，意味着有一个新的写入者挂起准备写入值到 <code>Channel</code> 当中，这时候有以下几种情况：</p><ol><li><code>Channel</code> 当中有挂起的读取者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li><li><code>Channel</code> 的 buffer 没满，写入者把值写入 buffer，然后立即恢复执行。</li><li><code>Channel</code> 的 buffer 已满，则写入者被存入挂起列表（writer_list）等待新的读取者读取时再恢复。</li></ol><p>了解了思路之后，它的实现就不难写出了，具体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_writer</span><span class="params">(WriterAwaiter&lt;ValueType&gt; *writer_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line">  <span class="comment">// 检查有没有挂起的读取者，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!reader_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader = reader_list.<span class="built_in">front</span>();</span><br><span class="line">    reader_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader-&gt;<span class="built_in">resume</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 未满，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (buffer.<span class="built_in">size</span>() &lt; buffer_capacity) &#123;</span><br><span class="line">    buffer.<span class="built_in">push</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 已满，对应情况 3</span></span><br><span class="line">  writer_list.<span class="built_in">push_back</span>(writer_awaiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对应的，<code>try_push_reader</code> 调用时，意味着有一个新的读取者挂起准备从 <code>Channel</code> 当中读取值，这时候有以下几种情况：</p><ol><li><code>Channel</code> 的 buffer 非空，读取者从 buffer 当中读取值，如果此时有挂起的写入者，需要去队头的写入者将值写入 buffer，然后立即恢复该写入者和当次的读取者。</li><li><code>Channel</code> 当中有挂起的写入者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li><li><code>Channel</code> 的 buffer 为空，则读取者被存入挂起列表（reader_list）等待新的写入者写入时再恢复。</li></ol><p>接下来是具体的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 非空，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = buffer.<span class="built_in">front</span>();</span><br><span class="line">    buffer.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 有挂起的写入者要及时将其写入 buffer 并恢复执行</span></span><br><span class="line">      <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">      writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">      buffer.<span class="built_in">push</span>(writer-&gt;_value);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有写入者挂起，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">    writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(writer-&gt;_value);</span><br><span class="line">    writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 为空，对应情况 3</span></span><br><span class="line">  reader_list.<span class="built_in">push_back</span>(reader_awaiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，我们已经完整给出 <code>Channel</code> 的实现。</p><blockquote><p><strong>说明</strong>：我们当然也可以在 <code>await_ready</code> 的时候提前做一次判断，如果命中第 1、2 两种情况可以直接让写入/读取协程不挂起继续执行，这样可以避免写入/读取者的无效挂起。为了方便介绍，本文就不再做相关优化了。</p></blockquote><h3 id="监听协程的提前销毁"><a href="#监听协程的提前销毁" class="headerlink" title="监听协程的提前销毁"></a>监听协程的提前销毁</h3><p>截止目前，我们给出的 <code>Channel</code> 仍然有个小小的限制，即 <code>Channel</code> 对象必须在持有 <code>Channel</code> 实例的协程退出之前关闭。</p><p>这主要是因为我们在 <code>Channel</code> 当中持有了已经挂起的读写协程的 <code>Awaiter</code> 的指针，一旦协程销毁，这些 <code>Awaiter</code> 也会被销毁，<code>Channel</code> 在关闭时试图恢复这些读写协程时就会出现程序崩溃（访问了野指针）。</p><p>为了解决这个问题，我们需要在 <code>Awaiter</code> 销毁时主动将自己的指针从 <code>Channel</code> 当中移除。以 <code>ReaderAwaiter</code> 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现移动构造函数，主要目的是将原对象的 channel 置为空</span></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="comment">// 协程恢复，channel 已经没用了</span></span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="comment">// channel 不为空，说明协程提前被销毁了</span></span><br><span class="line">    <span class="comment">// 调用 channel 的 remove_reader 将自己直接移除</span></span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在 <code>ReaderAwaiter</code> 的析构函数当中主动检查并移除了自己的指针，避免后续 <code>Channel</code> 对自身指针的无效访问。</p><p>对应的，<code>Channel</code> 当中也需要增加 <code>remove_reader</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并发环境，修改 reader_list 的操作都需要加锁</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">    reader_list.<span class="built_in">remove</span>(reader_awaiter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriterAwaiter</code> 的修改类似，不再赘述。</p><p>这样修改之后，即使我们把正在等待读写 <code>Channel</code> 的协程提前结束销毁，也不会影响 <code>Channel</code> 的继续使用以及后续的正常关闭了。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们终于又实现了一个新的玩具，现在我们来给它通电试试效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send: &quot;</span>, i);</span><br><span class="line">    <span class="comment">// 或者使用 write 函数：co_await channel.write(i++);</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">    <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;close channel, exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 或者使用 read 函数：auto received = co_await channel.read();</span></span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer2</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive2: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">3</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception2: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> channel = <span class="built_in">Channel</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> producer = <span class="built_in">Producer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer = <span class="built_in">Consumer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer2 = <span class="built_in">Consumer2</span>(channel);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 等待协程执行完成再退出</span></span><br><span class="line">  producer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer2.<span class="built_in">get_result</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子非常简单，我们用一个写入者两个接收者向 <code>Channel</code> 当中读写数据，为了让示例更加凌乱，我们还加了一点点延时，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">08:39:58.129 [Thread-26004] (main.cpp:15) Producer: send:  0</span><br><span class="line">08:39:58.130 [Thread-27716] (main.cpp:31) Consumer: receive:  0</span><br><span class="line">08:39:58.443 [Thread-26004] (main.cpp:15) Producer: send:  1</span><br><span class="line">08:39:58.444 [Thread-17956] (main.cpp:45) Consumer2: receive2:  1</span><br><span class="line">08:39:58.759 [Thread-26004] (main.cpp:15) Producer: send:  2</span><br><span class="line">08:39:59.071 [Thread-26004] (main.cpp:15) Producer: send:  3</span><br><span class="line">08:39:59.382 [Thread-26004] (main.cpp:15) Producer: send:  4</span><br><span class="line">08:40:00.145 [Thread-27716] (main.cpp:31) Consumer: receive:  4</span><br><span class="line">08:40:00.454 [Thread-26004] (main.cpp:15) Producer: send:  5</span><br><span class="line">08:40:01.448 [Thread-17956] (main.cpp:45) Consumer2: receive2:  5</span><br><span class="line">08:40:01.762 [Thread-26004] (main.cpp:15) Producer: send:  6</span><br><span class="line">08:40:02.152 [Thread-27716] (main.cpp:31) Consumer: receive:  6</span><br><span class="line">08:40:02.464 [Thread-26004] (main.cpp:15) Producer: send:  7</span><br><span class="line">08:40:04.164 [Thread-27716] (main.cpp:31) Consumer: receive:  7</span><br><span class="line">08:40:04.460 [Thread-17956] (main.cpp:45) Consumer2: receive2:  2</span><br><span class="line">08:40:04.475 [Thread-26004] (main.cpp:15) Producer: send:  8</span><br><span class="line">08:40:04.787 [Thread-26004] (main.cpp:15) Producer: send:  9</span><br><span class="line">08:40:06.169 [Thread-27716] (main.cpp:31) Consumer: receive:  9</span><br><span class="line">08:40:06.481 [Thread-26004] (main.cpp:22) Producer: close channel, exit.</span><br><span class="line">08:40:07.464 [Thread-17956] (main.cpp:52) Consumer2: exit.</span><br><span class="line">08:40:08.181 [Thread-27716] (main.cpp:38) Consumer: exit.</span><br></pre></td></tr></table></figure><p>结果我就不分析了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文给出了 C++ 协程版的 <code>Channel</code> 的 demo 实现，这进一步证明了 C++ 协程的基础 API 的设计足够灵活，能够支撑非常复杂的需求场景。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前我们主要关注的是协程与外部调用者的交互，这次我们也关注一下对等的协程之间的通信。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</title>
    <link href="https://www.bennyhuo.com//2022/03/20/cpp-coroutines-06-sleep/"/>
    <id>https://www.bennyhuo.com//2022/03/20/cpp-coroutines-06-sleep/</id>
    <published>2022-03-20T22:03:28.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你想要等待 100ms，你会怎么做？sleep_for(100ms) 吗？ </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV15v4y1g7Nu&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>在以往，我们想要让程序等待 100ms，我们只能调用线程的 sleep 函数来阻塞当前线程 100ms。</p><p>这样做确实可以让程序等待 100ms，但坏处就是这 100ms 期间，被阻塞的当前线程什么也做不了，白白占用了内存。协程出现之后，我们其实完全可以让协程在需要 sleep 的时候挂起，100ms 之后再来恢复执行，完全不需要阻塞当前线程。</p><p>想法不错，马上把用例给出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="comment">// 之前的写法，用 sleep_for 让当前线程睡眠 1 秒</span></span><br><span class="line">  <span class="comment">// std::this_thread::sleep_for(1s);</span></span><br><span class="line">  <span class="comment">// 等待 1 秒，注意 1s 是 chrono_literals 的字面值写法</span></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子大家已经见过多次了，之前用的是 <code>sleep_for</code> 让线程睡眠 1 秒，这次我们直接用 <code>co_await 1s</code>，看上去是不是特别的厉害？</p><h2 id="为-duration-实现-await-transform"><a href="#为-duration-实现-await-transform" class="headerlink" title="为 duration 实现 await_transform"></a>为 duration 实现 await_transform</h2><p>如果大家对于 C++ 11 不熟悉，可能会比较疑惑 <code>co_await 1s</code> 当中的 <code>1s</code> 是个什么东西。实际上这是 C++ 11 对字面值的一种支持，本质上就是一个运算符重载，这里的 <code>1s</code> 的类型是 <code>duration&lt;long long&gt;</code>。除了秒以外，时间的单位也可以是毫秒、纳秒、分钟、小时等等，这些 C++ 11 的 <code>duration</code> 都已经提供了完善的支持，因此我们只要对 <code>duration</code> 做支持即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了一个新的类型 <code>SleepAwaiter</code>，它的任务有两个：</p><ol><li>确保当前协程在若干毫秒之后恢复执行。</li><li>确保当前协程恢复执行时要调度到对应的调度器上。</li></ol><p>不难想到，<code>std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()</code> 实际上就是把任意单位的 <code>duration</code> 转换成毫秒。</p><p><code>SleepAwaiter</code> 的实现也很简单，我们直接给出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的延时执行工具类，全局只需要一个实例</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      <span class="comment">// _duration 毫秒之后执行下面的代码</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当中最为关键的就是 <code>Scheduler</code> 的实现了，这个类实际上本身就是一个独立的定时任务调度器。</p><h2 id="定时任务调度器-Scheduler"><a href="#定时任务调度器-Scheduler" class="headerlink" title="定时任务调度器 Scheduler"></a>定时任务调度器 Scheduler</h2><p>定时任务调度器，本质上就是一个时间管理大师。任何交给它的任务都需要有优先级，优先级的计算规则当然就是延时的长短，于是我们需要用到优先级队列来存储待执行的任务。</p><p>等下，任务队列？这让我想起上一篇文章当中的 <code>LooperExecutor</code>，如果我们给它加上计时执行的能力，<code>Scheduler</code> 的功能就差不多完成了。换个角度看，<code>LooperExecutor</code> 其实就是 <code>Scheduler</code> 的一个特化版本，它的所有任务的延时都是 0。</p><h3 id="定义定时任务的描述类型"><a href="#定义定时任务的描述类型" class="headerlink" title="定义定时任务的描述类型"></a>定义定时任务的描述类型</h3><p>为了方便管理定时任务，我们需要定义一个类型 <code>DelayedExecutable</code>，它包含一个函数和它要执行的绝对时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DelayedExecutable</span>(std::function&lt;<span class="built_in">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay) : <span class="built_in">func</span>(std::<span class="built_in">move</span>(func)) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 当前的时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出任务的计划执行时间</span></span><br><span class="line">    scheduled_time = current + delay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用时，返回从当前时间还需要多少毫秒到任务执行时间</span></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">delay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> scheduled_time - current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_scheduled_time</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduled_time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> scheduled_time;</span><br><span class="line">  std::function&lt;<span class="type">void</span>()&gt; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定时任务的描述类 <code>DelayedExecutable</code> 非常简单，相信大家一看就明白。</p><p>为了将 <code>DelayedExecutable</code> 存入优先级队列当中，我们还需要给它提给一个比较大小的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutableCompare</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(DelayedExecutable &amp;left, DelayedExecutable &amp;right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">get_scheduled_time</span>() &gt; right.<span class="built_in">get_scheduled_time</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类就很简单了，直接将对 <code>DelayedExecutable</code> 的比较转换成对它们的执行时间的比较。使用这个类对 <code>DelayedExecutable</code> 进行排序时，会使得时间靠前的对象排到前面。</p><h3 id="实现定时任务调度器"><a href="#实现定时任务调度器" class="headerlink" title="实现定时任务调度器"></a>实现定时任务调度器</h3><p>接下来我们直接给出 <code>Scheduler</code> 的实现，由于这个类与前面的 <code>LooperExecutor</code> 很像，我们只给出不同的部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  <span class="comment">// 注意这里改用优先级队列</span></span><br><span class="line">  std::priority_queue&lt;DelayedExecutable, std::vector&lt;DelayedExecutable&gt;, DelayedExecutableCompare&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从这里开始于 LooperExecutor 不同，这里需要判断优先级队头的任务，也就是最先要执行的任务是否需要立即执行</span></span><br><span class="line">      <span class="keyword">auto</span> executable = executable_queue.<span class="built_in">top</span>();</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> delay = executable.<span class="built_in">delay</span>();</span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队头的任务还没到执行时间，等待 delay 毫秒</span></span><br><span class="line">        <span class="keyword">auto</span> status = queue_condition.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(delay));</span><br><span class="line">        <span class="comment">// 如果等待期间没有延时比 delay 更小的任务加入，这里就会返回 timeout</span></span><br><span class="line">        <span class="keyword">if</span> (status != std::cv_status::timeout) &#123;</span><br><span class="line">          <span class="comment">// 不是 timeout，需要重新计算队头的延时</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">executable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay)</span> </span>&#123;</span><br><span class="line">    delay = delay &lt; <span class="number">0</span> ? <span class="number">0</span> : delay;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 只有队列为空或者比当前队头任务的延时更小时，需要调用 notify_one</span></span><br><span class="line">      <span class="comment">// 其他情况只需要按顺序依次执行即可</span></span><br><span class="line">      <span class="type">bool</span> need_notify = executable_queue.<span class="built_in">empty</span>() || executable_queue.<span class="built_in">top</span>().<span class="built_in">delay</span>() &gt; delay;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(<span class="built_in">DelayedExecutable</span>(std::<span class="built_in">move</span>(func), delay));</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">if</span> (need_notify) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对代码和注释的阅读，相信大家能够明白延时的实现其实是通过阻塞一个专门用于调度延时任务的线程来做到的。</p><p>相信有读者会有疑问：这不还是有阻塞吗？</p><p>没错，阻塞是免不了的。通常而言，我们也不会用一个线程去严格对应一个协程，当一个协程挂起时，执行这个协程的线程就会被空闲出来有机会去调度执行其他协程，进而让线程的利用率得到充分提升。如果有 10 个协程都需要执行延时，相较于阻塞这 10 个协程当前所在的 10 个线程而言，阻塞一个线程显然是更加经济的。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们又一次在文章的最后把要实现的功能做好，现在是收获的时刻了。</p><p>我们先来一个开胃菜。前面我们提到过，<code>Scheduler</code> 实际上是一个完整独立的功能模块，因此我们先写个简单的用例来测试一下它的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> scheduler = <span class="built_in">Scheduler</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;2&quot;</span>); &#125;, <span class="number">100</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;1&quot;</span>); &#125;, <span class="number">50</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;6&quot;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;5&quot;</span>); &#125;, <span class="number">500</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;3&quot;</span>); &#125;, <span class="number">200</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;4&quot;</span>); &#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">scheduler.<span class="built_in">shutdown</span>();</span><br><span class="line">scheduler.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>打印的数字是按照时间顺序排列的，但任务的添加却是乱序的。运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">22:12:54.611 [Thread-16076] (main.cpp:12) main: start</span><br><span class="line">22:12:54.673 [Thread-3252] (main.cpp:14) operator (): 1</span><br><span class="line">22:12:54.721 [Thread-3252] (main.cpp:13) operator (): 2</span><br><span class="line">22:12:54.815 [Thread-3252] (main.cpp:17) operator (): 3</span><br><span class="line">22:12:54.924 [Thread-3252] (main.cpp:18) operator (): 4</span><br><span class="line">22:12:55.113 [Thread-3252] (main.cpp:16) operator (): 5</span><br><span class="line">22:12:55.618 [Thread-3252] (main.cpp:15) operator (): 6</span><br></pre></td></tr></table></figure><p>可以看到 1-6 的顺序是可以保证的，前面的时间信息也可以看到延时能力基本上是符合预期的。</p><p>接下来，我们把前面用了好几次的 <code>Task</code> 的 demo 拿出来，加上延时，顺便也验证一下 <code>AsyncExecutor</code> 和 <code>NewThreadExecutor</code> 的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">100</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 100ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">500</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 500ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">22:14:49.531 [Thread-15596] (main.cpp:41) simple_task: task start ...</span><br><span class="line">22:14:49.641 [Thread-15596] (main.cpp:44) simple_task: after 100ms ...</span><br><span class="line">22:14:49.643 [Thread-26892] (main.cpp:25) simple_task2: task 2 start ...</span><br><span class="line">22:14:50.652 [Thread-26892] (main.cpp:28) simple_task2: task 2 returns after 1s.</span><br><span class="line">22:14:50.653 [Thread-15596] (main.cpp:46) simple_task: returns from task2:  2</span><br><span class="line">22:14:51.156 [Thread-15596] (main.cpp:49) simple_task: after 500ms ...</span><br><span class="line">22:14:51.158 [Thread-16816] (main.cpp:33) simple_task3: in task 3 start ...</span><br><span class="line">22:14:53.165 [Thread-26756] (main.cpp:36) simple_task3: task 3 returns after 2s.</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:51) simple_task: returns from task3:  3</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:58) operator (): simple task end:  6</span><br><span class="line">22:14:53.167 [Thread-11256] (main.cpp:64) test_tasks: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>我们把所有的 <code>sleep_for</code> 都替换成了本文实现的无阻塞的 sleep，运行效果上来看确实可以按照要求实现延时执行。</p><p>另外，由于这里的 <code>co_await 1s</code> 这样的操作都是挂起点，因此恢复时也会用协程的调度器去调度。可以看到，<code>simple_task2</code> 的两行日志的线程都是 <code>26892</code>，这大概是因为 <code>std::async</code> 背后是一个线程池，两次调度都调度到了同一个线程上，当然这个完全取决于 <code>std::async</code> 的实现。而 <code>simple_task3</code> 的两行日志就分别运行在 <code>16816</code> 和 <code>26756</code>，因为它的调度器是 <code>NewThreadExecutor</code>，每次都会新起一个线程来实现调度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文结合前面的 <code>Task</code> 的内容进一步给出了无阻塞式的 sleep 实现。通过本文的探讨，相信大家族在感慨 C++ 协程的设计真的是如此的灵活的同时，也进一步深入了解了 C++ 协程的用法。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果你想要等待 100ms，你会怎么做？sleep_for(100ms) 吗？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（5）：协程的调度器</title>
    <link href="https://www.bennyhuo.com//2022/03/20/cpp-coroutines-05-dispatcher/"/>
    <id>https://www.bennyhuo.com//2022/03/20/cpp-coroutines-05-dispatcher/</id>
    <published>2022-03-20T12:03:19.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程想要实现异步，很大程度上依赖于调度器的设计。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1TW4y1k7gp&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="调度器的抽象设计"><a href="#调度器的抽象设计" class="headerlink" title="调度器的抽象设计"></a>调度器的抽象设计</h2><p>为了实现协程的异步调度，我们需要提供调度器的实现。调度器听起来有些厉害，但实际上就是负责执行一段逻辑的工具。</p><p>下面我们给出调度器的抽象设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExecutor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是的，你没看错，调度器本身就是这么简单。</p><h2 id="调度的位置"><a href="#调度的位置" class="headerlink" title="调度的位置"></a>调度的位置</h2><p>现在我们已经知道了调度器的样子，那么问题来了，怎么才能把它接入到协程当中呢？这个问题换个说法，那就是什么情况下我们需要调度，或者说什么情况下我们可以实现调度。</p><p>这个问题如果你不知道答案，让你随便蒙，你大概也没有什么其他的选项可以选。因为协程的本质就是挂起和恢复，因此想要实现调度，就必须在挂起和恢复上做文章。想要在 C++ 的协程的挂起和恢复上做文章，那我们就只能考虑定制 Awaiter 了。我们再来回顾一下前面提到的 TaskAwaiter 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们只保留了最核心的三个函数，其他的代码都略去了。可以看到，想要实现调度，就只能在 <code>await_suspend</code> 上面做文章，因为其他两个函数都要求同步返回。</p><p>实际上，按照 C++ 协程的设计，<code>await_suspend</code> 确实是用来提供调度支持的，由于这个时间点协程已经完全挂起，因此我们可以在任意一个线程上调用 <code>handle.resume()</code>，你甚至不用担心线程安全的问题。这样看来，如果有调度器的存在，代码大概会变成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度器的类型有多种，因此专门提供一个模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 TaskAwaiter 的时候传入调度器的具体实现</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 将 resume 函数的调用交给调度器执行</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调度器应该由谁持有"><a href="#调度器应该由谁持有" class="headerlink" title="调度器应该由谁持有"></a>调度器应该由谁持有</h2><p><code>TaskAwaiter</code> 当中的调度器实例是从外部传来的，这样设计的目的是希望把调度器的创建和绑定交给协程本身。换句话说，调度器应该属于协程。这样设计的好处就是协程内部的代码均会被调度到它对应的调度器上执行，可以确保逻辑的一致性和正确性。</p><p>这么看来，调度器应该与 <code>Task</code> 或者 <code>TaskPromise</code> 绑定到一起。</p><p>当协程创建时，我们可以以某种方式执行一个调度器，让协程的执行从头到尾都调度到这个调度器上执行。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 协程启动时就要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="comment">// 协程从 simple_task2 挂起后恢复执行，也要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="comment">// 同上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过模板参数为 <code>Task</code> 绑定了一个叫做 <code>LooperExecutor</code> 的调度器（我们现在先不去管 <code>LooperExecutor</code> 的具体实现，这个我们后面会讲），这样一来，我们希望 <code>simple_task</code> 当中所有的代码都会被调度到 <code>LooperExecutor</code> 上执行。</p><p>请大家参考注释的说明，我们了解到所有挂起的位置都需要在恢复时拿到同一个 <code>LooperExecutor</code> 的实例，因此我们考虑首先对 <code>TaskPromise</code> 的定义做一下修改，引入 <code>Executor</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程启动时也需要在恢复时实现调度</span></span><br><span class="line">  <span class="function">DispatchAwaiter <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DispatchAwaiter&#123;&amp;executor&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Task 类型增加模板参数 Executor 可以方便创建协程时执行调度器的类型</span></span><br><span class="line">  <span class="function">Task&lt;ResultType, Executor&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Executor executor;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们在 <code>TaskPromise</code> 当中定义了 <code>await_transform</code>，因此协程当中只支持对 <code>Task</code> 类型的 <code>co_await</code> 操作，这样可以保证所有的 <code>co_await &lt;task&gt;</code> 都会在恢复执行时通过 <code>TaskAwaiter</code> 来确保后续逻辑的正确调度。</p><p>剩下的就是协程在启动时的 <code>initial_suspend</code> 了，这个也比较容易处理，我们给出 <code>DispatchAwaiter</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">DispatchAwaiter</span><span class="params">(AbstractExecutor *executor)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调度到协程对应的调度器上</span></span><br><span class="line">    _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此一来，协程内部的所有逻辑都可以顺利地调度到协程对应的调度器上了。</p><p><code>Task</code> 的改动不大，只是增加了模板参数 <code>Executor</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewThreadExecutor 是 AbstractExecutor 的子类，作为模板参数 Executor 的默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NewThreadExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将模板参数 Executor 传给 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType, Executor&gt;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以默认给 <code>Task</code> 指定一个调度器的实现 <code>NewThreadExecutor</code>。这些调度器可以通过指定类型在 <code>TaskPromise</code> 当中执行初始化，因为我们会保证他们都会有默认的无参构造器实现。</p><h2 id="调度器的实现"><a href="#调度器的实现" class="headerlink" title="调度器的实现"></a>调度器的实现</h2><p>接下来我们给出几种简单的调度器实现作为示例，读者有兴趣也可以按照自己的需要设计调度器的实现。</p><h3 id="NoopExecutor"><a href="#NoopExecutor" class="headerlink" title="NoopExecutor"></a>NoopExecutor</h3><p>看名字相比大家也能猜个八九不离十，这就是个什么都不干的调度器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoopExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们给 <code>Task</code> 搭配这个调度器，<code>Task</code> 的执行线程就完全取决于调用者或者恢复者所在的线程了。</p><h3 id="NewThreadExecutor"><a href="#NewThreadExecutor" class="headerlink" title="NewThreadExecutor"></a>NewThreadExecutor</h3><p>顾名思义，每次调度都创建一个新的线程。实现非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewThreadExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">thread</span>(func).<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AsyncExecutor"><a href="#AsyncExecutor" class="headerlink" title="AsyncExecutor"></a>AsyncExecutor</h3><p>这个在思路上与 <code>NewThreadExecutor</code> 差别不大，只是调度时交给了 <code>std::async</code> 去执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比之下，这个调度器可以利用 <code>std::async</code> 背后的线程调度，提升线程的利用率。</p><h3 id="LooperExecutor"><a href="#LooperExecutor" class="headerlink" title="LooperExecutor"></a>LooperExecutor</h3><p>LooperExecutor 稍微复杂一些，它通常出现在主线程为事件循环的场景，例如 UI 相关应用的开发场景。</p><p>考虑到我本身不希望引入 UI 相关的开发概念，这里直接给出一个简单的单线程事件循环，并以此来实现 LooperExecutor：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 的时候是工作状态，如果要关闭事件循环，就置为 false</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理事件循环</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前事件循环是否是工作状态，或者队列没有清空</span></span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 队列为空，需要等待新任务加入队列或者关闭事件循环的通知</span></span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="comment">// 如果队列为空，那么说明收到的是关闭的通知</span></span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="comment">// 现有逻辑下此处用 break 也可</span></span><br><span class="line">          <span class="comment">// 使用 continue 可以再次检查状态和队列，方便将来扩展</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取出第一个任务，解锁再执行。</span></span><br><span class="line">      <span class="comment">// 解锁非常：func 是外部逻辑，不需要锁保护；func 当中可能请求锁，导致死锁</span></span><br><span class="line">      <span class="keyword">auto</span> func = executable_queue.<span class="built_in">front</span>();</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    work_thread = std::<span class="built_in">thread</span>(&amp;LooperExecutor::run_loop, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    <span class="built_in">shutdown</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 等待线程执行完，防止出现意外情况</span></span><br><span class="line">    <span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(func);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="comment">// 通知队列，主要用于队列之前为空时调用 wait 等待的情况</span></span><br><span class="line">      <span class="comment">// 通知不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">      queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改后立即生效，在 run_loop 当中就能尽早（加锁前）就检测到 is_active 的变化</span></span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_complete) &#123;    </span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="comment">// 清空任务队列</span></span><br><span class="line">      <span class="keyword">decltype</span>(executable_queue) empty_queue;</span><br><span class="line">      std::<span class="built_in">swap</span>(executable_queue, empty_queue);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 wait 函数，避免 Looper 线程不退出</span></span><br><span class="line">    <span class="comment">// 不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">    queue_condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各位读者可以参考代码注释来理解其中的逻辑。简单来说就是：</p><ol><li>当队列为空时，Looper 的线程通过 <code>wait</code> 来实现阻塞等待。</li><li>有新任务加入时，通过 <code>notify_one</code> 来通知 <code>run_loop</code> 继续执行。</li></ol><h3 id="SharedLooperExecutor"><a href="#SharedLooperExecutor" class="headerlink" title="SharedLooperExecutor"></a>SharedLooperExecutor</h3><p>这个其实就是 <code>LooperExecutor</code> 的一个马甲，它的作用就是让各个协程共享一个 <code>LooperExecutor</code> 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedLooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> LooperExecutor sharedLooperExecutor;</span><br><span class="line">    sharedLooperExecutor.<span class="built_in">execute</span>(std::<span class="built_in">move</span>(func));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>这次我们基于上一篇文章当中的 demo 加入调度器的支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 Async 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会通过 std::async 上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 NewThread 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会新建一个线程来执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 Looper 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会在同一个线程上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的代码跟上次不能说完全没有修改吧，那也是几乎没有修改，除了加了调度器的类型作为 <code>Task</code> 的模板参数。运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11:46:03.305 [Thread-32620] (main.cpp:40) simple_task: task start ...</span><br><span class="line">11:46:03.307 [Thread-33524] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">11:46:04.310 [Thread-33524] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">11:46:04.312 [Thread-32620] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">11:46:04.313 [Thread-42232] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">11:46:06.327 [Thread-42232] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">11:46:06.330 [Thread-30760] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>请大家仔细观察，所有 <code>simple_task</code> 函数的日志输出都在 id 为 32620 的线程上，这实际上就是我们的 Looper 线程。当然，由于 <code>simple_task2</code> 和 <code>simple_task3</code> 当中没有挂起点，因此它们只会在 <code>initial_suspend</code> 时调度一次。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们终于给 <code>Task</code> 添加了调度器的支持。如此一来，我们就可以把 <code>Task</code> 绑定到合适的线程调度器上，来应对更加复杂的业务场景了。</p><p>读者也可以发挥自己的想象力，按照类似的方式定义出更加有用或者有趣的调度器。当然，本文给出的调度器没有做调度优化，有兴趣的读者也可以自己尝试</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程想要实现异步，很大程度上依赖于调度器的设计。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（4）：通用异步任务 Task</title>
    <link href="https://www.bennyhuo.com//2022/03/19/cpp-coroutines-04-task/"/>
    <id>https://www.bennyhuo.com//2022/03/19/cpp-coroutines-04-task/</id>
    <published>2022-03-19T16:03:08.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程主要用来降低异步任务的编写复杂度，异步任务各式各样，但归根结底就是一个结果的获取。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV163411g7np&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>为了方便介绍后续的内容，我们需要再定义一个类型 <code>Task</code> 来作为协程的返回值。<code>Task</code> 类型可以用来封装任何返回结果的异步行为（持续返回值的情况可能更适合使用序列生成器）。</p><p>实现的效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 1 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 2 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// result2 == 2</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// result3 == 3</span></span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义以 <code>Task&lt;ResultType&gt;</code> 为返回值类型的协程，并且可以在协程内部使用 <code>co_await</code> 来等待其他 <code>Task</code> 的执行。</p><p>外部非协程内的函数当中访问 <code>Task</code> 的结果时，我们可以通过回调或者同步阻塞调用两种方式来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步方式</span></span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步方式</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个效果，我们大致可以分析得到：</p><ol><li>需要一个结果类型来承载正常返回和异常抛出的情况。</li><li>需要为 <code>Task</code> 定义相应的 <code>promise_type</code> 类型来支持 <code>co_return</code> 和 <code>co_await</code>。</li><li>为 <code>Task</code> 实现获取结果的阻塞函数 <code>get_result</code> 或者用于获取返回值的回调 <code>then</code> 以及用于获取抛出的异常的回调 <code>catching</code>。</li></ol><h2 id="结果类型的定义"><a href="#结果类型的定义" class="headerlink" title="结果类型的定义"></a>结果类型的定义</h2><p>描述 <code>Task</code> 正常返回的结果和抛出的异常，只需要定义一个持有二者的类型即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化为默认值</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 正常返回时用结果初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(T &amp;&amp;value)</span> : _value(value) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 抛异常时用异常初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取结果，有异常则抛出异常</span></span><br><span class="line">  <span class="function">T <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T _value&#123;&#125;;</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>Result</code> 的模板参数 <code>T</code> 对应于 <code>Task</code> 的返回值类型。有了这个结果类型，我们就可以很方便地在需要读取结果的时候调用 <code>get_or_throw</code>。</p><h2 id="promise-type-的定义"><a href="#promise-type-的定义" class="headerlink" title="promise_type 的定义"></a>promise_type 的定义</h2><p>promise_type 的定义自然是最为重要的部分。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>基于前面几篇文章的基础，我们能够<del>很轻松地</del>给出它的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程立即执行</span></span><br><span class="line">  <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行结束后挂起，等待外部销毁。该逻辑与前面的 Generator 类似</span></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造协程的返回值对象 Task</span></span><br><span class="line">  <span class="function">Task&lt;ResultType&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将异常存入 result</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将返回值存入 result，对应于协程内部的 &#x27;co_return value&#x27;</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 使用 std::optional 可以区分协程是否执行完成</span></span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="await-transform"><a href="#await-transform" class="headerlink" title="await_transform"></a>await_transform</h3><p>光有这些还不够，我们还需要为 <code>Task</code> 添加 <code>co_await</code> 的支持。这里我们有两个选择：</p><ol><li>为 <code>Task</code> 实现 <code>co_await</code> 运算符</li><li>在 <code>promise_type</code> 当中定义 <code>await_transform</code></li></ol><p>从效果上来看，二者都可以做到。但区别在于，<code>await_transform</code> 是 <code>promsie_type</code> 的内部函数，可以直接访问到 <code>promise</code> 内部的状态；同时，<code>await_transform</code> 的定义也会限制协程内部对于其他类型的 <code>co_await</code> 的支持，将协程内部的挂起行为更好的管控起来，方便后续我们做统一的线程调度。因此此处我们采用 <code>await_transform</code> 来为 <code>Task</code> 提供 <code>co_await</code> 支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里的模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType&gt;(std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，返回了一个 <code>TaskAwaiter</code> 的对象。不过再次请大家注意，这里存在两个 <code>Task</code>，一个是 <code>TaskPromise</code> 对应的 <code>Task</code>，一个是 <code>co_await</code> 表达式的操作数 <code>Task</code>，后者是 <code>await_transform</code> 的参数。</p><p>下面是 <code>TaskAwaiter</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 task 执行完之后调用 resume</span></span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复执行时，被等待的 Task 已经执行完，调用 get_result 来获取结果</span></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R&gt; task;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个 <code>Task</code> 实例被 co_await 时，意味着它在 co_await 表达式返回之前已经执行完毕，当 <code>co_await</code> 表达式返回时，<code>Task</code> 的结果也就被取到，<code>Task</code> 实例在后续就没有意义了。因此 <code>TaskAwaiter</code> 的构造器当中接收 <code>Task &amp;&amp;</code>，防止 <code>co_await</code> 表达式之后继续对 <code>Task</code> 进行操作。</p><h3 id="同步阻塞获取结果"><a href="#同步阻塞获取结果" class="headerlink" title="同步阻塞获取结果"></a>同步阻塞获取结果</h3><p>为了防止 <code>result</code> 被外部随意访问，我们特意将其改为私有成员。接下来我们还需要提供相应的方式方便外部访问 <code>result</code>。</p><p>先来看一下如何实现同步阻塞的结果返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回</span></span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// 等待写入值之后调用 notify_all</span></span><br><span class="line">      completion.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有值，则直接返回（或者抛出异常）</span></span><br><span class="line">    <span class="keyword">return</span> result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">  std::mutex completion_lock;</span><br><span class="line">  std::condition_variable completion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要阻塞，就免不了用到锁（mutex）和条件变量（condition_variable），熟悉它们的读者一定觉得事情变得不那么简单了：这些工具在以往都是用在多线程并发的环境当中的。我们现在这么写其实也是为了后续应对多线程的场景，有关多线程调度的问题我们将在下一篇文章当中讨论。</p><h3 id="异步结果回调"><a href="#异步结果回调" class="headerlink" title="异步结果回调"></a>异步结果回调</h3><p>异步回调的实现稍微复杂一些，其实主要复杂在对于函数的运用。实际上对于回调的支持，主要就是支持回调的注册和回调的调用。根据结果类型的不同，回调又分为返回值的回调或者抛出异常的回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 加锁判断 result</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// result 已经有值</span></span><br><span class="line">      <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">      <span class="comment">// 解锁之后再调用 func</span></span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">func</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则添加回调函数，等待调用</span></span><br><span class="line">      completion_callbacks.<span class="built_in">push_back</span>(func);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调列表，我们允许对同一个 Task 添加多个回调</span></span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_callbacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;callback : completion_callbacks) &#123;</span><br><span class="line">      <span class="built_in">callback</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用完成，清空回调</span></span><br><span class="line">    completion_callbacks.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，如果只是在单线程环境内运行协程，这里的异步回调的作用可能并不明显。这里只是先给出定义，待我们后续支持线程调度之后，这些回调支持就会非常有价值了。</p><h2 id="Task-的实现"><a href="#Task-的实现" class="headerlink" title="Task 的实现"></a>Task 的实现</h2><p>现在我们已经实现了最为关键的 <code>promise_type</code>，接下来给出 <code>Task</code> 类型的完整定义。我想各位读者一定明白，<code>Task</code> 不过就是个摆设，它的能力大多都是通过调用 <code>promise_type</code> 来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明 promise_type 为 TaskPromise 类型</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>(ResultType)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>(result.<span class="built_in">get_or_throw</span>());</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// 忽略异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略返回值</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">finally</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123; <span class="built_in">func</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span>: handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;&amp;task) <span class="keyword">noexcept</span>: <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(task.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  Task &amp;<span class="keyword">operator</span>=(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们完成了 <code>Task</code> 的第一个通用版本的实现，这个版本的实现当中尽管我们对 <code>Task</code> 的结果做了加锁，但考虑到目前我们仍没有提供线程切换的能力，因此这实际上是一个无调度器版本的 <code>Task</code> 实现。</p><h2 id="Task-的-void-特化"><a href="#Task-的-void-特化" class="headerlink" title="Task 的 void 特化"></a>Task 的 void 特化</h2><p>前面讨论的 <code>Task</code> 有一个作为返回值类型的模板参数 <code>ResultType</code>。实际上有些时候我们只是希望一段任务可以异步执行完，而不关注它的结果，这时候 <code>ResultType</code> 就需要是 <code>void</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很快你就会发现问题。编译器会告诉你模板实例化错误，因为我们没法用 <code>void</code> 来声明变量；编译器还会告诉你协程体里面如果没有返回值，你应该提供为 <code>promise_type</code> 提供 <code>return_void</code> 函数。</p><p>看来情况没有那么简单。C++ 的模板经常会遇到这种需要特化的情况，我们只需要对之前的 <code>Task&lt;ResultType&gt;</code> 版本的定义稍作修改，就可以给出 <code>Task&lt;void&gt;</code> 的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 用 void 作为第一个模板参数实例化 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;<span class="type">void</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是 void，因此不用 return</span></span><br><span class="line">    <span class="comment">// 这时这个函数的作用就是阻塞当前线程等待协程执行完成</span></span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// func 的类型参数 void()，注意之前这个模板类型构造器还有个参数 ResultType</span></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 我们也会对 result 做 void 版本的实例化，这里只是检查有没有异常抛出</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// ignore.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你会发现变化的只是跟结果相关的部分。相应的，<code>TaskPromise</code> 也需要做出修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Task 的模板参数</span></span><br><span class="line">  <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回值类型改成 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不再需要 return</span></span><br><span class="line">    result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// Result 的模板参数变化</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再是 return_value 了</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;();</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void </span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void</span></span><br><span class="line">  std::optional&lt;Result&lt;<span class="type">void</span>&gt;&gt; result;</span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有 <code>Result</code> 也有对应的 <code>void</code> 实例化版本，其实就是把存储返回值相关的逻辑全部删掉，只保留异常相关的部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们进一步完善了 <code>Task</code> 对不同类型的结果的支持，理论上我们可以使用 <code>Task</code> 来构建各式各样的协程了。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来我们可以试着把文章开头的代码运行一下了。为了更仔细地观察程序的执行，我们也在一些节点打印了日志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>debug</code> 是我自定义的一个宏，可以在打印日志的时候附加上时间、线程、函数等信息，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">16:46:30.448 [Thread-25132] (main.cpp:40) simple_task: task start ...</span><br><span class="line">16:46:30.449 [Thread-25132] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">16:46:31.459 [Thread-25132] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">16:46:31.460 [Thread-25132] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">16:46:31.461 [Thread-25132] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">16:46:33.469 [Thread-25132] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">16:46:33.470 [Thread-25132] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>由于我们的任务在执行过程中没有进行任何线程切换，因此各个 <code>Task</code> 的执行实际上是串行的，就如同我们调用普通函数一样。当然，这显然不是我们的最终目的，下一篇我们就来介绍如何给 <code>Task</code> 增加调度器的支持。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们详细介绍了无调度器版本的 <code>Task</code> 的实现。尽管程序尚未真正实现异步执行，但至少从形式上，我们已经非常接近协程最神奇的地方了。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程主要用来降低异步任务的编写复杂度，异步任务各式各样，但归根结底就是一个结果的获取。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</title>
    <link href="https://www.bennyhuo.com//2022/03/14/cpp-coroutines-03-functional/"/>
    <id>https://www.bennyhuo.com//2022/03/14/cpp-coroutines-03-functional/</id>
    <published>2022-03-14T16:03:21.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们还可以对序列生成器产生的数据流做进一步的筛选和处理，而这一切都可以基于协程去实现。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1dB4y1X7mY&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="序列生成器的泛化"><a href="#序列生成器的泛化" class="headerlink" title="序列生成器的泛化"></a>序列生成器的泛化</h2><p>我们已经有了一个 int 版本的 Generator，实际上我们也很容易把它泛化成模板类型，改动的地方不多，基本上把原 Generator 类型当中的 <code>int</code> 替换成模板参数 <code>T</code> 即可，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span> : std::exception &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样原来生成斐波那契数列的函数也需要稍作调整：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不过就是给 Generator 加了个模板参数而已。</p><h2 id="创建-Generator-的便捷函数"><a href="#创建-Generator-的便捷函数" class="headerlink" title="创建 Generator 的便捷函数"></a>创建 Generator 的便捷函数</h2><p>现在我们知道，想要创建 Generator 就需要定义一个函数或者 Lambda。不过从输出的结果上看， Generator 实际上就是一个“懒”序列，因此我们当然可以通过一个数组就能创建出 Generator 了。</p><p>使用数组创建 Generator 的版本实现比较简单，我们直接给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_array</span><span class="params">(T array[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 C++ 的数组作为参数时相当于指针，需要传入长度 n。用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_array</span>(array, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>显然，这个写法不能令人满意。</p><p>我们把数组改成 std::list 如何呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_list</span><span class="params">(std::list&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: list) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比数组，<code>std::list</code> 的版本少了一个长度参数，因为长度的信息被封装到 <code>std::list</code> 当中了。用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_list</span>(std::list&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>这个虽然有进步，但缺点也很明显，因为每次都要创建一个 <code>std::list</code>，说得直接一点儿就是每次都要多写 <code>std::list</code> 这 9 个字符。</p><p>这时候我们就很自然地想到了初始化列表的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from</span><span class="params">(std::initializer_list&lt;T&gt; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: args) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们就可以有下面的用法了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>不错，看上去需要写的内容少很多了。</p><p>不过，如果这对花括号也不用写的话，那就完美了。想要做到这一点，我们需要用到 C++ 17 的折叠表达式（fold expression）的特性，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...TArgs&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="type">static</span> <span class="title">from</span><span class="params">(TArgs ...args)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">co_yield</span> args, ...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的模板参数包（template parameters pack）不能用递归的方式去调用 from，因为那样的话我们会得到非常多的 Generator 对象。</p><p>用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>这下看上去完美多了。</p><h2 id="实现-map-和-flat-map"><a href="#实现-map-和-flat-map" class="headerlink" title="实现 map 和 flat_map"></a>实现 map 和 flat_map</h2><p>熟悉函数式编程的读者可能已经意识到了，我们定义的 Generator 实际上已经非常接近 Monad 的定义了。那我们是不是可以给它实现 map 和 flat_map 呢？</p><h3 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h3><p>map 就是将 Generator 当中的 T 映射成一个新的类型 U，得到一个新的 <code>Generator&lt;U&gt;</code>。下面我们给出第一个版本的 map 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">  Generator&lt;U&gt; <span class="title">map</span><span class="params">(std::function&lt;U(T)&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 this 的所有权移动到新创建的 Generator 内部，确保生命周期的一致性</span></span><br><span class="line">    <span class="keyword">auto</span> up_stream = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 判断 this 当中是否有下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (up_stream.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 使用 next 读取下一个元素</span></span><br><span class="line">      <span class="comment">// 通过 f 将其变换成 U 类型的值，再使用 co_yield 传出</span></span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(up_stream.next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>std::function&lt;U(T)&gt;</code> 当中的模板参数 <code>U(T)</code> 是个模板构造器，放到这里就表示这个函数的参数类型为 <code>T</code>，返回值类型为 <code>U</code>。</p><p>接下来我们给出用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibonacci 是上一篇文章当中定义的函数，返回 Generator&lt;int&gt;</span></span><br><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>&lt;std::string&gt;([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 map 函数，我们将 <code>Generator&lt;int&gt;</code> 转换成了 <code>Generator&lt;std::string&gt;</code>，外部使用 <code>generator_str</code> 就会得到字符串。</p><p>当然，这个实现有个小小的缺陷，那就是 map 函数的模板参数 U 必须显式提供，如上例中的 <code>&lt;std::string&gt;</code>，这是因为我们在定义 map 时用到了模板构造器，这使得类型推断变得复杂。</p><p>为了解决这个问题，我们就要用到模板的一些高级特性了，下面给出第二个版本的 map 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  Generator&lt;std::<span class="type">invoke_result_t</span>&lt;F, T&gt;&gt; <span class="built_in">map</span>(F f) &#123;</span><br><span class="line">    <span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">while</span> (up_steam.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(up_steam.next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们直接用模板参数 <code>F</code> 来表示转换函数 f 的类型。map 本身的定义要求 <code>F</code> 的参数类型是 <code>T</code>，然后通过 <code>std::invoke_result_t&lt;F, T&gt;</code> 类获取 <code>F</code> 的返回值类型。</p><p>这样我们在使用时就不需要显式的传入模板参数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-flat-map"><a href="#实现-flat-map" class="headerlink" title="实现 flat_map"></a>实现 flat_map</h3><p>在给出实现之前，我们需要先简单了解一下 flat_map 的概念。</p><p>前面提到的 map 是元素到元素的映射，而 flap_map 是元素到 Generator 的映射，然后将这些映射之后的 Generator 再展开（flat），组合成一个新的 Generator。这意味如果一个 Generator 会传出 5 个值，那么这 5 个值每一个值都会映射成一个新的 Generator，，得到的这 5 个 Generator 又会整合成一个新的 Generator。</p><p>由此可知，map 不会使得新 Generator 的值的个数发生变化，flat_map 会。</p><p>下面我们给出 flat_map 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="comment">// 返回值类型就是 F 的返回值类型</span></span><br><span class="line">  <span class="function">std::<span class="type">invoke_result_t</span>&lt;F, T&gt; <span class="title">flat_map</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 this 的所有权移动到新创建的 Generator 内部，确保生命周期的一致性</span></span><br><span class="line">    <span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">while</span> (up_steam.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 值映射成新的 Generator</span></span><br><span class="line">      <span class="keyword">auto</span> generator = <span class="built_in">f</span>(up_steam.<span class="built_in">next</span>());</span><br><span class="line">      <span class="comment">// 将新的 Generator 展开</span></span><br><span class="line">      <span class="keyword">while</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> generator.<span class="built_in">next</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加深大家的理解，我们给出一个小例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 返回值类型必须显式写出来，表明这个函数是个协程</span></span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="comment">// 在协程当中，我们可以使用 co_yield 传值出来</span></span><br><span class="line">        <span class="keyword">co_yield</span> j; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;* &quot;</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这个例子的运行输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* *</span><br><span class="line">* * *</span><br><span class="line">* * * *</span><br></pre></td></tr></table></figure><p>我们来稍微做下拆解。</p><ol><li><code>Generator&lt;int&gt;::from(1, 2, 3, 4)</code> 得到的是序列 <code>1 2 3 4</code></li><li>flat_map 之后，得到 <code>0 0 1 0 1 2 0 1 2 3</code></li></ol><p>由于我们在 0 的位置做了换行，因此得到的输出就是 * 组成的三角形了。</p><h2 id="其他有趣的函数"><a href="#其他有趣的函数" class="headerlink" title="其他有趣的函数"></a>其他有趣的函数</h2><h3 id="遍历所有值的-for-each"><a href="#遍历所有值的-for-each" class="headerlink" title="遍历所有值的 for_each"></a>遍历所有值的 for_each</h3><p>序列的最终使用，往往就是遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">for_each</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="built_in">f</span>(<span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠值的-fold"><a href="#折叠值的-fold" class="headerlink" title="折叠值的 fold"></a>折叠值的 fold</h3><p>Generator 会生成很多值，如果我们需要对这些值做一些整体的处理，并最终得到一个值，那么我们就需要折叠函数 fold：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  R <span class="title">fold</span><span class="params">(R initial, F f)</span> </span>&#123;</span><br><span class="line">    R acc = initial;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      acc = <span class="built_in">f</span>(acc, <span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它需要一个初始值，函数 f 接收两个参数，分别是 acc 和序列生成器当前迭代的元素，每次经过 f 做运算得到的结果会作为下次迭代的 acc 传入，直到最后 acc 作为 fold 的返回值返回。</p><p>我们可以很方便地使用 fold 求和或者求取阶乘，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result: 720</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .<span class="built_in">fold</span>(<span class="number">1</span>, [](<span class="keyword">auto</span> acc, <span class="keyword">auto</span> i)&#123; </span><br><span class="line">    <span class="keyword">return</span> acc * i;  <span class="comment">// 计算阶乘</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="求和函数-sum"><a href="#求和函数-sum" class="headerlink" title="求和函数 sum"></a>求和函数 sum</h3><p>求和本身可以用前面的 fold 来实现，当然我们也可以直接给出 sum 函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      sum += <span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result: 21</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">double</span>&gt;::<span class="built_in">from</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6.0f</span>).<span class="built_in">sum</span>();</span><br></pre></td></tr></table></figure><h3 id="过滤部分值的-filter"><a href="#过滤部分值的-filter" class="headerlink" title="过滤部分值的 filter"></a>过滤部分值的 filter</h3><p>你几乎可以在任何看到 map/flat_map 的场合看到 filter，毕竟有些值我们根本不需要。</p><p>想要实现这个过滤，只需要一个条件判断，下面我们给出 fitler 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">filter</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">while</span> (up_steam.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = up_steam.<span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截取前-n-个值的-take-n"><a href="#截取前-n-个值的-take-n" class="headerlink" title="截取前 n 个值的 take(n)"></a>截取前 n 个值的 take(n)</h3><p>序列生成器往往与<strong>懒序列</strong>同时出现，因为<strong>懒序列</strong>之所以<strong>懒</strong>，往往是因为它的长度可能很长（甚至无限，例如斐波那契数列），一次性将所有的值加载出来会比较影响性能。</p><p>对于这种很长的懒序列，我们最终能用到的值可能并不多，因此我们需要一个函数 <code>take(n)</code> 对序列的前 <code>n</code> 个做截取。</p><p>它的实现也是显而易见的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="title">take</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; n &amp;&amp; up_steam.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> up_steam.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截取到指定条件的-take-while"><a href="#截取到指定条件的-take-while" class="headerlink" title="截取到指定条件的 take_while"></a>截取到指定条件的 take_while</h3><p>take_while 的实现就好像是 filter 与 take(n) 的一个结合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">take_while</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">while</span> (up_steam.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = up_steam.<span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们想要截取小于 100 的所有斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fibonacci</span>().<span class="built_in">take_while</span>([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">100</span>;</span><br><span class="line">&#125;).for_each([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55 89</span><br></pre></td></tr></table></figure><h2 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h2><p>前面给出了这么多函数的实现，目的主要是为了<del>凑字数</del>让大家充分理解 C++ 协程的妙处。为了进一步确认大家对于前面例子的理解程度，我们再给出一个例子，请大家思考这当中的每一个 lambda 分别调用几次，以及输出什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    .<span class="built_in">filter</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;filter: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">map</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i * <span class="number">3</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;flat_map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="built_in">take</span>(<span class="number">3</span>)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;for_each: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>大家在分析的时候，请牢记 Generator 生成的序列是懒序列，只要最终访问到的时候才会生成。</p><p>这意味着中间的 map 其中根本不会主动消费 Generator，flat_map 也不会，filter 也不会，take 也不会。只有 for_each 调用的时候，才会真正需要知道 Generator 当中都有什么。</p><p>输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter: 1</span><br><span class="line">filter: 2</span><br><span class="line">map: 2</span><br><span class="line">flat_map: 6</span><br><span class="line">for_each: 0</span><br><span class="line">for_each: 1</span><br><span class="line">for_each: 2</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：大家可以返回去再看一下我们给出的函数的实现，找一下哪些当中用到了 <code>co_yield</code>，哪些没有用到，以及这两类函数有什么区别。</p></blockquote><h2 id="Generator-的所有权"><a href="#Generator-的所有权" class="headerlink" title="Generator 的所有权"></a>Generator 的所有权</h2><p>在前面的函数实现中，有部分函数会在一开始转移 this 的所有权：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> up_steam = std::<span class="built_in">move</span>(*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这是为什么呢？</p><p>因为 this 很有可能是一个泛左值，在函数返回之后会立即销毁。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt; generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).<span class="built_in">map</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">generator.for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>map 函数的 this 实际上是 from 函数的返回值，这个返回值会在 map 函数返回之后立即进行析构。如果我们不在 map 内部转移 this 的所有权，那么 this 对应的协程也会随着 from 的返回值的析构而销毁。有关这个问题的讨论，也可以参见这个 issue：<a href="https://github.com/bennyhuo/CppCoroutines/issues/4">03 中对右值 Generator 进行函数式变换析构的问题</a>。</p><p>还有一个小问题，为什么有些函数不需要转移 this 的所有权呢？</p><p>这些函数包括 sum、for_each、fold 等等，在这些函数内部 this 的值就会被消费完毕，因此 Generator 是否销毁对后续的程序执行没有任何影响。事实上，细心的读者可能已经发现，这些函数还有一个非常显著的特征：它们的返回值都不是 Generator。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对前文当中的序列生成器做了泛化，使它能够支持任意类型的序列生成。此外，我们也针对序列生成器添加了一系列的函数式的支持，以帮助读者进一步深入理解协程的工作机制。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们还可以对序列生成器产生的数据流做进一步的筛选和处理，而这一切都可以基于协程去实现。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（2）：实现一个序列生成器</title>
    <link href="https://www.bennyhuo.com//2022/03/11/cpp-coroutines-02-generator/"/>
    <id>https://www.bennyhuo.com//2022/03/11/cpp-coroutines-02-generator/</id>
    <published>2022-03-11T22:03:49.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列生成器是一个非常经典的协程应用场景。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1ug411d7Xy&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>现在我们已经了解了绝大部分 C++ 协程的特性，可以试着来实现一些小案例了。</p><p>简单的说，序列生成器通常的实现就是在一个协程内部通过某种方式向外部传一个值出去，并且将自己挂起，外部调用者则可以获取到这个值，并且在后续继续恢复执行序列生成器来获取下一个值。</p><p>显然，挂起和向外部传值的任务就需要通过 <code>co_await</code> 来完成了，外部获取值的任务就要通过协程的返回值来完成。</p><p>由此我们大致能想到最终程序的样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 generator 有个 next 函数，调用它时我们需要想办法让协程恢复执行，并将下一个值传出来。</p><p>好了，接下来我们就带着这两个问题去寻找解决办法，顺便把剩下的一点点 C++ 协程的知识补齐。</p><h2 id="调用者获取值"><a href="#调用者获取值" class="headerlink" title="调用者获取值"></a>调用者获取值</h2><p>截止到目前我们都没有真正尝试去调用过协程，现在是个很好的机会。我们观察一下 main 函数当中的这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 的类型就是我们即将实现的序列生成器类型 <code>Generator</code>，结合上一篇文章当中对于协程返回值类型的介绍，我们先大致给出它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行时不挂起，执行到第一个挂起点</span></span><br><span class="line">    <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行结束后不需要挂起</span></span><br><span class="line">    <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了简单，我们认为序列生成器当中不会抛出异常，这里不做任何处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ???.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码当中有两处我们标注为 ???，表示暂时还不知道怎么处理。</p><p>第一个是我们想要在 Generator 当中 resume 协程的话，需要拿到 coroutine_handle，这个要怎么做到呢？</p><p>这时候我希望大家一定要记住一点，promise_type 是连接协程内外的桥梁，想要拿到什么，找 promise_type 要。标准库提供了一个通过 promise_type 的对象的地址获取 coroutine_handle 的函数，它实际上是 coroutine_handle 的一个静态函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Promise</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_handle</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(_Promise&amp; _Prom)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来，我们只需要在 <code>get_return_object</code> 函数调用时，先获取 coroutine_handle，然后再传给即将构造出来的 Generator 即可，因此我们稍微修改一下前面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是如何获取协程内部传出来的值的问题了。同样，本着有事儿找 promise_type 的原则，我们可以直接给它定义一个 value 成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="comment">// 通过 handle 获取 promise，然后再取到 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="协程内部挂起并传值"><a href="#协程内部挂起并传值" class="headerlink" title="协程内部挂起并传值"></a>协程内部挂起并传值</h2><p>现在的问题就是如何从协程内部传值给 promise_type 了。</p><p>我们再来观察一下最终实现的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是 <code>co_await i++;</code> 这一句，我们发现 <code>co_await</code> 后面的是一个整型值，而不是我们在前面的文章当中提到的满足等待体（awaiter）条件的类型，这种情况下该怎么办呢？</p><p>实际上，对于 <code>co_await &lt;expr&gt;</code> 表达式当中 <code>expr</code> 的处理，C++ 有一套完善的流程：</p><ol><li>如果 promise_type 当中定义了 await_transform 函数，那么先通过 <code>promise.await_transform(expr)</code> 来对 expr 做一次转换，得到的对象称为 awaitable；否则 awaitable 就是 expr 本身。</li><li>接下来使用 awaitable 对象来获取等待体（awaiter）。如果 awaitable 对象有 <code>operator co_await</code> 运算符重载，那么等待体就是 <code>operator co_await(awaitable)</code>，否则等待体就是 awaitable 对象本身。</li></ol><p>听上去，我们要么给 promise_type 实现一个 <code>await_tranform(int)</code> 函数，要么就为整型实现一个 <code>operator co_await</code> 的运算符重载，二者选一个就可以了。</p><h3 id="方案-1：实现-operator-co-await"><a href="#方案-1：实现-operator-co-await" class="headerlink" title="方案 1：实现 operator co_await"></a>方案 1：实现 operator co_await</h3><p>这个方案就是给 int 定义 operator co_await 的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">IntAwaiter</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Generator::promise_type&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      handle.<span class="built_in">promise</span>().value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> IntAwaiter&#123;.value = value&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个方案对于我们这个特定的场景下是行不通的，因为在 C++ 当中我们是无法给基本类型定义运算符重载的。</p><p>不过，如果我们遇到的情况不是基本类型，那么运算符重载的思路就可以行得通。<code>operator co_await</code> 的重载我们将会在后面给出例子。</p><h3 id="方案-2：await-transform"><a href="#方案-2：await-transform" class="headerlink" title="方案 2：await_transform"></a>方案 2：await_transform</h3><p>运算符重载行不通，那就只能通过 await_tranform 来做转换了。</p><p>代码比较简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传值的同时要挂起，值存入 value 当中</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">await_transform</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部调用者或者恢复者可以通过读取 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义了 <code>await_transform</code> 函数之后，<code>co_await expr</code> 就相当于 <code>co_await promise.await_transform(expr)</code> 了。</p><p>至此，我们的例子就可以运行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h2><p>虽然我们的协程已经能够正常工作，但它仍然存在缺陷。</p><h3 id="问题-1：无法确定是否存在下一个元素"><a href="#问题-1：无法确定是否存在下一个元素" class="headerlink" title="问题 1：无法确定是否存在下一个元素"></a>问题 1：无法确定是否存在下一个元素</h3><p>当外部调用者或者恢复者试图调用 <code>next</code> 来获取下一个元素的时候，它其实并不知道能不能真的得到一个结果。程序也可能抛出异常：</p><p>如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 只传出 5 个值</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 试图读取 15 个值</span></span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的结果是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure><p>最后一个输出的 4 实际上是恰好遇到协程销毁之前的状态，此时 promise 当中的 value 值还是之前的 4。而当我们试图不断的去读取协程的值，程序就抛出 SIGSEGV  的错误。错误的原因你可能已经想到了，当协程体执行完之后，协程的状态就会被销毁，如果我们再访问协程的话，就相当于访问了一个野指针。</p><p>为了解决这个问题，我们需要增加一个 has_next 函数，用来判断是否还有新的值传出来，has_next 函数调用的时候有两种情况：</p><ol><li>已经有一个值传出来了，还没有被外部消费</li><li>还没有现成的值可以用，需要尝试恢复执行协程来看看还有没有下一个值传出来</li></ol><p>这里我们需要有一种有效的办法来判断 value 是不是有效的，单凭 value 本身我们其实是无法确定它的值是不是被消费了，因此我们需要加一个值来存储这个状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程执行完成之后，外部读取值时抛出的异常</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">bool</span> is_ready = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个成员 state 来记录协程执行的状态，状态的类型一共三种，只有 READY 的时候我们才能拿到值。</p><p>接下来改造 <code>next</code> 函数，同时增加 <code>has_next</code> 函数来描述协程是否仍然可以有值传出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (!handle || handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程还没有执行完成，并且下一个值还没有准备好</span></span><br><span class="line">    <span class="keyword">if</span> (!handle.<span class="built_in">promise</span>().is_ready) &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="comment">// 恢复执行之后协程执行完，这时候必然没有通过 co_await 传出值来</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此时一定有值，is_ready 为 true </span></span><br><span class="line">      <span class="comment">// 消费当前的值，重置 is_ready 为 false</span></span><br><span class="line">      handle.<span class="built_in">promise</span>().is_ready = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ExhaustedException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样外部使用时就需要先通过 has_next 来判断是否有下一个值，然后再去读取了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2：协程状态的销毁比-Generator-对象的销毁更早"><a href="#问题-2：协程状态的销毁比-Generator-对象的销毁更早" class="headerlink" title="问题 2：协程状态的销毁比 Generator 对象的销毁更早"></a>问题 2：协程状态的销毁比 Generator 对象的销毁更早</h3><p>我们前面提到过，协程的状态在协程体执行完之后就会销毁，除非协程挂起在 <code>final_suspend</code> 调用时。</p><p>我们的例子当中 <code>final_suspend</code> 返回了 <code>std::suspend_never</code>，因此协程的销毁时机其实比 Generator 更早：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完，协程的状态已经销毁</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator 对象在此仍然有效</span></span><br></pre></td></tr></table></figure><p>这看上去似乎问题不大，因为我们在前面通过 <code>has_next</code> 的判断保证了读取值的安全性。</p><p>但实际上情况并非如此。我们在 <code>has_next</code> 当中调用了 <code>coroutine_handle::done</code> 来判断协程体是否执行完成，判断之前很可能协程已经销毁，<code>coroutine_handle</code> 这时候都已经是无效的了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果协程已经执行完成，理论上协程的状态已经销毁，handle 指向的是一个无效的协程</span></span><br><span class="line">  <span class="comment">// 如果 handle 本身已经无效，因此 done 函数的调用此时也是无效的</span></span><br><span class="line">  <span class="keyword">if</span> (!handle || handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此为了让协程的状态的生成周期与 <code>Generator</code> 一致，我们必须将协程的销毁交给 <code>Generator</code> 来处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是挂起，让 Generator 来销毁</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="comment">// 销毁协程</span></span><br><span class="line">    handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="问题-3：复制对象导致协程被销毁"><a href="#问题-3：复制对象导致协程被销毁" class="headerlink" title="问题 3：复制对象导致协程被销毁"></a>问题 3：复制对象导致协程被销毁</h3><p>这个问题确切地说是<strong>问题 2</strong>的解决方案不完善引起的。</p><p>我们在 Generator 的析构函数当中销毁协程，这本身没有什么问题，但如果我们把 Generator 对象做一下复制，例如从一个函数当中返回，情况可能就会变得复杂。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">returns_generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> g = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">if</span> (g.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; g.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">returns_generator</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码乍一看似乎没什么问题，但由于我们把 <code>g</code> 当做返回值返回了，这时候 <code>g</code> 这个对象就发生了一次复制，然后临时对象被销毁。接下来的事儿大家就很容易想到了，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">-572662307</span><br><span class="line"></span><br><span class="line">Process finished with exit code -1073741819 (0xC0000005)</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们需要妥善地处理 Generator 的复制构造器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Generator</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;&amp;generator) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(generator.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Generator &amp;<span class="keyword">operator</span>=(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只提供了右值复制构造器，对于左值复制构造器，我们直接删除掉以禁止使用。原因也很简单，对于每一个协程实例，都有且仅能有一个 Generator 实例与之对应，因此我们只支持移动对象，而不支持复制对象。</p><h2 id="使用-co-yield"><a href="#使用-co-yield" class="headerlink" title="使用 co_yield"></a>使用 co_yield</h2><p>序列生成器这个需求的实现其实有个更好的选择，那就是使用 <code>co_yield</code>。<code>co_yield</code> 就是专门为向外传值来设计的，如果大家对其他语言的协程有了解，也一定见到过各种 <code>yield</code> 的实现。</p><p>C++ 当中的 <code>co_yield expr</code> 等价于 <code>co_await promise.yield_value(expr)</code>，我们只需要将前面例子当中的 <code>await_transform</code> 函数替换成 <code>yield_value</code> 就可以使用 <code>co_yield</code> 来传值了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 await_transform 替换为 yield_value</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      is_ready = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 co_yield 来替换 co_await</span></span><br><span class="line">    <span class="keyword">co_yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到改动点非常少，运行效果与前面的例子一致。</p><p>尽管可以实现相同的效果，但通常情况下我们使用 <code>co_await</code> 更多的关注点在挂起自己，等待别人上，而使用 <code>co_yield</code> 则是挂起自己传值出去。因此我们应该针对合适的场景做出合适的选择。</p><h2 id="使用序列生成器生成斐波那契数列"><a href="#使用序列生成器生成斐波那契数列" class="headerlink" title="使用序列生成器生成斐波那契数列"></a>使用序列生成器生成斐波那契数列</h2><p>接下来我们要使用序列生成器来实现一个更有意义的例子，即斐波那契数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">0</span>; <span class="comment">// fib(0)</span></span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">1</span>; <span class="comment">// fib(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a + b; <span class="comment">// fib(N), N &gt; 1</span></span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这个实现非常的直接，完全不需要考虑 fib(N - 1) 和 fib(N - 2) 的存储问题。</p><p>如果没有协程，我们的实现可能是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初值不符合整体的规律，需要单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">-1</span>)&#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      b = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> next = b;</span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时先构造一个 Fibonacci 对象，然后调用 next 函数来获取下一个值。对比之下，协程的实现带来的好处是显而易见的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文围绕序列生成器这个经典的协程案例介绍了协程的销毁、co_await 运算符、await_transform 以及 yield_value 的用法。</p><p>说出来你可能不信，如果这篇文章你能够完全理解，那么相信你对 C++ 协程特性的了解已经比较全面了。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序列生成器是一个非常经典的协程应用场景。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（1）：C++ 协程概览</title>
    <link href="https://www.bennyhuo.com//2022/03/09/cpp-coroutines-01-intro/"/>
    <id>https://www.bennyhuo.com//2022/03/09/cpp-coroutines-01-intro/</id>
    <published>2022-03-09T23:03:56.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1vv4y1A7fX&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程就是一段可以<strong>挂起（suspend）</strong>和<strong>恢复（resume）</strong>的程序，一般而言，就是一个支持<strong>挂起</strong>和<strong>恢复</strong>的函数。</p><p>这么说比较抽象，我们下面看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fun 是一个非常普通的函数，大家对它的直观印象是什么呢？</p><ul><li>它有四行代码</li><li>这四行代码一行一行依次执行</li><li>这四行代码连续执行</li></ul><p>作为一个合格的程序员，我们的眼睛就是编译器，我们的脑子就是运行时。相信大家在看完这个函数的定义之后脑子里面已经不自主的把它运行过了：这个函数一旦开始，就无法暂停。</p><p>如果一个函数能够暂停，那它就可以被认为是我们开头提到的协程。所以<strong>挂起</strong>你就可以理解成暂停，<strong>恢复</strong>你就理解成从暂停的地方继续执行。</p><p>下面我们给出一段 C++ 协程的不完整的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Result 的定义我们后面再谈论，大家只需要知道 Result 是按照协程的规则定义的类型，在 C++ 当中，一个函数的返回值类型如果是符合协程的规则的类型，那么这个函数就是一个协程。</p><p>请大家留意一下这个函数体当中的 <code>co_await std::suspend_always&#123;&#125;;</code>，其中 <code>co_await</code> 是个关键字，它的出现，通常来说就会使得当前函数（协程）的执行被挂起。也就是说我们在控制台看到输出 1 以后，很可能过了很久才看到 2，这个“很久”也一般不是因为当前执行的线程被阻塞了，而是当前函数（协程）执行的位置被存起来，在将来某个时间点又读取出来继续执行的。</p><h2 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h2><p>很多读者在初次接触到协程这个概念的时候，总是会想得太过于复杂，以至于觉得<strong>挂起</strong>和<strong>恢复</strong>充满了神秘色彩而无法理解。这确实大可不必，你只要能理解听歌的时候可以暂停继续，能理解下载的时候可以断点续传，那你就必然可以理解协程的<strong>挂起</strong>和<strong>恢复</strong>。</p><p>那么问题来了，在我们现有的语言特性框架下，如何实现所谓的<strong>挂起</strong>和<strong>恢复</strong>呢？</p><p>我们以音频文件的播放为例，我们将其与协程的执行做对比，例如整个音频文件对比协程的函数体（即<strong>协程体</strong>），完整的对比见下表：</p><table><thead><tr><th>音频</th><th>协程</th></tr></thead><tbody><tr><td>音频文件</td><td>协程体</td></tr><tr><td>音频播放</td><td>协程执行</td></tr><tr><td>播放暂停</td><td>执行挂起</td></tr><tr><td>播放恢复</td><td>执行恢复</td></tr><tr><td>播放异常</td><td>执行异常</td></tr><tr><td>播放完成</td><td>协程返回</td></tr></tbody></table><p>音频暂停的时候需要记录音频暂停的位置，同时之前正在播放的音频也不会销毁（即便销毁重建，也要能够完全恢复原样）。</p><p>类似地，协程挂起时，我们需要记录函数执行的位置，C++ 协程会在开始执行时的第一步就使用 <code>operator new</code> 来开辟一块内存来存放这些信息，这块内存或者说这个对象又被称为<strong>协程的状态（coroutine state）</strong>。</p><p>协程的状态不仅会被用于存放挂起时的位置（后称为<strong>挂起点</strong>），也会在协程开始执行时存入协程体的参数值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>start_value</code> 就会被存入协程的状态当中。</p><p>需要注意的是，如果参数是值类型，他们的值或被移动或被复制（取决于类型自身的复制构造和移动构造的定义）到协程的状态当中；如果是引用、指针类型，那么存入协程的状态的值将会是引用或指针本身，而不是其指向的对象，这时候需要开发者自行保证协程在挂起后续恢复执行时参数引用或者指针指向的对象仍然存活。</p><p>与创建相对应，在协程执行完成或者被外部主动销毁之后，协程的状态也随之被销毁释放。</p><p>看到这里，大家也不必紧张，协程的状态的创建和销毁都是编译器帮我们处理好的，不需要我们显式的处理。</p><h2 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h2><p>协程的挂起是协程的灵魂。C++ 通过 <code>co_await</code> 表达式来处理协程的挂起，表达式的操作对象则为<strong>等待体（awaiter）</strong>。</p><p>等待体需要实现三个函数，这三个函数在挂起和恢复时分别调用。</p><h3 id="await-ready"><a href="#await-ready" class="headerlink" title="await_ready"></a>await_ready</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>await_ready 返回 bool 类型，如果返回 true，则表示已经就绪，无需挂起；否则表示需要挂起。</p><p>标准库当中提供了两个非常简单直接的等待体，<code>struct suspend_always</code> 表示总是挂起，<code>struct suspend_never</code> 表示总是不挂起。不难想到，这二者的功能主要就是依赖 await_ready 函数的返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_never</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true，总是不挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_always</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回 false，总是挂起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="await-suspend"><a href="#await-suspend" class="headerlink" title="await_suspend"></a>await_suspend</h3><p>await_ready 返回 false 时，协程就挂起了。这时候协程的局部变量和挂起点都会被存入协程的状态当中，await_suspend 被调用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">await_suspend</span>(std::coroutine_handle&lt;&gt; coroutine_handle);</span><br></pre></td></tr></table></figure><p>参数 coroutine_handle 用来表示当前协程，我们可以在稍后合适的时机通过调用 resume 来恢复执行当前协程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coroutine_handle.<span class="built_in">resume</span>();</span><br></pre></td></tr></table></figure><p>注意到 await_suspend 函数的返回值类型我们没有明确给出，因为它有以下几种选项：</p><ul><li>返回 void 类型或者返回 true，表示当前协程挂起之后将执行权还给当初调用或者恢复当前协程的函数。</li><li>返回 false，则恢复执行当前协程。注意此时不同于 await_ready 返回 true 的情形，此时协程已经挂起，await_suspend 返回 false 相当于挂起又立即恢复。</li><li>返回其他协程的 coroutine_handle 对象，这时候返回的 coroutine_handle 对应的协程被恢复执行。</li><li>抛出异常，此时当前协程恢复执行，并在当前协程当中抛出异常。</li></ul><p>可见，await_suspend 支持的情况非常多，也相对复杂。实际上这也是 C++ 协程当中最为核心的函数之一了。</p><h3 id="await-resume"><a href="#await-resume" class="headerlink" title="await_resume"></a>await_resume</h3><p>协程恢复执行之后，等待体的 await_resume 函数被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">await_resume</span>()；</span><br></pre></td></tr></table></figure><p>同样地，await_resume 的返回值类型也是不限定的，返回值将作为 <code>co_await</code> 表达式的返回值。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>了解了以上内容以后，我们可以自己定义一个非常简单的等待体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程挂起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 切换线程</span></span><br><span class="line">    std::<span class="built_in">async</span>([=]()&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">      <span class="comment">// sleep 1s</span></span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); </span><br><span class="line">      <span class="comment">// 恢复协程</span></span><br><span class="line">      coroutine_handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value 将作为 co_await 表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">co_await</span> Awaiter&#123;.value = <span class="number">1000</span>&#125; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">// 1 秒之后再执行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1000</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>其中 “1000” 在 “1” 输出 1 秒之后输出。</p><blockquote><p><strong>说明</strong>：co_await 后面的对象也可以不是等待体，这类情况需要定义其他的函数和运算符来转换成等待体。这个我们后面再讨论。</p></blockquote><h2 id="协程的返回值类型"><a href="#协程的返回值类型" class="headerlink" title="协程的返回值类型"></a>协程的返回值类型</h2><p>我们前面提到，区别一个函数是不是协程，是通过它的返回值类型来判断的。如果它的返回值类型满足协程的规则，那这个函数就会<strong>被编译成</strong>协程。</p><p>那么，这个<strong>协程的规则</strong>是什么呢？规则就是返回值类型能够实例化下面的模板类型 <code>_Coroutine_traits</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Coroutine_traits &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Coroutine_traits</span>&lt;_Ret, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Ret::promise_type&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> promise_type = <span class="keyword">typename</span> _Ret::promise_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_traits</span> : _Coroutine_traits&lt;_Ret&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>简单来说，就是返回值类型 <code>_Ret</code> 能够找到一个类型 <code>_Ret::promise_type</code> 与之相匹配。这个 <code>promise_type</code> 既可以是直接定义在 <code>_Ret</code> 当中的类型，也可以通过 <code>using</code> 指向已经存在的其他外部类型。</p><p>此时，我们就可以给出 <code>Result</code> 的部分实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="协程返回值对象的构建"><a href="#协程返回值对象的构建" class="headerlink" title="协程返回值对象的构建"></a>协程返回值对象的构建</h2><p>我们再看一下协程的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时你已经了解 C++ 当中如何界定一个协程。不过你可能会产生一个新的问题，返回值是从哪儿来的？协程体当中并没有给出 Result 对象创建的代码。</p><p>实际上，Result 对象的创建是由 promise_type 负责的，我们需要定义一个 <code>get_return_object</code> 函数来处理对 Result 对象的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建 Result 对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同于一般的函数，协程的返回值并不是在返回之前才创建，而是在协程的状态创建出来之后马上就创建的。也就是说，协程的状态被创建出来之后，会立即构造 <code>promise_type</code> 对象，进而调用 <code>get_return_object</code> 来创建返回值对象。</p><p><code>promise_type</code> 类型的构造函数参数列表如果与协程的参数列表一致，那么构造 <code>promise_type</code> 时就会调用这个构造函数。否则，就通过默认无参构造函数来构造 <code>promise_type</code>。</p><h2 id="协程体的执行"><a href="#协程体的执行" class="headerlink" title="协程体的执行"></a>协程体的执行</h2><p>在协程的返回值被创建之后，协程体就要被执行了。</p><h3 id="initial-suspend"><a href="#initial-suspend" class="headerlink" title="initial_suspend"></a>initial_suspend</h3><p>为了方便灵活扩展，协程体执行的第一步是调用 <code>co_await promise.initial_suspend()</code>，<code>initial_suspend</code> 的返回值就是一个等待对象（awaiter），如果返回值满足挂起的条件，则协程体在最一开始就立即挂起。这个点实际上非常重要，我们可以通过控制 initial_suspend 返回的等待体来实现协程的执行调度。有关调度的内容我们后面会专门探讨。</p><h3 id="协程体的执行-1"><a href="#协程体的执行-1" class="headerlink" title="协程体的执行"></a>协程体的执行</h3><p>接下来执行协程体。</p><p>协程体当中会存在 co_await、co_yield、co_return 三种协程特有的调用，其中</p><ul><li>co_await 我们前面已经介绍过，用来将协程挂起。</li><li>co_yield 则是 co_await 的一个马甲，用于传值给协程的调用者或恢复者或被恢复者，我们后面会专门用一篇文章给出例子介绍它的用法。</li><li>co_return 则用来返回一个值或者从协程体返回。</li></ul><h4 id="协程体的返回值"><a href="#协程体的返回值" class="headerlink" title="协程体的返回值"></a>协程体的返回值</h4><p>对于返回一个值的情况，需要在 promise_type 当中定义一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">return_value</span>();</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，我们的 Coroutine 函数就需要使用 co_return 来返回一个整数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1000 会作为参数传入，即 return_value 函数的参数 value 的值为 1000。</p><p>这时候读者可能会疑惑，这个值好像没什么用啊？大家别急，这个值可以存到 promise_type 对象当中，外部的调用者可以获取到。</p><h4 id="协程体返回-void"><a href="#协程体返回-void" class="headerlink" title="协程体返回 void"></a>协程体返回 void</h4><p>除了返回值的情况以外，C++ 协程当然也支持返回 void。只不过 promise_type 要定义的函数就不再是 return_value 了，而是 return_void 了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时，协程内部就可以通过 co_return 来退出协程体了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="协程体抛出异常"><a href="#协程体抛出异常" class="headerlink" title="协程体抛出异常"></a>协程体抛出异常</h4><p>协程体除了正常返回以外，也可以抛出异常。异常实际上也是一种结果的类型，因此处理方式也与返回结果相似。我们只需要在 promise_type 当中定义一个函数，在异常抛出时这个函数就会被调用到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      exception_ = std::<span class="built_in">current_exception</span>(); <span class="comment">// 获取当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="final-suspend"><a href="#final-suspend" class="headerlink" title="final_suspend"></a>final_suspend</h3><p>当协程执行完成或者抛出异常之后会先清理局部变量，接着调用 final_suspend 来方便开发者自行处理其他资源的销毁逻辑。final_suspend 也可以返回一个等待体使得当前协程挂起，但之后当前协程应当通过 coroutine_handle 的 destroy 函数来直接销毁，而不是 resume。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们介绍了一些 C++ 协程的各种概念和约定，看似介绍了非常多的内容，但因为示例较少又感觉什么都没介绍。大家不要着急，C++ 协程的概念基本上就这么多，剩下的文章我们都将基于一个或多个具体的场景展开来介绍如何运用 C++ 协程来解决问题。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（0）：前言</title>
    <link href="https://www.bennyhuo.com//2022/03/06/cpp-coroutines-00-foreword/"/>
    <id>https://www.bennyhuo.com//2022/03/06/cpp-coroutines-00-foreword/</id>
    <published>2022-03-06T21:03:17.000Z</published>
    <updated>2024-07-21T13:13:12.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><p>C++ 20 标准发布之后，协程终于正式成为 C++ 特性当中的一员。</p><p>作为一门本身极其复杂的语言，C++ 秉承着不劝退不开心的原则，将协程的 API 设计得非常复杂。以至于有开发者甚至发出了“这玩意根本就不是给人用的”这样的感叹。</p><p>等等，我们是不是搞错了，C++ 协程的 API 确实不是设计给业务开发者直接使用的。实际上，标准当中给出的 API 足够的灵活，也足够的基础，框架的开发者可以基于这些 API 将过去异步的函数改造成协程风格的版本。</p><p>没错，这就是 C++。</p><p>一门不造轮子就让人不舒服的语言，它总是在用它自己的方式逼着开发者进步。为了帮助大家认识和了解 C++ 协程的设计思路以及基本用法，我计划写几篇文章来介绍一下 C++ 协程的相关特性。</p><p>本人 C++ 水平有限，文章内容的安排将尽可能以介绍特性为主，涉及到的框架实现不建议在生产环境当中直接使用。</p><p>另外，为了方便读者阅读和实验，文章涉及到的所有源码均已上传于 <a href="https://github.com/bennyhuo/CppCoroutines">GitHub: bennyhuo/CppCoroutines</a>。</p><p>相信大家读完这一系列文章之后，也还是不一定会 C++ 协程 ：）</p><blockquote><p><strong>说明</strong>：C++ 23 有望基于协程提供不少有用的支持，例如与异步任务密不可分的 executor、network 等等，不过这些内容我暂时不会在后面的文章当中涉及，等 C++ 23 正式发布之后再做补充。</p></blockquote><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（9）：异步函数与其他语言的互调用</title>
    <link href="https://www.bennyhuo.com//2022/02/16/swift-coroutines-09-interop/"/>
    <id>https://www.bennyhuo.com//2022/02/16/swift-coroutines-09-interop/</id>
    <published>2022-02-16T23:02:59.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在很多 iOS APP 还是用 Objective-C 写的，异步函数在 Objective-C 当中怎么调用也是个问题。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="从异步回调到异步函数"><a href="#从异步回调到异步函数" class="headerlink" title="从异步回调到异步函数"></a>从异步回调到异步函数</h2><p>截止目前，我们已经详细探讨了 Swift 协程当中的绝大多数语法设计，这其中最基本也是最重要的就是异步函数。</p><p>在异步函数出现之前，我们通常会为函数添加回调来实现异步结果返回，以 Swift 的网络请求库 Alamofire 为例，它的 DataRequest 有这样一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">responseData</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods,</span><br><span class="line">  <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Data</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有很多参数，不过我们只需要关心最后一个：completionHandler，它是一个闭包，接收一个参数为 <code>AFDataResponse&lt;Data&gt;</code> 的类型作为请求结果。</p><p>从 Swift 5.5 开始，我们可以将其包装成异步函数，添加对结果的异步返回、异常的传播以及对取消响应的支持：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">responseDataAsync</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods</span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            responseData(</span><br><span class="line">                queue: queue,</span><br><span class="line">                dataPreprocessor: dataPreprocessor,</span><br><span class="line">                emptyResponseCodes: emptyResponseCodes, emptyRequestMethods: emptyRequestMethods</span><br><span class="line">            ) &#123; response <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> data): continuation.resume(returning: data)</span><br><span class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> error): continuation.resume(throwing: error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; onCancel: &#123;</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从异步回调到异步函数总是要经过这样一个包装的过程，这个过程实际上并不轻松。因此我们也更希望第三方开发者在提供异步回调的时候同时提供异步函数的版本来方便我们按需使用。</p><h2 id="Objective-C-的异步回调"><a href="#Objective-C-的异步回调" class="headerlink" title="Objective-C 的异步回调"></a>Objective-C 的异步回调</h2><h3 id="Objective-C-回调函数的自动转换"><a href="#Objective-C-回调函数的自动转换" class="headerlink" title="Objective-C 回调函数的自动转换"></a>Objective-C 回调函数的自动转换</h3><p>在以前的 iOS SDK 当中，接收形如 completionHandler 这样的回调的 Objective-C 函数有 1000 多个。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)signData:(NSData *)signData </span><br><span class="line">withSecureElementPass:(PKSecureElementPass *)secureElementPass </span><br><span class="line">      completion:(void (^)(NSData *signedData, NSData *signature, NSError *error))completion;</span><br></pre></td></tr></table></figure><p>这个函数相当于 Swift 的如下函数声明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, </span><br><span class="line">    <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>, </span><br><span class="line"><span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">Data</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure><p>如果我们对这些函数一个一个完成包装，那必然会耗费大量的时间和精力。因此，Swift 对接收类似的回调并符合一定条件的 Objective-C 函数自动做了一些转换，以上述 signData 函数为例，可以被自动转换为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">Data</span>)</span><br></pre></td></tr></table></figure><p>我们来简单分析一下这个转换过程。</p><ol><li>参数 completion 被移除了。 completion 的类型是 Objective-C 的 block，可以用来处理异步结果的返回。</li><li>转换后的异步函数的返回值 (Data, Data)，它实际上对应于 completion 除 <code>NSError *</code> 之外的两个参数。需要注意的是，回调当中的 signedData 和 signature 的类型均为 <code>NSData *</code>，它们实际上是可以为 nil 的，单纯考虑类型的映射，它们应该映射成 Swift 的 <code>Data?</code> 类型，而在转换之后的异步函数当中则为 <code>Data</code> 类型，这是因为逻辑上如果这俩个 <code>Data</code> 返回 nil，则应该通过参数 <code>NSError *</code> 来使得异步函数抛出异常。这个细节一定要注意。</li><li>completion 的参数 <code>NSError *</code> 表示结果有可能会出现异常，因此转换后的异步函数是会抛出异常的，声明为 throws。</li></ol><p>那这个转换需要符合什么条件呢？</p><ul><li>函数本身和参数回调的返回值均为 void</li><li>回调只能被调用一次</li><li>函数被显式地用 swift_async 修饰或者隐式地通过参数名来推导，其中支持推导的情况包括：<ul><li>函数只有一个参数且它的标签为 WithCompletion、WithCompletionHandler、WithCompletionBlock、WithReplyTo、WithReply。</li><li>函数有多个参数，且最后一个是回调，并且它的标签为 completion，withCompletion，completionHandler，withCompletionHandler，completionBlock，withCompletionBlock，replyTo，withReplyTo，reply 或者 replyTo。</li><li>函数有多个参数，且最后一个参数的标签以一个参数的情况当中列出的标签结尾，最后一个参数是回调。</li></ul></li></ul><p>我们再给一个例子，请大家注意它的函数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)getUserAsync:(NSString *)name completion:(void (^)(User *, NSError *))completion;</span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">userAsync</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">String</span>!) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">User</span>?</span><br></pre></td></tr></table></figure><p>对于以 get 开头的 Objective-C 函数，转换之后函数名当中的 get 被去除了。除此之外其他规则与前面提到的一致。</p><p>有了这个转换，很多旧 SDK 当中的 Objective-C 回调函数都可以当成 Swift 的异步函数来调用，可以极大的简化我们的开发流程。</p><h3 id="在-Objective-C-当中调用-Swift-的异步函数"><a href="#在-Objective-C-当中调用-Swift-的异步函数" class="headerlink" title="在 Objective-C 当中调用 Swift 的异步函数"></a>在 Objective-C 当中调用 Swift 的异步函数</h3><p>相反地，如果我们定义了 Swift 的异步函数，并且希望在 Objective-C 当中调用，则可以声明成 @objc 异步函数，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">class</span> <span class="title class_">GitHubApiAsync</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">listFollowers</span>(<span class="params">for</span> <span class="params">userName</span>: <span class="type">String</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AF</span>.request(<span class="string">&quot;<span class="subst">\(GITHUB_API_ENDPOINT)</span>/users/<span class="subst">\(userName)</span>/followers&quot;</span>).responseDecodableAsync()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitHubApiAsync 类当中的 listFollowers 函数相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface GitHubApiAsync : NSObject</span><br><span class="line">+ (void)listFollowersFor:(NSString * _Nonnull)userName completionHandler:(void (^ _Nonnull)(NSArray&lt;User *&gt; * _Nullable, NSError * _Nullable))completionHandler;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="调用-Kotlin-的挂起函数（suspend-function）"><a href="#调用-Kotlin-的挂起函数（suspend-function）" class="headerlink" title="调用 Kotlin 的挂起函数（suspend function）"></a>调用 Kotlin 的挂起函数（suspend function）</h2><p>了解了 Swift 的异步函数如何与 Objective-C 互调用的细节之后，再来看一下 Kotlin 的挂起函数是如何支持被 Swift 调用的。当然这个特性还在实验当中，后续也可能会发生变化。</p><h3 id="支持-Objective-C-回调"><a href="#支持-Objective-C-回调" class="headerlink" title="支持 Objective-C 回调"></a>支持 Objective-C 回调</h3><p>Kotlin 1.4 开始引入了挂起函数对 Swift 的支持，支持的方式就是讲挂起函数转成回调，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greeting</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后会生成 Objective-C 头文件，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">__attribute__((swift_name(&quot;Greeting&quot;)))</span><br><span class="line">@interface SharedGreeting : SharedBase</span><br><span class="line">...</span><br><span class="line">- (NSString *)greeting __attribute__((swift_name(&quot;greeting()&quot;)));</span><br><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><p>生成的类名为 <code>SharedGreeting</code>，其中 Shared 是模块名。<code>__attribute__((swift_name(&quot;Greeting&quot;)))</code> 使得这个 Objective-C 类映射到 Swift 当中的名字是 <code>Greeting</code>。</p><p>我们重点关注一下 greetingAsync 函数，它映射成了下面的回调形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure><h3 id="支持-Swift-异步函数"><a href="#支持-Swift-异步函数" class="headerlink" title="支持 Swift 异步函数"></a>支持 Swift 异步函数</h3><p>Kotlin 挂起函数对于 Objective-C 回调的支持，正好命中了前面讨论的回调自动转换成 Swift 异步函数的条件，因此理论上在 Swift 5.5 当中，我们也可以直接把 Kotlin 的挂起函数当成 Swift 的异步函数去调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里还有一些细节的问题。Kotlin 1.5.30 当中也对此做了一点点跟进，在生成的 Objective-C 头文件当中添加了对 <code>_Nullable_result</code> 的支持，这使得 Kotlin 的挂起函数在返回可空类型时，能够正确被转化成返回 optional 类型的 Swift 异步函数，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun greetingAsyncNullable(): <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, $&#123;Platform().platform&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个例子的返回值类型声明为 <code>String?</code>，生成的 Objective-C 函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)greetingAsyncNullableWithCompletionHandler:(void (^)(NSString * _Nullable_result, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsyncNullable(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure><p>仔细对比与 greetingAsync 的差异不难发现，返回值的类型在 greetingAsyncNullable 当中被映射成了 <code>NSString * _Nullable_result</code>，而在 greetingAsync 当中则映射成了 <code>NSString * _Nullable</code>。这就不得不提一下 <code>_Nullable_result</code> 与 <code>_Nullable</code> 的差异了，前者可以令转化之后的 Swift 异步函数返回 optional 类型（对应于 Kotlin 的可空类型，nullable type），而后者则返回非 optional 类型（对应于 Kotlin 的不可空类型，nonnull type）。</p><h3 id="Kotlin-挂起函数的异常传播"><a href="#Kotlin-挂起函数的异常传播" class="headerlink" title="Kotlin 挂起函数的异常传播"></a>Kotlin 挂起函数的异常传播</h3><p>如果 Kotlin 的挂起函数没有声明为 <code>@Throws</code>，则只有 <code>CancellationException</code> 会被转换为 <code>NSError</code> 抛到 Swift 当中，其他的都会作为严重错误使程序退出，因此如果需要暴露给 Swift 调用，我们通常建议对于可能有异常抛出的 Kotlin 函数添加 <code>@Throws</code> 注解，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;error from Kotlin&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 Swift 调用时也可以直接捕获到这个异常：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swift</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync())</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=KotlinException Code=0 &quot;error from Kotlin&quot; UserInfo=&#123;NSLocalizedDescription=error from Kotlin, KotlinException=kotlin.IllegalArgumentException: error from Kotlin, KotlinExceptionOrigin=&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文零传递"><a href="#上下文零传递" class="headerlink" title="上下文零传递"></a>上下文零传递</h3><p>尽管目前 Kotlin 的挂起函数可以被当做 Swift 的异步函数去调用，但 Kotlin 侧仍没有专门仔细地针对 Swift 异步函数调用的场景进行专门的设计和定制。因此像 Swift 侧的取消状态（在 Kotlin 挂起函数中获取 Swift 的 Task 的取消状态）、调度器（Swift 的 actor 以及与 Task 绑定的调度器）、TaskLocal 变量以及 Kotlin 侧挂起函数执行时的调度器、协程上下文等状态都是没有实现传递的。</p><p>基于这一点，大家在使用过程中应当尽可能将函数的设计进行简化，避免场景过于复杂而引发令人难以理解的问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们探讨了 Swift 协程当中的异步函数（async function）与 Objective-C 的互调用问题，其中介绍了 Objective-C 回调自动映射成 Swift 异步函数的条件和细节，以及 Kotlin 挂起函数对 Swift 异步函数的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在很多 iOS APP 还是用 Objective-C 写的，异步函数在 Objective-C 当中怎么调用也是个问题。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（8）：TaskLocal</title>
    <link href="https://www.bennyhuo.com//2022/02/12/swift-coroutines-08-tasklocal/"/>
    <id>https://www.bennyhuo.com//2022/02/12/swift-coroutines-08-tasklocal/</id>
    <published>2022-02-12T21:02:24.000Z</published>
    <updated>2024-07-21T13:13:12.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果我想要定义一个变量，它的值只在 Task 内部共享，怎么做到呢？ </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="TaskLocal-值的定义和使用"><a href="#TaskLocal-值的定义和使用" class="headerlink" title="TaskLocal 值的定义和使用"></a>TaskLocal 值的定义和使用</h2><p>TaskLocal 值就是 Task 私有的值，不同的 Task 对于这个变量的访问将得到不同的结果。</p><p>下面我们给出示例演示如何定义一个 TaskLocal 值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskLocal 值必须定义为静态的存储属性，并使用 TaskLocal 这个属性包装器（property wrapper）来包装。TaskLocal 值也受限于属性包装器的支持范围，不能定义为顶级属性。</p><p>变量 tag 的初始值为 <code>default</code>，属性包装器 TaskLocal 的构造器会接收这个值并存起来备用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> defaultValue: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">defaultValue</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.defaultValue <span class="operator">=</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解属性包装器的读者应该也能想到初始值的定义还可以写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span>(wrappedValue: <span class="string">&quot;default&quot;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察 TaskLocal 的定义，我们也发现它对于被包装的类型是有要求的，即要实现 Sendable 协议。</p><blockquote><p>有关 Swift 属性包装器的介绍，可以参考我之前的一篇文章：<a href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/">Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</a>。</p></blockquote><p>了解了定义之后，接下来看用法。</p><p>首先要写入值，我们只需要调用属性包装器的 withValue 函数，它的声明如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, </span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>, </span><br><span class="line">    <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, </span><br><span class="line">    <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span></span><br></pre></td></tr></table></figure><p>调用示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in my task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $tag 就是 tag 的属性包装器的 projectedValue，这个值正是 TaskLocal 这个属性包装器对象本身。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">TaskLocal</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withValue 有两个参数，一个是要绑定给 tag 的值，即 <code>MyTask</code>；另一个就是一个闭包，这个绑定的值只有在这个闭包当中有效，一旦闭包执行结束，tag 绑定的值的生命周期也就结束了。</p><p>接下来我们尝试去读取它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">logWithTag</span>(<span class="keyword">_</span> <span class="params">message</span>: <span class="keyword">Any</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(Logger.tag)</span>): <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取的方式就显得普通而又枯燥了。写法非常直接，不过大家要明白，这个读的行为实际上是通过 TaskLocal 属性包装器完成的。</p><p>作为对比，我们给出一个稍微完整的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in withValue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> logWithTag(<span class="string">&quot;out of withValue&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="keyword">in</span> withValue</span><br><span class="line">(<span class="keyword">default</span>): out of withValue</span><br></pre></td></tr></table></figure><h2 id="Task-对于-TaskLocal-的继承"><a href="#Task-对于-TaskLocal-的继承" class="headerlink" title="Task 对于 TaskLocal 的继承"></a>Task 对于 TaskLocal 的继承</h2><p>上一篇文章当中我们通过示例演示了 <code>init</code> 和 <code>detach</code> 构造的 Task 实例对 actor 上下文的继承，这次我们给大家再演示一下对 TaskLocal 的继承，以进一步加深大家的理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.init&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.detached &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.detached&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子相比之前的调度器的例子就更显得普通而又枯燥了，程序输出如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="type">Task</span>.<span class="keyword">init</span></span><br><span class="line">(<span class="keyword">default</span>): <span class="type">Task</span>.detached</span><br></pre></td></tr></table></figure><p>可以看到，通过 <code>detached</code> 创建的 Task 实例可谓是“六亲不认”，不仅不继承 actor 的上下文，也对 TaskLocal 不管不顾。另外不难想到的是，Swift 并没有提供修改外部 TaskLocal 值的 API，因此外部的 TaskLocal 值只能被继承，不能被修改。</p><h2 id="深入探查-TaskLocal-的存储方式"><a href="#深入探查-TaskLocal-的存储方式" class="headerlink" title="深入探查 TaskLocal 的存储方式"></a>深入探查 TaskLocal 的存储方式</h2><p>TaskLocal 值虽然看起来就是个静态存储属性，但它的值实际上是存储在 Task 相关的内存当中的。它的读写性能自然也与它的存储方式有关，因此为了确保能够正确合理的使用 TaskLocal，我们有必要了解一下它究竟是如何存储的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个变量唯一，用于查找值的 key</span></span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">Builtin</span>.<span class="type">RawPointer</span> &#123;</span><br><span class="line">    <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, to: <span class="type">Builtin</span>.<span class="type">RawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 TaskLocal 值的值时调用该函数</span></span><br><span class="line">  <span class="comment">// 通过 _taskLocalValueGet 到 Task 实例当中查找对应的值</span></span><br><span class="line">  <span class="comment">// 如果没有找到，则返回 defaultValue，即初始值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">get</span>() -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> rawValue <span class="operator">=</span> _taskLocalValueGet(key: key) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.defaultValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> storagePtr <span class="operator">=</span></span><br><span class="line">        rawValue.bindMemory(to: <span class="type">Value</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Value</span>&gt;(mutating: storagePtr).pointee</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(<span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>,</span><br><span class="line">                           <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span>) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入值</span></span><br><span class="line">    _taskLocalValuePush(key: key, value: valueDuringOperation)</span><br><span class="line">    <span class="keyword">defer</span> &#123; </span><br><span class="line">        <span class="comment">// 确保在 withValue 退出的时候将值释放掉</span></span><br><span class="line">        _taskLocalValuePop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> operation()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们注意到有几个关键的函数，它们的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePush&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePush</span>&lt;<span class="type">Value</span>&gt;(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*: Key*/</span>,</span><br><span class="line">  <span class="params">value</span>: __owned <span class="type">Value</span></span><br><span class="line">) <span class="comment">// where Key: TaskLocal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePop&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePop</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValueGet&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValueGet</span>(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*Key*/</span></span><br><span class="line">) -&gt; <span class="type">UnsafeMutableRawPointer</span>? <span class="comment">// where Key: TaskLocal</span></span><br></pre></td></tr></table></figure><p>通过 _silgen_name 的值，我们可以找到他们在 C++ 当中的定义，以 <code>_taskLocalValueGet</code> 为例，我们给出 <code>swift_task_localValueGet</code> 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SWIFT_CC</span>(swift)</span><br><span class="line"><span class="function"><span class="type">static</span> OpaqueValue* <span class="title">swift_task_localValueGetImpl</span><span class="params">(<span class="type">const</span> HeapObject *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (AsyncTask *task = <span class="built_in">swift_task_getCurrent</span>()) &#123;</span><br><span class="line">    <span class="comment">// 从当前 Task 的本地存储当中读取值，AsyncTask 实际上就是 C++ 层当中 Task 对应的类型</span></span><br><span class="line">    <span class="keyword">return</span> task-&gt;<span class="built_in">localValueGet</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncTask::localValueGet</code> 本质上调用的就是 <code>TaskLocal::Storage::getValue(AsyncTask *,const HeapObject *)</code>，我们同样可以找到它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OpaqueValue* TaskLocal::Storage::<span class="built_in">getValue</span>(AsyncTask *task,</span><br><span class="line">                                          <span class="type">const</span> HeapObject *key) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(key &amp;&amp; <span class="string">&quot;TaskLocal key must not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> item = head;</span><br><span class="line">  <span class="comment">// 遍历以 head 为头节点的链表</span></span><br><span class="line">  <span class="keyword">while</span> (item) &#123;</span><br><span class="line">    <span class="comment">// 比较 key，直到找到对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;key == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> item-&gt;<span class="built_in">getStoragePtr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = item-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，查找过程其实就是链表的遍历查找，时间复杂度为 O(n)。</p><p>我们再稍微观察一下插入和删除的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> TaskLocal::Storage::<span class="built_in">pushValue</span>(AsyncTask *task,</span><br><span class="line">                                   <span class="type">const</span> HeapObject *key,</span><br><span class="line">                                   <span class="comment">/* +1 */</span> OpaqueValue *value,</span><br><span class="line">                                   <span class="type">const</span> Metadata *valueType) &#123;</span><br><span class="line">  <span class="keyword">auto</span> item = Item::<span class="built_in">createLink</span>(task, key, valueType);</span><br><span class="line">  valueType-&gt;<span class="built_in">vw_initializeWithTake</span>(item-&gt;<span class="built_in">getStoragePtr</span>(), value);</span><br><span class="line">  head = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> TaskLocal::Storage::<span class="built_in">popValue</span>(AsyncTask *task) &#123;</span><br><span class="line">  <span class="keyword">auto</span> old = head;</span><br><span class="line">  head = head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  old-&gt;<span class="built_in">destroy</span>(task);</span><br><span class="line">  <span class="keyword">return</span> head != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现这实际上就是一个采用头插法的单链表。为什么选择这样的设计呢？</p><p>显然，绝大多数情况下 TaskLocal 值的数量都不会很多，同时插入的值只在 withValue 函数范围内有效也使得绝大多数查找的值都排在链表前面，因此线性查找的效率并不会存在性能问题。</p><p>而链表的结构也使得增删节点非常容易，使用头插法使得 withValue 函数退出时释放销毁对应的值也变得非常容易，时间复杂度只需要 O(1)。</p><p>另外，使用单链表来存储 TaskLocal 值还有一个好处，那就是变量遮蔽，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task1&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task3&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> logWithTag(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;22&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Task1</span>): <span class="number">1</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">2</span></span><br><span class="line">(<span class="type">Task3</span>): <span class="number">3</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">22</span></span><br><span class="line">(<span class="type">Task1</span>): <span class="number">11</span></span><br></pre></td></tr></table></figure><p>简单总结一下，TaskLocal 值是存在链表当中的，我们在使用过程中应当避免使用过多的 TaskLocal 值，也应该适当地减少对 TaskLocal 值的访问次数，以避免性能上最坏的情况出现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对 TaskLocal 值的使用和实现机制做了剖析。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果我想要定义一个变量，它的值只在 Task 内部共享，怎么做到呢？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
</feed>
