<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benny Huo</title>
  
  <subtitle>学海无涯，其乐无穷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bennyhuo.com/"/>
  <updated>2023-08-04T20:00:04.507Z</updated>
  <id>https://www.bennyhuo.com/</id>
  
  <author>
    <name>Benny Huo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接下来的一些想法</title>
    <link href="https://www.bennyhuo.com//2023/08/04/roadmap-2023/"/>
    <id>https://www.bennyhuo.com//2023/08/04/roadmap-2023/</id>
    <published>2023-08-04T20:08:04.000Z</published>
    <updated>2023-08-04T20:00:04.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想法很多，需要慢慢花时间去落实。 </p></blockquote><span id="more"></span><p>朋友们好，我是 bennyhuo。</p><p>这篇文章我准备聊聊接下来我想做的一些事情，让关注我的朋友们能够大概知道我在公众号、B站等平台接下来会输出哪些方面的内容。</p><h2 id="内容选题"><a href="#内容选题" class="headerlink" title="内容选题"></a>内容选题</h2><p>内容选题会尽量专注于编程语言特性。</p><p>首先，最重要的就是 Kotlin 相关的专题内容。目前在考虑中的一个专题是 Kotlin 与 Swift 核心特性的对比和分析。Kotlin 方向的内容我会花比较多的时间研究，内容也会偏向于进阶。</p><p>其次，我会对 Java、C++ 的新特性保持关注，除了更新《Java 核心技术》的读书视频以外，目前计划中有一个专题是 Java 18-21 新特性介绍（Java 17 的新特性专题文章已经发布）。相比之下，C++ 的内容做起来会更耗费精力，毕竟 C++ 比 Java 的新特性更多，也更复杂，因此暂时会优先考虑把《现代 C++ 核心特性解析》的读书视频做完。</p><p>此外，《Rust 官方电子书》和 《Effective Python》 的读书视频也在持续更新。</p><p>暂时没有开新坑的计划，所以大家可以踏实地等我更新这些视频。</p><h2 id="内容形式"><a href="#内容形式" class="headerlink" title="内容形式"></a>内容形式</h2><p>前面其实已经提到了，内容的形式主要分为文章和视频。我会优先考虑视频的更新，尽量保证两天一更，不过，可能每个月会休息几天。在不适合录制视频的情况下（比如嗓子不舒服的时候），我会抽空撰写专题文章，所以文章的发布频率可能会相对低一些。</p><p>以上都是公开的内容。知识星球也会每月发布一期会员视频，会员视频的内容以学习思考、工作方法之类的方向为主，与公开的内容有一定的定位差异。我也在考虑将一部分专题文章放到知识星球作为会员专题文章，不过暂时还没有确定具体操作形式。</p><h2 id="发布平台"><a href="#发布平台" class="headerlink" title="发布平台"></a>发布平台</h2><p>在催更微信群的朋友应该知道我最近这几天一直在打磨批量发布视频的工具。这个工具目前已经支持了将视频批量发布到 B站、YouTube、抖音、微信公众号（也会同步到视频号）四个平台，因此后续的视频发布终于可以轻松实现多平台同时发布了。</p><p>不管你习惯使用哪个平台，你都可以通过搜索 “<strong>霍丙乾 bennyhuo</strong>” 找到我的账号，收看我的视频内容。近期，我会陆续将存量的视频发布到抖音和微信公众号上，尽快与 B 站和 YouTube 逐步实现同步。</p><p>文章则会按照优先级在我的个人网站（<a href="https://www.bennyhuo.com)、微信公众号和掘金发布./">https://www.bennyhuo.com）、微信公众号和掘金发布。</a></p><h2 id="一点愿景"><a href="#一点愿景" class="headerlink" title="一点愿景"></a>一点愿景</h2><p>我不是计算机专业毕业的，我学到的很多计算机相关的知识都来自于互联网上各位前辈的无私奉献。其中对我影响最大的是 <a href="https://space.bilibili.com/2884629">oeasy 老师</a>，他现在还在 B 站持续发布新的视频教程来帮助大家。我一直觉得能坚持做这样一件事实在是太酷了。</p><p>我希望把事情做得纯粹一些，因此你不会在我的公众号看到 “几年心血总结出这篇八股文”、“阿里 P8 教你面试” 之类的广告，也不会在我的视频里面看到我明示大家投币三连求关注的转场动画。</p><p>希望我现在发布的内容也能对大家有所帮助。十几年后说起来，有过这么个人曾经影响过你。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想法很多，需要慢慢花时间去落实。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="规划" scheme="https://www.bennyhuo.com/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="思考" scheme="https://www.bennyhuo.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>说一件小事</title>
    <link href="https://www.bennyhuo.com//2023/03/29/new-name-and-new-journey/"/>
    <id>https://www.bennyhuo.com//2023/03/29/new-name-and-new-journey/</id>
    <published>2023-03-29T14:03:58.000Z</published>
    <updated>2023-04-17T07:37:39.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信公众号 “Kotlin” 即将更名为 “霍丙乾 bennyhuo”，作为我的个人公众号为大家分享技术内容。 </p></blockquote><span id="more"></span><h2 id="微信公众号-“Kotlin”-是怎么来的？"><a href="#微信公众号-“Kotlin”-是怎么来的？" class="headerlink" title="微信公众号 “Kotlin” 是怎么来的？"></a>微信公众号 “Kotlin” 是怎么来的？</h2><p>过去的几年里，我一直专注于研究和推广 Kotlin。从 2016 年开始，我注册了微信公众号 “Kotlin”，用来推送我录制的 Kotlin 入门视频，并且在这个号上面定期发布 Kotlin 相关的技术文章以及组织的各类活动。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330075842.png">  </p><p>最初，JetBrains 没有在国内投入专门的资源来推广 Kotlin。后来圣佑加入 Kotlin，成为 JetBrains 唯一的中文技术布道师，国内的活动、社区组织也才慢慢走上正轨。同时，在 Google 的助力下，Kotlin 成为大家熟知的现代编程语言，愿意学习 Kotlin 并且愿意输出 Kotlin 内容的开发者也越来越多。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329205933.png">  </p><p>2020 年写完书之后，我开始研究一些与 Kotlin 关联不大的内容，顺便出了一门 C 语言课。这门课的同学经常催我出一门 C++ 的课，于是我开始在 B 站发 C++ 视频，还写了一系列“渡劫 C++ 协程”的文章。随着我涉猎的内容方向就越来越广泛，这些内容与微信公众号 “Kotlin” 的名字产生了比较大的违和感。</p><p>经过两年时间的探索和思考，我终于下定决心做出一些改变。我向 JetBrains 提了一下我的想法，得到了他们的赞同，于是现在我们终于有了官方的 Kotlin 微信公众号啦！如果大家希望关注 Kotlin 官方的动态，请一定关注官方公众号 “Kotlin开发者”。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329212925.png">  </p><p>至此，以我个人名义注册的微信公众号 “Kotlin” 已经完成了它的使命。接下来，它将作为我的个人公众号，继续向关注我的朋友们推送我的个人思考和技术分享。</p><h2 id="还会推送-Kotlin-相关的内容吗？"><a href="#还会推送-Kotlin-相关的内容吗？" class="headerlink" title="还会推送 Kotlin 相关的内容吗？"></a>还会推送 Kotlin 相关的内容吗？</h2><p>当然！</p><p>毫不客气甚至有些骄傲地说，所有编程语言里面，我最擅长的就是 Kotlin。我会持续关注 Kotlin 的最新动态和发展方向，也会与 JetBrains 的朋友们保持联系，在需要的时候参与 Kotlin 相关的活动。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214234.png">  </p><p>今年，我还将出版一本 Kotlin 的新书，书名暂定为《深入实践 Kotlin 元编程》，内容主要包括注解处理器、编译器插件等。这些内容基本上是我通过反复阅读 Kotlin 编译器、Jetpack Compose 等项目的源码整理出来的。与《深入理解 Kotlin 协程》类似，这本书的内容对于知识的剖析较为深入，阅读起来有一定的挑战性，相信一定能够给读者带来一些启发。届时，公众号也会推送相关的内容作为补充，方便读者了解其中的细节。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330070944.png">  </p><p>哦对了，我还是一名 Kotlin GDE，组织上也会要求我们定期输出相关的视频、文章。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214632.png">  </p><p>除了 Kotlin 相关的内容以外，我也会输出一些 C/C++、Java、JavaScript 甚至 Rust 相关的内容。具体什么内容可能取决于我那一段时间的兴趣和投入。</p><p>之前有朋友跟我说，其实这些跟 Kotlin 都有关系，因为 Kotlin 要支持多平台嘛。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330071605.png">  </p><h2 id="目前主要在哪些平台输出内容？"><a href="#目前主要在哪些平台输出内容？" class="headerlink" title="目前主要在哪些平台输出内容？"></a>目前主要在哪些平台输出内容？</h2><p>目前我输出内容的形式主要是文章和视频，在公众号更名之后，发布的平台主要是以下几个：</p><ul><li>Bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>YouTube：<a href="https://www.youtube.com/channel/UCt47g8sEoUkI6R855ol3Gdw"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li><li>掘金：<a href="https://juejin.cn/user/1187128286120631"><strong>霍丙乾 bennyhuo</strong></a></li></ul><p>当然，也欢迎大家收藏我的个人主页和 GitHub：</p><ul><li>个人主页：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a> </li><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li></ul><p>感谢大家一如既往的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号 “Kotlin” 即将更名为 “霍丙乾 bennyhuo”，作为我的个人公众号为大家分享技术内容。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://www.bennyhuo.com/tags/kotlin/"/>
    
      <category term="公众号" scheme="https://www.bennyhuo.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="规划" scheme="https://www.bennyhuo.com/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2022 总结 - bennyhuo</title>
    <link href="https://www.bennyhuo.com//2022/12/31/summary-2022/"/>
    <id>https://www.bennyhuo.com//2022/12/31/summary-2022/</id>
    <published>2022-12-31T07:12:13.000Z</published>
    <updated>2023-04-17T07:37:39.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>也还是闲不住的一年呢。 </p></blockquote><span id="more"></span><p>一年又过去了。这一年也还是做了很多事情的。</p><h2 id="视频内容输出"><a href="#视频内容输出" class="headerlink" title="视频内容输出"></a>视频内容输出</h2><p>今年继续在 B 站发视频，欢迎关注：<a href="https://space.bilibili.com/28615855"><strong>bennyhuo 不是算命的</strong></a>。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221228152123.png">  </p><p>相比去年（2021 年），今年的视频大多数是读书视频。</p><ul><li><a href="https://www.bilibili.com/video/BV1Ni4y1U714/">《深入理解 Kotlin 协程》完结 共 16 集</a></li><li><a href="https://www.bilibili.com/video/BV1vv4y1A7fX/">《渡劫 C++ 协程》完结 共 7 集</a></li><li><a href="https://www.bilibili.com/video/BV1UY4y1z7W7/">《TypeScript 入门》完结 共 10 集</a></li><li><a href="https://www.bilibili.com/video/BV1Fu411Q7af/">《Dart 开发语言概览》完结 共 17 集</a></li><li><a href="https://www.bilibili.com/video/BV13T4y1k7qQ/">《现代 C++ 特性解析》更新至第六章，共 11 集</a></li><li><a href="https://www.bilibili.com/video/BV1HB4y1C7zH/">《Effective Python》更新至第 15 条，共 14 集</a></li><li><a href="https://www.bilibili.com/video/BV1NR4y1A7Tk/">《Rust 程序设计语言》更新至第七章，共 23 集</a></li><li><a href="https://www.bilibili.com/video/BV1ZV4y1L7Kx/">《Jetpack Compose 从入门到实战》更新至第二章，共 12 集</a></li></ul><p>Kotlin 版本更新的视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1eM4y1P7cR/">Kotlin 1.6 共 6 期</a></li><li><a href="https://www.bilibili.com/video/BV1ma411E7ZU/">Kotlin 1.7 共 2 期</a></li></ul><p>还有一些散装的视频，比如<a href="https://www.bilibili.com/video/BV1pT4y1Y746/">“神奇的 C 语言”</a>系列，说起来 C 语言的视频播放量是真的高。</p><p>订阅量从年初的 5900 左右增长到接近 17500，基本达到了我年初的预期（12000），<strong>谢谢大家的关注和一键三连</strong>。不瞒各位说，我当时还定了一个挑战目标：18000，还真是恰到好处的差一点儿。</p><p>2023 年的想法，未更新完的读书视频当中，这几本是确定要更完的：</p><ul><li>《Effective Python》</li><li>《Rust 程序设计语言》</li><li>《现代 C++ 特性解析》</li></ul><p>此外应该也会有一些 Java 相关的视频。</p><p>小伙伴们问得最多的是 Flutter 不更了吗，Compose 不更了吗？统一回复：对，不更了。</p><h2 id="文字内容输出"><a href="#文字内容输出" class="headerlink" title="文字内容输出"></a>文字内容输出</h2><p>今年文章写得不多，也就两个合集：</p><ul><li><a href="https://www.bennyhuo.com/book/cpp-coroutines/">渡劫 C++ 协程</a></li><li><a href="https://www.bennyhuo.com/book/swift-coroutines/">闲话 Swift 协程</a></li></ul><p>尽管写完《深入理解 Kotlin 协程》之后我就对协程这个话题比较麻木了，不过对于其他语言的协程我还是很好奇的。C++ 和 Swift 的协程的实现与 Kotlin 协程有很多相似之处，有兴趣的朋友不妨读一下这几篇文章了解一下。</p><p>今年也在写书。“深入实践 Kotlin 元编程”（暂定书名）这本书目前底稿已经全部完成，我目前正在逐字逐句做校对，预计还需要一个多月才能全部交付到编辑侧完成第一遍审稿。参考《深入理解 Kotlin 协程》的时间，2023 年内出版是没什么问题的。</p><p>这本书的内容大概涵盖了 Kotlin 开发实践当中另一个难点。大家常听说的 APT、KSP、KCP 在这本书当中都有详细介绍。如果大家想要提前了解书的内容，可以看一下我的 GitHub 2022 年的提交记录。经常有朋友我问有没有好的 KSP 或者 KCP 的示例代码，其实我近一年维护的所有项目基本上都与之相关。</p><p>写书是一件苦差事，每次写书的时候都在心里说写完这本就再也不写了。也许明年可以尝试写一些小册子，搞轻松一些。“渡劫 C++ 协程” 这种我觉得就挺好。</p><h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>今年的社区活动，一共有三次，其中还包括一次线下活动，真是不容易。</p><ul><li><p><a href="https://www.bilibili.com/video/BV1kG411n7KH/">2022.7 Kotlin 炉边漫谈 Podcast 第二期</a>：“Kotlin 炉边漫谈” 是 Kotlin 社区推出的一款节目，每期都会邀请一些有趣的嘉宾参与闲聊。据说我是那个最不会聊天的。</p></li><li><p><a href="https://www.bilibili.com/video/BV1ye4y1Y728/">2022.9.1 使用 Kotlin 多平台特性统一 JS 调用 Native 函数的体验</a>：这期分享主要介绍了 Klue 这个项目的实现思路和细节。Klue 是 Kotlin 多平台特性的一个很好的实践场景。这个项目明年应该会继续探索下去，今年之所以搁浅，实在是因为精力有限。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231150245.png">  </p></li><li><p><a href="https://www.bilibili.com/video/BV1t14y1L7SA/">2022.10.30 小猿口算 Android 项目的优化实践</a>：这期分享主要介绍了我在猿辅导公司小猿口算团队与团队其他同学一起做的各方面的工程优化。能把有趣的技术应用到公司项目当中，也是一件快事。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231152701.png">  </p></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>2022 年还有一些开源项目在维护。比较重要的就是下面的几个：</p><ul><li><a href="https://github.com/bennyhuo/Kotlin-Trim-Indent">Kotlin-Trim-Indent</a>：处理 Kotlin 多行字符串缩进的编译器插件。</li><li><a href="https://github.com/bennyhuo/KotlinDeepCopy">KotlinDeepCopy</a>：很多年的老项目了，今年又尝试了很多想法。</li><li><a href="https://github.com/bennyhuo/kotlin-compile-testing-extensions">kotlin-compile-testing-extensions</a>：对框架 kotlin-compile-testing 做的扩展，方便做 Kotlin 编译器相关项目的单测。</li><li><a href="https://github.com/bennyhuo/Klue">Klue</a>：使用 Kotlin 多平台特性对 Android/iOS 与 WebView/React Native 的互调用进行简化。</li></ul><p>今年因为写书，一直在做 Kotlin 编译器相关的尝试。明年的重心可能会放到 Klue 上面。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家在 B 站关注我：<strong>bennyhuo 不是算命的</strong>。</p><p>也欢迎大家关注微信公众号：<strong>bennyhuo</strong>。</p><p>2023 继续加油。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;也还是闲不住的一年呢。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="2022" scheme="https://www.bennyhuo.com/tags/2022/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（10）：后记</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-10-postscript/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-10-postscript/</id>
    <published>2022-03-27T23:03:55.000Z</published>
    <updated>2023-04-17T07:37:39.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><p><strong>渡劫 C++ 协程</strong>系列文章本来不在我的计划范围内。</p><p>相较于我常用的几门语言（可能是 Kotlin、Java、Python、JavaScript）来讲，我对 C++ 的熟悉程度并不是特别高。因此尽管群里的小伙伴们经常提议讲点儿 C++ 的内容（都出了一门 C 语言课了，还讲不了 C++？），考虑到精力和经验有限，我都拒绝了。</p><p>不过，人生就是那么奇妙，前不久我刚好有点儿时间，也正遇到群里有小伙伴们提到 C++ 协程，就硬着头皮看了一下午，录了一期视频 <a href="https://www.bilibili.com/video/BV1z5411Z7K5">协程上手经典案例：实现一个序列生成器</a>。既然有了第一期，那就得有第二期，结果越往后越感觉我这个讲法不太对。</p><p>过了一段时间之后，我的<a href="https://www.bennyhuo.com/book/swift-coroutines/"><strong>闲话 Swift 协程</strong></a>系列文章完结，同时我对 C++ 协程的认知也在不断加深，那么好吧，再写一系列 C++ 协程的文章吧。在学习 Swift 协程时，我可以翻阅 Swift 的语言设计文档以及源码，整个过程还算轻松，因此称为<strong>闲话 Swift 协程</strong>；C++ 的情况就不太一样了，设计文档看着令人头疼，标准库的源码又看得我眼花缭乱，于是得名<strong>渡劫 C++ 协程</strong>。</p><p>我在最初做 Kotlin 协程的介绍的时候，很多朋友都在问我协程究竟能做什么，再后来不少读者在发现 Kotlin 协程的默认调度器居然是个线程池，于是就认为 “Kotlin 协程的本质就是个线程池” —— 这真的是让人哭笑不得。</p><p>为了让读者能够更加深刻的认识协程，我在<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书当中花了整整一章的篇幅介绍了常见语言对协程的支持情况，对比彼此之间的差异，甚至用 Kotlin 协程的基本 API 来模拟其他语言的协程特性。</p><p>Kotlin 的协程和 C++ 的协程在设计分层上有着惊人的相似之处，二者在标准库当中仅仅提供了为数不多的基本 API，想要将协程运用到业务实践当中还需要有协程框架的支持。C++ 20 已经走出了第一步，这大概相当于 Kotlin 1.1 时的状态。</p><p>我当时为了让读者能够深入理解 Kotlin 协程框架的设计，干脆自己动手实现了一个简版的协程框架 <a href="https://github.com/bennyhuo/CoroutineLite">CoroutineLite</a>。而<strong>渡劫 C++ 协程</strong>的核心内容也是在尝试通过自己实现 C++ 的协程框架来深入理解 C++ 协程。按照这个思路，我们还可以继续深入探索，例如实现 <code>Task</code> 的取消，为 <code>Task</code> 添加父子关系以实现结构化并发等等能力，只是受限于时间和精力，我决定暂时停止这一次奇妙的探索历程。</p><p>如果想要在生产环境当中使用 C++ 20 提供的协程，我们可能还需要持续关注 C++ 委员会后续对协程的规划和设计。让我们期待将来 C++ 新标准对协程提供更多的支持吧。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（9）：一个简单的示例</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-09-http/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-09-http/</id>
    <published>2022-03-26T14:03:52.000Z</published>
    <updated>2023-04-17T07:37:39.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在本文当中，我将使用前文实现好的 <code>Task</code> 来发起一个简单的网络请求。</p><p>我会借助一些已有的框架来完成这次的目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpp-httplib/0.10.4</span><br><span class="line">openssl/3.0.2</span><br><span class="line">nlohmann_json/3.10.5</span><br></pre></td></tr></table></figure><p>这些框架可以通过 <a href="https://www.bilibili.com/video/BV1wL411u74B/">conan</a> 很轻松的完成安装。</p><h3 id="示例实现"><a href="#示例实现" class="headerlink" title="示例实现"></a>示例实现</h3><p>首先我们给出发起网络请求的核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用协程包装网络请求，请求的处理调度到 std::async 上</span></span><br><span class="line"><span class="function">Task&lt;std::string, AsyncExecutor&gt; <span class="title">http_get</span><span class="params">(std::string host, std::string path)</span> </span>&#123;</span><br><span class="line">  <span class="function">httplib::Client <span class="title">cli</span><span class="params">(host)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞地发起网络请求</span></span><br><span class="line">  <span class="keyword">auto</span> res = cli.<span class="built_in">Get</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="comment">// 返回响应内容，类型为 std::string</span></span><br><span class="line">    <span class="keyword">co_return</span> res-&gt;body;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">co_return</span> httplib::<span class="built_in">to_string</span>(res.<span class="built_in">error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 httplib 来完成网络请求的处理非常简单直接，我们只需要把 url 传入即可。通常我们的网络请求都会在 io 线程当中发起，因此我们将其调度到 <code>AsyncExecutor</code> 上。</p><p>接下来，我们再定义一个协程来调用 <code>http_get</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">test_http</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send request...&quot;</span>); <span class="comment">// Looper 线程上执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起网络请求，切换线程，当前协程挂起，Looper 线程被释放（此时 Looper 线程可以去调度其他任务）</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">http_get</span>(<span class="string">&quot;https://api.github.com&quot;</span>, <span class="string">&quot;/users/bennyhuo&quot;</span>);</span><br><span class="line">    <span class="comment">// 请求返回，当前协程接着在 Looper 线程上调度执行</span></span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑处理，解析 json</span></span><br><span class="line">    <span class="keyword">auto</span> json = nlohmann::json::<span class="built_in">parse</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印 json 内容</span></span><br><span class="line">    <span class="built_in">debug</span>(json.<span class="built_in">dump</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 假装这是其他业务处理</span></span><br><span class="line">    <span class="built_in">debug</span>(json[<span class="string">&quot;login&quot;</span>], json[<span class="string">&quot;url&quot;</span>]);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">22:10:54.046 [Thread-08056] (main.cpp:27) test_http: send request...</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:29) test_http: done.</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:31) test_http: &#123;</span><br><span class="line">  &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6336960?v=4&quot;,</span><br><span class="line">  &quot;bio&quot;: &quot;Google Developer Expert @Kotlin&quot;,</span><br><span class="line">  &quot;blog&quot;: &quot;https://www.bennyhuo.com&quot;,</span><br><span class="line">  ...  中间内容很多，省略掉 ...</span><br><span class="line">  &quot;updated_at&quot;: &quot;2022-03-23T13:51:26Z&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">&#125;</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:32) test_http: &quot;bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:33) test_http: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:34) test_http: &quot;Google Developer Expert @Kotlin&quot;</span><br></pre></td></tr></table></figure><p>在这个示例当中，我们没有使用协程来解决阻塞的问题，而是将一个异步的请求封装成同步的代码。<code>test_http</code> 当中的代码全程在 Looper 线程当中执行，尽管中间穿插了一个异步网络请求，但这看上去丝毫没有影响程序的连贯性和简洁性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的内容相对轻松，因为我们终于停止了基于协程的基础 API 的探索。</p><p>实际上，如果你发现你用到的某些 API 提供了异步回调，你完全可以使用 <code>Awaiter</code> 对其提供 <code>co_await</code> 的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（8）：通用 Awaiter</title>
    <link href="https://www.bennyhuo.com//2022/03/27/cpp-coroutines-08-awaiter/"/>
    <id>https://www.bennyhuo.com//2022/03/27/cpp-coroutines-08-awaiter/</id>
    <published>2022-03-25T14:03:52.000Z</published>
    <updated>2023-04-17T07:37:39.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每次我们新增功能时，都需要修改 TaskPromise 增加对应的 await_transform 函数，这显然是个设计问题。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们前面在实现无阻塞 sleep 和 Channel 的时候都需要专门实现对应的 Awaiter 类型，并且在 TaskPromise 当中添加相应的 <code>await_transform</code> 函数。增加新类型这没什么问题，但如果每增加一个新功能就要对原有的 <code>TaskPromise</code> 类型做修改，这说明 <code>TaskPromise</code> 的扩展性不够好。</p><p>当然，有读者会说，如果我们把所有的 <code>await_transform</code> 函数都去掉，改成给对应的类型实现 <code>operator co_await</code> 来获取 Awaiter（例如 sleep 的例子当中通过 duration 转 Awaiter） 或者干脆就自己就定义成 Awaiter（例如 <code>Channel</code> 当中的 <code>ReadAwaiter</code>），这样我们就不用总是修改 <code>TaskPromise</code> 了。话虽如此，但完全由外部定义 Awaiter 对象的获取会使得调度器无法被包装正确使用，甚至我们在定义 <code>TaskPromise</code> 的时候把调度器定义成私有成员，因为我们根本不希望外部能够轻易获取到调度器的实例。</p><p>使用 <code>await_transform</code> 本质上就是为了保证调度器的正确应用，却带来了扩展上的问题，那这是说 C++ 协程的设计有问题吗？当然也不是。我们完全可以定义一个 Awaiter 类型，外部只需要继承这个 Awaiter 在受限的范围内自定义逻辑，完成自己的需求同时也能保证调度器的调度。</p><h2 id="通用的-await-transform"><a href="#通用的-await-transform" class="headerlink" title="通用的 await_transform"></a>通用的 await_transform</h2><p>了解了需求背景之后，我们只需要在 <code>TaskPromise</code> 当中定义一个更加通用版本的 <code>await_transform</code>，来为 Awaiter 提供调度器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">  AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">    awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看得没错，我们真的只是给这个通用的 <code>Awaiter</code> 添加了当前协程的调度器。</p><h2 id="Awaiter-的定义"><a href="#Awaiter-的定义" class="headerlink" title="Awaiter 的定义"></a>Awaiter 的定义</h2><p>既然 <code>Awaiter</code> 的核心是调度器，我们可以直接给出它的基本定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *executor)</span> </span>&#123;</span><br><span class="line">    _executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方便用调度器调度任意逻辑，这里也处理了调度器为空的情况</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_executor) &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>(std::<span class="built_in">move</span>(f));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为 Awaiter 本身，当然也得有标准当中定义的基本的三个函数要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单处理，永远挂起，当然这也是协程调度的一个潜在的优化点</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前协程的 handle，方面后面恢复</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回 co_await 的结果，当然对于 void 的情况，我们也会有特化版本</span></span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 结果对子类可见，方便灵活操作</span></span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 保存协程的 handle，恢复时会用到，私有化这个成员目的是将其逻辑封装，避免滥用</span></span><br><span class="line">  std::coroutine_handle&lt;&gt; _handle = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数是协程在挂起和恢复时调用的。我们将协程 <code>handle</code> 的保存和结果的返回逻辑固化，因为几乎所有的 Awaiter 都有这样的需求。不过协程的挂起后和恢复前是两个非常重要的时间点，扩展 Awaiter 时经常需要在这两个时间点实现定义化的业务逻辑，因此我们需要定义两个虚函数让子类按需实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    <span class="comment">// 调用 after_suspend，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">after_suspend</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 before_resume，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">before_resume</span>();</span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是协程的恢复了，这时候我们要求必须使用调度器进行调度。为了防止外部不按要求处理调度逻辑，我们将调度器和协程的 <code>handle</code> 都定义为私有成员，因此我们也需要提供相应的函数来封装协程恢复的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复时，co_await 表达式返回 value</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(R value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, value]() &#123;</span><br><span class="line">      <span class="comment">// 将 value 封装到 _result 当中，await_resume 时会返回 value</span></span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;R&gt;(value));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不提供 value，但也要恢复协程，这种情况需要子类在 before_resume 当中写入 _result，或者抛出异常</span></span><br><span class="line">  <span class="comment">// 我们将会在 Channel 关闭时用到这个函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>]() &#123; _handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂起点出现异常，用异常来恢复协程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_exception</span><span class="params">(std::exception_ptr &amp;&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, e]() &#123;</span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;std::exception_ptr&gt;(e));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，如果我们想要扩展新功能，只需要继承 <code>Awaiter</code>，在 <code>after_suspend</code> 当中或者之后找个合适的时机调用 <code>resume/resume_unsafe/resume_exception</code> 三个函数当中的任意一个来恢复协程即可。如果在恢复前有其他逻辑需要处理，也可以覆写 <code>before_resume</code> 来实现。</p><h2 id="Awaiter-的应用"><a href="#Awaiter-的应用" class="headerlink" title="Awaiter 的应用"></a>Awaiter 的应用</h2><p>接下来我们使用 <code>Awaiter</code> 对现有的几个 awaiter 类型做重构，之后再尝试基于 <code>Awaiter</code> 做一点小小的扩展。</p><h3 id="重构-SleepAwaiter"><a href="#重构-SleepAwaiter" class="headerlink" title="重构 SleepAwaiter"></a>重构 SleepAwaiter</h3><p><code>SleepAwaiter</code> 是最简单的一个。我们当初为了让无阻塞的 sleep 看上去更加自然，直接对 <code>duration</code> 做了支持，于是可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>duration</code> 的支持源自于在 <code>TaskPromise</code> 当中添加了 <code>duration</code> 转 <code>SleepAwaiter</code> 的 <code>awaiter_transform</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不要求对 <code>duration</code> 直接支持的话，我们其实也可以这么设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(SleepAwaiter awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保存调度器，后面调度用</span></span><br><span class="line">  awaiter._executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与我们前面给出的通用 <code>Awaiter</code> 版本的  <code>await_transform</code> 如出一辙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传入调度器，后面调度用</span></span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以使用通用的 <code>Awaiter</code> 重构 <code>SleepAwaiter</code>，下面我们给出重构前和重构后的对比：</p><p><strong>重构前</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重构后</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> : Awaiter&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增一个支持 duration 的构造器，方便外部使用</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这部分逻辑以前写在 await_suspend 当中</span></span><br><span class="line">    <span class="comment">// 现在我们写在覆写的 after_suspend 当中</span></span><br><span class="line">    <span class="comment">// 调用位置实际上没有变化，但我们不用再关心 handle 和 调度器了</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>] &#123; <span class="built_in">resume</span>(); &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重构之后，我们无需单独为 <code>SleepAwaiter</code> 添加 <code>await_transform</code> 的支持，就可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得不够美观，也可以定义一个协程版本的函数 sleep_for：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">sleep_for</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写出来的代码就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">sleep_for</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重构-Channel-的-Awaiter"><a href="#重构-Channel-的-Awaiter" class="headerlink" title="重构 Channel 的 Awaiter"></a>重构 Channel 的 Awaiter</h3><p>Channel 有两个 Awaiter，分别是 <code>ReaderAwaiter</code>、<code>WriterAwaiter</code>，以前者为例：</p><p><strong>重构前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这代码大家已经见过，这里同样贴出来只是为了让大家能够直接对比：</p><p><strong>重构后</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;ValueType&gt; &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : Awaiter&lt;ValueType&gt;(), channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;ValueType&gt;(other),</span><br><span class="line">        <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = <span class="keyword">this</span>-&gt;_result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，调度的逻辑统一抽象到父类 <code>Awaiter</code> 当中，代码的逻辑更加紧凑了。不仅如此，之前在 <code>TaskPromise</code> 当中定义的 <code>await_transform</code> 也不需要了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不再需要</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">  reader_awaiter.executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriterAwaiter</code> 同理，不再赘述。</p><h3 id="重构-TaskAwaiter"><a href="#重构-TaskAwaiter" class="headerlink" title="重构 TaskAwaiter"></a>重构 TaskAwaiter</h3><p><code>TaskAwaiter</code> 是用来等待其他 <code>Task</code> 的执行完成的。它同样可以用前面的通用 <code>Awaiter</code> 改造：</p><p><strong>重构前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : _executor(completion._executor), <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为对比，重构后的代码同样变得简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), <span class="built_in">task</span>(std::<span class="built_in">move</span>(awaiter.task)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 先不去获取结果，原因是除了正常的返回值以外，还可能是异常</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume_unsafe</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有返回值，则赋值给 _result，否则直接抛异常</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_result = <span class="built_in">Result</span>(task.<span class="built_in">get_result</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R, Executor&gt; task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改造完成之后，如果不希望为 <code>Task</code> 增加特权支持的话，之前对 <code>TaskAwaiter</code> 的 <code>await_transform</code> 同样可以删除掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接删掉</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为 <code>Task</code> 类型增加一个函数来获取 <code>TaskAwaiter</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NoopExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">as_awaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;ResultType, Executor&gt;(std::<span class="built_in">move</span>(*<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦调用 <code>as_awaiter</code>，我们就会将 <code>Task</code> 的内容全部转移到新创建的 <code>TaskAwaiter</code> 当中，并且返回给外部使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除 TaskAwaiter&lt;&gt; await_transform(Task&lt;&gt;)</span></span><br><span class="line">  <span class="comment">// 可以采用以下方式在外部将 Task 转成 TaskAwaiter，然后再 co_await</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>().<span class="built_in">as_awaiter</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在我们自己实现的这套 <code>Task</code> 框架当中，<code>Task</code> 自然是“特权阶层”，我们不会真的删除为 <code>Task</code> 定制的 <code>await_transform</code>。但也不难看出，经过改造的 <code>Awaiter</code> 的子类代码量和复杂度都有降低；同时也不再需要定义专门的 <code>await_transform</code> 函数来明确支持 <code>TaskAwaiter</code>，避免了扩展性不强的尴尬。</p><h3 id="添加对-std-future-的扩展支持"><a href="#添加对-std-future-的扩展支持" class="headerlink" title="添加对 std::future 的扩展支持"></a>添加对 std::future 的扩展支持</h3><p>按照 C++ 标准的发展趋势来看，<code>std::future</code> 应该在将来会支持类似于 <code>Task::then</code> 这样的函数回调，那时候我们完全不需要自己独立定义一套 <code>Task</code>，只需要基于 <code>std::future</code> 进行扩展即可。</p><p>当然这都是后话了。现在 <code>std::future</code> 还不支持回调，我们可以另起一个线程来阻塞得等待它的结果，并在结果返回之后恢复协程的执行，这样一来，我们的 <code>Task</code> 框架也就能够支持形如 <code>co_await as_awaiter(future)</code> 这样的写法了。</p><p>想要做到这一点，我们只需要基于前面的 <code>Awaiter</code> 来依样画葫芦：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FutureAwaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _future(std::move(future)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), _future(std::<span class="built_in">move</span>(awaiter._future)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  FutureAwaiter &amp;<span class="keyword">operator</span>=(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::future::get 会阻塞等待结果的返回，因此我们新起一个线程等待结果的返回</span></span><br><span class="line">    <span class="comment">// 如果后续 std::future 增加了回调，这里直接注册回调即可</span></span><br><span class="line">    std::<span class="built_in">thread</span>([<span class="keyword">this</span>]()&#123;</span><br><span class="line">      <span class="comment">// 获取结果，并恢复协程</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume</span>(<span class="keyword">this</span>-&gt;_future.<span class="built_in">get</span>());</span><br><span class="line">    &#125;).<span class="built_in">detach</span>(); </span><br><span class="line">    <span class="comment">// std::thread 必须 detach 或者 join 二选一</span></span><br><span class="line">    <span class="comment">// 也可以使用 std::jthread </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::future&lt;R&gt; _future;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>FutureAwaiter</code> 与 <code>TaskAwaiter</code> 除了 <code>after_suspend</code> 和 <code>before_resume</code> 处有些不同之外，几乎完全一样（当然除了这俩函数以外也基本上没有其他逻辑了）。</p><p>如果你愿意，你也可以定义一个 <code>as_awaiter</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span></span><br><span class="line"><span class="function">FutureAwaiter&lt;R&gt; <span class="title">as_awaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FutureAwaiter</span>(std::<span class="built_in">move</span>(future));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在协程当中就可以使用 <code>co_await</code> 来等待 <code>std::future</code> 的返回了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">as_awaiter</span>(std::<span class="built_in">async</span>([]() &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">  &#125;));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AwaiterImpl-的类型约束"><a href="#AwaiterImpl-的类型约束" class="headerlink" title="AwaiterImpl 的类型约束"></a>AwaiterImpl 的类型约束</h2><p>本文给出的通用的 <code>await_transform</code> 有个小小的漏洞，我们不妨再次观察一下这个函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，只要 <code>AwaiterImpl</code> 类型定义了协程的 <code>Awaiter</code> 类型的三个函数，并且定义有 <code>install_executor</code> 函数，在这里就可以蒙混过关，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FakeAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">co_await</span> <span class="title">FakeAwaiter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>FakeAwaiter</code> 的定义符合前面的模板类型 <code>AwaiteImpl</code> 的要求，但却不符合我们的预期。为了避免这种情况发生，我们必须想办法要求 <code>AwaiterImpl</code> 只能是 <code>Awaiter</code> 或者它的子类。</p><p>这如果是在 Java 当中，我们可以很轻松地指定泛型的上界来达到目的。但 C++ 的模板显然与 Java 泛型的设计相差较大，不能直接在定义模板参数时指定上界。不过 C++ 20 的 concept 可以用来为模板参数限定父类。</p><p>我们需要定义一个用来检查类关系的 concept：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">concept</span> AwaiterImplRestriction = std::is_base_of&lt;Awaiter&lt;R&gt;, AwaiterImpl&gt;::value;</span><br></pre></td></tr></table></figure><p>接下来我们只需要在 <code>await_transform</code> 的模板声明后面加上这个 concept 即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span><br><span class="line"><span class="comment">// ??? 是 AwaiterImpl 继承父类 Awaiter 时传入的模板参数，但我们现在还不知道是什么</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, ???&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;  ...  &#125;</span><br></pre></td></tr></table></figure><p>不过这里有个问题，我们其实并不知道 <code>AwaiterImpl</code> 的实际类型在继承 <code>Awaiter</code> 时到底用了什么类型的模板参数，这怎么办呢？</p><p>有一个简单的办法，那就是为 <code>Awaiter</code> 声明一个内部类型 <code>ResultType</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ResultType = R;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用 <code>Awaiter::ResultType</code> 来获取这个类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, <span class="keyword">typename</span> AwaiterImpl::ResultType&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样像前面提到的 <code>FakeAwaiter</code> 那样的类型，就不能作为 <code>co_await</code> 表达式的参数了。即便我们为 <code>FakeAwaiter</code> 声明 <code>ResultType</code> 也不行，<code>co_await FakeAwaiter()</code> 的报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidate template ignored: constraints not satisfied [with AwaiterImpl = FakeAwaiter] </span><br><span class="line">because &#x27;AwaiterImplRestriction&lt;FakeAwaiter, typename FakeAwaiter::ResultType&gt;&#x27; evaluated to false </span><br><span class="line">because &#x27;std::is_base_of&lt;Awaiter&lt;void&gt;, FakeAwaiter&gt;::value&#x27; evaluated to false call to &#x27;await_transform&#x27; implicitly required by &#x27;co_await&#x27; here</span><br></pre></td></tr></table></figure><p>可见 <code>FakeAwaiter</code> 并不能满足与 <code>Awaiter</code> 的父子类关系，因此无法作为 <code>AwaiterImpl</code> 的模板实参。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了一种实现较为通用的 Awaiter 的方法，目的在于增加现有 <code>Task</code> 框架的扩展性，避免通过频繁改动 <code>TaskPromise</code> 来新增功能。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每次我们新增功能时，都需要修改 TaskPromise 增加对应的 await_transform 函数，这显然是个设计问题。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</title>
    <link href="https://www.bennyhuo.com//2022/03/22/cpp-coroutines-07-channel/"/>
    <id>https://www.bennyhuo.com//2022/03/22/cpp-coroutines-07-channel/</id>
    <published>2022-03-22T14:03:14.000Z</published>
    <updated>2023-04-24T09:38:23.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前我们主要关注的是协程与外部调用者的交互，这次我们也关注一下对等的协程之间的通信。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1oA4y1R7jn&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><h3 id="Go-routine-的-Channel"><a href="#Go-routine-的-Channel" class="headerlink" title="Go routine 的 Channel"></a>Go routine 的 Channel</h3><p>Go routine 当中有一个重要的特性就是 Channel。我们可以向 Channel 当中写数据，也可以从中读数据。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Channel 实例</span></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line"><span class="comment">// 创建只读 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="type">int</span> = channel</span><br><span class="line"><span class="comment">// 创建只写 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="type">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">  <span class="comment">// 遍历 Channel</span></span><br><span class="line">  <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// 读取 Channel，值存入 i，状态存入 ok 当中</span></span><br><span class="line">    i, ok := &lt;-readChannel</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Channel 被关闭时，ok 为 false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">    <span class="comment">// 向 Channel 当中写数据</span></span><br><span class="line">    writeChannel &lt;- i</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这个例子是我写 <a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书时用到过的一个非常简单的 Go routine 的例子，它的运行输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure><p>Go 当中的 Channel 默认是没有 buffer 的，我们也可以通过 <code>make chan</code> 在初始化 Channel 的时候指定 buffer。在 buffer 已满的情况下，写入者会先挂起等待读取者后再恢复执行，反之亦然。等待的过程中，所处的协程会挂起，执行调度的线程自然也会被释放用于调度其他逻辑。</p><h3 id="C-协程的-Channel-实现设计"><a href="#C-协程的-Channel-实现设计" class="headerlink" title="C++ 协程的 Channel 实现设计"></a>C++ 协程的 Channel 实现设计</h3><p>Kotlin 协程当中也有 Channel，与 Go 的不同之处在于 Kotlin 的 Channel 其实是基于协程最基本的 API 在框架层面实现的，并非语言原生提供的能力。C++ 的协程显然也可以采用这个思路，实际上整个这一系列 C++ 协程的文章都是在介绍如何使用 C++ 20 标准当中提供的基本的协程 API 在构建更复杂的框架支持。</p><p>我们来看一下我们最终的 Channel 的用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 写入时调用 write 函数</span></span><br><span class="line">    <span class="keyword">co_await</span> channel.<span class="built_in">write</span>(i++);</span><br><span class="line">    <span class="comment">// 或者使用 &lt;&lt; 运算符</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持关闭</span></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取时使用 read 函数，表达式的值就是读取的值</span></span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="comment">// 或者使用 &gt;&gt; 运算符将读取的值写入变量当中</span></span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="comment">// 捕获 Channel 关闭时抛出的异常</span></span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 Channel 也可以在构造的时候传入 buffer 的大小，默认没有 buffer。</p><h2 id="co-await-表达式的支持"><a href="#co-await-表达式的支持" class="headerlink" title="co_await 表达式的支持"></a>co_await 表达式的支持</h2><p>想要支持 <code>co_await</code> 表达式，只需要为 Channel 读写函数返回的 Awaiter 类型添加相应的 <code>await_transform</code> 函数。我们姑且认为 <code>read</code> 和 <code>write</code> 两个函数的返回值类型 <code>ReaderAwaiter</code> 和 <code>WriterAwaiter</code>，接下来就添加一个非常简单的 <code>await_transform</code> 的支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 void 的实例化版本也是一样的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">    reader_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(WriterAwaiter&lt;_ValueType&gt; writer_awaiter)</span> </span>&#123;</span><br><span class="line">    writer_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> writer_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Channel</code> 的 buffer 和对 <code>Channel</code> 的读写本身会决定协程是否挂起或恢复，因此这些逻辑我们都将在 <code>Channel</code> 当中给出，<code>TaskPromise</code> 能做的就是把调度器传过去，当协程恢复时使用。</p><h2 id="Awaiter-的实现"><a href="#Awaiter-的实现" class="headerlink" title="Awaiter 的实现"></a>Awaiter 的实现</h2><p>Awaiter 负责在挂起时将自己存入 <code>Channel</code>，并且在需要时恢复协程。因此除了前面看到需要在恢复执行协程时的调度器之外，Awaiter 还需要持有 <code>Channel</code>、需要读写的值。</p><p>下面是 <code>WriterAwaiter</code> 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriterAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  <span class="comment">// 调度器不是必须的，如果没有，则直接在当前线程执行（等价于 NoopExecutor）</span></span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 写入 Channel 的值</span></span><br><span class="line">  ValueType _value;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriterAwaiter</span>(Channel&lt;ValueType&gt; *channel, ValueType value)</span><br><span class="line">    : <span class="built_in">channel</span>(channel), _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录协程 handle，恢复时用</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_writer</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中恢复该协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们将调度器调度的逻辑封装在这里</span></span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对应的，还有 <code>ReaderAwaiter</code>，实现类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  <span class="comment">// 用于 channel &gt;&gt; received; 这种情况</span></span><br><span class="line">  <span class="comment">// 需要将变量的地址传入，协程恢复时写入变量内存</span></span><br><span class="line">  ValueType* p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中正常恢复读协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 关闭时调用 resume() 函数来恢复该协程</span></span><br><span class="line">  <span class="comment">// 在 await_resume 当中，如果 Channel 关闭，会抛出 Channel 关闭异常</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单说来，Awaiter 的功能就是：</p><ol><li>负责用协程的调度器在需要时恢复协程</li><li>处理读写的值的传递</li></ol><h2 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h2><p>接下来我们给出 <code>Channel</code> 当中根据 buffer 的情况来处理读写两端的挂起和恢复的逻辑。</p><h3 id="Channel-的基本结构"><a href="#Channel-的基本结构" class="headerlink" title="Channel 的基本结构"></a>Channel 的基本结构</h3><p>我们先来看一下 <code>Channel</code> 的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ChannelClosedException</span> : std::exception &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Channel is closed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_closed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经关闭，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!_is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ChannelClosedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(<span class="type">int</span> capacity = <span class="number">0</span>)</span> : buffer_capacity(capacity) &#123;</span></span><br><span class="line">    _is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 表示 Channel 尚未关闭</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _is_active.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 Channel</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> expect = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 判断如果已经关闭，则不再重复操作</span></span><br><span class="line">    <span class="comment">// 比较 _is_active 为 true 时才会完成设置操作，并且返回 true</span></span><br><span class="line">    <span class="keyword">if</span>(_is_active.<span class="built_in">compare_exchange_strong</span>(expect, <span class="literal">false</span>, std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 清理资源</span></span><br><span class="line">      <span class="built_in">clean_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不希望 Channel 被移动或者复制</span></span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;&amp;channel) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Channel &amp;<span class="keyword">operator</span>=(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁时关闭</span></span><br><span class="line">  ~<span class="built_in">Channel</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// buffer 的容量</span></span><br><span class="line">  <span class="type">int</span> buffer_capacity;</span><br><span class="line">  std::queue&lt;ValueType&gt; buffer;</span><br><span class="line">  <span class="comment">// buffer 已满时，新来的写入者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;WriterAwaiter&lt;ValueType&gt; *&gt; writer_list;</span><br><span class="line">  <span class="comment">// buffer 为空时，新来的读取者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;ReaderAwaiter&lt;ValueType&gt; *&gt; reader_list;</span><br><span class="line">  <span class="comment">// Channel 的状态标识</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; _is_active;</span><br><span class="line"></span><br><span class="line">  std::mutex channel_lock;</span><br><span class="line">  std::condition_variable channel_condition;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clean_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要对已经挂起等待的协程予以恢复执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> writer : writer_list) &#123;</span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    writer_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> reader : reader_list) &#123;</span><br><span class="line">      reader-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    reader_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 buffer</span></span><br><span class="line">    <span class="keyword">decltype</span>(buffer) empty_buffer;</span><br><span class="line">    std::<span class="built_in">swap</span>(buffer, empty_buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过了解 <code>Channel</code> 的基本结构，我们已经知道了 <code>Channel</code> 当中存了哪些信息。接下来我们就要填之前埋下的坑了：分别是在协程当中读写值用到的 <code>read</code> 和 <code>write</code> 函数，以及在挂起协程时 Awaiter 当中调用的 <code>try_push_writer</code> 和 <code>try_push_reader</code>。</p><h3 id="read-和-write"><a href="#read-和-write" class="headerlink" title="read 和 write"></a>read 和 write</h3><p>这两个函数也没什么实质的功能，就是把 Awaiter 创建出来，然后填充信息再返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">write</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WriterAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;&lt;(ValueType value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReaderAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&gt;&gt;(ValueType &amp;value_ref) &#123;</span><br><span class="line">    <span class="keyword">auto</span> awaiter =  <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// 保存待赋值的变量的地址，方便后续写入</span></span><br><span class="line">    awaiter.p_value = &amp;value_ref;</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当中除了 <code>operator&gt;&gt;</code> 的实现需要多保存一个变量的地址以外，大家只需要注意一下对于 <code>check_closed</code> 的调用即可，它的功能很简单：在 <code>Channel</code> 关闭之后调用它会抛出 <code>ChannelClosedException</code>。</p><h3 id="try-push-writer-和-try-push-reader"><a href="#try-push-writer-和-try-push-reader" class="headerlink" title="try_push_writer 和 try_push_reader"></a><code>try_push_writer</code> 和 <code>try_push_reader</code></h3><p>这是 <code>Channel</code> 当中最为核心的两个函数了，他们的功能正好相反。</p><p><code>try_push_writer</code> 调用时，意味着有一个新的写入者挂起准备写入值到 <code>Channel</code> 当中，这时候有以下几种情况：</p><ol><li><code>Channel</code> 当中有挂起的读取者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li><li><code>Channel</code> 的 buffer 没满，写入者把值写入 buffer，然后立即恢复执行。</li><li><code>Channel</code> 的 buffer 已满，则写入者被存入挂起列表（writer_list）等待新的读取者读取时再恢复。</li></ol><p>了解了思路之后，它的实现就不难写出了，具体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_writer</span><span class="params">(WriterAwaiter&lt;ValueType&gt; *writer_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line">  <span class="comment">// 检查有没有挂起的读取者，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!reader_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader = reader_list.<span class="built_in">front</span>();</span><br><span class="line">    reader_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader-&gt;<span class="built_in">resume</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 未满，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (buffer.<span class="built_in">size</span>() &lt; buffer_capacity) &#123;</span><br><span class="line">    buffer.<span class="built_in">push</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 已满，对应情况 3</span></span><br><span class="line">  writer_list.<span class="built_in">push_back</span>(writer_awaiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对应的，<code>try_push_reader</code> 调用时，意味着有一个新的读取者挂起准备从 <code>Channel</code> 当中读取值，这时候有以下几种情况：</p><ol><li><code>Channel</code> 的 buffer 非空，读取者从 buffer 当中读取值，如果此时有挂起的写入者，需要去队头的写入者将值写入 buffer，然后立即恢复该写入者和当次的读取者。</li><li><code>Channel</code> 当中有挂起的写入者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li><li><code>Channel</code> 的 buffer 为空，则读取者被存入挂起列表（reader_list）等待新的写入者写入时再恢复。</li></ol><p>接下来是具体的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 非空，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = buffer.<span class="built_in">front</span>();</span><br><span class="line">    buffer.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 有挂起的写入者要及时将其写入 buffer 并恢复执行</span></span><br><span class="line">      <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">      writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">      buffer.<span class="built_in">push</span>(writer-&gt;_value);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有写入者挂起，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">    writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(writer-&gt;_value);</span><br><span class="line">    writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 为空，对应情况 3</span></span><br><span class="line">  reader_list.<span class="built_in">push_back</span>(reader_awaiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，我们已经完整给出 <code>Channel</code> 的实现。</p><blockquote><p><strong>说明</strong>：我们当然也可以在 <code>await_ready</code> 的时候提前做一次判断，如果命中第 1、2 两种情况可以直接让写入/读取协程不挂起继续执行，这样可以避免写入/读取者的无效挂起。为了方便介绍，本文就不再做相关优化了。</p></blockquote><h3 id="监听协程的提前销毁"><a href="#监听协程的提前销毁" class="headerlink" title="监听协程的提前销毁"></a>监听协程的提前销毁</h3><p>截止目前，我们给出的 <code>Channel</code> 仍然有个小小的限制，即 <code>Channel</code> 对象必须在持有 <code>Channel</code> 实例的协程退出之前关闭。</p><p>这主要是因为我们在 <code>Channel</code> 当中持有了已经挂起的读写协程的 <code>Awaiter</code> 的指针，一旦协程销毁，这些 <code>Awaiter</code> 也会被销毁，<code>Channel</code> 在关闭时试图恢复这些读写协程时就会出现程序崩溃（访问了野指针）。</p><p>为了解决这个问题，我们需要在 <code>Awaiter</code> 销毁时主动将自己的指针从 <code>Channel</code> 当中移除。以 <code>ReaderAwaiter</code> 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现移动构造函数，主要目的是将原对象的 channel 置为空</span></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="comment">// 协程恢复，channel 已经没用了</span></span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="comment">// channel 不为空，说明协程提前被销毁了</span></span><br><span class="line">    <span class="comment">// 调用 channel 的 remove_reader 将自己直接移除</span></span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在 <code>ReaderAwaiter</code> 的析构函数当中主动检查并移除了自己的指针，避免后续 <code>Channel</code> 对自身指针的无效访问。</p><p>对应的，<code>Channel</code> 当中也需要增加 <code>remove_reader</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并发环境，修改 reader_list 的操作都需要加锁</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">    reader_list.<span class="built_in">remove</span>(reader_awaiter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriterAwaiter</code> 的修改类似，不再赘述。</p><p>这样修改之后，即使我们把正在等待读写 <code>Channel</code> 的协程提前结束销毁，也不会影响 <code>Channel</code> 的继续使用以及后续的正常关闭了。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们终于又实现了一个新的玩具，现在我们来给它通电试试效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send: &quot;</span>, i);</span><br><span class="line">    <span class="comment">// 或者使用 write 函数：co_await channel.write(i++);</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">    <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;close channel, exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 或者使用 read 函数：auto received = co_await channel.read();</span></span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer2</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive2: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">3</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception2: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> channel = <span class="built_in">Channel</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> producer = <span class="built_in">Producer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer = <span class="built_in">Consumer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer2 = <span class="built_in">Consumer2</span>(channel);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 等待协程执行完成再退出</span></span><br><span class="line">  producer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer2.<span class="built_in">get_result</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子非常简单，我们用一个写入者两个接收者向 <code>Channel</code> 当中读写数据，为了让示例更加凌乱，我们还加了一点点延时，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">08:39:58.129 [Thread-26004] (main.cpp:15) Producer: send:  0</span><br><span class="line">08:39:58.130 [Thread-27716] (main.cpp:31) Consumer: receive:  0</span><br><span class="line">08:39:58.443 [Thread-26004] (main.cpp:15) Producer: send:  1</span><br><span class="line">08:39:58.444 [Thread-17956] (main.cpp:45) Consumer2: receive2:  1</span><br><span class="line">08:39:58.759 [Thread-26004] (main.cpp:15) Producer: send:  2</span><br><span class="line">08:39:59.071 [Thread-26004] (main.cpp:15) Producer: send:  3</span><br><span class="line">08:39:59.382 [Thread-26004] (main.cpp:15) Producer: send:  4</span><br><span class="line">08:40:00.145 [Thread-27716] (main.cpp:31) Consumer: receive:  4</span><br><span class="line">08:40:00.454 [Thread-26004] (main.cpp:15) Producer: send:  5</span><br><span class="line">08:40:01.448 [Thread-17956] (main.cpp:45) Consumer2: receive2:  5</span><br><span class="line">08:40:01.762 [Thread-26004] (main.cpp:15) Producer: send:  6</span><br><span class="line">08:40:02.152 [Thread-27716] (main.cpp:31) Consumer: receive:  6</span><br><span class="line">08:40:02.464 [Thread-26004] (main.cpp:15) Producer: send:  7</span><br><span class="line">08:40:04.164 [Thread-27716] (main.cpp:31) Consumer: receive:  7</span><br><span class="line">08:40:04.460 [Thread-17956] (main.cpp:45) Consumer2: receive2:  2</span><br><span class="line">08:40:04.475 [Thread-26004] (main.cpp:15) Producer: send:  8</span><br><span class="line">08:40:04.787 [Thread-26004] (main.cpp:15) Producer: send:  9</span><br><span class="line">08:40:06.169 [Thread-27716] (main.cpp:31) Consumer: receive:  9</span><br><span class="line">08:40:06.481 [Thread-26004] (main.cpp:22) Producer: close channel, exit.</span><br><span class="line">08:40:07.464 [Thread-17956] (main.cpp:52) Consumer2: exit.</span><br><span class="line">08:40:08.181 [Thread-27716] (main.cpp:38) Consumer: exit.</span><br></pre></td></tr></table></figure><p>结果我就不分析了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文给出了 C++ 协程版的 <code>Channel</code> 的 demo 实现，这进一步证明了 C++ 协程的基础 API 的设计足够灵活，能够支撑非常复杂的需求场景。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前我们主要关注的是协程与外部调用者的交互，这次我们也关注一下对等的协程之间的通信。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</title>
    <link href="https://www.bennyhuo.com//2022/03/20/cpp-coroutines-06-sleep/"/>
    <id>https://www.bennyhuo.com//2022/03/20/cpp-coroutines-06-sleep/</id>
    <published>2022-03-20T14:03:28.000Z</published>
    <updated>2023-04-24T09:38:23.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你想要等待 100ms，你会怎么做？sleep_for(100ms) 吗？ </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV15v4y1g7Nu&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>在以往，我们想要让程序等待 100ms，我们只能调用线程的 sleep 函数来阻塞当前线程 100ms。</p><p>这样做确实可以让程序等待 100ms，但坏处就是这 100ms 期间，被阻塞的当前线程什么也做不了，白白占用了内存。协程出现之后，我们其实完全可以让协程在需要 sleep 的时候挂起，100ms 之后再来恢复执行，完全不需要阻塞当前线程。</p><p>想法不错，马上把用例给出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="comment">// 之前的写法，用 sleep_for 让当前线程睡眠 1 秒</span></span><br><span class="line">  <span class="comment">// std::this_thread::sleep_for(1s);</span></span><br><span class="line">  <span class="comment">// 等待 1 秒，注意 1s 是 chrono_literals 的字面值写法</span></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子大家已经见过多次了，之前用的是 <code>sleep_for</code> 让线程睡眠 1 秒，这次我们直接用 <code>co_await 1s</code>，看上去是不是特别的厉害？</p><h2 id="为-duration-实现-await-transform"><a href="#为-duration-实现-await-transform" class="headerlink" title="为 duration 实现 await_transform"></a>为 duration 实现 await_transform</h2><p>如果大家对于 C++ 11 不熟悉，可能会比较疑惑 <code>co_await 1s</code> 当中的 <code>1s</code> 是个什么东西。实际上这是 C++ 11 对字面值的一种支持，本质上就是一个运算符重载，这里的 <code>1s</code> 的类型是 <code>duration&lt;long long&gt;</code>。除了秒以外，时间的单位也可以是毫秒、纳秒、分钟、小时等等，这些 C++ 11 的 <code>duration</code> 都已经提供了完善的支持，因此我们只要对 <code>duration</code> 做支持即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了一个新的类型 <code>SleepAwaiter</code>，它的任务有两个：</p><ol><li>确保当前协程在若干毫秒之后恢复执行。</li><li>确保当前协程恢复执行时要调度到对应的调度器上。</li></ol><p>不难想到，<code>std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()</code> 实际上就是把任意单位的 <code>duration</code> 转换成毫秒。</p><p><code>SleepAwaiter</code> 的实现也很简单，我们直接给出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的延时执行工具类，全局只需要一个实例</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      <span class="comment">// _duration 毫秒之后执行下面的代码</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当中最为关键的就是 <code>Scheduler</code> 的实现了，这个类实际上本身就是一个独立的定时任务调度器。</p><h2 id="定时任务调度器-Scheduler"><a href="#定时任务调度器-Scheduler" class="headerlink" title="定时任务调度器 Scheduler"></a>定时任务调度器 Scheduler</h2><p>定时任务调度器，本质上就是一个时间管理大师。任何交给它的任务都需要有优先级，优先级的计算规则当然就是延时的长短，于是我们需要用到优先级队列来存储待执行的任务。</p><p>等下，任务队列？这让我想起上一篇文章当中的 <code>LooperExecutor</code>，如果我们给它加上计时执行的能力，<code>Scheduler</code> 的功能就差不多完成了。换个角度看，<code>LooperExecutor</code> 其实就是 <code>Scheduler</code> 的一个特化版本，它的所有任务的延时都是 0。</p><h3 id="定义定时任务的描述类型"><a href="#定义定时任务的描述类型" class="headerlink" title="定义定时任务的描述类型"></a>定义定时任务的描述类型</h3><p>为了方便管理定时任务，我们需要定义一个类型 <code>DelayedExecutable</code>，它包含一个函数和它要执行的绝对时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DelayedExecutable</span>(std::function&lt;<span class="built_in">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay) : <span class="built_in">func</span>(std::<span class="built_in">move</span>(func)) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 当前的时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出任务的计划执行时间</span></span><br><span class="line">    scheduled_time = current + delay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用时，返回从当前时间还需要多少毫秒到任务执行时间</span></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">delay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> scheduled_time - current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_scheduled_time</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduled_time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> scheduled_time;</span><br><span class="line">  std::function&lt;<span class="type">void</span>()&gt; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定时任务的描述类 <code>DelayedExecutable</code> 非常简单，相信大家一看就明白。</p><p>为了将 <code>DelayedExecutable</code> 存入优先级队列当中，我们还需要给它提给一个比较大小的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutableCompare</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(DelayedExecutable &amp;left, DelayedExecutable &amp;right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">get_scheduled_time</span>() &gt; right.<span class="built_in">get_scheduled_time</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类就很简单了，直接将对 <code>DelayedExecutable</code> 的比较转换成对它们的执行时间的比较。使用这个类对 <code>DelayedExecutable</code> 进行排序时，会使得时间靠前的对象排到前面。</p><h3 id="实现定时任务调度器"><a href="#实现定时任务调度器" class="headerlink" title="实现定时任务调度器"></a>实现定时任务调度器</h3><p>接下来我们直接给出 <code>Scheduler</code> 的实现，由于这个类与前面的 <code>LooperExecutor</code> 很像，我们只给出不同的部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  <span class="comment">// 注意这里改用优先级队列</span></span><br><span class="line">  std::priority_queue&lt;DelayedExecutable, std::vector&lt;DelayedExecutable&gt;, DelayedExecutableCompare&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从这里开始于 LooperExecutor 不同，这里需要判断优先级队头的任务，也就是最先要执行的任务是否需要立即执行</span></span><br><span class="line">      <span class="keyword">auto</span> executable = executable_queue.<span class="built_in">top</span>();</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> delay = executable.<span class="built_in">delay</span>();</span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队头的任务还没到执行时间，等待 delay 毫秒</span></span><br><span class="line">        <span class="keyword">auto</span> status = queue_condition.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(delay));</span><br><span class="line">        <span class="comment">// 如果等待期间没有延时比 delay 更小的任务加入，这里就会返回 timeout</span></span><br><span class="line">        <span class="keyword">if</span> (status != std::cv_status::timeout) &#123;</span><br><span class="line">          <span class="comment">// 不是 timeout，需要重新计算队头的延时</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">executable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay)</span> </span>&#123;</span><br><span class="line">    delay = delay &lt; <span class="number">0</span> ? <span class="number">0</span> : delay;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 只有队列为空或者比当前队头任务的延时更小时，需要调用 notify_one</span></span><br><span class="line">      <span class="comment">// 其他情况只需要按顺序依次执行即可</span></span><br><span class="line">      <span class="type">bool</span> need_notify = executable_queue.<span class="built_in">empty</span>() || executable_queue.<span class="built_in">top</span>().<span class="built_in">delay</span>() &gt; delay;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(<span class="built_in">DelayedExecutable</span>(std::<span class="built_in">move</span>(func), delay));</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">if</span> (need_notify) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对代码和注释的阅读，相信大家能够明白延时的实现其实是通过阻塞一个专门用于调度延时任务的线程来做到的。</p><p>相信有读者会有疑问：这不还是有阻塞吗？</p><p>没错，阻塞是免不了的。通常而言，我们也不会用一个线程去严格对应一个协程，当一个协程挂起时，执行这个协程的线程就会被空闲出来有机会去调度执行其他协程，进而让线程的利用率得到充分提升。如果有 10 个协程都需要执行延时，相较于阻塞这 10 个协程当前所在的 10 个线程而言，阻塞一个线程显然是更加经济的。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们又一次在文章的最后把要实现的功能做好，现在是收获的时刻了。</p><p>我们先来一个开胃菜。前面我们提到过，<code>Scheduler</code> 实际上是一个完整独立的功能模块，因此我们先写个简单的用例来测试一下它的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> scheduler = <span class="built_in">Scheduler</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;2&quot;</span>); &#125;, <span class="number">100</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;1&quot;</span>); &#125;, <span class="number">50</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;6&quot;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;5&quot;</span>); &#125;, <span class="number">500</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;3&quot;</span>); &#125;, <span class="number">200</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;4&quot;</span>); &#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">scheduler.<span class="built_in">shutdown</span>();</span><br><span class="line">scheduler.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>打印的数字是按照时间顺序排列的，但任务的添加却是乱序的。运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">22:12:54.611 [Thread-16076] (main.cpp:12) main: start</span><br><span class="line">22:12:54.673 [Thread-3252] (main.cpp:14) operator (): 1</span><br><span class="line">22:12:54.721 [Thread-3252] (main.cpp:13) operator (): 2</span><br><span class="line">22:12:54.815 [Thread-3252] (main.cpp:17) operator (): 3</span><br><span class="line">22:12:54.924 [Thread-3252] (main.cpp:18) operator (): 4</span><br><span class="line">22:12:55.113 [Thread-3252] (main.cpp:16) operator (): 5</span><br><span class="line">22:12:55.618 [Thread-3252] (main.cpp:15) operator (): 6</span><br></pre></td></tr></table></figure><p>可以看到 1-6 的顺序是可以保证的，前面的时间信息也可以看到延时能力基本上是符合预期的。</p><p>接下来，我们把前面用了好几次的 <code>Task</code> 的 demo 拿出来，加上延时，顺便也验证一下 <code>AsyncExecutor</code> 和 <code>NewThreadExecutor</code> 的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">100</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 100ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">500</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 500ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">22:14:49.531 [Thread-15596] (main.cpp:41) simple_task: task start ...</span><br><span class="line">22:14:49.641 [Thread-15596] (main.cpp:44) simple_task: after 100ms ...</span><br><span class="line">22:14:49.643 [Thread-26892] (main.cpp:25) simple_task2: task 2 start ...</span><br><span class="line">22:14:50.652 [Thread-26892] (main.cpp:28) simple_task2: task 2 returns after 1s.</span><br><span class="line">22:14:50.653 [Thread-15596] (main.cpp:46) simple_task: returns from task2:  2</span><br><span class="line">22:14:51.156 [Thread-15596] (main.cpp:49) simple_task: after 500ms ...</span><br><span class="line">22:14:51.158 [Thread-16816] (main.cpp:33) simple_task3: in task 3 start ...</span><br><span class="line">22:14:53.165 [Thread-26756] (main.cpp:36) simple_task3: task 3 returns after 2s.</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:51) simple_task: returns from task3:  3</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:58) operator (): simple task end:  6</span><br><span class="line">22:14:53.167 [Thread-11256] (main.cpp:64) test_tasks: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>我们把所有的 <code>sleep_for</code> 都替换成了本文实现的无阻塞的 sleep，运行效果上来看确实可以按照要求实现延时执行。</p><p>另外，由于这里的 <code>co_await 1s</code> 这样的操作都是挂起点，因此恢复时也会用协程的调度器去调度。可以看到，<code>simple_task2</code> 的两行日志的线程都是 <code>26892</code>，这大概是因为 <code>std::async</code> 背后是一个线程池，两次调度都调度到了同一个线程上，当然这个完全取决于 <code>std::async</code> 的实现。而 <code>simple_task3</code> 的两行日志就分别运行在 <code>16816</code> 和 <code>26756</code>，因为它的调度器是 <code>NewThreadExecutor</code>，每次都会新起一个线程来实现调度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文结合前面的 <code>Task</code> 的内容进一步给出了无阻塞式的 sleep 实现。通过本文的探讨，相信大家族在感慨 C++ 协程的设计真的是如此的灵活的同时，也进一步深入了解了 C++ 协程的用法。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果你想要等待 100ms，你会怎么做？sleep_for(100ms) 吗？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（5）：协程的调度器</title>
    <link href="https://www.bennyhuo.com//2022/03/20/cpp-coroutines-05-dispatcher/"/>
    <id>https://www.bennyhuo.com//2022/03/20/cpp-coroutines-05-dispatcher/</id>
    <published>2022-03-20T04:03:19.000Z</published>
    <updated>2023-04-24T09:38:23.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程想要实现异步，很大程度上依赖于调度器的设计。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1TW4y1k7gp&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="调度器的抽象设计"><a href="#调度器的抽象设计" class="headerlink" title="调度器的抽象设计"></a>调度器的抽象设计</h2><p>为了实现协程的异步调度，我们需要提供调度器的实现。调度器听起来有些厉害，但实际上就是负责执行一段逻辑的工具。</p><p>下面我们给出调度器的抽象设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExecutor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是的，你没看错，调度器本身就是这么简单。</p><h2 id="调度的位置"><a href="#调度的位置" class="headerlink" title="调度的位置"></a>调度的位置</h2><p>现在我们已经知道了调度器的样子，那么问题来了，怎么才能把它接入到协程当中呢？这个问题换个说法，那就是什么情况下我们需要调度，或者说什么情况下我们可以实现调度。</p><p>这个问题如果你不知道答案，让你随便蒙，你大概也没有什么其他的选项可以选。因为协程的本质就是挂起和恢复，因此想要实现调度，就必须在挂起和恢复上做文章。想要在 C++ 的协程的挂起和恢复上做文章，那我们就只能考虑定制 Awaiter 了。我们再来回顾一下前面提到的 TaskAwaiter 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们只保留了最核心的三个函数，其他的代码都略去了。可以看到，想要实现调度，就只能在 <code>await_suspend</code> 上面做文章，因为其他两个函数都要求同步返回。</p><p>实际上，按照 C++ 协程的设计，<code>await_suspend</code> 确实是用来提供调度支持的，由于这个时间点协程已经完全挂起，因此我们可以在任意一个线程上调用 <code>handle.resume()</code>，你甚至不用担心线程安全的问题。这样看来，如果有调度器的存在，代码大概会变成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度器的类型有多种，因此专门提供一个模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 TaskAwaiter 的时候传入调度器的具体实现</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 将 resume 函数的调用交给调度器执行</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调度器应该由谁持有"><a href="#调度器应该由谁持有" class="headerlink" title="调度器应该由谁持有"></a>调度器应该由谁持有</h2><p><code>TaskAwaiter</code> 当中的调度器实例是从外部传来的，这样设计的目的是希望把调度器的创建和绑定交给协程本身。换句话说，调度器应该属于协程。这样设计的好处就是协程内部的代码均会被调度到它对应的调度器上执行，可以确保逻辑的一致性和正确性。</p><p>这么看来，调度器应该与 <code>Task</code> 或者 <code>TaskPromise</code> 绑定到一起。</p><p>当协程创建时，我们可以以某种方式执行一个调度器，让协程的执行从头到尾都调度到这个调度器上执行。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 协程启动时就要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="comment">// 协程从 simple_task2 挂起后恢复执行，也要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="comment">// 同上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过模板参数为 <code>Task</code> 绑定了一个叫做 <code>LooperExecutor</code> 的调度器（我们现在先不去管 <code>LooperExecutor</code> 的具体实现，这个我们后面会讲），这样一来，我们希望 <code>simple_task</code> 当中所有的代码都会被调度到 <code>LooperExecutor</code> 上执行。</p><p>请大家参考注释的说明，我们了解到所有挂起的位置都需要在恢复时拿到同一个 <code>LooperExecutor</code> 的实例，因此我们考虑首先对 <code>TaskPromise</code> 的定义做一下修改，引入 <code>Executor</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程启动时也需要在恢复时实现调度</span></span><br><span class="line">  <span class="function">DispatchAwaiter <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DispatchAwaiter&#123;&amp;executor&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Task 类型增加模板参数 Executor 可以方便创建协程时执行调度器的类型</span></span><br><span class="line">  <span class="function">Task&lt;ResultType, Executor&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Executor executor;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们在 <code>TaskPromise</code> 当中定义了 <code>await_transform</code>，因此协程当中只支持对 <code>Task</code> 类型的 <code>co_await</code> 操作，这样可以保证所有的 <code>co_await &lt;task&gt;</code> 都会在恢复执行时通过 <code>TaskAwaiter</code> 来确保后续逻辑的正确调度。</p><p>剩下的就是协程在启动时的 <code>initial_suspend</code> 了，这个也比较容易处理，我们给出 <code>DispatchAwaiter</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">DispatchAwaiter</span><span class="params">(AbstractExecutor *executor)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调度到协程对应的调度器上</span></span><br><span class="line">    _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此一来，协程内部的所有逻辑都可以顺利地调度到协程对应的调度器上了。</p><p><code>Task</code> 的改动不大，只是增加了模板参数 <code>Executor</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewThreadExecutor 是 AbstractExecutor 的子类，作为模板参数 Executor 的默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NewThreadExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将模板参数 Executor 传给 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType, Executor&gt;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以默认给 <code>Task</code> 指定一个调度器的实现 <code>NewThreadExecutor</code>。这些调度器可以通过指定类型在 <code>TaskPromise</code> 当中执行初始化，因为我们会保证他们都会有默认的无参构造器实现。</p><h2 id="调度器的实现"><a href="#调度器的实现" class="headerlink" title="调度器的实现"></a>调度器的实现</h2><p>接下来我们给出几种简单的调度器实现作为示例，读者有兴趣也可以按照自己的需要设计调度器的实现。</p><h3 id="NoopExecutor"><a href="#NoopExecutor" class="headerlink" title="NoopExecutor"></a>NoopExecutor</h3><p>看名字相比大家也能猜个八九不离十，这就是个什么都不干的调度器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoopExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们给 <code>Task</code> 搭配这个调度器，<code>Task</code> 的执行线程就完全取决于调用者或者恢复者所在的线程了。</p><h3 id="NewThreadExecutor"><a href="#NewThreadExecutor" class="headerlink" title="NewThreadExecutor"></a>NewThreadExecutor</h3><p>顾名思义，每次调度都创建一个新的线程。实现非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewThreadExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">thread</span>(func).<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AsyncExecutor"><a href="#AsyncExecutor" class="headerlink" title="AsyncExecutor"></a>AsyncExecutor</h3><p>这个在思路上与 <code>NewThreadExecutor</code> 差别不大，只是调度时交给了 <code>std::async</code> 去执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比之下，这个调度器可以利用 <code>std::async</code> 背后的线程调度，提升线程的利用率。</p><h3 id="LooperExecutor"><a href="#LooperExecutor" class="headerlink" title="LooperExecutor"></a>LooperExecutor</h3><p>LooperExecutor 稍微复杂一些，它通常出现在主线程为事件循环的场景，例如 UI 相关应用的开发场景。</p><p>考虑到我本身不希望引入 UI 相关的开发概念，这里直接给出一个简单的单线程事件循环，并以此来实现 LooperExecutor：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 的时候是工作状态，如果要关闭事件循环，就置为 false</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理事件循环</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前事件循环是否是工作状态，或者队列没有清空</span></span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 队列为空，需要等待新任务加入队列或者关闭事件循环的通知</span></span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="comment">// 如果队列为空，那么说明收到的是关闭的通知</span></span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="comment">// 现有逻辑下此处用 break 也可</span></span><br><span class="line">          <span class="comment">// 使用 continue 可以再次检查状态和队列，方便将来扩展</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取出第一个任务，解锁再执行。</span></span><br><span class="line">      <span class="comment">// 解锁非常：func 是外部逻辑，不需要锁保护；func 当中可能请求锁，导致死锁</span></span><br><span class="line">      <span class="keyword">auto</span> func = executable_queue.<span class="built_in">front</span>();</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    work_thread = std::<span class="built_in">thread</span>(&amp;LooperExecutor::run_loop, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    <span class="built_in">shutdown</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 等待线程执行完，防止出现意外情况</span></span><br><span class="line">    <span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(func);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="comment">// 通知队列，主要用于队列之前为空时调用 wait 等待的情况</span></span><br><span class="line">      <span class="comment">// 通知不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">      queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改后立即生效，在 run_loop 当中就能尽早（加锁前）就检测到 is_active 的变化</span></span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_complete) &#123;    </span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="comment">// 清空任务队列</span></span><br><span class="line">      <span class="keyword">decltype</span>(executable_queue) empty_queue;</span><br><span class="line">      std::<span class="built_in">swap</span>(executable_queue, empty_queue);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 wait 函数，避免 Looper 线程不退出</span></span><br><span class="line">    <span class="comment">// 不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">    queue_condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各位读者可以参考代码注释来理解其中的逻辑。简单来说就是：</p><ol><li>当队列为空时，Looper 的线程通过 <code>wait</code> 来实现阻塞等待。</li><li>有新任务加入时，通过 <code>notify_one</code> 来通知 <code>run_loop</code> 继续执行。</li></ol><h3 id="SharedLooperExecutor"><a href="#SharedLooperExecutor" class="headerlink" title="SharedLooperExecutor"></a>SharedLooperExecutor</h3><p>这个其实就是 <code>LooperExecutor</code> 的一个马甲，它的作用就是让各个协程共享一个 <code>LooperExecutor</code> 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedLooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> LooperExecutor sharedLooperExecutor;</span><br><span class="line">    sharedLooperExecutor.<span class="built_in">execute</span>(std::<span class="built_in">move</span>(func));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>这次我们基于上一篇文章当中的 demo 加入调度器的支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 Async 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会通过 std::async 上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 NewThread 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会新建一个线程来执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 Looper 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会在同一个线程上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的代码跟上次不能说完全没有修改吧，那也是几乎没有修改，除了加了调度器的类型作为 <code>Task</code> 的模板参数。运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11:46:03.305 [Thread-32620] (main.cpp:40) simple_task: task start ...</span><br><span class="line">11:46:03.307 [Thread-33524] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">11:46:04.310 [Thread-33524] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">11:46:04.312 [Thread-32620] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">11:46:04.313 [Thread-42232] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">11:46:06.327 [Thread-42232] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">11:46:06.330 [Thread-30760] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>请大家仔细观察，所有 <code>simple_task</code> 函数的日志输出都在 id 为 32620 的线程上，这实际上就是我们的 Looper 线程。当然，由于 <code>simple_task2</code> 和 <code>simple_task3</code> 当中没有挂起点，因此它们只会在 <code>initial_suspend</code> 时调度一次。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们终于给 <code>Task</code> 添加了调度器的支持。如此一来，我们就可以把 <code>Task</code> 绑定到合适的线程调度器上，来应对更加复杂的业务场景了。</p><p>读者也可以发挥自己的想象力，按照类似的方式定义出更加有用或者有趣的调度器。当然，本文给出的调度器没有做调度优化，有兴趣的读者也可以自己尝试</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程想要实现异步，很大程度上依赖于调度器的设计。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（4）：通用异步任务 Task</title>
    <link href="https://www.bennyhuo.com//2022/03/19/cpp-coroutines-04-task/"/>
    <id>https://www.bennyhuo.com//2022/03/19/cpp-coroutines-04-task/</id>
    <published>2022-03-19T08:03:08.000Z</published>
    <updated>2023-04-24T09:38:23.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程主要用来降低异步任务的编写复杂度，异步任务各式各样，但归根结底就是一个结果的获取。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV163411g7np&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>为了方便介绍后续的内容，我们需要再定义一个类型 <code>Task</code> 来作为协程的返回值。<code>Task</code> 类型可以用来封装任何返回结果的异步行为（持续返回值的情况可能更适合使用序列生成器）。</p><p>实现的效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 1 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 2 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// result2 == 2</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// result3 == 3</span></span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义以 <code>Task&lt;ResultType&gt;</code> 为返回值类型的协程，并且可以在协程内部使用 <code>co_await</code> 来等待其他 <code>Task</code> 的执行。</p><p>外部非协程内的函数当中访问 <code>Task</code> 的结果时，我们可以通过回调或者同步阻塞调用两种方式来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步方式</span></span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步方式</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个效果，我们大致可以分析得到：</p><ol><li>需要一个结果类型来承载正常返回和异常抛出的情况。</li><li>需要为 <code>Task</code> 定义相应的 <code>promise_type</code> 类型来支持 <code>co_return</code> 和 <code>co_await</code>。</li><li>为 <code>Task</code> 实现获取结果的阻塞函数 <code>get_result</code> 或者用于获取返回值的回调 <code>then</code> 以及用于获取抛出的异常的回调 <code>catching</code>。</li></ol><h2 id="结果类型的定义"><a href="#结果类型的定义" class="headerlink" title="结果类型的定义"></a>结果类型的定义</h2><p>描述 <code>Task</code> 正常返回的结果和抛出的异常，只需要定义一个持有二者的类型即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化为默认值</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 正常返回时用结果初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(T &amp;&amp;value)</span> : _value(value) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 抛异常时用异常初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取结果，有异常则抛出异常</span></span><br><span class="line">  <span class="function">T <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T _value&#123;&#125;;</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>Result</code> 的模板参数 <code>T</code> 对应于 <code>Task</code> 的返回值类型。有了这个结果类型，我们就可以很方便地在需要读取结果的时候调用 <code>get_or_throw</code>。</p><h2 id="promise-type-的定义"><a href="#promise-type-的定义" class="headerlink" title="promise_type 的定义"></a>promise_type 的定义</h2><p>promise_type 的定义自然是最为重要的部分。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>基于前面几篇文章的基础，我们能够<del>很轻松地</del>给出它的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程立即执行</span></span><br><span class="line">  <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行结束后挂起，等待外部销毁。该逻辑与前面的 Generator 类似</span></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造协程的返回值对象 Task</span></span><br><span class="line">  <span class="function">Task&lt;ResultType&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将异常存入 result</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将返回值存入 result，对应于协程内部的 &#x27;co_return value&#x27;</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 使用 std::optional 可以区分协程是否执行完成</span></span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="await-transform"><a href="#await-transform" class="headerlink" title="await_transform"></a>await_transform</h3><p>光有这些还不够，我们还需要为 <code>Task</code> 添加 <code>co_await</code> 的支持。这里我们有两个选择：</p><ol><li>为 <code>Task</code> 实现 <code>co_await</code> 运算符</li><li>在 <code>promise_type</code> 当中定义 <code>await_transform</code></li></ol><p>从效果上来看，二者都可以做到。但区别在于，<code>await_transform</code> 是 <code>promsie_type</code> 的内部函数，可以直接访问到 <code>promise</code> 内部的状态；同时，<code>await_transform</code> 的定义也会限制协程内部对于其他类型的 <code>co_await</code> 的支持，将协程内部的挂起行为更好的管控起来，方便后续我们做统一的线程调度。因此此处我们采用 <code>await_transform</code> 来为 <code>Task</code> 提供 <code>co_await</code> 支持：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里的模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType&gt;(std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，返回了一个 <code>TaskAwaiter</code> 的对象。不过再次请大家注意，这里存在两个 <code>Task</code>，一个是 <code>TaskPromise</code> 对应的 <code>Task</code>，一个是 <code>co_await</code> 表达式的操作数 <code>Task</code>，后者是 <code>await_transform</code> 的参数。</p><p>下面是 <code>TaskAwaiter</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 task 执行完之后调用 resume</span></span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复执行时，被等待的 Task 已经执行完，调用 get_result 来获取结果</span></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R&gt; task;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个 <code>Task</code> 实例被 co_await 时，意味着它在 co_await 表达式返回之前已经执行完毕，当 <code>co_await</code> 表达式返回时，<code>Task</code> 的结果也就被取到，<code>Task</code> 实例在后续就没有意义了。因此 <code>TaskAwaiter</code> 的构造器当中接收 <code>Task &amp;&amp;</code>，防止 <code>co_await</code> 表达式之后继续对 <code>Task</code> 进行操作。</p><h3 id="同步阻塞获取结果"><a href="#同步阻塞获取结果" class="headerlink" title="同步阻塞获取结果"></a>同步阻塞获取结果</h3><p>为了防止 <code>result</code> 被外部随意访问，我们特意将其改为私有成员。接下来我们还需要提供相应的方式方便外部访问 <code>result</code>。</p><p>先来看一下如何实现同步阻塞的结果返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回</span></span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// 等待写入值之后调用 notify_all</span></span><br><span class="line">      completion.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有值，则直接返回（或者抛出异常）</span></span><br><span class="line">    <span class="keyword">return</span> result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">  std::mutex completion_lock;</span><br><span class="line">  std::condition_variable completion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要阻塞，就免不了用到锁（mutex）和条件变量（condition_variable），熟悉它们的读者一定觉得事情变得不那么简单了：这些工具在以往都是用在多线程并发的环境当中的。我们现在这么写其实也是为了后续应对多线程的场景，有关多线程调度的问题我们将在下一篇文章当中讨论。</p><h3 id="异步结果回调"><a href="#异步结果回调" class="headerlink" title="异步结果回调"></a>异步结果回调</h3><p>异步回调的实现稍微复杂一些，其实主要复杂在对于函数的运用。实际上对于回调的支持，主要就是支持回调的注册和回调的调用。根据结果类型的不同，回调又分为返回值的回调或者抛出异常的回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 加锁判断 result</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// result 已经有值</span></span><br><span class="line">      <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">      <span class="comment">// 解锁之后再调用 func</span></span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">func</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则添加回调函数，等待调用</span></span><br><span class="line">      completion_callbacks.<span class="built_in">push_back</span>(func);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调列表，我们允许对同一个 Task 添加多个回调</span></span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_callbacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;callback : completion_callbacks) &#123;</span><br><span class="line">      <span class="built_in">callback</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用完成，清空回调</span></span><br><span class="line">    completion_callbacks.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，如果只是在单线程环境内运行协程，这里的异步回调的作用可能并不明显。这里只是先给出定义，待我们后续支持线程调度之后，这些回调支持就会非常有价值了。</p><h2 id="Task-的实现"><a href="#Task-的实现" class="headerlink" title="Task 的实现"></a>Task 的实现</h2><p>现在我们已经实现了最为关键的 <code>promise_type</code>，接下来给出 <code>Task</code> 类型的完整定义。我想各位读者一定明白，<code>Task</code> 不过就是个摆设，它的能力大多都是通过调用 <code>promise_type</code> 来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明 promise_type 为 TaskPromise 类型</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>(ResultType)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>(result.<span class="built_in">get_or_throw</span>());</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// 忽略异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略返回值</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">finally</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123; <span class="built_in">func</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span>: handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;&amp;task) <span class="keyword">noexcept</span>: <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(task.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  Task &amp;<span class="keyword">operator</span>=(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们完成了 <code>Task</code> 的第一个通用版本的实现，这个版本的实现当中尽管我们对 <code>Task</code> 的结果做了加锁，但考虑到目前我们仍没有提供线程切换的能力，因此这实际上是一个无调度器版本的 <code>Task</code> 实现。</p><h2 id="Task-的-void-特化"><a href="#Task-的-void-特化" class="headerlink" title="Task 的 void 特化"></a>Task 的 void 特化</h2><p>前面讨论的 <code>Task</code> 有一个作为返回值类型的模板参数 <code>ResultType</code>。实际上有些时候我们只是希望一段任务可以异步执行完，而不关注它的结果，这时候 <code>ResultType</code> 就需要是 <code>void</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很快你就会发现问题。编译器会告诉你模板实例化错误，因为我们没法用 <code>void</code> 来声明变量；编译器还会告诉你协程体里面如果没有返回值，你应该提供为 <code>promise_type</code> 提供 <code>return_void</code> 函数。</p><p>看来情况没有那么简单。C++ 的模板经常会遇到这种需要特化的情况，我们只需要对之前的 <code>Task&lt;ResultType&gt;</code> 版本的定义稍作修改，就可以给出 <code>Task&lt;void&gt;</code> 的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 用 void 作为第一个模板参数实例化 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;<span class="type">void</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是 void，因此不用 return</span></span><br><span class="line">    <span class="comment">// 这时这个函数的作用就是阻塞当前线程等待协程执行完成</span></span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// func 的类型参数 void()，注意之前这个模板类型构造器还有个参数 ResultType</span></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 我们也会对 result 做 void 版本的实例化，这里只是检查有没有异常抛出</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// ignore.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你会发现变化的只是跟结果相关的部分。相应的，<code>TaskPromise</code> 也需要做出修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Task 的模板参数</span></span><br><span class="line">  <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回值类型改成 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不再需要 return</span></span><br><span class="line">    result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// Result 的模板参数变化</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再是 return_value 了</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;();</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void </span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void</span></span><br><span class="line">  std::optional&lt;Result&lt;<span class="type">void</span>&gt;&gt; result;</span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有 <code>Result</code> 也有对应的 <code>void</code> 实例化版本，其实就是把存储返回值相关的逻辑全部删掉，只保留异常相关的部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们进一步完善了 <code>Task</code> 对不同类型的结果的支持，理论上我们可以使用 <code>Task</code> 来构建各式各样的协程了。</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来我们可以试着把文章开头的代码运行一下了。为了更仔细地观察程序的执行，我们也在一些节点打印了日志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>debug</code> 是我自定义的一个宏，可以在打印日志的时候附加上时间、线程、函数等信息，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">16:46:30.448 [Thread-25132] (main.cpp:40) simple_task: task start ...</span><br><span class="line">16:46:30.449 [Thread-25132] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">16:46:31.459 [Thread-25132] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">16:46:31.460 [Thread-25132] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">16:46:31.461 [Thread-25132] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">16:46:33.469 [Thread-25132] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">16:46:33.470 [Thread-25132] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure><p>由于我们的任务在执行过程中没有进行任何线程切换，因此各个 <code>Task</code> 的执行实际上是串行的，就如同我们调用普通函数一样。当然，这显然不是我们的最终目的，下一篇我们就来介绍如何给 <code>Task</code> 增加调度器的支持。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们详细介绍了无调度器版本的 <code>Task</code> 的实现。尽管程序尚未真正实现异步执行，但至少从形式上，我们已经非常接近协程最神奇的地方了。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程主要用来降低异步任务的编写复杂度，异步任务各式各样，但归根结底就是一个结果的获取。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</title>
    <link href="https://www.bennyhuo.com//2022/03/14/cpp-coroutines-03-functional/"/>
    <id>https://www.bennyhuo.com//2022/03/14/cpp-coroutines-03-functional/</id>
    <published>2022-03-14T08:03:21.000Z</published>
    <updated>2023-04-24T09:38:23.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们还可以对序列生成器产生的数据流做进一步的筛选和处理，而这一切都可以基于协程去实现。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1dB4y1X7mY&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="序列生成器的泛化"><a href="#序列生成器的泛化" class="headerlink" title="序列生成器的泛化"></a>序列生成器的泛化</h2><p>我们已经有了一个 int 版本的 Generator，实际上我们也很容易把它泛化成模板类型，改动的地方不多，基本上把原 Generator 类型当中的 <code>int</code> 替换成模板参数 <code>T</code> 即可，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span> : std::exception &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样原来生成斐波那契数列的函数也需要稍作调整：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不过就是给 Generator 加了个模板参数而已。</p><h2 id="创建-Generator-的便捷函数"><a href="#创建-Generator-的便捷函数" class="headerlink" title="创建 Generator 的便捷函数"></a>创建 Generator 的便捷函数</h2><p>现在我们知道，想要创建 Generator 就需要定义一个函数或者 Lambda。不过从输出的结果上看， Generator 实际上就是一个“懒”序列，因此我们当然可以通过一个数组就能创建出 Generator 了。</p><p>使用数组创建 Generator 的版本实现比较简单，我们直接给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_array</span><span class="params">(T array[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 C++ 的数组作为参数时相当于指针，需要传入长度 n。用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_array</span>(array, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>显然，这个写法不能令人满意。</p><p>我们把数组改成 std::list 如何呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_list</span><span class="params">(std::list&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: list) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比数组，<code>std::list</code> 的版本少了一个长度参数，因为长度的信息被封装到 <code>std::list</code> 当中了。用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_list</span>(std::list&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>这个虽然有进步，但缺点也很明显，因为每次都要创建一个 <code>std::list</code>，说得直接一点儿就是每次都要多写 <code>std::list</code> 这 9 个字符。</p><p>这时候我们就很自然地想到了初始化列表的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from</span><span class="params">(std::initializer_list&lt;T&gt; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: args) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们就可以有下面的用法了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>不错，看上去需要写的内容少很多了。</p><p>不过，如果这对花括号也不用写的话，那就完美了。想要做到这一点，我们需要用到 C++ 17 的折叠表达式（fold expression）的特性，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...TArgs&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="type">static</span> <span class="title">from</span><span class="params">(TArgs ...args)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">co_yield</span> args, ...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的模板参数包（template parameters pack）不能用递归的方式去调用 from，因为那样的话我们会得到非常多的 Generator 对象。</p><p>用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>这下看上去完美多了。</p><h2 id="实现-map-和-flat-map"><a href="#实现-map-和-flat-map" class="headerlink" title="实现 map 和 flat_map"></a>实现 map 和 flat_map</h2><p>熟悉函数式编程的读者可能已经意识到了，我们定义的 Generator 实际上已经非常接近 Monad 的定义了。那我们是不是可以给它实现 map 和 flat_map 呢？</p><h3 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h3><p>map 就是将 Generator 当中的 T 映射成一个新的类型 U，得到一个新的 <code>Generator&lt;U&gt;</code>。下面我们给出第一个版本的 map 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">  Generator&lt;U&gt; <span class="title">map</span><span class="params">(std::function&lt;U(T)&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 this 当中是否有下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 使用 next 读取下一个元素</span></span><br><span class="line">      <span class="comment">// 通过 f 将其变换成 U 类型的值，再使用 co_yield 传出</span></span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>std::function&lt;U(T)&gt;</code> 当中的模板参数 <code>U(T)</code> 是个模板构造器，放到这里就表示这个函数的参数类型为 <code>T</code>，返回值类型为 <code>U</code>。</p><p>接下来我们给出用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibonacci 是上一篇文章当中定义的函数，返回 Generator&lt;int&gt;</span></span><br><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>&lt;std::string&gt;([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 map 函数，我们将 <code>Generator&lt;int&gt;</code> 转换成了 <code>Generator&lt;std::string&gt;</code>，外部使用 <code>generator_str</code> 就会得到字符串。</p><p>当然，这个实现有个小小的缺陷，那就是 map 函数的模板参数 U 必须显式提供，如上例中的 <code>&lt;std::string&gt;</code>，这是因为我们在定义 map 时用到了模板构造器，这使得类型推断变得复杂。</p><p>为了解决这个问题，我们就要用到模板的一些高级特性了，下面给出第二个版本的 map 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  Generator&lt;std::<span class="type">invoke_result_t</span>&lt;F, T&gt;&gt; <span class="built_in">map</span>(F f) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们直接用模板参数 <code>F</code> 来表示转换函数 f 的类型。map 本身的定义要求 <code>F</code> 的参数类型是 <code>T</code>，然后通过 <code>std::invoke_result_t&lt;F, T&gt;</code> 类获取 <code>F</code> 的返回值类型。</p><p>这样我们在使用时就不需要显式的传入模板参数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-flat-map"><a href="#实现-flat-map" class="headerlink" title="实现 flat_map"></a>实现 flat_map</h3><p>在给出实现之前，我们需要先简单了解一下 flat_map 的概念。</p><p>前面提到的 map 是元素到元素的映射，而 flap_map 是元素到 Generator 的映射，然后将这些映射之后的 Generator 再展开（flat），组合成一个新的 Generator。这意味如果一个 Generator 会传出 5 个值，那么这 5 个值每一个值都会映射成一个新的 Generator，，得到的这 5 个 Generator 又会整合成一个新的 Generator。</p><p>由此可知，map 不会使得新 Generator 的值的个数发生变化，flat_map 会。</p><p>下面我们给出 flat_map 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="comment">// 返回值类型就是 F 的返回值类型</span></span><br><span class="line">  <span class="function">std::<span class="type">invoke_result_t</span>&lt;F, T&gt; <span class="title">flat_map</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 值映射成新的 Generator</span></span><br><span class="line">      <span class="keyword">auto</span> generator = <span class="built_in">f</span>(<span class="built_in">next</span>());</span><br><span class="line">      <span class="comment">// 将新的 Generator 展开</span></span><br><span class="line">      <span class="keyword">while</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> generator.<span class="built_in">next</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加深大家的理解，我们给出一个小例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 返回值类型必须显式写出来，表明这个函数是个协程</span></span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="comment">// 在协程当中，我们可以使用 co_yield 传值出来</span></span><br><span class="line">        <span class="keyword">co_yield</span> j; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;* &quot;</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这个例子的运行输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* *</span><br><span class="line">* * *</span><br><span class="line">* * * *</span><br></pre></td></tr></table></figure><p>我们来稍微做下拆解。</p><ol><li><code>Generator&lt;int&gt;::from(1, 2, 3, 4)</code> 得到的是序列 <code>1 2 3 4</code></li><li>flat_map 之后，得到 <code>0 0 1 0 1 2 0 1 2 3</code></li></ol><p>由于我们在 0 的位置做了换行，因此得到的输出就是 * 组成的三角形了。</p><h2 id="其他有趣的函数"><a href="#其他有趣的函数" class="headerlink" title="其他有趣的函数"></a>其他有趣的函数</h2><h3 id="遍历所有值的-for-each"><a href="#遍历所有值的-for-each" class="headerlink" title="遍历所有值的 for_each"></a>遍历所有值的 for_each</h3><p>序列的最终使用，往往就是遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">for_each</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="built_in">f</span>(<span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折叠值的-fold"><a href="#折叠值的-fold" class="headerlink" title="折叠值的 fold"></a>折叠值的 fold</h3><p>Generator 会生成很多值，如果我们需要对这些值做一些整体的处理，并最终得到一个值，那么我们就需要折叠函数 fold：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  R <span class="title">fold</span><span class="params">(R initial, F f)</span> </span>&#123;</span><br><span class="line">    R acc = initial;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      acc = <span class="built_in">f</span>(acc, <span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它需要一个初始值，函数 f 接收两个参数，分别是 acc 和序列生成器当前迭代的元素，每次经过 f 做运算得到的结果会作为下次迭代的 acc 传入，直到最后 acc 作为 fold 的返回值返回。</p><p>我们可以很方便地使用 fold 求和或者求取阶乘，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result: 720</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .<span class="built_in">fold</span>(<span class="number">1</span>, [](<span class="keyword">auto</span> acc, <span class="keyword">auto</span> i)&#123; </span><br><span class="line">    <span class="keyword">return</span> acc * i;  <span class="comment">// 计算阶乘</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="求和函数-sum"><a href="#求和函数-sum" class="headerlink" title="求和函数 sum"></a>求和函数 sum</h3><p>求和本身可以用前面的 fold 来实现，当然我们也可以直接给出 sum 函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      sum += <span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result: 21</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">double</span>&gt;::<span class="built_in">from</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6.0f</span>).<span class="built_in">sum</span>();</span><br></pre></td></tr></table></figure><h3 id="过滤部分值的-filter"><a href="#过滤部分值的-filter" class="headerlink" title="过滤部分值的 filter"></a>过滤部分值的 filter</h3><p>你几乎可以在任何看到 map/flat_map 的场合看到 filter，毕竟有些值我们根本不需要。</p><p>想要实现这个过滤，只需要一个条件判断，下面我们给出 fitler 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">filter</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = <span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截取前-n-个值的-take-n"><a href="#截取前-n-个值的-take-n" class="headerlink" title="截取前 n 个值的 take(n)"></a>截取前 n 个值的 take(n)</h3><p>序列生成器往往与<strong>懒序列</strong>同时出现，因为<strong>懒序列</strong>之所以<strong>懒</strong>，往往是因为它的长度可能很长（甚至无限，例如斐波那契数列），一次性将所有的值加载出来会比较影响性能。</p><p>对于这种很长的懒序列，我们最终能用到的值可能并不多，因此我们需要一个函数 <code>take(n)</code> 对序列的前 <code>n</code> 个做截取。</p><p>它的实现也是显而易见的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="title">take</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; n &amp;&amp; <span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截取到指定条件的-take-while"><a href="#截取到指定条件的-take-while" class="headerlink" title="截取到指定条件的 take_while"></a>截取到指定条件的 take_while</h3><p>take_while 的实现就好像是 filter 与 take(n) 的一个结合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">take_while</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = <span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们想要截取小于 100 的所有斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fibonacci</span>().<span class="built_in">take_while</span>([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">100</span>;</span><br><span class="line">&#125;).for_each([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55 89</span><br></pre></td></tr></table></figure><h2 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h2><p>前面给出了这么多函数的实现，目的主要是为了<del>凑字数</del>让大家充分理解 C++ 协程的妙处。为了进一步确认大家对于前面例子的理解程度，我们再给出一个例子，请大家思考这当中的每一个 lambda 分别调用几次，以及输出什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    .<span class="built_in">filter</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;filter: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">map</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i * <span class="number">3</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;flat_map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="built_in">take</span>(<span class="number">3</span>)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;for_each: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>大家在分析的时候，请牢记 Generator 生成的序列是懒序列，只要最终访问到的时候才会生成。</p><p>这意味着中间的 map 其中根本不会主动消费 Generator，flat_map 也不会，filter 也不会，take 也不会。只有 for_each 调用的时候，才会真正需要知道 Generator 当中都有什么。</p><p>输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter: 1</span><br><span class="line">filter: 2</span><br><span class="line">map: 2</span><br><span class="line">flat_map: 6</span><br><span class="line">for_each: 0</span><br><span class="line">for_each: 1</span><br><span class="line">for_each: 2</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：大家可以返回去再看一下我们给出的函数的实现，找一下哪些当中用到了 <code>co_yield</code>，哪些没有用到，以及这两类函数有什么区别。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对前文当中的序列生成器做了泛化，使它能够支持任意类型的序列生成。此外，我们也针对序列生成器添加了一系列的函数式的支持，以帮助读者进一步深入理解协程的工作机制。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们还可以对序列生成器产生的数据流做进一步的筛选和处理，而这一切都可以基于协程去实现。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（2）：实现一个序列生成器</title>
    <link href="https://www.bennyhuo.com//2022/03/11/cpp-coroutines-02-generator/"/>
    <id>https://www.bennyhuo.com//2022/03/11/cpp-coroutines-02-generator/</id>
    <published>2022-03-11T14:03:49.000Z</published>
    <updated>2023-04-24T09:38:23.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列生成器是一个非常经典的协程应用场景。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1ug411d7Xy&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>现在我们已经了解了绝大部分 C++ 协程的特性，可以试着来实现一些小案例了。</p><p>简单的说，序列生成器通常的实现就是在一个协程内部通过某种方式向外部传一个值出去，并且将自己挂起，外部调用者则可以获取到这个值，并且在后续继续恢复执行序列生成器来获取下一个值。</p><p>显然，挂起和向外部传值的任务就需要通过 <code>co_await</code> 来完成了，外部获取值的任务就要通过协程的返回值来完成。</p><p>由此我们大致能想到最终程序的样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 generator 有个 next 函数，调用它时我们需要想办法让协程恢复执行，并将下一个值传出来。</p><p>好了，接下来我们就带着这两个问题去寻找解决办法，顺便把剩下的一点点 C++ 协程的知识补齐。</p><h2 id="调用者获取值"><a href="#调用者获取值" class="headerlink" title="调用者获取值"></a>调用者获取值</h2><p>截止到目前我们都没有真正尝试去调用过协程，现在是个很好的机会。我们观察一下 main 函数当中的这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 的类型就是我们即将实现的序列生成器类型 <code>Generator</code>，结合上一篇文章当中对于协程返回值类型的介绍，我们先大致给出它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行时直接挂起等待外部调用 resume 获取下一个值</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行结束后不需要挂起</span></span><br><span class="line">    <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了简单，我们认为序列生成器当中不会抛出异常，这里不做任何处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ???.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码当中有两处我们标注为 ???，表示暂时还不知道怎么处理。</p><p>第一个是我们想要在 Generator 当中 resume 协程的话，需要拿到 coroutine_handle，这个要怎么做到呢？</p><p>这时候我希望大家一定要记住一点，promise_type 是连接协程内外的桥梁，想要拿到什么，找 promise_type 要。标准库提供了一个通过 promise_type 的对象的地址获取 coroutine_handle 的函数，它实际上是 coroutine_handle 的一个静态函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Promise</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_handle</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(_Promise&amp; _Prom)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来，我们只需要在 <code>get_return_object</code> 函数调用时，先获取 coroutine_handle，然后再传给即将构造出来的 Generator 即可，因此我们稍微修改一下前面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是如何获取协程内部传出来的值的问题了。同样，本着有事儿找 promise_type 的原则，我们可以直接给它定义一个 value 成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="comment">// 通过 handle 获取 promise，然后再取到 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="协程内部挂起并传值"><a href="#协程内部挂起并传值" class="headerlink" title="协程内部挂起并传值"></a>协程内部挂起并传值</h2><p>现在的问题就是如何从协程内部传值给 promise_type 了。</p><p>我们再来观察一下最终实现的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是 <code>co_await i++;</code> 这一句，我们发现 <code>co_await</code> 后面的是一个整型值，而不是我们在前面的文章当中提到的满足等待体（awaiter）条件的类型，这种情况下该怎么办呢？</p><p>实际上，对于 <code>co_await &lt;expr&gt;</code> 表达式当中 <code>expr</code> 的处理，C++ 有一套完善的流程：</p><ol><li>如果 promise_type 当中定义了 await_transform 函数，那么先通过 <code>promise.await_transform(expr)</code> 来对 expr 做一次转换，得到的对象称为 awaitable；否则 awaitable 就是 expr 本身。</li><li>接下来使用 awaitable 对象来获取等待体（awaiter）。如果 awaitable 对象有 <code>operator co_await</code> 运算符重载，那么等待体就是 <code>operator co_await(awaitable)</code>，否则等待体就是 awaitable 对象本身。</li></ol><p>听上去，我们要么给 promise_type 实现一个 <code>await_tranform(int)</code> 函数，要么就为整型实现一个 <code>operator co_await</code> 的运算符重载，二者选一个就可以了。</p><h3 id="方案-1：实现-operator-co-await"><a href="#方案-1：实现-operator-co-await" class="headerlink" title="方案 1：实现 operator co_await"></a>方案 1：实现 operator co_await</h3><p>这个方案就是给 int 定义 operator co_await 的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">IntAwaiter</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Generator::promise_type&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      handle.<span class="built_in">promise</span>().value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> IntAwaiter&#123;.value = value&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个方案对于我们这个特定的场景下是行不通的，因为在 C++ 当中我们是无法给基本类型定义运算符重载的。</p><p>不过，如果我们遇到的情况不是基本类型，那么运算符重载的思路就可以行得通。<code>operator co_await</code> 的重载我们将会在后面给出例子。</p><h3 id="方案-2：await-transform"><a href="#方案-2：await-transform" class="headerlink" title="方案 2：await_transform"></a>方案 2：await_transform</h3><p>运算符重载行不通，那就只能通过 await_tranform 来做转换了。</p><p>代码比较简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传值的同时要挂起，值存入 value 当中</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">await_transform</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部调用者或者恢复者可以通过读取 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义了 <code>await_transform</code> 函数之后，<code>co_await expr</code> 就相当于 <code>co_await promise.await_transform(expr)</code> 了。</p><p>至此，我们的例子就可以运行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h2><p>虽然我们的协程已经能够正常工作，但它仍然存在缺陷。</p><h3 id="问题-1：无法确定是否存在下一个元素"><a href="#问题-1：无法确定是否存在下一个元素" class="headerlink" title="问题 1：无法确定是否存在下一个元素"></a>问题 1：无法确定是否存在下一个元素</h3><p>当外部调用者或者恢复者试图调用 <code>next</code> 来获取下一个元素的时候，它其实并不知道能不能真的得到一个结果。程序也可能抛出异常：</p><p>如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 只传出 5 个值</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 试图读取 15 个值</span></span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的结果是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure><p>最后一个输出的 4 实际上是恰好遇到协程销毁之前的状态，此时 promise 当中的 value 值还是之前的 4。而当我们试图不断的去读取协程的值，程序就抛出 SIGSEGV  的错误。错误的原因你可能已经想到了，当协程体执行完之后，协程的状态就会被销毁，如果我们再访问协程的话，就相当于访问了一个野指针。</p><p>为了解决这个问题，我们需要增加一个 has_next 函数，用来判断是否还有新的值传出来，has_next 函数调用的时候有两种情况：</p><ol><li>已经有一个值传出来了，还没有被外部消费</li><li>还没有现成的值可以用，需要尝试恢复执行协程来看看还有没有下一个值传出来</li></ol><p>这里我们需要有一种有效的办法来判断 value 是不是有效的，单凭 value 本身我们其实是无法确定它的值是不是被消费了，因此我们需要加一个值来存储这个状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程执行完成之后，外部读取值时抛出的异常</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">bool</span> is_ready = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个成员 state 来记录协程执行的状态，状态的类型一共三种，只有 READY 的时候我们才能拿到值。</p><p>接下来改造 <code>next</code> 函数，同时增加 <code>has_next</code> 函数来描述协程是否仍然可以有值传出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程还没有执行完成，并且下一个值还没有准备好</span></span><br><span class="line">    <span class="keyword">if</span> (!handle.<span class="built_in">promise</span>().is_ready) &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="comment">// 恢复执行之后协程执行完，这时候必然没有通过 co_await 传出值来</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此时一定有值，is_ready 为 true </span></span><br><span class="line">      <span class="comment">// 消费当前的值，重置 is_ready 为 false</span></span><br><span class="line">      handle.<span class="built_in">promise</span>().is_ready = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ExhaustedException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样外部使用时就需要先通过 has_next 来判断是否有下一个值，然后再去读取了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2：协程状态的销毁比-Generator-对象的销毁更早"><a href="#问题-2：协程状态的销毁比-Generator-对象的销毁更早" class="headerlink" title="问题 2：协程状态的销毁比 Generator 对象的销毁更早"></a>问题 2：协程状态的销毁比 Generator 对象的销毁更早</h3><p>我们前面提到过，协程的状态在协程体执行完之后就会销毁，除非协程挂起在 <code>final_suspend</code> 调用时。</p><p>我们的例子当中 <code>final_suspend</code> 返回了 <code>std::suspend_never</code>，因此协程的销毁时机其实比 Generator 更早：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完，协程的状态已经销毁</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator 对象在此仍然有效</span></span><br></pre></td></tr></table></figure><p>这看上去似乎问题不大，因为我们在前面通过 <code>has_next</code> 的判断保证了读取值的安全性。</p><p>但实际上情况并非如此。我们在 <code>has_next</code> 当中调用了 <code>coroutine_handle::done</code> 来判断协程体是否执行完成，判断之前很可能协程已经销毁，<code>coroutine_handle</code> 这时候都已经是无效的了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果协程已经执行完成，理论上协程的状态已经销毁，handle 指向的是一个无效的协程</span></span><br><span class="line">  <span class="comment">// 如果 handle 本身已经无效，因此 done 函数的调用此时也是无效的</span></span><br><span class="line">  <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此为了让协程的状态的生成周期与 <code>Generator</code> 一致，我们必须将协程的销毁交给 <code>Generator</code> 来处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是挂起，让 Generator 来销毁</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="comment">// 销毁协程</span></span><br><span class="line">    handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="问题-3：复制对象导致协程被销毁"><a href="#问题-3：复制对象导致协程被销毁" class="headerlink" title="问题 3：复制对象导致协程被销毁"></a>问题 3：复制对象导致协程被销毁</h3><p>这个问题确切地说是<strong>问题 2</strong>的解决方案不完善引起的。</p><p>我们在 Generator 的析构函数当中销毁协程，这本身没有什么问题，但如果我们把 Generator 对象做一下复制，例如从一个函数当中返回，情况可能就会变得复杂。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">returns_generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> g = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">if</span> (g.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; g.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">returns_generator</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码乍一看似乎没什么问题，但由于我们把 <code>g</code> 当做返回值返回了，这时候 <code>g</code> 这个对象就发生了一次复制，然后临时对象被销毁。接下来的事儿大家就很容易想到了，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">-572662307</span><br><span class="line"></span><br><span class="line">Process finished with exit code -1073741819 (0xC0000005)</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们需要妥善地处理 Generator 的复制构造器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Generator</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;&amp;generator) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(generator.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Generator &amp;<span class="keyword">operator</span>=(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只提供了右值复制构造器，对于左值复制构造器，我们直接删除掉以禁止使用。原因也很简单，对于每一个协程实例，都有且仅能有一个 Generator 实例与之对应，因此我们只支持移动对象，而不支持复制对象。</p><h2 id="使用-co-yield"><a href="#使用-co-yield" class="headerlink" title="使用 co_yield"></a>使用 co_yield</h2><p>序列生成器这个需求的实现其实有个更好的选择，那就是使用 <code>co_yield</code>。<code>co_yield</code> 就是专门为向外传值来设计的，如果大家对其他语言的协程有了解，也一定见到过各种 <code>yield</code> 的实现。</p><p>C++ 当中的 <code>co_yield expr</code> 等价于 <code>co_await promise.yield_value(expr)</code>，我们只需要将前面例子当中的 <code>await_transform</code> 函数替换成 <code>yield_value</code> 就可以使用 <code>co_yield</code> 来传值了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 await_transform 替换为 yield_value</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      is_ready = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 co_yield 来替换 co_await</span></span><br><span class="line">    <span class="keyword">co_yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到改动点非常少，运行效果与前面的例子一致。</p><p>尽管可以实现相同的效果，但通常情况下我们使用 <code>co_await</code> 更多的关注点在挂起自己，等待别人上，而使用 <code>co_yield</code> 则是挂起自己传值出去。因此我们应该针对合适的场景做出合适的选择。</p><h2 id="使用序列生成器生成斐波那契数列"><a href="#使用序列生成器生成斐波那契数列" class="headerlink" title="使用序列生成器生成斐波那契数列"></a>使用序列生成器生成斐波那契数列</h2><p>接下来我们要使用序列生成器来实现一个更有意义的例子，即斐波那契数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">0</span>; <span class="comment">// fib(0)</span></span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">1</span>; <span class="comment">// fib(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a + b; <span class="comment">// fib(N), N &gt; 1</span></span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这个实现非常的直接，完全不需要考虑 fib(N - 1) 和 fib(N - 2) 的存储问题。</p><p>如果没有协程，我们的实现可能是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初值不符合整体的规律，需要单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">-1</span>)&#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      b = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> next = b;</span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时先构造一个 Fibonacci 对象，然后调用 next 函数来获取下一个值。对比之下，协程的实现带来的好处是显而易见的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文围绕序列生成器这个经典的协程案例介绍了协程的销毁、co_await 运算符、await_transform 以及 yield_value 的用法。</p><p>说出来你可能不信，如果这篇文章你能够完全理解，那么相信你对 C++ 协程特性的了解已经比较全面了。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序列生成器是一个非常经典的协程应用场景。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（1）：C++ 协程概览</title>
    <link href="https://www.bennyhuo.com//2022/03/09/cpp-coroutines-01-intro/"/>
    <id>https://www.bennyhuo.com//2022/03/09/cpp-coroutines-01-intro/</id>
    <published>2022-03-09T15:03:56.000Z</published>
    <updated>2023-04-24T09:38:23.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。 </p></blockquote><span id="more"></span><iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1vv4y1A7fX&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程就是一段可以<strong>挂起（suspend）</strong>和<strong>恢复（resume）</strong>的程序，一般而言，就是一个支持<strong>挂起</strong>和<strong>恢复</strong>的函数。</p><p>这么说比较抽象，我们下面看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fun 是一个非常普通的函数，大家对它的直观印象是什么呢？</p><ul><li>它有四行代码</li><li>这四行代码一行一行依次执行</li><li>这四行代码连续执行</li></ul><p>作为一个合格的程序员，我们的眼睛就是编译器，我们的脑子就是运行时。相信大家在看完这个函数的定义之后脑子里面已经不自主的把它运行过了：这个函数一旦开始，就无法暂停。</p><p>如果一个函数能够暂停，那它就可以被认为是我们开头提到的协程。所以<strong>挂起</strong>你就可以理解成暂停，<strong>恢复</strong>你就理解成从暂停的地方继续执行。</p><p>下面我们给出一段 C++ 协程的不完整的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Result 的定义我们后面再谈论，大家只需要知道 Result 是按照协程的规则定义的类型，在 C++ 当中，一个函数的返回值类型如果是符合协程的规则的类型，那么这个函数就是一个协程。</p><p>请大家留意一下这个函数体当中的 <code>co_await std::suspend_always&#123;&#125;;</code>，其中 <code>co_await</code> 是个关键字，它的出现，通常来说就会使得当前函数（协程）的执行被挂起。也就是说我们在控制台看到输出 1 以后，很可能过了很久才看到 2，这个“很久”也一般不是因为当前执行的线程被阻塞了，而是当前函数（协程）执行的位置被存起来，在将来某个时间点又读取出来继续执行的。</p><h2 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h2><p>很多读者在初次接触到协程这个概念的时候，总是会想得太过于复杂，以至于觉得<strong>挂起</strong>和<strong>恢复</strong>充满了神秘色彩而无法理解。这确实大可不必，你只要能理解听歌的时候可以暂停继续，能理解下载的时候可以断点续传，那你就必然可以理解协程的<strong>挂起</strong>和<strong>恢复</strong>。</p><p>那么问题来了，在我们现有的语言特性框架下，如何实现所谓的<strong>挂起</strong>和<strong>恢复</strong>呢？</p><p>我们以音频文件的播放为例，我们将其与协程的执行做对比，例如整个音频文件对比协程的函数体（即<strong>协程体</strong>），完整的对比见下表：</p><table><thead><tr><th>音频</th><th>协程</th></tr></thead><tbody><tr><td>音频文件</td><td>协程体</td></tr><tr><td>音频播放</td><td>协程执行</td></tr><tr><td>播放暂停</td><td>执行挂起</td></tr><tr><td>播放恢复</td><td>执行恢复</td></tr><tr><td>播放异常</td><td>执行异常</td></tr><tr><td>播放完成</td><td>协程返回</td></tr></tbody></table><p>音频暂停的时候需要记录音频暂停的位置，同时之前正在播放的音频也不会销毁（即便销毁重建，也要能够完全恢复原样）。</p><p>类似地，协程挂起时，我们需要记录函数执行的位置，C++ 协程会在开始执行时的第一步就使用 <code>operator new</code> 来开辟一块内存来存放这些信息，这块内存或者说这个对象又被称为<strong>协程的状态（coroutine state）</strong>。</p><p>协程的状态不仅会被用于存放挂起时的位置（后称为<strong>挂起点</strong>），也会在协程开始执行时存入协程体的参数值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>start_value</code> 就会被存入协程的状态当中。</p><p>需要注意的是，如果参数是值类型，他们的值或被移动或被复制（取决于类型自身的复制构造和移动构造的定义）到协程的状态当中；如果是引用、指针类型，那么存入协程的状态的值将会是引用或指针本身，而不是其指向的对象，这时候需要开发者自行保证协程在挂起后续恢复执行时参数引用或者指针指向的对象仍然存活。</p><p>与创建相对应，在协程执行完成或者被外部主动销毁之后，协程的状态也随之被销毁释放。</p><p>看到这里，大家也不必紧张，协程的状态的创建和销毁都是编译器帮我们处理好的，不需要我们显式的处理。</p><h2 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h2><p>协程的挂起是协程的灵魂。C++ 通过 <code>co_await</code> 表达式来处理协程的挂起，表达式的操作对象则为<strong>等待体（awaiter）</strong>。</p><p>等待体需要实现三个函数，这三个函数在挂起和恢复时分别调用。</p><h3 id="await-ready"><a href="#await-ready" class="headerlink" title="await_ready"></a>await_ready</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>await_ready 返回 bool 类型，如果返回 true，则表示已经就绪，无需挂起；否则表示需要挂起。</p><p>标准库当中提供了两个非常简单直接的等待体，<code>struct suspend_always</code> 表示总是挂起，<code>struct suspend_never</code> 表示总是不挂起。不难想到，这二者的功能主要就是依赖 await_ready 函数的返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_never</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true，总是不挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_always</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回 false，总是挂起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="await-suspend"><a href="#await-suspend" class="headerlink" title="await_suspend"></a>await_suspend</h3><p>await_ready 返回 false 时，协程就挂起了。这时候协程的局部变量和挂起点都会被存入协程的状态当中，await_suspend 被调用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">await_suspend</span>(std::coroutine_handle&lt;&gt; coroutine_handle);</span><br></pre></td></tr></table></figure><p>参数 coroutine_handle 用来表示当前协程，我们可以在稍后合适的时机通过调用 resume 来恢复执行当前协程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coroutine_handle.<span class="built_in">resume</span>();</span><br></pre></td></tr></table></figure><p>注意到 await_suspend 函数的返回值类型我们没有明确给出，因为它有以下几种选项：</p><ul><li>返回 void 类型或者返回 true，表示当前协程挂起之后将执行权还给当初调用或者恢复当前协程的函数。</li><li>返回 false，则恢复执行当前协程。注意此时不同于 await_ready 返回 true 的情形，此时协程已经挂起，await_suspend 返回 false 相当于挂起又立即恢复。</li><li>返回其他协程的 coroutine_handle 对象，这时候返回的 coroutine_handle 对应的协程被恢复执行。</li><li>抛出异常，此时当前协程恢复执行，并在当前协程当中抛出异常。</li></ul><p>可见，await_suspend 支持的情况非常多，也相对复杂。实际上这也是 C++ 协程当中最为核心的函数之一了。</p><h3 id="await-resume"><a href="#await-resume" class="headerlink" title="await_resume"></a>await_resume</h3><p>协程恢复执行之后，等待体的 await_resume 函数被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">await_resume</span>()；</span><br></pre></td></tr></table></figure><p>同样地，await_resume 的返回值类型也是不限定的，返回值将作为 <code>co_await</code> 表达式的返回值。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>了解了以上内容以后，我们可以自己定义一个非常简单的等待体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程挂起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 切换线程</span></span><br><span class="line">    std::<span class="built_in">async</span>([=]()&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">      <span class="comment">// sleep 1s</span></span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); </span><br><span class="line">      <span class="comment">// 恢复协程</span></span><br><span class="line">      coroutine_handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value 将作为 co_await 表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">co_await</span> Awaiter&#123;.value = <span class="number">1000</span>&#125; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">// 1 秒之后再执行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1000</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>其中 “1000” 在 “1” 输出 1 秒之后输出。</p><blockquote><p><strong>说明</strong>：co_await 后面的对象也可以不是等待体，这类情况需要定义其他的函数和运算符来转换成等待体。这个我们后面再讨论。</p></blockquote><h2 id="协程的返回值类型"><a href="#协程的返回值类型" class="headerlink" title="协程的返回值类型"></a>协程的返回值类型</h2><p>我们前面提到，区别一个函数是不是协程，是通过它的返回值类型来判断的。如果它的返回值类型满足协程的规则，那这个函数就会<strong>被编译成</strong>协程。</p><p>那么，这个<strong>协程的规则</strong>是什么呢？规则就是返回值类型能够实例化下面的模板类型 <code>_Coroutine_traits</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Coroutine_traits &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Coroutine_traits</span>&lt;_Ret, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Ret::promise_type&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> promise_type = <span class="keyword">typename</span> _Ret::promise_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_traits</span> : _Coroutine_traits&lt;_Ret&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>简单来说，就是返回值类型 <code>_Ret</code> 能够找到一个类型 <code>_Ret::promise_type</code> 与之相匹配。这个 <code>promise_type</code> 既可以是直接定义在 <code>_Ret</code> 当中的类型，也可以通过 <code>using</code> 指向已经存在的其他外部类型。</p><p>此时，我们就可以给出 <code>Result</code> 的部分实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="协程返回值对象的构建"><a href="#协程返回值对象的构建" class="headerlink" title="协程返回值对象的构建"></a>协程返回值对象的构建</h2><p>我们再看一下协程的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时你已经了解 C++ 当中如何界定一个协程。不过你可能会产生一个新的问题，返回值是从哪儿来的？协程体当中并没有给出 Result 对象创建的代码。</p><p>实际上，Result 对象的创建是由 promise_type 负责的，我们需要定义一个 <code>get_return_object</code> 函数来处理对 Result 对象的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建 Result 对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同于一般的函数，协程的返回值并不是在返回之前才创建，而是在协程的状态创建出来之后马上就创建的。也就是说，协程的状态被创建出来之后，会立即构造 <code>promise_type</code> 对象，进而调用 <code>get_return_object</code> 来创建返回值对象。</p><p><code>promise_type</code> 类型的构造函数参数列表如果与协程的参数列表一致，那么构造 <code>promise_type</code> 时就会调用这个构造函数。否则，就通过默认无参构造函数来构造 <code>promise_type</code>。</p><h2 id="协程体的执行"><a href="#协程体的执行" class="headerlink" title="协程体的执行"></a>协程体的执行</h2><p>在协程的返回值被创建之后，协程体就要被执行了。</p><h3 id="initial-suspend"><a href="#initial-suspend" class="headerlink" title="initial_suspend"></a>initial_suspend</h3><p>为了方便灵活扩展，协程体执行的第一步是调用 <code>co_await promise.initial_suspend()</code>，<code>initial_suspend</code> 的返回值就是一个等待对象（awaiter），如果返回值满足挂起的条件，则协程体在最一开始就立即挂起。这个点实际上非常重要，我们可以通过控制 initial_suspend 返回的等待体来实现协程的执行调度。有关调度的内容我们后面会专门探讨。</p><h3 id="协程体的执行-1"><a href="#协程体的执行-1" class="headerlink" title="协程体的执行"></a>协程体的执行</h3><p>接下来执行协程体。</p><p>协程体当中会存在 co_await、co_yield、co_return 三种协程特有的调用，其中</p><ul><li>co_await 我们前面已经介绍过，用来将协程挂起。</li><li>co_yield 则是 co_await 的一个马甲，用于传值给协程的调用者或恢复者或被恢复者，我们后面会专门用一篇文章给出例子介绍它的用法。</li><li>co_return 则用来返回一个值或者从协程体返回。</li></ul><h4 id="协程体的返回值"><a href="#协程体的返回值" class="headerlink" title="协程体的返回值"></a>协程体的返回值</h4><p>对于返回一个值的情况，需要在 promise_type 当中定义一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??? <span class="built_in">return_value</span>();</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，我们的 Coroutine 函数就需要使用 co_return 来返回一个整数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1000 会作为参数传入，即 return_value 函数的参数 value 的值为 1000。</p><p>这时候读者可能会疑惑，这个值好像没什么用啊？大家别急，这个值可以存到 promise_type 对象当中，外部的调用者可以获取到。</p><h4 id="协程体返回-void"><a href="#协程体返回-void" class="headerlink" title="协程体返回 void"></a>协程体返回 void</h4><p>除了返回值的情况以外，C++ 协程当然也支持返回 void。只不过 promise_type 要定义的函数就不再是 return_value 了，而是 return_void 了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时，协程内部就可以通过 co_return 来退出协程体了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="协程体抛出异常"><a href="#协程体抛出异常" class="headerlink" title="协程体抛出异常"></a>协程体抛出异常</h4><p>协程体除了正常返回以外，也可以抛出异常。异常实际上也是一种结果的类型，因此处理方式也与返回结果相似。我们只需要在 promise_type 当中定义一个函数，在异常抛出时这个函数就会被调用到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      exception_ = std::<span class="built_in">current_exception</span>(); <span class="comment">// 获取当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="final-suspend"><a href="#final-suspend" class="headerlink" title="final_suspend"></a>final_suspend</h3><p>当协程执行完成或者抛出异常之后会先清理局部变量，接着调用 final_suspend 来方便开发者自行处理其他资源的销毁逻辑。final_suspend 也可以返回一个等待体使得当前协程挂起，但之后当前协程应当通过 coroutine_handle 的 destroy 函数来直接销毁，而不是 resume。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们介绍了一些 C++ 协程的各种概念和约定，看似介绍了非常多的内容，但因为示例较少又感觉什么都没介绍。大家不要着急，C++ 协程的概念基本上就这么多，剩下的文章我们都将基于一个或多个具体的场景展开来介绍如何运用 C++ 协程来解决问题。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>渡劫 C++ 协程（0）：前言</title>
    <link href="https://www.bennyhuo.com//2022/03/06/cpp-coroutines-00-foreword/"/>
    <id>https://www.bennyhuo.com//2022/03/06/cpp-coroutines-00-foreword/</id>
    <published>2022-03-06T21:03:17.000Z</published>
    <updated>2023-04-17T07:37:39.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li><li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li><li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li><li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li><li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li><li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li><li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li></ul><p>C++ 20 标准发布之后，协程终于正式成为 C++ 特性当中的一员。</p><p>作为一门本身极其复杂的语言，C++ 秉承着不劝退不开心的原则，将协程的 API 设计得非常复杂。以至于有开发者甚至发出了“这玩意根本就不是给人用的”这样的感叹。</p><p>等等，我们是不是搞错了，C++ 协程的 API 确实不是设计给业务开发者直接使用的。实际上，标准当中给出的 API 足够的灵活，也足够的基础，框架的开发者可以基于这些 API 将过去异步的函数改造成协程风格的版本。</p><p>没错，这就是 C++。</p><p>一门不造轮子就让人不舒服的语言，它总是在用它自己的方式逼着开发者进步。为了帮助大家认识和了解 C++ 协程的设计思路以及基本用法，我计划写几篇文章来介绍一下 C++ 协程的相关特性。</p><p>本人 C++ 水平有限，文章内容的安排将尽可能以介绍特性为主，涉及到的框架实现不建议在生产环境当中直接使用。</p><p>另外，为了方便读者阅读和实验，文章涉及到的所有源码均已上传于 <a href="https://github.com/bennyhuo/CppCoroutines">GitHub: bennyhuo/CppCoroutines</a>。</p><p>相信大家读完这一系列文章之后，也还是不一定会 C++ 协程 ：）</p><blockquote><p><strong>说明</strong>：C++ 23 有望基于协程提供不少有用的支持，例如与异步任务密不可分的 executor、network 等等，不过这些内容我暂时不会在后面的文章当中涉及，等 C++ 23 正式发布之后再做补充。</p></blockquote><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.bennyhuo.com/tags/c/"/>
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（9）：异步函数与其他语言的互调用</title>
    <link href="https://www.bennyhuo.com//2022/02/16/swift-coroutines-09-interop/"/>
    <id>https://www.bennyhuo.com//2022/02/16/swift-coroutines-09-interop/</id>
    <published>2022-02-16T23:02:59.000Z</published>
    <updated>2023-04-17T07:37:39.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在很多 iOS APP 还是用 Objective-C 写的，异步函数在 Objective-C 当中怎么调用也是个问题。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="从异步回调到异步函数"><a href="#从异步回调到异步函数" class="headerlink" title="从异步回调到异步函数"></a>从异步回调到异步函数</h2><p>截止目前，我们已经详细探讨了 Swift 协程当中的绝大多数语法设计，这其中最基本也是最重要的就是异步函数。</p><p>在异步函数出现之前，我们通常会为函数添加回调来实现异步结果返回，以 Swift 的网络请求库 Alamofire 为例，它的 DataRequest 有这样一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">responseData</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods,</span><br><span class="line">  <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Data</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有很多参数，不过我们只需要关心最后一个：completionHandler，它是一个闭包，接收一个参数为 <code>AFDataResponse&lt;Data&gt;</code> 的类型作为请求结果。</p><p>从 Swift 5.5 开始，我们可以将其包装成异步函数，添加对结果的异步返回、异常的传播以及对取消响应的支持：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">responseDataAsync</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods</span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            responseData(</span><br><span class="line">                queue: queue,</span><br><span class="line">                dataPreprocessor: dataPreprocessor,</span><br><span class="line">                emptyResponseCodes: emptyResponseCodes, emptyRequestMethods: emptyRequestMethods</span><br><span class="line">            ) &#123; response <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> data): continuation.resume(returning: data)</span><br><span class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> error): continuation.resume(throwing: error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; onCancel: &#123;</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从异步回调到异步函数总是要经过这样一个包装的过程，这个过程实际上并不轻松。因此我们也更希望第三方开发者在提供异步回调的时候同时提供异步函数的版本来方便我们按需使用。</p><h2 id="Objective-C-的异步回调"><a href="#Objective-C-的异步回调" class="headerlink" title="Objective-C 的异步回调"></a>Objective-C 的异步回调</h2><h3 id="Objective-C-回调函数的自动转换"><a href="#Objective-C-回调函数的自动转换" class="headerlink" title="Objective-C 回调函数的自动转换"></a>Objective-C 回调函数的自动转换</h3><p>在以前的 iOS SDK 当中，接收形如 completionHandler 这样的回调的 Objective-C 函数有 1000 多个。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)signData:(NSData *)signData </span><br><span class="line">withSecureElementPass:(PKSecureElementPass *)secureElementPass </span><br><span class="line">      completion:(void (^)(NSData *signedData, NSData *signature, NSError *error))completion;</span><br></pre></td></tr></table></figure><p>这个函数相当于 Swift 的如下函数声明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, </span><br><span class="line">    <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>, </span><br><span class="line"><span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">Data</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure><p>如果我们对这些函数一个一个完成包装，那必然会耗费大量的时间和精力。因此，Swift 对接收类似的回调并符合一定条件的 Objective-C 函数自动做了一些转换，以上述 signData 函数为例，可以被自动转换为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">Data</span>)</span><br></pre></td></tr></table></figure><p>我们来简单分析一下这个转换过程。</p><ol><li>参数 completion 被移除了。 completion 的类型是 Objective-C 的 block，可以用来处理异步结果的返回。</li><li>转换后的异步函数的返回值 (Data, Data)，它实际上对应于 completion 除 <code>NSError *</code> 之外的两个参数。需要注意的是，回调当中的 signedData 和 signature 的类型均为 <code>NSData *</code>，它们实际上是可以为 nil 的，单纯考虑类型的映射，它们应该映射成 Swift 的 <code>Data?</code> 类型，而在转换之后的异步函数当中则为 <code>Data</code> 类型，这是因为逻辑上如果这俩个 <code>Data</code> 返回 nil，则应该通过参数 <code>NSError *</code> 来使得异步函数抛出异常。这个细节一定要注意。</li><li>completion 的参数 <code>NSError *</code> 表示结果有可能会出现异常，因此转换后的异步函数是会抛出异常的，声明为 throws。</li></ol><p>那这个转换需要符合什么条件呢？</p><ul><li>函数本身和参数回调的返回值均为 void</li><li>回调只能被调用一次</li><li>函数被显式地用 swift_async 修饰或者隐式地通过参数名来推导，其中支持推导的情况包括：<ul><li>函数只有一个参数且它的标签为 WithCompletion、WithCompletionHandler、WithCompletionBlock、WithReplyTo、WithReply。</li><li>函数有多个参数，且最后一个是回调，并且它的标签为 completion，withCompletion，completionHandler，withCompletionHandler，completionBlock，withCompletionBlock，replyTo，withReplyTo，reply 或者 replyTo。</li><li>函数有多个参数，且最后一个参数的标签以一个参数的情况当中列出的标签结尾，最后一个参数是回调。</li></ul></li></ul><p>我们再给一个例子，请大家注意它的函数名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)getUserAsync:(NSString *)name completion:(void (^)(User *, NSError *))completion;</span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">userAsync</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">String</span>!) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">User</span>?</span><br></pre></td></tr></table></figure><p>对于以 get 开头的 Objective-C 函数，转换之后函数名当中的 get 被去除了。除此之外其他规则与前面提到的一致。</p><p>有了这个转换，很多旧 SDK 当中的 Objective-C 回调函数都可以当成 Swift 的异步函数来调用，可以极大的简化我们的开发流程。</p><h3 id="在-Objective-C-当中调用-Swift-的异步函数"><a href="#在-Objective-C-当中调用-Swift-的异步函数" class="headerlink" title="在 Objective-C 当中调用 Swift 的异步函数"></a>在 Objective-C 当中调用 Swift 的异步函数</h3><p>相反地，如果我们定义了 Swift 的异步函数，并且希望在 Objective-C 当中调用，则可以声明成 @objc 异步函数，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">class</span> <span class="title class_">GitHubApiAsync</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">listFollowers</span>(<span class="params">for</span> <span class="params">userName</span>: <span class="type">String</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AF</span>.request(<span class="string">&quot;<span class="subst">\(GITHUB_API_ENDPOINT)</span>/users/<span class="subst">\(userName)</span>/followers&quot;</span>).responseDecodableAsync()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GitHubApiAsync 类当中的 listFollowers 函数相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface GitHubApiAsync : NSObject</span><br><span class="line">+ (void)listFollowersFor:(NSString * _Nonnull)userName completionHandler:(void (^ _Nonnull)(NSArray&lt;User *&gt; * _Nullable, NSError * _Nullable))completionHandler;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="调用-Kotlin-的挂起函数（suspend-function）"><a href="#调用-Kotlin-的挂起函数（suspend-function）" class="headerlink" title="调用 Kotlin 的挂起函数（suspend function）"></a>调用 Kotlin 的挂起函数（suspend function）</h2><p>了解了 Swift 的异步函数如何与 Objective-C 互调用的细节之后，再来看一下 Kotlin 的挂起函数是如何支持被 Swift 调用的。当然这个特性还在实验当中，后续也可能会发生变化。</p><h3 id="支持-Objective-C-回调"><a href="#支持-Objective-C-回调" class="headerlink" title="支持 Objective-C 回调"></a>支持 Objective-C 回调</h3><p>Kotlin 1.4 开始引入了挂起函数对 Swift 的支持，支持的方式就是讲挂起函数转成回调，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greeting</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后会生成 Objective-C 头文件，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">__attribute__((swift_name(&quot;Greeting&quot;)))</span><br><span class="line">@interface SharedGreeting : SharedBase</span><br><span class="line">...</span><br><span class="line">- (NSString *)greeting __attribute__((swift_name(&quot;greeting()&quot;)));</span><br><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><p>生成的类名为 <code>SharedGreeting</code>，其中 Shared 是模块名。<code>__attribute__((swift_name(&quot;Greeting&quot;)))</code> 使得这个 Objective-C 类映射到 Swift 当中的名字是 <code>Greeting</code>。</p><p>我们重点关注一下 greetingAsync 函数，它映射成了下面的回调形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure><h3 id="支持-Swift-异步函数"><a href="#支持-Swift-异步函数" class="headerlink" title="支持 Swift 异步函数"></a>支持 Swift 异步函数</h3><p>Kotlin 挂起函数对于 Objective-C 回调的支持，正好命中了前面讨论的回调自动转换成 Swift 异步函数的条件，因此理论上在 Swift 5.5 当中，我们也可以直接把 Kotlin 的挂起函数当成 Swift 的异步函数去调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里还有一些细节的问题。Kotlin 1.5.30 当中也对此做了一点点跟进，在生成的 Objective-C 头文件当中添加了对 <code>_Nullable_result</code> 的支持，这使得 Kotlin 的挂起函数在返回可空类型时，能够正确被转化成返回 optional 类型的 Swift 异步函数，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun greetingAsyncNullable(): <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, $&#123;Platform().platform&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个例子的返回值类型声明为 <code>String?</code>，生成的 Objective-C 函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)greetingAsyncNullableWithCompletionHandler:(void (^)(NSString * _Nullable_result, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsyncNullable(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure><p>仔细对比与 greetingAsync 的差异不难发现，返回值的类型在 greetingAsyncNullable 当中被映射成了 <code>NSString * _Nullable_result</code>，而在 greetingAsync 当中则映射成了 <code>NSString * _Nullable</code>。这就不得不提一下 <code>_Nullable_result</code> 与 <code>_Nullable</code> 的差异了，前者可以令转化之后的 Swift 异步函数返回 optional 类型（对应于 Kotlin 的可空类型，nullable type），而后者则返回非 optional 类型（对应于 Kotlin 的不可空类型，nonnull type）。</p><h3 id="Kotlin-挂起函数的异常传播"><a href="#Kotlin-挂起函数的异常传播" class="headerlink" title="Kotlin 挂起函数的异常传播"></a>Kotlin 挂起函数的异常传播</h3><p>如果 Kotlin 的挂起函数没有声明为 <code>@Throws</code>，则只有 <code>CancellationException</code> 会被转换为 <code>NSError</code> 抛到 Swift 当中，其他的都会作为严重错误使程序退出，因此如果需要暴露给 Swift 调用，我们通常建议对于可能有异常抛出的 Kotlin 函数添加 <code>@Throws</code> 注解，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;error from Kotlin&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在 Swift 调用时也可以直接捕获到这个异常：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swift</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync())</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=KotlinException Code=0 &quot;error from Kotlin&quot; UserInfo=&#123;NSLocalizedDescription=error from Kotlin, KotlinException=kotlin.IllegalArgumentException: error from Kotlin, KotlinExceptionOrigin=&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文零传递"><a href="#上下文零传递" class="headerlink" title="上下文零传递"></a>上下文零传递</h3><p>尽管目前 Kotlin 的挂起函数可以被当做 Swift 的异步函数去调用，但 Kotlin 侧仍没有专门仔细地针对 Swift 异步函数调用的场景进行专门的设计和定制。因此像 Swift 侧的取消状态（在 Kotlin 挂起函数中获取 Swift 的 Task 的取消状态）、调度器（Swift 的 actor 以及与 Task 绑定的调度器）、TaskLocal 变量以及 Kotlin 侧挂起函数执行时的调度器、协程上下文等状态都是没有实现传递的。</p><p>基于这一点，大家在使用过程中应当尽可能将函数的设计进行简化，避免场景过于复杂而引发令人难以理解的问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们探讨了 Swift 协程当中的异步函数（async function）与 Objective-C 的互调用问题，其中介绍了 Objective-C 回调自动映射成 Swift 异步函数的条件和细节，以及 Kotlin 挂起函数对 Swift 异步函数的支持。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在很多 iOS APP 还是用 Objective-C 写的，异步函数在 Objective-C 当中怎么调用也是个问题。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（8）：TaskLocal</title>
    <link href="https://www.bennyhuo.com//2022/02/12/swift-coroutines-08-tasklocal/"/>
    <id>https://www.bennyhuo.com//2022/02/12/swift-coroutines-08-tasklocal/</id>
    <published>2022-02-12T21:02:24.000Z</published>
    <updated>2023-04-17T07:37:39.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果我想要定义一个变量，它的值只在 Task 内部共享，怎么做到呢？ </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="TaskLocal-值的定义和使用"><a href="#TaskLocal-值的定义和使用" class="headerlink" title="TaskLocal 值的定义和使用"></a>TaskLocal 值的定义和使用</h2><p>TaskLocal 值就是 Task 私有的值，不同的 Task 对于这个变量的访问将得到不同的结果。</p><p>下面我们给出示例演示如何定义一个 TaskLocal 值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskLocal 值必须定义为静态的存储属性，并使用 TaskLocal 这个属性包装器（property wrapper）来包装。TaskLocal 值也受限于属性包装器的支持范围，不能定义为顶级属性。</p><p>变量 tag 的初始值为 <code>default</code>，属性包装器 TaskLocal 的构造器会接收这个值并存起来备用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> defaultValue: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">defaultValue</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.defaultValue <span class="operator">=</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解属性包装器的读者应该也能想到初始值的定义还可以写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span>(wrappedValue: <span class="string">&quot;default&quot;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察 TaskLocal 的定义，我们也发现它对于被包装的类型是有要求的，即要实现 Sendable 协议。</p><blockquote><p>有关 Swift 属性包装器的介绍，可以参考我之前的一篇文章：<a href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/">Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</a>。</p></blockquote><p>了解了定义之后，接下来看用法。</p><p>首先要写入值，我们只需要调用属性包装器的 withValue 函数，它的声明如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, </span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>, </span><br><span class="line">    <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, </span><br><span class="line">    <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span></span><br></pre></td></tr></table></figure><p>调用示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in my task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $tag 就是 tag 的属性包装器的 projectedValue，这个值正是 TaskLocal 这个属性包装器对象本身。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">TaskLocal</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withValue 有两个参数，一个是要绑定给 tag 的值，即 <code>MyTask</code>；另一个就是一个闭包，这个绑定的值只有在这个闭包当中有效，一旦闭包执行结束，tag 绑定的值的生命周期也就结束了。</p><p>接下来我们尝试去读取它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">logWithTag</span>(<span class="keyword">_</span> <span class="params">message</span>: <span class="keyword">Any</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(Logger.tag)</span>): <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取的方式就显得普通而又枯燥了。写法非常直接，不过大家要明白，这个读的行为实际上是通过 TaskLocal 属性包装器完成的。</p><p>作为对比，我们给出一个稍微完整的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in withValue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> logWithTag(<span class="string">&quot;out of withValue&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="keyword">in</span> withValue</span><br><span class="line">(<span class="keyword">default</span>): out of withValue</span><br></pre></td></tr></table></figure><h2 id="Task-对于-TaskLocal-的继承"><a href="#Task-对于-TaskLocal-的继承" class="headerlink" title="Task 对于 TaskLocal 的继承"></a>Task 对于 TaskLocal 的继承</h2><p>上一篇文章当中我们通过示例演示了 <code>init</code> 和 <code>detach</code> 构造的 Task 实例对 actor 上下文的继承，这次我们给大家再演示一下对 TaskLocal 的继承，以进一步加深大家的理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.init&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.detached &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.detached&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子相比之前的调度器的例子就更显得普通而又枯燥了，程序输出如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="type">Task</span>.<span class="keyword">init</span></span><br><span class="line">(<span class="keyword">default</span>): <span class="type">Task</span>.detached</span><br></pre></td></tr></table></figure><p>可以看到，通过 <code>detached</code> 创建的 Task 实例可谓是“六亲不认”，不仅不继承 actor 的上下文，也对 TaskLocal 不管不顾。另外不难想到的是，Swift 并没有提供修改外部 TaskLocal 值的 API，因此外部的 TaskLocal 值只能被继承，不能被修改。</p><h2 id="深入探查-TaskLocal-的存储方式"><a href="#深入探查-TaskLocal-的存储方式" class="headerlink" title="深入探查 TaskLocal 的存储方式"></a>深入探查 TaskLocal 的存储方式</h2><p>TaskLocal 值虽然看起来就是个静态存储属性，但它的值实际上是存储在 Task 相关的内存当中的。它的读写性能自然也与它的存储方式有关，因此为了确保能够正确合理的使用 TaskLocal，我们有必要了解一下它究竟是如何存储的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个变量唯一，用于查找值的 key</span></span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">Builtin</span>.<span class="type">RawPointer</span> &#123;</span><br><span class="line">    <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, to: <span class="type">Builtin</span>.<span class="type">RawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 TaskLocal 值的值时调用该函数</span></span><br><span class="line">  <span class="comment">// 通过 _taskLocalValueGet 到 Task 实例当中查找对应的值</span></span><br><span class="line">  <span class="comment">// 如果没有找到，则返回 defaultValue，即初始值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">get</span>() -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> rawValue <span class="operator">=</span> _taskLocalValueGet(key: key) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.defaultValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> storagePtr <span class="operator">=</span></span><br><span class="line">        rawValue.bindMemory(to: <span class="type">Value</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Value</span>&gt;(mutating: storagePtr).pointee</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(<span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>,</span><br><span class="line">                           <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span>) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入值</span></span><br><span class="line">    _taskLocalValuePush(key: key, value: valueDuringOperation)</span><br><span class="line">    <span class="keyword">defer</span> &#123; </span><br><span class="line">        <span class="comment">// 确保在 withValue 退出的时候将值释放掉</span></span><br><span class="line">        _taskLocalValuePop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> operation()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们注意到有几个关键的函数，它们的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePush&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePush</span>&lt;<span class="type">Value</span>&gt;(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*: Key*/</span>,</span><br><span class="line">  <span class="params">value</span>: __owned <span class="type">Value</span></span><br><span class="line">) <span class="comment">// where Key: TaskLocal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePop&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePop</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValueGet&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValueGet</span>(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*Key*/</span></span><br><span class="line">) -&gt; <span class="type">UnsafeMutableRawPointer</span>? <span class="comment">// where Key: TaskLocal</span></span><br></pre></td></tr></table></figure><p>通过 _silgen_name 的值，我们可以找到他们在 C++ 当中的定义，以 <code>_taskLocalValueGet</code> 为例，我们给出 <code>swift_task_localValueGet</code> 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SWIFT_CC</span>(swift)</span><br><span class="line"><span class="function"><span class="type">static</span> OpaqueValue* <span class="title">swift_task_localValueGetImpl</span><span class="params">(<span class="type">const</span> HeapObject *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (AsyncTask *task = <span class="built_in">swift_task_getCurrent</span>()) &#123;</span><br><span class="line">    <span class="comment">// 从当前 Task 的本地存储当中读取值，AsyncTask 实际上就是 C++ 层当中 Task 对应的类型</span></span><br><span class="line">    <span class="keyword">return</span> task-&gt;<span class="built_in">localValueGet</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncTask::localValueGet</code> 本质上调用的就是 <code>TaskLocal::Storage::getValue(AsyncTask *,const HeapObject *)</code>，我们同样可以找到它的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OpaqueValue* TaskLocal::Storage::<span class="built_in">getValue</span>(AsyncTask *task,</span><br><span class="line">                                          <span class="type">const</span> HeapObject *key) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(key &amp;&amp; <span class="string">&quot;TaskLocal key must not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> item = head;</span><br><span class="line">  <span class="comment">// 遍历以 head 为头节点的链表</span></span><br><span class="line">  <span class="keyword">while</span> (item) &#123;</span><br><span class="line">    <span class="comment">// 比较 key，直到找到对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;key == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> item-&gt;<span class="built_in">getStoragePtr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = item-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，查找过程其实就是链表的遍历查找，时间复杂度为 O(n)。</p><p>我们再稍微观察一下插入和删除的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> TaskLocal::Storage::<span class="built_in">pushValue</span>(AsyncTask *task,</span><br><span class="line">                                   <span class="type">const</span> HeapObject *key,</span><br><span class="line">                                   <span class="comment">/* +1 */</span> OpaqueValue *value,</span><br><span class="line">                                   <span class="type">const</span> Metadata *valueType) &#123;</span><br><span class="line">  <span class="keyword">auto</span> item = Item::<span class="built_in">createLink</span>(task, key, valueType);</span><br><span class="line">  valueType-&gt;<span class="built_in">vw_initializeWithTake</span>(item-&gt;<span class="built_in">getStoragePtr</span>(), value);</span><br><span class="line">  head = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> TaskLocal::Storage::<span class="built_in">popValue</span>(AsyncTask *task) &#123;</span><br><span class="line">  <span class="keyword">auto</span> old = head;</span><br><span class="line">  head = head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  old-&gt;<span class="built_in">destroy</span>(task);</span><br><span class="line">  <span class="keyword">return</span> head != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现这实际上就是一个采用头插法的单链表。为什么选择这样的设计呢？</p><p>显然，绝大多数情况下 TaskLocal 值的数量都不会很多，同时插入的值只在 withValue 函数范围内有效也使得绝大多数查找的值都排在链表前面，因此线性查找的效率并不会存在性能问题。</p><p>而链表的结构也使得增删节点非常容易，使用头插法使得 withValue 函数退出时释放销毁对应的值也变得非常容易，时间复杂度只需要 O(1)。</p><p>另外，使用单链表来存储 TaskLocal 值还有一个好处，那就是变量遮蔽，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task1&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task3&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> logWithTag(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;22&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Task1</span>): <span class="number">1</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">2</span></span><br><span class="line">(<span class="type">Task3</span>): <span class="number">3</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">22</span></span><br><span class="line">(<span class="type">Task1</span>): <span class="number">11</span></span><br></pre></td></tr></table></figure><p>简单总结一下，TaskLocal 值是存在链表当中的，我们在使用过程中应当避免使用过多的 TaskLocal 值，也应该适当地减少对 TaskLocal 值的访问次数，以避免性能上最坏的情况出现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对 TaskLocal 值的使用和实现机制做了剖析。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果我想要定义一个变量，它的值只在 Task 内部共享，怎么做到呢？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</title>
    <link href="https://www.bennyhuo.com//2022/02/12/swift-coroutines-07-globalactor/"/>
    <id>https://www.bennyhuo.com//2022/02/12/swift-coroutines-07-globalactor/</id>
    <published>2022-02-12T07:02:30.000Z</published>
    <updated>2023-04-17T07:37:39.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们已经知道可以使用 actor 来确保数据的线程安全，但对于数据的保护总是需要定义专门的 actor 实例是不是太麻烦了一些？ </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="什么是-GlobalActor"><a href="#什么是-GlobalActor" class="headerlink" title="什么是 GlobalActor"></a>什么是 GlobalActor</h2><p>前面我们为了保护特定的状态，就把这些状态包装到一个特定的 actor 实例当中，保护的方式就是将对于这些状态的访问调度到相应的 actor 的调度器当中串行执行。</p><p>那么问题来了，如果我有很多分散到不同类甚至不同模块的状态，希望统一调度，该怎么办？最典型的例子就是将 UI 操作调度到主线程，UI 本身就分散在不同的组件当中，对于 UI 的操作更是如此。为了应对这种场景，Swift 在提供了 actor 的基础上又进一步提供了 GlobalActor，旨在提供全局统一的执行调度。</p><p>GlobalActor 是一个协议，我们来看一下它的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ActorType</span> : _Concurrency.<span class="type">Actor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="keyword">Self</span>.<span class="type">ActorType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sharedUnownedExecutor: _Concurrency.<span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ActorType</code> 是实现 <code>GlobalActor</code> 协议的类型需要提供的全局唯一的 actor 的类型</li><li><code>shared</code> 是上述全局唯一的 actor 的实例</li><li><code>sharedUnownedExecutor</code> 是上述全局唯一的 actor 实例的调度器，它的值要求与 <code>shared.unownedExecutor</code> 一致</li></ul><p>所以只要确定了 <code>shared</code> 是谁，那么这个 <code>GlobalActor</code> 也就确定了。</p><p>此外，一个类型在实现 <code>GlobalActor</code> 时，我们还可以用 <code>@globalActor</code> 来修饰它，这样我们就可以用这个实现类去修饰需要使用该 <code>GlobalActor</code> 的实现类来隔离的函数或者属性了。这么说比较抽象，我们接下来看看官方目前提供的唯一一个 <code>GlobalActor</code> 实现是怎么定义的。</p><h2 id="探索-MainActor"><a href="#探索-MainActor" class="headerlink" title="探索 MainActor"></a>探索 MainActor</h2><p><code>MainActor</code> 是目前唯一一个 <code>GlobalActor</code> 的实现，它用来将对属性或者函数的访问隔离到主线程上执行。我们来看看它的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@globalActor</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">actor</span> <span class="title class_">MainActor</span>: <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">MainActor</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@inlinable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">nonisolated</span> <span class="keyword">var</span> unownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnownedSerialExecutor</span>(<span class="type">Builtin</span>.buildMainActorExecutorRef())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@inlinable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> sharedUnownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnownedSerialExecutor</span>(<span class="type">Builtin</span>.buildMainActorExecutorRef())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 <code>MainActor</code> 是一个 actor 类型，这对于 <code>GlobalActor</code> 协议来说不是必须的，我们完全可以定义一个 class 来实现 <code>GlobalActor</code>，并且把一个 actor 类型关联到 <code>GlobalActor</code> 上即可。当然，如果条件允许，直接用 actor 类型来实现 <code>GlobalActor</code> 自然更方便一些。</p><p>我们在前面提到过，<code>sharedUnownedExecutor</code> 要与 <code>shared.unownedExecutor</code> 一致，这里很显然二者本质上都是 <code>Builtin.buildMainActorExecutorRef()</code>。</p><p>此外，<code>MainActor</code> 被 <code>@globalActor</code> 修饰之后，自己就可以被用于修饰属性、函数或者类型，我们给出几个简单的 <code>MainActor</code> 的例子：</p><p>修饰属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@MainActor</span> <span class="keyword">var</span> value: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMain</span>() &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMain</span>(<span class="params">block</span>: <span class="meta">@MainActor</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMain before&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMain after&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UiState</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">value</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被 <code>@MainActor</code> 修饰的函数在调用时，如果当前不在主线程，则必须异步调度到主线程上执行；同样地，被修饰的属性在被其他线程访问时，也必须异步调度到主线程上处理。</p><p>被 <code>@MainActor</code> 修饰的类的构造器、属性、函数都需要调度到主线程上执行。需要注意的是，为了保证继承的一致性，被修饰的类需要满足或没有父类、或同样被 <code>@MainActor</code> 修饰、或父类是 <code>NSObject</code>；被修饰的类的子类也将会隐式获得 <code>@MainActor</code> 上的状态隔离。</p><p>这里的异步访问逻辑实际上与 actor 类型的状态和函数的关系相同，即被 <code>@MainActor</code> 修饰的函数内部访问同样被 <code>@MainActor</code> 修饰的属性时则不需要异步执行，就好像它们都被定义到 <code>MainActor</code> 这个 actor 类型当中一样。</p><p>以上使用方法和细节同样适用于其他 <code>GlobalActor</code> 的实现。</p><h2 id="自定义-GlobalActor-的实现"><a href="#自定义-GlobalActor-的实现" class="headerlink" title="自定义 GlobalActor 的实现"></a>自定义 GlobalActor 的实现</h2><p>了解了 <code>MainActor</code> 的定义之后，我们就可以试着给出自定义的 <code>GlobalActor</code> 实现了，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@globalActor</span> <span class="keyword">actor</span> <span class="title class_">MyActor</span>: <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 协议当中的 associatedtype</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ActorType</span> <span class="operator">=</span> <span class="type">MyActor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 当中的 shared，返回一个全局共享的 MyActor 实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared: <span class="type">MyActor</span> <span class="operator">=</span> <span class="type">MyActor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> _sharedExecutor <span class="operator">=</span> <span class="type">MyExecutor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 当中的 sharedUnownedExecutor，返回自己的调度器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedUnownedExecutor: <span class="type">UnownedSerialExecutor</span> <span class="operator">=</span> _sharedExecutor.asUnownedSerialExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示实现 Actor 协议当中的调度器，避免让编译器自动生成</span></span><br><span class="line">    <span class="keyword">let</span> unownedExecutor: <span class="type">UnownedSerialExecutor</span> <span class="operator">=</span> sharedUnownedExecutor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中自定义的调度器 <code>MyExecutor</code> 的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyExecutor</span> : <span class="title class_">SerialExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义 DispatchQueue，用于真正地调度异步函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> dispatcher: <span class="type">DispatchQueue</span> <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;MyActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调度时，Swift 的协程运行时会创建一个 UnownedJob 实例调用 enqueue 进行调度</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">job</span>: <span class="type">UnownedJob</span>) &#123;</span><br><span class="line">        log(<span class="string">&quot;enqueue&quot;</span>)</span><br><span class="line">        <span class="type">MyExecutor</span>.dispatcher.async &#123;</span><br><span class="line">            <span class="comment">// 执行这个 job</span></span><br><span class="line">            job._runSynchronously(on: <span class="keyword">self</span>.asUnownedSerialExecutor())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 unowned 引用，得到 UnownedSerialExecutor 实例</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asUnownedSerialExecutor</span>() -&gt; <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">        <span class="type">UnownedSerialExecutor</span>(ordinary: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以简单阅读代码的注释来了解他们的作用。注意到 <code>MyActor</code> 也实现了 <code>GlobalActor</code> 协议，我们也使用 <code>@globalActor</code> 来修饰 <code>MyActor</code>，这样我们就可以用 <code>@MyActor</code> 像 <code>@MainActor</code> 那样去修饰函数、属性和类，并让它调度到我们自己实现的调度器上了。</p><p>有关 <code>MyActor</code> 的使用示例，我们将在下一节进一步讨论。</p><blockquote><p><strong>注意</strong> 截至本文撰写时，Swift 的最新版本为 5.5.1。当前 Swift 协程对于自定义调度器的支持还在提案阶段，细节可参见：<a href="https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md">Custom Executors</a>。</p></blockquote><h2 id="深入探讨-Actor-与协程的调度"><a href="#深入探讨-Actor-与协程的调度" class="headerlink" title="深入探讨 Actor 与协程的调度"></a>深入探讨 Actor 与协程的调度</h2><p>Swift 的协程在执行调度问题上目前还比较含蓄，文档当中很少提及异步函数的执行以及异步函数返回时如何恢复。实际上，异步函数所在的调用位置会关联一个调度器，这个调度器要么来自于所在的 Task，要么来自于当前函数所属于的 actor 实例。</p><p>Swift 定义了两个默认的调度器，一个是并发的，一个是串行的；另外就是我们前面提到的，用于将异步函数调度到主线程上的主线程的调度器。</p><p>为了搞清楚 Swift 协程究竟是如何调度的，我们用 <code>MainActor</code> 和自定义的 <code>MyActor</code> 来调度我们的异步函数，看看有什么新发现。</p><p>在下面的例子当中，我们使用 @MainActor 修饰函数 calledOnMain：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMain</span>() &#123;</span><br><span class="line">    log(<span class="string">&quot;onMain&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建一个 Task 来调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> calledOnMain()</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用 log 这个定义的函数来打印输出，它与 print 的不同之处在于它会同时打印当前线程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x6000015c41c0</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x6000015c4080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] onMain</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x6000015c41c0</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure><p>可以看到，calledOnMain 被调度到了 MainThread 上执行。task start 和 task end 执行所在的线程相同（当然也可以不同，但一定是相同的调度器所属的线程），这说明 calledOnMain 返回之后 Task 又被调度与之关联的调度器上执行。</p><p>@MainActor 也可以被用于修饰闭包的类型，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMain</span>(<span class="params">block</span>: <span class="meta">@MainActor</span> <span class="keyword">@escaping</span> () <span class="keyword">async</span> -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们试着调用一下这个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> runOnMain &#123;</span><br><span class="line">        log(<span class="string">&quot;on main&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMain before</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600000ac8380</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] on main</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMain after</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure><p>这次只有 block 才会被调度到 MainThread 上，因为只有它被 @MainActor 修饰。</p><p>从这个例子当中我们其实还能推测出调度发生的位置，即：</p><ul><li>异步函数开始执行</li><li>异步函数返回之处</li></ul><p>实际上除此之外，Task 开始时也可能会发生一次调度。这些都是可能的调度位置，Swift 的运行时会根据实际情况判断调度前后是不是属于同一个调度器，以决定是不是真的需要发生调度。这些也能从我们待会儿的例子当中得到印证。</p><p>接下来我们使用 <code>MyActor</code> 依样画葫芦，完成类似的例子：</p><p>首先是函数的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMyExecutor</span>(<span class="params">block</span>: <span class="meta">@MyActor</span> <span class="keyword">@escaping</span> () <span class="keyword">async</span> -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMyExecutor</span>() &#123;</span><br><span class="line">    log(<span class="string">&quot;onMyExecutor&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用它们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> calledOnMyExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> runOnMyExecutor &#123;</span><br><span class="line">        log(<span class="string">&quot;on MyExecutor before sleep&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span>)</span><br><span class="line">        log(<span class="string">&quot;on MyExecutor after sleep&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] onMyExecutor</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] on <span class="type">MyExecutor</span> before sleep</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] on <span class="type">MyExecutor</span> after sleep</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor end</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure><p>注意到 <code>calledOnMyExecutor</code> 调用时、<code>runOnMyExecutor</code> 当中的 <code>block</code> 执行时、<code>block</code> 当中的 sleep 之后恢复时分别执行了一次 <code>enqueue</code>。大家有兴趣的话也可以在其中穿插一些需要调度到主线程的函数调用，看看实际的调度情况。</p><h2 id="Task-与-actor-上下文"><a href="#Task-与-actor-上下文" class="headerlink" title="Task 与 actor 上下文"></a>Task 与 actor 上下文</h2><p>我们在前面介绍 Task 的构造时，讲到过可以使用 <code>init</code> 和 <code>detached</code> 两种方式来构造 Task 实例，前者会继承外部的上下文，包括 actor、TaskLocal 等，后者则不会。</p><p>下面的例子将会证明这其中有关 actor 的部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> runOnMain &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;task in runOnMain&quot;</span>)</span><br><span class="line">        &#125;.value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.detached &#123;</span><br><span class="line">            log(<span class="string">&quot;detached task in runOnMain&quot;</span>)</span><br><span class="line">        &#125;.value</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的介绍，我们已经知道 runOnMain 的参数 block 会被调度到 MainThread 上执行，那么其中的两个 <code>Task</code> 的日志输出理论上会有不同的表现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor start</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] task <span class="keyword">in</span> runOnMain</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] detached task <span class="keyword">in</span> runOnMain</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] runOnMyExecutor end</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] task end</span><br></pre></td></tr></table></figure><p>实际上也正是如此，<code>task in runOnMain</code> 打印到了 MainThread 上，而 <code>detached task in runOnMain</code> 因为通过 <code>detached</code> 创建的 <code>Task</code> 实例不会继承外部的 actor（以及其调度器），因此打印到了其他线程上（也就是默认的调度器上）。</p><p>Task 的两种不同的构造方式对于 TaskLocal 的继承情况同样如此，我们将在下一篇文章当中再给出对比示例。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们详细介绍了 GlobalActor 的设计初衷、实现方式以及使用方法，也探讨了 Swift 协程的调度细节，相信读者看到这里时，已经掌握了绝大多数 Swift 协程的相关知识。</p><p>下一篇文章我们将简单介绍一下 TaskLocal 的使用方法。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们已经知道可以使用 actor 来确保数据的线程安全，但对于数据的保护总是需要定义专门的 actor 实例是不是太麻烦了一些？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（6）：Actor 和属性隔离</title>
    <link href="https://www.bennyhuo.com//2022/02/12/swift-coroutines-06-actor/"/>
    <id>https://www.bennyhuo.com//2022/02/12/swift-coroutines-06-actor/</id>
    <published>2022-02-12T06:02:30.000Z</published>
    <updated>2023-04-17T07:37:39.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异步函数大多数情况下会并发地执行在不同的线程，那么线程安全怎么来保证？ </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="什么是-actor"><a href="#什么是-actor" class="headerlink" title="什么是 actor"></a>什么是 actor</h2><p>Swift 为了解决线程安全的问题，引入了一个非常有用的概念叫做 actor。Actor 模型是计算机科学领域的一个用于并行计算的数学模型，其中 actor 是模型当中的基本计算单元。</p><p>在 Swift 当中，actor 包含 state、mailbox、executor 三个重要的组成部分，其中：</p><ul><li>state 就是 actor 当中存储的值，它是受到 actor 保护的，访问时会有一些限制以避免数据竞争（data race）。</li><li>mailbox 字面意思是邮箱的意思，在这里我们可以理解成一个消息队列。外部对于 actor 的可变状态的访问需要发送一个异步消息到 mailbox 当中，actor 的 executor 会串行地执行 mailbox 当中的消息以确保 state 是线程安全的。</li><li>executor，actor 的逻辑（包括状态修改、访问等）执行所在的执行器。</li></ul><p>下面我们给出一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> accountNumber: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> balance: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">accountNumber</span>: <span class="type">Int</span>, <span class="params">initialDeposit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.accountNumber <span class="operator">=</span> accountNumber</span><br><span class="line">        <span class="keyword">self</span>.balance <span class="operator">=</span> initialDeposit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 actor 叫做 BankAccount（这个例子来自 Swift 的 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md">proposal</a>)，不难看出 actor 在形式上与 class 很像，不仅如此，actor 也能像它们一样定义扩展，声明泛型，实现协议等等。</p><p>Actor 实际上也是引用类型，所以用起来也更像是确保了数据线程安全的 class，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account <span class="operator">=</span> <span class="type">BankAccount</span>(accountNumber: <span class="number">1234</span>, initialDeposit: <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> account2 <span class="operator">=</span> account</span><br><span class="line"><span class="built_in">print</span>(account <span class="operator">===</span> account2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们可以用类似于 class 的方式来构造 actor，并且创建多个变量指向同一个实例，以及使用 === 来判断是否指向同一个实例。程序运行时，我们也可以看到 account 和 account2 指向的地址是相同的：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-02-05-21-51-33.png"></p><h2 id="Actor-的属性隔离"><a href="#Actor-的属性隔离" class="headerlink" title="Actor 的属性隔离"></a>Actor 的属性隔离</h2><p>为了描述存钱这个行为，我们可能希望在外部修改 balance 的值，如果是 struct 或者 class，这个行为并不麻烦，但对于 actor 来讲，这个修改可能是不安全的，因此不被允许。</p><p>那怎么办？我们前面提到修改 actor 的状态需要发邮件，actor 会在收到邮件之后一个一个处理并异步返回给你结果（有没有一种给领导发邮件审批的感觉），这个叫做 actor-isolated（即属性隔离）。</p><p>所以我们打开 outlook 发个邮件？当然不是，开个小玩笑。Swift 的 actor 已经把”发邮件“这个操作设计得非常简洁了，简单说就是两点：</p><ol><li>actor 的可变状态只能在 actor 内部被修改（隔离嘛）</li><li>发邮件其实就是一个异步函数调用的过程</li></ol><p>所以我们需要给 BankAccount 定义一个存钱的函数来完成对 balance 的修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">deposit</span>(<span class="params">amount</span>: <span class="type">Double</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(amount <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">        balance <span class="operator">=</span> balance <span class="operator">+</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把它定义在扩展当中，接下来就可以愉快得存钱了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account <span class="operator">=</span> <span class="type">BankAccount</span>(accountNumber: <span class="number">1234</span>, initialDeposit: <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(account.accountNumber) <span class="comment">// OK，不可变状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> account.balance) <span class="comment">// 可变状态的访问需要使用 await</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> account.deposit(amount: <span class="number">90</span>) <span class="comment">// actor 的函数调用需要 await</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> account.balance)</span><br></pre></td></tr></table></figure><p>这个例子当中有几个细节请大家留意：</p><ol><li>accountNumber 可以直接访问，因为它不可变。不可变就意味着不存在线程安全问题。</li><li>对可变的状态 balance 的访问以及对函数 deposit 的调用都是异步调用，需要用 await，因为这个访问实际上封装了发邮件的过程。</li></ol><p>接下来再给大家看一下转账的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">BankError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">transfer</span>(<span class="params">amount</span>: <span class="type">Double</span>, <span class="params">to</span> <span class="params">other</span>: <span class="type">BankAccount</span>) <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> amount <span class="operator">&gt;</span> balance &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">BankError</span>.insufficientFunds</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    balance <span class="operator">=</span> balance <span class="operator">-</span> amount</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other.balance = other.balance + amount 错误示例</span></span><br><span class="line">    <span class="keyword">await</span> other.deposit(amount: amount) <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 transfer 是 BankAccount 自己的函数，修改自己 balance 的值自然没有什么问题。但修改 other 这个 BankAccount 实例的 balance 的值却是不行的，因为 tranfer 函数执行时实际上是 self 这个实例在处理自己的邮件，这里面如果偷偷修改了 other 的 balance 的值就可能导致 other 的状态出现问题（试想一下你处理自己的邮件的时候偷偷把领导的邮件给删了，看他发现了之后骂不骂你）。</p><p>这个例子告诉我们，actor 的状态只能在自己实例的函数内部修改，而不能跨实例修改。</p><h2 id="外部函数修改-actor-的状态"><a href="#外部函数修改-actor-的状态" class="headerlink" title="外部函数修改 actor 的状态"></a>外部函数修改 actor 的状态</h2><p>前面我们反复提到 actor 的状态只能在自己的函数内部修改，是因为 actor 的函数的调用是在对应的 executor 上安全地执行的。如果外部的函数也能够满足这个调用条件，那么理论上也是安全的。</p><p>Swift 提供了 actor-isolated paramters 这样的特性，字面意思即满足 actor 状态隔离的参数，如果我们在定义外部函数时将需要访问的 actor 类型的参数声明为 isolated，那么我们就可以在函数内部修改这个 actor 的状态了。</p><p>基于这一点，我们也可以把 deposit 函数定义成顶级函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">deposit</span>(<span class="params">amount</span>: <span class="type">Double</span>, <span class="params">to</span> <span class="params">account</span>: <span class="keyword">isolated</span> <span class="type">BankAccount</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">    account.balance <span class="operator">=</span> account.balance <span class="operator">+</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到参数 account 的类型被关键字 isolated 修饰，表明函数 deposit 的调用需要保证 account 的状态修改安全。不难想到，对于这个函数的调用，我们需要使用 await：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> deposit(amount: <span class="number">1000</span>, to: account)</span><br></pre></td></tr></table></figure><p>显然，这里的 isolated 参数不能有多个（至少现在是这样），不然在实现起来会比较麻烦。</p><h2 id="声明不需要隔离的属性或函数"><a href="#声明不需要隔离的属性或函数" class="headerlink" title="声明不需要隔离的属性或函数"></a>声明不需要隔离的属性或函数</h2><p>Actor 的属性默认都是需要被隔离保护的，但也有一些属性可能并不需要被保护，例如我们前面提到的不可变的状态。Swift 允许为 actor 声明不需要隔离的属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> : <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;Bank account #<span class="subst">\(accountNumber)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 description 被声明为 nonisolated，这样对于它的访问就不会受到 balance 那么多的限制了。</p><p>nonisolated 同样可以用来修饰函数，但这样的函数就不能直接访问被隔离的状态了，只能像外部函数一样使用 await 来异步访问。</p><p>这个特性在 Actor 实现 Protocol 的时候也显得非常有用，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> : <span class="title class_">Hashable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">BankAccount</span>, <span class="params">rhs</span>: <span class="type">BankAccount</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.accountNumber <span class="operator">==</span> rhs.accountNumber</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">func</span> <span class="title function_">hash</span>(<span class="params">into</span> <span class="params">hasher</span>: <span class="keyword">inout</span> <span class="type">Hasher</span>) &#123;</span><br><span class="line">        hasher.combine(accountNumber)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            accountNumber.hashValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不加 nonisolated，编译器会给出如下提示：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-02-05-22-39-08.png"></p><p>顺便提一句，在早期的提案当中，你可能会见到 @actorIndependent，它后来被重命名为 nonisolated，这样在语法上与 nonmutating 也更加一致。</p><h2 id="Actor-与-Sendable"><a href="#Actor-与-Sendable" class="headerlink" title="Actor 与 @Sendable"></a>Actor 与 @Sendable</h2><p>在介绍协程的过程中，我们见过很多函数的闭包都被声明为 <code>@Sendable</code>，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskCancellationHandler</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, </span><br><span class="line">    <span class="params">onCancel</span> <span class="params">handler</span>: <span class="meta">@Sendable</span> () -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure><p>其中 onCancel 就被声明为 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md">@Sendable</a>，这表明只有实现了 <code>Sendable</code> 协议的类型实例才能被这个闭包所捕获。</p><p>Actor 天生就是线程安全的，因此也是符合 Sendable 协议的。实际上 Swift 的每一个 actor 类型都隐式地实现了一个叫做 <code>Actor</code> 的协议，而这个协议也正实现了 <code>Sendable</code> 协议。</p><p>我们看一下 <code>Actor</code> 的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Actor</span> : <span class="title class_">AnyObject</span>, <span class="title class_">Sendable</span> &#123;</span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> unownedExecutor: _Concurrency.<span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了定义了调度器之外，它也继承了 Sendable 协议。因此如果大家遇到 @Sendable 闭包需要捕获变量的问题，不妨试一试使用 Actor 来做一层封装。</p><p>顺便提一句，actor 的调度器目前主要由编译器提供默认的实现。官方目前对于自定义调度器的途径还没有给出明确的支持，不过我们将在下一篇文章当中详细探索一下调度器的使用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们主要介绍了 Swift 协程当中的 actor 的基本用法，并重点对属性隔离做了详细介绍。</p><p>有关 actor 的调度器的内容，我们将在下一篇文章当中详细介绍。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;异步函数大多数情况下会并发地执行在不同的线程，那么线程安全怎么来保证？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（5）：Task 的取消</title>
    <link href="https://www.bennyhuo.com//2022/01/28/swift-coroutines-05-cancellation/"/>
    <id>https://www.bennyhuo.com//2022/01/28/swift-coroutines-05-cancellation/</id>
    <published>2022-01-28T22:01:40.000Z</published>
    <updated>2023-04-17T07:37:39.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>但凡是个任务，就有可能被取消。取消了该怎么办呢？ </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="Task-的取消就是个状态"><a href="#Task-的取消就是个状态" class="headerlink" title="Task 的取消就是个状态"></a>Task 的取消就是个状态</h2><p>Task 的取消其实非常简单，就是将 Task 标记为取消状态。那 Task 的执行体要怎么做才能让任务真正取消呢？我们先看个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure><p>我们创建了一个 Task，正常情况下它应该很快被执行到，因此第一行日志可以打印出来，随即进入 10s 的睡眠状态。但我们在 Task 外部等了 500ms 之后把它取消了，如果不出什么意外的话，在 Task 睡眠时它就被取消了。</p><p>既然任务被取消了，凭我们主观的判断，第二句日志应该是打印不出来的，但实际的情况却是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task start</span><br><span class="line">task finish</span><br><span class="line">success()</span><br></pre></td></tr></table></figure><p>这说明 Task 的取消只是一个状态标记，它不会强制 Task 的执行体中断，换句话说 Task 的取消并不像杀进程那样粗暴。</p><p>实际上，我们可以在任务的执行体当中读取到 Task 的取消状态，我们把程序稍作修改如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task start</span><br><span class="line">task finish, isCancelled: true</span><br><span class="line">success()</span><br></pre></td></tr></table></figure><p>可以看到，Task 确实被取消了，我们也可以读取到这个状态，如果我们需要让我们的 Task 执行体响应它的取消状态，那就需要做出这个状态的判断，并且做出响应，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个例子还不够理想，毕竟睡眠的 10s 是不能响应取消的。那如果让 sleep 函数内部也能响应取消，问题是不是就解决了？</p><h2 id="通过抛-CancellationError-来响应取消"><a href="#通过抛-CancellationError-来响应取消" class="headerlink" title="通过抛 CancellationError 来响应取消"></a>通过抛 CancellationError 来响应取消</h2><p>Task 的执行过程中，难免会存在多层异步函数的嵌套的情况，如果最深处的某一个函数响应了取消状态，怎样才能让外部的异步函数也能很好的配合好这个响应？这其实就是在回答上一节留下的 sleep 该如何响应取消的问题。如果想要优雅地给出这个答案，只能通过抛异常的方式了，因为任何条件分支的判断都无法实现有效的传播，而异常天然就具备这样的特性。</p><p>所以常见的异常响应方式非常简单，如果你在编写一个需要响应取消状态的异步函数，当你检查到 Task 被取消时，只需要抛一个 <code>CancellationError</code> 即可，大家都遵守这个规则，那么这个 Task 就能被优雅地结束。</p><p>实际上 Task 一共有两个 sleep 函数，我们仔细对比一下它们的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="keyword">_</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="params">nanoseconds</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><p>二者的区别有两处：</p><ul><li>参数的 label</li><li>是否会抛出异常</li></ul><p>第二个函数明确通过参数的 label 告诉我们参数是纳秒，同时它还会抛出异常。什么异常？自然是在 Task 被取消时抛出 <code>CancellationError</code>。这么看来我们只需要稍微调整一下代码就能完美解决问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task start</span><br><span class="line">failure(Swift.CancellationError())</span><br></pre></td></tr></table></figure><p>符合预期。</p><p>实际上，如果大家仔细查阅 Swift 的文档，你就会发现第一个 sleep 函数已经被废弃了，它的问题想必大家也已经非常明白了吧。</p><h2 id="checkCancellation：更方便地检查取消状态"><a href="#checkCancellation：更方便地检查取消状态" class="headerlink" title="checkCancellation：更方便地检查取消状态"></a>checkCancellation：更方便地检查取消状态</h2><p>前面的例子我们算是躺赢了，但如果实际的代码是下面这样呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        doHardWork(i) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难，我们只需要加个判断嘛，这样在每次循环的开始，如果 Task 已经被取消，我们就能够及时地停止这个任务的执行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">CancellationError</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        doHardWork(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这里有个更方便的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation()</span><br><span class="line">        doHardWork(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数也没啥神秘的，因为它的实现非常直接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkCancellation</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">Task</span>&lt;<span class="type">Never</span>, <span class="type">Never</span>&gt;.isCancelled &#123;</span><br><span class="line">        <span class="keyword">throw</span> _Concurrency.<span class="type">CancellationError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册取消回调"><a href="#注册取消回调" class="headerlink" title="注册取消回调"></a>注册取消回调</h2><p>前面提到的响应取消的情况实际上是两种类型：</p><ul><li>调用其他支持响应取消的异步函数，在取消时它会抛出 CancellationError</li><li>自己的代码当中主动检查取消状态，并抛出 CancellationError（或者直接退出执行逻辑）</li></ul><p>但如果异步的逻辑封装在第三方代码当中，我们只能想办法在 Task 取消时调用第三方的取消逻辑来完成响应，这时候情况就复杂一些了。我们就以 GCD 的异步 API 为例，首先我们对 DispatchWorkItem 做个包装：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContinuationWorkItem</span>&lt;<span class="title class_">T</span>, <span class="title class_">E</span>&gt; <span class="title class_">where</span> <span class="title class_">E</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> continuation: <span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;?</span><br><span class="line">    <span class="keyword">let</span> block: (<span class="type">ContinuationWorkItem</span>) -&gt; <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> dispatchItem: <span class="type">DispatchWorkItem</span> <span class="operator">=</span> <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.continuation<span class="operator">?</span>.resume(returning: <span class="keyword">self</span>.block(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.dispatchItem.isCancelled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">block</span>: <span class="keyword">@escaping</span> (<span class="type">ContinuationWorkItem</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.block <span class="operator">=</span> block</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">installContinuation</span>(<span class="params">continuation</span>: <span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.continuation <span class="operator">=</span> continuation</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>() &#123;</span><br><span class="line">        dispatchItem.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包装的目的在于支持 <code>installContinuation</code>，通过获取 Task 的 continuation 来实现异步结果的返回。</p><p>这里还有一个细节，block 的类型与 DispatchWorkItem 的 block 多了个参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> block: (<span class="type">ContinuationWorkItem</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure><p>这主要是为了方面我们在 block 当中可以读取到 GCD 的任务是否被取消了。</p><p>接下来我们试着用 Task 来封装 GCD 的异步任务，并且实现对取消的响应：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> asyncRequest <span class="operator">=</span> <span class="type">ContinuationWorkItem</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; &#123; item <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;async start&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i <span class="operator">&lt;</span> <span class="number">10</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>item.isCancelled &#123;</span><br><span class="line">            <span class="comment">// 单位 秒</span></span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.1</span>)</span><br><span class="line">            i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i = <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> item.isCancelled &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;async cancelled, <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;async finish&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="keyword">await</span> withCheckedContinuation &#123; (continuation: <span class="type">CheckedContinuation</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;) <span class="keyword">in</span></span><br><span class="line">            asyncRequest.installContinuation(continuation: continuation)</span><br><span class="line">            <span class="type">DispatchQueue</span>.global().async(execute: asyncRequest.dispatchItem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; onCancel: &#123;</span><br><span class="line">        asyncRequest.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure><p>asyncRequest 其实就是我们创建的对 ContinuationWorkItem 实例，它对 DispatchWorkItem 做了包装，在后面的代码当中传给了 DispatchQueue 去异步执行。为了能够及时感知到 Task 的取消状态变化，我们用到了 withTaskCancellationHandler 这个函数，它的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskCancellationHandler</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, </span><br><span class="line">    <span class="params">onCancel</span> <span class="params">handler</span>: <span class="meta">@Sendable</span> () -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure><p>显然，这个函数也是个异步函数，它有两个参数，分别是：</p><ul><li>operation，即我们要在当前 Task 当中执行的代码逻辑</li><li>onCancel，在 operation 执行时，如果 Task 被取消，该回调立即执行</li></ul><p>有了这个函数，我们就可以在调用第三方异步操作时，及时感知到 Task 的取消状态，并通知第三方取消异步操作。</p><h2 id="TaskGroup-的取消"><a href="#TaskGroup-的取消" class="headerlink" title="TaskGroup 的取消"></a>TaskGroup 的取消</h2><p>TaskGroup 也可以被取消，很容易理解，所有从属于 TaskGroup 的 Task 在前者被取消以后也会被取消。下面我们给出一个非常简单的例子来说明这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> taskCount <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> withTaskGroup(of: (<span class="type">Int</span>, <span class="type">Int</span>).<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>taskCount &#123;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled <span class="operator">&amp;&amp;</span> count <span class="operator">&lt;</span> max &#123;</span><br><span class="line">                <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span> <span class="operator">+</span> <span class="type">UInt64</span>(arc4random_uniform(<span class="number">500_000_000</span>)))</span><br><span class="line">                count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Task: <span class="subst">\(i)</span>, count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (i, count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5500_000_000</span>)</span><br><span class="line">    group.cancelAll()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> result <span class="keyword">in</span> group &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 TaskGroup 当中启动了 10 个 Task， 这些 Task 每隔约 1 ~ 1.5 秒就会令 count 加 1，最终把 Task 的序号和 count 的值返回。TaskGroup 则在启动了所有的 Task 之后 5.5 秒的时候取消，因此前面的 Task 大多只能将 count 增加到 5 左右。运行结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span>: <span class="number">4</span>, count: <span class="number">1</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">6</span>, count: <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">2</span>, count: <span class="number">4</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">8</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">9</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">9</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">5</span>, count: <span class="number">4</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">7</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">result: (<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">4</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">6</span>, count: <span class="number">5</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">3</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">result: (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">2</span>, count: <span class="number">5</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">0</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">result: (<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">1</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>我们省略了部分相似的输出，大家只需要关注包含 result 的行，其中 Task 9 返回的 count 为 4，Task 1 返回的 count 为 5。这说明 TaskGroup 在取消时其中的 Task 确实都被取消了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们重点讨论了 Task 的取消的设计，包括取消状态的概念，如何在不同情况下响应取消状态；最后也通过一个简单地例子了解了一下 TaskGroup 的取消。</p><p>大家只需要牢记一点，Task 的取消只是一个状态，需要内部执行逻辑的响应。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;但凡是个任务，就有可能被取消。取消了该怎么办呢？ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>闲话 Swift 协程（4）：TaskGroup 与结构化并发</title>
    <link href="https://www.bennyhuo.com//2022/01/22/swift-coroutines-04-structured-concurrency/"/>
    <id>https://www.bennyhuo.com//2022/01/22/swift-coroutines-04-structured-concurrency/</id>
    <published>2022-01-22T21:01:22.000Z</published>
    <updated>2023-04-17T07:37:39.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇文章我们提到了结构化并发，这听上去很高级。 </p></blockquote><span id="more"></span><ul><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li><li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li><li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li><li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li><li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li><li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li><li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li></ul><h2 id="TaskGroup-的基本用法"><a href="#TaskGroup-的基本用法" class="headerlink" title="TaskGroup 的基本用法"></a>TaskGroup 的基本用法</h2><p>我们现在已经知道怎么在自己的程序里面调用异步函数了。</p><p>不难发现，调用异步函数的关键点是创建 Task 的实例。通过 Task 的构造器或者 detach 函数创建的 Task 实例都是顶级的，这意味着这些实例都需要单独管理。在真实的业务场景中，我们难免会创建很多 Task 实例来执行不同的异步任务，但这些任务之间往往都是存在关联的，因此我们绝大多数情况下更希望这些 Task 实例是作为一个或者几个整体来统一管理的。</p><p>这就需要 TaskGroup 了。</p><p>创建 TaskGroup 的方式非常简单，使用 <code>withTaskGroup(of:returning:body:)</code> 函数即可，它的完整定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">withTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>, </span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>, </span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br></pre></td></tr></table></figure><p>它有三个参数，但实际上前两个其实就是泛型参数，其中</p><ul><li><code>ChildTaskResult</code> 表示这个 TaskGroup 内创建的 Task 的结果类型</li><li><code>GroupResult</code> TaskGroup 自身的结果类型</li></ul><p>后者其实也是第三个参数 body 的返回值类型。</p><p>注意到 <code>withTaskGroup</code> 是异步函数，它会在 TaskGroup 当中所有的子 Task 执行完之后再返回。我们可以在 body 当中向 TaskGroup 当中添加子 Task，用到 addTask 函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addTask</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> -&gt; <span class="type">ChildTaskResult</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>priority 是当前任务的优先级</li><li>operation 就是任务的执行体</li></ul><p>尽管 <code>withTaskGroup</code> 会等待子 Task 执行完，但有些情况下我们希望在 body 当中就提前等待子 Task 的执行结果，这时候我们有两种做法：</p><ul><li>如果只关心子 Task 是否执行完，可以调用 TaskGroup 的 <code>waitForAll</code> 函数。不难想到，这也是一个异步函数。</li><li>更常见的情况是获取子 Task 的结果，这时候我们可以直接迭代 TaskGroup，或者调用 TaskGroup 的 <code>next</code> 函数来获取下一个已完成的子 Task 的结果。注意，获取的结果的顺序取决于子 Task 完成的顺序，而不是它们添加到 TaskGroup 当中的顺序。</li></ul><h2 id="一个结构化并发的简单示例"><a href="#一个结构化并发的简单示例" class="headerlink" title="一个结构化并发的简单示例"></a>一个结构化并发的简单示例</h2><p>下面我们给大家看一个非常简单的异步分段计算的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个计算 [min, max) 范围内整数的和的闭包，注意前闭后开</span></span><br><span class="line"><span class="keyword">let</span> add <span class="operator">=</span> &#123; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> min<span class="operator">..&lt;</span>max &#123;</span><br><span class="line">        sum <span class="operator">+=</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seg <span class="operator">=</span> <span class="number">10</span> <span class="comment">// 分段大小</span></span><br><span class="line"><span class="keyword">let</span> n <span class="operator">=</span> <span class="type">Int</span>(arc4random_uniform(<span class="number">10000</span>)) <span class="comment">// 产生一个随机数，下面计算 [0, n] 内的整数和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>, returning: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 计算分段和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>(n <span class="operator">/</span> seg) &#123;</span><br><span class="line">        group.addTask &#123; add(seg <span class="operator">*</span> (i <span class="operator">-</span> <span class="number">1</span>), seg <span class="operator">*</span> i) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 n 不能被 seg 整除，计算剩余部分的和</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="operator">%</span> seg <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            add(n <span class="operator">-</span> n <span class="operator">%</span> seg, n <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 group 的子任务结果，汇总</span></span><br><span class="line">    <span class="keyword">var</span> totalSum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> result <span class="keyword">in</span> group &#123;</span><br><span class="line">        totalSum <span class="operator">+=</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>通过 <code>withTaskGroup</code> 创建了一个 TaskGroup 实例，子 Task 的结果类型和 TaskGroup 的类型都是 Int，我们将 [0, n] 的整数按照 seg 进行分段，每段整数的和通过一个子 Task 来完成计算。</p><p>由于子 Task 的实例我们是无法直接拿到的，因此我们需要通过 TaskGroup 的实例来获取子任务的结果。通过上面的例子我们不难发现 group 是可以被迭代的，很自然的能想到 TaskGroup 有以下函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() <span class="keyword">async</span> -&gt; <span class="type">ChildTaskResult</span>?</span><br></pre></td></tr></table></figure><p>并且实现了 AsyncSequence 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TaskGroup</span> : <span class="title class_">_Concurrency</span>.<span class="title class_">AsyncSequence</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure><p>AsyncSequence 与 Sequence 的不同之处在于它的迭代器的 next 函数是异步函数，这就与前面 TaskGroup 的 next 函数对应上了。</p><p>计算 totalSum 除了使用经典的 for 循环以外，我们也可以使用 reduce：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> totalSum <span class="operator">=</span> <span class="keyword">await</span> group.reduce(<span class="number">0</span>) &#123; acc, i <span class="keyword">in</span></span><br><span class="line">    acc <span class="operator">+</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 reduce 的第一个参数是初始值，第二个参数是个闭包，它的参数 acc 是累积的结果，i 是当前的元素，返回值则会作为下一个元素调用时的 acc 传入，最终得到的就是所有子 Task 的结果的和。</p><h2 id="会抛异常的-TaskGroup"><a href="#会抛异常的-TaskGroup" class="headerlink" title="会抛异常的 TaskGroup"></a>会抛异常的 TaskGroup</h2><p>大家可能发现了，我们前面创建的 TaskGroup 里面的子 Task 不能抛异常。因此我们很自然的想到还有一套可以抛异常的 TaskGroup 的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withThrowingTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>, </span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>, </span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> _Concurrency.<span class="type">ThrowingTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">Error</span>&gt;) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">GroupResult</span></span><br></pre></td></tr></table></figure><p>通过它创建的 TaskGroup 的类型是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@frozen</span> <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">ThrowingTaskGroup</span>&lt;<span class="title class_">ChildTaskResult</span>, <span class="title class_">Failure</span>&gt; <span class="title class_">where</span> <span class="title class_">Failure</span> : <span class="title class_">Error</span></span><br></pre></td></tr></table></figure><p>ThrowingTaskGroup 与 TaskGroup 的本质是一致的，只不过 ThrowingTaskGroup 的所有成员函数都增加了 throws 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="number">1000000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 withThrowingTaskGroup 是 rethrows 的，如果闭包参数里面有异常抛出，调用时也需要做异常处理。例子当中调用到了 Task 的 sleep 函数，需要大家注意的是 Task 有两个 sleep 函数，带 nanoseconds 的这个版本是会抛异常的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数没有 label，没有标记为 throws，调用时不需要处理异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="keyword">_</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数有 label，标记为 throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="params">nanoseconds</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><p>因此这里需要使用 <code>withThrowingTaskGroup</code> 来做异常的传递。</p><p>除抛异常这个点以外，ThrowingTaskGroup 的用法与 TaskGroup 完全一致。</p><h2 id="子-Task-的异常处理"><a href="#子-Task-的异常处理" class="headerlink" title="子 Task 的异常处理"></a>子 Task 的异常处理</h2><p>在 TaskGroup 当中，子 Task 如果抛出了异常，当外部调用者试图通过 TaskGroup 实例获取它的结果时也会抛出这个异常。需要注意的是，由于子 Task 结果的获取顺序取决于实际 Task 的完成时间，因此获取结果时需要注意对单个 Task 的结果进行异常捕获，以免影响其他 Task 的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span>)</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> errorThrown()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1500_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="operator">!</span>group.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> group.next() <span class="operator">??</span> <span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子当中，返回 0 的子 Task 抛了异常，我们在试图遍历 group 时就会遇到这个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">Runtime Error</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>而其他的子 Task 的结果是可以正常获取的。可见 TaskGroup 当中的 Task 抛异常并不会影响其他 Task 的运行。</p><h2 id="不要把-TaskGroup-的实例泄漏到外部"><a href="#不要把-TaskGroup-的实例泄漏到外部" class="headerlink" title="不要把 TaskGroup 的实例泄漏到外部"></a>不要把 TaskGroup 的实例泄漏到外部</h2><p>从前面的例子我们大致可以看出，Swift 的 TaskGroup 的 API 设计还是非常谨慎的，TaskGroup 的实例只有在 <code>withTaskGroup</code> 的闭包参数当中使用，外部没有办法直接获取。</p><p>那有没有办法能让 TaskGroup 的实例逃逸出这个闭包呢？我们来做一点儿小尝试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskGroup: <span class="type">TaskGroup</span>&lt;<span class="type">Int</span>&gt;?</span><br><span class="line"><span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; (group) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    taskGroup <span class="operator">=</span> group</span><br><span class="line">    group.addTask &#123; <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> group <span class="operator">=</span> taskGroup <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group is nil&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> i <span class="keyword">in</span> group &#123; </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在闭包外面定义一个变量 taskGroup，在闭包里面给 taskGroup 赋值。接下来我们在外面尝试访问以下 taskGroup 的子任务结果，运行之后就会发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process finished with exit code 133 (interrupted by signal 5: SIGTRAP)</span><br></pre></td></tr></table></figure><p>错误发生的位置就是这里： <code>for await i in group &#123; ... &#125;</code>。</p><p>为什么会出现异常呢？我们前面提到过， <code>withTaskGroup</code> 会在所有的子 Task 执行完以后再返回，这是否意味着 TaskGroup 的实例也会在此时被销毁呢？</p><p>遇到这种问题，我们只需要翻阅一下 swift 的源码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>,</span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>,</span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _group <span class="operator">=</span> <span class="type">Builtin</span>.createTaskGroup(<span class="type">ChildTaskResult</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">var</span> group <span class="operator">=</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;(group: _group)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the withTaskGroup body.</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> body(<span class="operator">&amp;</span>group)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> group.awaitAllRemainingTasks()</span><br><span class="line"></span><br><span class="line">    <span class="type">Builtin</span>.destroyTaskGroup(_group)</span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，withTaskGroup 返回前会先等待所有的子 Task 执行完毕，然后将 TaskGroup 销毁。因此将 TaskGroup 的实例泄漏到外部没有任何意义。</p><h2 id="不要在子-Task-当中修改-TaskGroup"><a href="#不要在子-Task-当中修改-TaskGroup" class="headerlink" title="不要在子 Task 当中修改 TaskGroup"></a>不要在子 Task 当中修改 TaskGroup</h2><p>TaskGroup 泄漏到外部是危险的，这其实很容易想到。那么在子 Task 当中呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> withTaskGroup(of: <span class="type">Void</span>.<span class="keyword">self</span>) &#123; (group) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        group.addTask &#123; <span class="comment">// error!</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inner task&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你尝试在子 Task 当中去修改 group（addTask 是 mutating func），你会得到这样的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mutation of captured parameter &#x27;group&#x27; in concurrently-executing code</span><br></pre></td></tr></table></figure><p>正如前面提到不能把 TaskGroup 的实例泄漏到外面一样，它也同样不能泄漏到子 Task 的执行体当中。道理也很简单，子 Task 的执行体可能会被调度到不同的线程上，这样就导致对 TaskGroup 的修改是并发的，不安全。</p><h2 id="async-let"><a href="#async-let" class="headerlink" title="async let"></a>async let</h2><p>除了使用 TaskGroup 添加子 Task 的方式来构造结构化并发以外，我们还有一种比较便捷的方式，那就是使用 async let。async let 一方面可以让子 Task 的创建和结果的返回变得更加简单，另一方面也可以解决子 Task 的结果不好定位的问题（因为遍历 TaskGroup 时子 Task 的结果返回顺序不确定）。</p><p>下面我们给出一个简单的例子来说明这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> info: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> followers: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">let</span> projects: [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个数据结构 User，我们现在需要通过访问网络情况来构造这样一个实例，其中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUserInfo</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getFollowers</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getProjects</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个函数将发送异步网络请求去获取对应字段的数据。如果使用 TaskGroup，代码写起来将会比较复杂：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> info(value: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> followers(value: [<span class="type">String</span>])</span><br><span class="line">    <span class="keyword">case</span> projects(value: [<span class="type">String</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getUser</span>(<span class="params">name</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> withTaskGroup(of: <span class="type">Result</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .info(value: <span class="keyword">await</span> getUserInfo(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .followers(value: <span class="keyword">await</span> getFollowers(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .projects(value: <span class="keyword">await</span> getProjects(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> info: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">var</span> followers: [<span class="type">String</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">var</span> projects: [<span class="type">String</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> r <span class="keyword">in</span> group &#123;</span><br><span class="line">            <span class="keyword">switch</span> r &#123;</span><br><span class="line">            <span class="keyword">case</span> .info(value: <span class="keyword">let</span> value):</span><br><span class="line">                info <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">case</span> .followers(value: <span class="keyword">let</span> value):</span><br><span class="line">                followers <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">case</span> .projects(value: <span class="keyword">let</span> value):</span><br><span class="line">                projects <span class="operator">=</span> value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">User</span>(name: name, info: info <span class="operator">??</span> <span class="string">&quot;&quot;</span>, followers: followers <span class="operator">??</span> [], projects: projects <span class="operator">??</span> [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面多次提到对 TaskGroup 进行遍历获取子 Task 的结果时存在顺序的不确定性，为了解决这个问题我们定义了一个枚举 Result 将子 Task 的结果与枚举值进行绑定，方便后续读取结果。这个过程异常繁琐，且引入额外的类型实现结果的绑定让问题变得更加复杂。</p><p>如果使用 async let，这个问题就会变得非常简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUser</span>(<span class="params">name</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> info <span class="operator">=</span> getUserInfo(name)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> followers <span class="operator">=</span> getFollowers(name)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> projects <span class="operator">=</span> getProjects(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">User</span>(name: name, info: <span class="keyword">await</span> info, followers: <span class="keyword">await</span> followers, projects: <span class="keyword">await</span> projects)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async let 会创建一个子 Task 来完成后面的调用，并且把结果绑定到对应的变量当中。以 info 为例，当我们需要读取其结果时，只需要 await info 即可，这样就大大降低了我们获取异步子 Task 的结果的复杂度。</p><p>另外稍微提一句的是，在 Swift 当中，async 函数的调用必须使用 await 来等待这个限制会强制我们等待异步函数的结果，如果希望同时触发多个异步函数的调用，async let 能解决的问题也是有限的。例如我们想要并发获取多个 User 的数据，需要实现以下函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>:[<span class="type">String</span>]) <span class="keyword">async</span> -&gt; [<span class="type">User</span>]</span><br></pre></td></tr></table></figure><p>我们可以基于前面的 getUser 来实现这个函数，为了保证 User 数据的获取的并发性，我们需要同时创建多个 Task 来完成请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>:[<span class="type">String</span>]) <span class="keyword">async</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">    <span class="keyword">await</span> withTaskGroup(of: <span class="type">User</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">            group.addTask &#123;</span><br><span class="line">                <span class="keyword">await</span> getUser(name: name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> group.reduce(into: <span class="type">Array</span>&lt;<span class="type">User</span>&gt;()) &#123; (partialResult, user) <span class="keyword">in</span></span><br><span class="line">            partialResult.append(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下 async let 就显得有点儿力不从心了。</p><p>更进一步，如果这里要求返回的 User 跟传入的 name 能够在顺序上一一对应，使用 TaskGroup 实现就会比较麻烦，因为 TaskGroup 的结果顺序是子 Task 完成的顺序。</p><p>实际上，保证结果的顺序与 Task 的添加顺序一致是有实际需求的，我们也可以使用一组 Task 而不是 TaskGroup 来实现这个需求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>: [<span class="type">String</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> tasks <span class="operator">=</span> names.map &#123; name <span class="keyword">in</span></span><br><span class="line">        <span class="type">Task</span> &#123; () -&gt; <span class="type">User</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUser(name: name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler(operation: &#123;</span><br><span class="line">        <span class="keyword">var</span> users <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">User</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks &#123;</span><br><span class="line">            users.append(<span class="keyword">try</span> <span class="keyword">await</span> task.value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users</span><br><span class="line">    &#125;, onCancel: &#123;</span><br><span class="line">        tasks.forEach &#123; task <span class="keyword">in</span> task.cancel() &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这时候我们创建的 Task 都是不隶属于 TaskGroup 的（即非结构化并发），此时我们要小心处理 Task 取消的情况，以免出现内存泄漏和逻辑错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们简单介绍了一下 TaskGroup 的用法，大家可以基于这些内容开始做一些简单的尝试了。结构化并发当中还有一些重要的概念我们将在接下来的几篇文章当中逐步介绍。</p><hr><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li><li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li><li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上一篇文章我们提到了结构化并发，这听上去很高级。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coroutines" scheme="https://www.bennyhuo.com/tags/coroutines/"/>
    
      <category term="Swift" scheme="https://www.bennyhuo.com/tags/swift/"/>
    
      <category term="Async await" scheme="https://www.bennyhuo.com/tags/async-await/"/>
    
  </entry>
  
</feed>
