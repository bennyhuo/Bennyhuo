<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018 JetBrains 开发者大会见闻</title>
    <url>/2018/11/18/2018-JetBrains-Day/</url>
    <content><![CDATA[<blockquote>
<p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p>
</blockquote>
<p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg"></p>
<span id="more"></span>

<p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p>
<p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p>
<p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg"></p>
<p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg"></p>
<p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p>
<p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href="mailto:&#98;&#101;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#x6f;&#64;&#x6b;&#x6f;&#116;&#108;&#x69;&#x6e;&#101;&#x72;&#x2e;&#99;&#110;">&#98;&#101;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#x6f;&#64;&#x6b;&#x6f;&#116;&#108;&#x69;&#x6e;&#101;&#x72;&#x2e;&#99;&#110;</a>）。</p>
<p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p>
<p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg"></p>
<p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p>
<p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p>
<p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p>
<p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg"></p>
<p>还有一个是 Nyan 进度条的插件，很有趣：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg"></p>
<p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Api</span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: GitUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Api</span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getJetBrains</span><span class="params">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p>
<p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p>
<p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p>
<p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg"></p>
<p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p>
<p>PS：茶歇的小饼干也很好吃啊！</p>
<hr>
<p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p>
<p>链接：<a href="https://share.weiyun.com/5YMPoL4">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p>
<hr>
<p>Kotlin 中文站：<a href="https://www.kotlincn.net/">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href="https://www.kotliner.cn/">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href="https://discuss.kotliner.cn/">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href="https://ktor.kotlincn.net/">https://ktor.kotlincn.net</a></p>
<hr>
<p>欢迎关注：微信公众号 Kotlin</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg"></p>
]]></content>
      <tags>
        <tag>JetBrains</tag>
        <tag>News</tag>
      </tags>
  </entry>
  <entry>
    <title>新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题</title>
    <url>/2019/02/05/2019_new_year/</url>
    <content><![CDATA[<h3 id="0-新年立个-Flag"><a href="#0-新年立个-Flag" class="headerlink" title="0. 新年立个 Flag"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p>
<p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p>
<p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p>
<span id="more"></span>

<p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p>
<p>下面我们说我们今天的正题：</p>
<h3 id="1-Kotlin-不能完全兼容-Java-吗？"><a href="#1-Kotlin-不能完全兼容-Java-吗？" class="headerlink" title="1. Kotlin 不能完全兼容 Java 吗？"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p>
<hr>
<p><strong>原帖开始</strong></p>
<p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="keyword">public</span> String mmm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiException</span><span class="params">(Throwable throwable, <span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(throwable);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> detailMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在kotlin中调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exception = ApiException(Throwable(),<span class="number">1</span>)</span><br><span class="line">exception.code <span class="comment">//正常</span></span><br><span class="line">exception.message <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<p>错误信息如下：</p>
<blockquote>
<p>Overload resolution ambiguity. All these functions match. public final var message</p>
</blockquote>
<p>java中调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ApiException</span>(Throwable(),<span class="number">1</span>).message 完全正常</span><br></pre></td></tr></table></figure>

<p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p>
<p><strong>原帖结束</strong></p>
<hr>
<p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p>
<p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p>
<p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p>
<p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p>
<p>先用 Java 包装一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtApiException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(ApiException a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再在 Kotlin 里面这样调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = ApiException()</span><br><span class="line"><span class="keyword">val</span> t = (a <span class="keyword">as</span> Throwable).message</span><br><span class="line"><span class="keyword">val</span> r = ExtApiException.getMessage(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ApiException.<span class="title">realMessage</span><span class="params">()</span></span> = ExtApiException.getMessage(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure>

<p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p>
<h3 id="2-为什么-message-会和-getMessage-纠缠不清？"><a href="#2-为什么-message-会和-getMessage-纠缠不清？" class="headerlink" title="2. 为什么 message 会和 getMessage 纠缠不清？"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Throwable</span> <span class="keyword">public</span> <span class="keyword">constructor</span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> message: kotlin.String? </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p>
<h3 id="3-真的没有办法通过-Kotlin-实现访问吗？"><a href="#3-真的没有办法通过-Kotlin-实现访问吗？" class="headerlink" title="3. 真的没有办法通过 Kotlin 实现访问吗？"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exception = ApiException(Throwable(<span class="string">&quot;ThrowableMessage&quot;</span>),<span class="number">1</span>)</span><br><span class="line">println((exception <span class="keyword">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure>

<p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">property1</span><span class="params">(property: <span class="type">KProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">mutableProperty1</span><span class="params">(property: <span class="type">KMutableProperty1</span>&lt;<span class="type">R</span>, T&gt;)</span></span> = property</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ApiException.throwableMessage: String?</span><br><span class="line">        <span class="keyword">get</span>() = property1(Throwable::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ApiException.apiMessage</span><br><span class="line">    <span class="keyword">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">set</span>(<span class="keyword">this</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p>
<p>当然我们也可以通过是否可空来区分，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ApiException.apiMessage2: String</span><br><span class="line">    <span class="keyword">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p>
<p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HelloKt$apiMessage$2</span> <span class="keyword">extends</span> <span class="title class_">MutablePropertyReference1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KMutableProperty1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloKt$apiMessage$2</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;message&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getSignature</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;getMessage()Ljava/lang/String;&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> KDeclarationContainer <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Reflection.getOrCreateKotlinClass(ApiException.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="meta">@Nullable</span> Object receiver)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((ApiException)receiver).message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="meta">@Nullable</span> Object receiver, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">      ((ApiException)receiver).message = (String)value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p>
<p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>
]]></content>
      <tags>
        <tag>NewYear</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为 Gradle 的 KTS 脚本添加扩展？</title>
    <url>/2021/04/17/Add-extensions-to-build-scripts/</url>
    <content><![CDATA[<blockquote>
<p>本质上还是要搞清楚 KTS 是怎么运行的 </p>
</blockquote>
<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1BU4y1b7Wk&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>




<p>要知道在 Groovy 当中想要做到这一点并不难，毕竟作为一门动态类型的语言，只要运行时能够访问到即可，反正又不需要 IDE 代码提示。但在 Kotlin 这里情况就显得有点儿麻烦了，因为我们添加的扩展要在编译的时候就能够让编译器访问到。</p>
<h2 id="1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？"><a href="#1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？" class="headerlink" title="1. Kotlin DSL 的 Gradle 脚本是怎么运行的？"></a>1. Kotlin DSL 的 Gradle 脚本是怎么运行的？</h2><p>为了搞清楚怎么添加扩展，我们同样需要搞清楚采用 Kotlin DSL 的 Gradle 脚本是怎么运行的。但受限于篇幅，我就不带着大家一步一步去看源码了，大家有兴趣可以在 Gradle 源码当中找到 org.gradle.kotlin.dsl 包，其中就是有关 Kotlin DSL 的支持的实现。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png" alt="Gradle Kotlin DSL 的源码路径"></p>
<p>有了前面“<a href="http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=793373419&lang=zh_CN#rd">你的 Gradle 脚本是怎么运行起来的？</a>”这个视频的基础，相信大家已经了解了 Gradle 脚本运行时的两个阶段：</p>
<ul>
<li>classpath 阶段</li>
<li>body 阶段</li>
</ul>
<p>其实 Kotlin DSL 也是如此，只不过运行的时候具体的形式稍微有些差异。</p>
<p>Kotlin DSL 版本的脚本被称为 “Program”，它在 Gradle 的实现当中也通过一个叫 <strong>Program</strong> 的类及其子类来描述，定义在 Program.kt 文件当中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">	<span class="keyword">object</span> Empty: Program() &#123; ... &#125;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Buildscript</span>(<span class="keyword">override</span> <span class="keyword">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PluginManagement</span>(<span class="keyword">override</span> <span class="keyword">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Plugins</span>(<span class="keyword">override</span> <span class="keyword">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Stage1Sequence</span>(<span class="keyword">val</span> pluginManagement: PluginManagement?, <span class="keyword">val</span> buildscript: Buildscript?, <span class="keyword">val</span> plugins: Plugins?) : Stage1()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Script</span>(<span class="keyword">val</span> source: ProgramSource) : Program()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Staged</span>(<span class="keyword">val</span> stage1: Stage1, <span class="keyword">val</span> stage2: Script) : Program()</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stage1</span> : <span class="type">Program</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到所有在 classpath 阶段编译运行的代码块都继承自 Stage1 这个类。我认为这段代码定义中最有趣的是 <code>Stage1Sequence</code>，它通过类型的形式强制给出了几个代码块的顺序的定义。</p>
<blockquote>
<p><strong>提示：</strong>可以看到这还是一个密封的使用案例，所以不要总是说密封类没啥用，代码储备量的贫乏限制了大家的想象力。</p>
</blockquote>
<p>那么它究竟是怎么运行的呢？</p>
<p>简单来说就是任意一个 Kotlin DSL 的 Gradle 脚本都会把分属于不同阶段的部分拆分开，每一个部分都会编译成两个类，叫做 <strong>Program</strong> 和 <strong>Build_gradle</strong>，其中 Program 类的 execute 函数是调用入口，DSL 脚本的内容则被编译成 Build_gradle 类的构造函数。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417092350607.png" alt="Kotlin DSL 的编译运行示意图"></p>
<p>有朋友肯定会发出疑问，两个阶段分别编译出不同的两个类，但名字是一样的，这不会冲突吗？当然不会，二者运行时用的 classloader 都是不一样的。而且需要特别注意的是，我们会在 classpath 阶段的 buildscript 代码块中添加 classpath，所以这个阶段与 body 阶段运行时的 classpath 是不一样的，因此不是所有在 body 阶段能访问到的类和成员都能在 classpath 阶段访问到。</p>
<p>我们以之前改造好的根目录下的 build.gradle.kts 为例，它的内容如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    <span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra(<span class="string">&quot;1.4.30&quot;</span>)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlin_version</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        classpath(<span class="string">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class="line">        <span class="comment">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        <span class="keyword">if</span> (plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">            group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">            version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">            apply(plugin = <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.register&lt;Delete&gt;(<span class="string">&quot;clean&quot;</span>) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时会分成两部分，其中 </p>
<ul>
<li><p>classpath 阶段的内容为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    <span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra(<span class="string">&quot;1.4.30&quot;</span>)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlin_version</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        classpath(<span class="string">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class="line">        <span class="comment">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>body 阶段的内容为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        <span class="keyword">if</span> (plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">            group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">            version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">            apply(plugin = <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.register&lt;Delete&gt;(<span class="string">&quot;clean&quot;</span>) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>由于 body 阶段的 classloader 包含了 classpath 阶段添加的依赖，因此在 body 阶段可以访问所有前面 dependencies 当中添加的 maven 依赖库中的类。</p>
<p>大家也可以单步调试一下这个脚本来深入了解一下它。值得一提的是，Gradle 在编译运行时会生成两个不同的 jar 包来存储 <strong>Program</strong> 和 <strong>Gradle_build</strong> 类，因此我们可以通过加载它的 classloader 找到这两个 jar 包的路径。</p>
<p>在 buildscript 当中随便找个位置打断点，启动调试之后，就可以看到下面的情景，顺着 classloader 就可以看到生成的 jar 在 <code>&lt;用户目录&gt;/.gradle/caches/jars-8/</code> 下：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416171142126.png" alt="classpath stage 的脚本编译生成的 jar"></p>
<p>我们找到这个 jar 包，里面正如我们前面所讲，两个类，反编译之后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Program</span> <span class="keyword">extends</span> <span class="title class_">StagedProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> &#123;</span><br><span class="line">        var1.setupEmbeddedKotlinFor(var2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 运行 classpath 阶段的脚本</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Build_gradle</span>(var2, (Project)var2.getTarget());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var1.applyPluginsTo(var2, MultiPluginRequests.EMPTY);</span><br><span class="line">        var1.applyBasePluginsTo((Project)var2.getTarget());</span><br><span class="line">        <span class="comment">// 加载并运行 body 阶段的脚本</span></span><br><span class="line">        var1.evaluateSecondStageOf(<span class="built_in">this</span>, var2, <span class="string">&quot;Project/TopLevel/stage2&quot;</span>, HashCode.fromBytes(...), var1.accessorsClassPathFor(var2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Build_gradle</span> <span class="keyword">extends</span> <span class="title class_">CompiledKotlinBuildscriptBlock</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Project $$implicitReceiver0;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Build_gradle</span><span class="params">(KotlinScriptHost var1, Project var2)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(var1);</span><br><span class="line">      <span class="built_in">this</span>.$$implicitReceiver0 = var2;</span><br><span class="line">      <span class="comment">// 运行 buildscript 块</span></span><br><span class="line">      ((Build_gradle)<span class="built_in">this</span>).buildscript((Function1)<span class="literal">null</span>.INSTANCE);</span><br><span class="line">      <span class="type">Unit</span> <span class="variable">var10001</span> <span class="operator">=</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上我们可以看到 classpath 阶段的脚本运行完之后马上就开始编译、加载和运行 body 阶段的脚本了。</p>
<p>接下来我们再看下 body 阶段，同样断点运行到 body 对应的脚本时，我们可以看到调用栈其实跟 classpath 是一致的，调用顺序是 </p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417093245689.png" alt="脚本的调用顺序"></p>
<p>其中第二个 eval 就是在运行 body 阶段的脚本了：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416170811407.png" alt="body stage 的脚本编译生成的 jar"></p>
<p>这与我们反编译看到的 classpath 当中的 Program 的代码时一致的。</p>
<p>我们也把 body 阶段的 jar 反编译后贴出来，我稍微加了点儿注释，大家可以大致感受一下对应的脚本内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Program</span> <span class="keyword">extends</span> <span class="title class_">ExecutableProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Build_gradle</span>(var2, (Project)var2.getTarget());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Build_gradle</span> <span class="keyword">extends</span> <span class="title class_">CompiledKotlinBuildScript</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Project $$implicitReceiver0;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Delete $$result;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Build_gradle</span><span class="params">(KotlinScriptHost var1, Project var2)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(var1);</span><br><span class="line">      <span class="built_in">this</span>.$$implicitReceiver0 = var2;</span><br><span class="line">       <span class="comment">// 调用 subprojects</span></span><br><span class="line">      <span class="built_in">this</span>.$$implicitReceiver0.subprojects((Action)<span class="literal">null</span>.INSTANCE);</span><br><span class="line">       <span class="comment">// 定义 task &quot;clean&quot;</span></span><br><span class="line">      <span class="type">Project</span> <span class="variable">$this$task$iv</span> <span class="operator">=</span> <span class="built_in">this</span>.$$implicitReceiver0;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name$iv</span> <span class="operator">=</span> <span class="string">&quot;clean&quot;</span>;</span><br><span class="line">       <span class="comment">// task &quot;clean&quot; 的配置代码</span></span><br><span class="line">      <span class="type">Function1</span> <span class="variable">configuration$iv</span> <span class="operator">=</span> (Function1)(<span class="keyword">new</span> <span class="title class_">Function1</span>() </span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(<span class="meta">@NotNull</span> Delete $<span class="built_in">this</span>$task)</span> &#123;</span><br><span class="line">             <span class="comment">// 对应于 group = &quot;build&quot;</span></span><br><span class="line">            $<span class="built_in">this</span>$task.setGroup(<span class="string">&quot;build&quot;</span>);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 对应于 delete(rootProject.buildDir)</span></span><br><span class="line">            Object[] var10001 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">Project</span> <span class="variable">var10004</span> <span class="operator">=</span> Build_gradle.<span class="built_in">this</span>.$$implicitReceiver0.getRootProject();</span><br><span class="line">            Intrinsics.checkExpressionValueIsNotNull(var10004, <span class="string">&quot;rootProject&quot;</span>);</span><br><span class="line">            var10001[<span class="number">0</span>] = var10004.getBuildDir();</span><br><span class="line">            $<span class="built_in">this</span>$task.delete(var10001);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 对应于 task&lt;Delete&gt;(...)，前面的 configuration$iv 对应于 Lambda 表达式</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">$i$f$task</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">Task</span> <span class="variable">var9</span> <span class="operator">=</span> ProjectExtensionsKt.task($<span class="built_in">this</span>$task$iv, name$iv, Reflection.getOrCreateKotlinClass(Delete.class), configuration$iv);</span><br><span class="line">      <span class="built_in">this</span>.$$result = (Delete)var9;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截止目前，我想大家应该能够明白 Gradle Kotlin DSL 脚本是如何运行的了。</p>
<p>接下来我们就看看如何实现扩展的定义。</p>
<h2 id="2-定义一个像-mavenCentral-一样的函数"><a href="#2-定义一个像-mavenCentral-一样的函数" class="headerlink" title="2. 定义一个像 mavenCentral 一样的函数"></a>2. 定义一个像 mavenCentral 一样的函数</h2><p>我们定义一个类似于 mavenCentral 的函数 tencentCloud 来方便我们添加腾讯云的 maven 仓库镜像，并以此来说明扩展的定义有哪些注意事项。最终的效果是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    tencentCloud()</span><br><span class="line">    <span class="comment">//等价于：maven(&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很好写，repositories { … } 的参数的 Receiver 是 RepositoryHandler：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> RepositoryHandler.<span class="title">tencentCloud</span><span class="params">()</span></span> &#123;</span><br><span class="line">    maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来问题就是：我们应该把这个扩展函数写在哪里呢？</p>
<h3 id="2-1-定义在根工程的-build-gradle-kts-当中"><a href="#2-1-定义在根工程的-build-gradle-kts-当中" class="headerlink" title="2.1 定义在根工程的 build.gradle.kts 当中"></a>2.1 定义在根工程的 build.gradle.kts 当中</h3><p>按照我们前面的分析，只要定义在 Gradle 脚本当中，不管写到哪里，都相当于定义了在了 Build_gradle 的构造函数当中，这样一个局部的函数只能在当前范围内使用：</p>
<p><strong>build.gradle.kts(rootProject)</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> RepositoryHandler.<span class="title">tencentCloud</span><span class="params">()</span></span> &#123;</span><br><span class="line">    maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        tencentCloud() <span class="comment">// ERROR!! IDE 可能不报错，但编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        tencentCloud() <span class="comment">// OK，都在 body 阶段的 Build_gradle 构造内部</span></span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>build.gradle.kts(:app)</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        tencentCloud() <span class="comment">// ERROR!! 不在同一个作用域内</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果不理想，但不管怎么样，我们现在已经实现了相同运行阶段的文件范围内的扩展实现。</p>
<h3 id="2-2-定义在-buildSrc-当中"><a href="#2-2-定义在-buildSrc-当中" class="headerlink" title="2.2 定义在 buildSrc 当中"></a>2.2 定义在 buildSrc 当中</h3><p>buildSrc 是一个神奇的存在，工程当中所有的脚本都可以访问到它当中的类和函数。我们可以在 BuildTreePreparingProjectsPreparer 的 prepareProjects 方法当中看到对 buildSrc 的处理：</p>
<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareProjects</span><span class="params">(GradleInternal gradle)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">ClassLoaderScope</span> <span class="variable">baseProjectClassLoaderScope</span> <span class="operator">=</span> parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class="line">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Build buildSrc and export classpath to root project</span></span><br><span class="line">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class="line">	<span class="comment">// Evaluate projects</span></span><br><span class="line">    delegate.prepareProjects(gradle);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 evaluate project 之前，buildSrc 模块的代码就被添加到了 baseProjectClassLoaderScope 当中，这个 classloaderScope 实际上是后续所有 project 的脚本都能访问到的。</p>
<p>这样看来，在 build.gradle.kts 当中任意代码运行之前，buildSrc 的代码就已经在 classpath 当中了，因此把我们的扩展添加到 buildSrc 当中，就能解决整个工程的脚本访问的问题。</p>
<p>至此，我们实现了为整个工程的构建脚本定义扩展。这一点与我们在 buildSrc 当中定义依赖的版本常量的思路实际上也是一致的。</p>
<h3 id="2-3-定义在-init-gradle-kts-当中"><a href="#2-3-定义在-init-gradle-kts-当中" class="headerlink" title="2.3 定义在 init.gradle.kts 当中"></a>2.3 定义在 init.gradle.kts 当中</h3><p>接下来我们就要考虑，有没有什么办法让我的电脑上所有的工程都能支持这个扩展呢？</p>
<p>我们很自然地想到 init.gradle.kts，因为 Gradle 会在处理编译流程之前就加载运行这个脚本；如果我们把它放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 目录下，那么所有的工程在启动编译时都会默认执行这个脚本。</p>
<p>不过事情并不是想想的那样顺利，因为 init.gradle.kts 当中直接定义这个扩展函数也会同样只能在局部范围内有效，达不到我们的目标。</p>
<p>那是不是只要比 project 当中的 buildscript 执行得早，并且我们提前通过常规的 classpath 函数添加依赖，就能让 project 当中的 buildscript 访问到呢？不行。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">beforeProject &#123;</span><br><span class="line">    buildscript &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            mavenLocal()</span><br><span class="line">        &#125;</span><br><span class="line">        dependencies &#123;</span><br><span class="line">            classpath(<span class="string">&quot;com.bennyhuo.gradle:repos:1.0-SNAPSHOT&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把我们的扩展发布到 maven 的仓库当中，然后通过常规的 classpath 的方式引入，我们非常清楚这段代码一定会比我们在工程当中的 buildscript 先运行，但 classpath 调用之后实际上是添加到了 body 阶段的 classloader 当中的，而在 classpath 阶段运行的 buildscript 使用的 classloader 实际上是 body 阶段的父 classloader，因而达不到我们的目的。</p>
<p>那怎么办？经过我反复的调试，暂时没有找到很好的正规途径的办法。</p>
<p>常规操作搞不定就只能骚操作了。思路也很简单，找到加载 buildSrc 的那个 classloader，它其实也是加载运行 classpath 阶段的 buildscript  代码的 classloader，我们在里面添加一下我们自己的依赖即可。重点就在 BuildTreePreparingProjectsPreparer 的 prepareProjects 当中:</p>
<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareProjects</span><span class="params">(GradleInternal gradle)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">ClassLoaderScope</span> <span class="variable">baseProjectClassLoaderScope</span> <span class="operator">=</span> parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class="line">    <span class="comment">// 这个 classloader 被 gradle 持有，我们可以通过 gradle 实例获取到它</span></span><br><span class="line">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Build buildSrc and export classpath to root project</span></span><br><span class="line">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class="line">	<span class="comment">// Evaluate projects</span></span><br><span class="line">    delegate.prepareProjects(gradle);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 buildBuildSrcAndLockClassloader 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBuildSrcAndLockClassloader</span><span class="params">(GradleInternal gradle, ClassLoaderScope baseProjectClassLoaderScope)</span> &#123;</span><br><span class="line">    <span class="type">ClassPath</span> <span class="variable">buildSrcClassPath</span> <span class="operator">=</span> buildSourceBuilder.buildAndGetClassPath(gradle);</span><br><span class="line">    <span class="comment">// 重点看这一句，export 可以添加一个 `ClassPath` 类型的实例</span></span><br><span class="line">    baseProjectClassLoaderScope.export(buildSrcClassPath).lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此只要我们自己也调用一下这个 export 方法，把我们自己编译好的 jar 包作为 ClassPath 传进去，问题就解决了。</p>
<p>当然，上帝在为我们打开了一扇窗户的同时又装上了不锈钢纱窗。事情并不是那么直接就能办到的，因为后面那个 lock，它的意思真的就是 lock。</p>
<p><strong>文件：DefaultClassLoaderScope.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ClassLoaderScope <span class="title function_">export</span><span class="params">(ClassPath classPath)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 必须是非锁定状态，如果已经 lock，这里抛出断言异常</span></span><br><span class="line">    assertNotLocked();</span><br><span class="line">    <span class="comment">// 在解析了所有的 classpath 之后才会创建，buildSrc 添加的时候为 null</span></span><br><span class="line">    <span class="keyword">if</span> (exportingClassLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 命中这个分支</span></span><br><span class="line">        export = export.plus(classPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock 了之后，我们想要直接调用 export 方法来添加我们自己的 jar 包的愿望落空，不过上帝还是给我们的不锈钢纱窗留了一把钥匙的，那就是 Java 反射。我们可以通过反射来直接修改 export，无视 lock 的状态，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.gradle.api.<span class="keyword">internal</span>.GradleInternal</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.<span class="keyword">internal</span>.initialization.DefaultClassLoaderScope</span><br><span class="line"><span class="keyword">import</span> org.gradle.<span class="keyword">internal</span>.classpath.ClassPath</span><br><span class="line"><span class="keyword">import</span> org.gradle.<span class="keyword">internal</span>.classpath.DefaultClassPath</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前脚本所在目录下的 repos-1.0-SNAPSHOT.jar 文件</span></span><br><span class="line"><span class="keyword">val</span> depFile = file(<span class="string">&quot;repos-1.0-SNAPSHOT.jar&quot;</span>)</span><br><span class="line"><span class="comment">// 在 project evaluate 之前调用，比 buildscript 早</span></span><br><span class="line">beforeProject &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == rootProject)&#123;</span><br><span class="line">        <span class="keyword">val</span> gradleInternal = gradle <span class="keyword">as</span> GradleInternal</span><br><span class="line">        <span class="keyword">val</span> field = DefaultClassLoaderScope::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;export&quot;</span>)</span><br><span class="line">        field.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> oldClassPath = field.<span class="keyword">get</span>(gradleInternal.baseProjectClassLoaderScope()) <span class="keyword">as</span> ClassPath</span><br><span class="line">        field.<span class="keyword">set</span>(gradleInternal.baseProjectClassLoaderScope(), oldClassPath + DefaultClassPath.of(depFile))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把扩展函数编译成的 jar 文件也放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 中：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417085046475.png" alt="init 脚本和 jar 依赖的文件路径"></p>
<p>这样运行时就会把这个 jar 添加到 baseProjectClassLoaderScope 当中，所有的工程就都能访问到它了。</p>
<p>需要注意的是，我们的示例是基于 Gradle 7.0 的，不同版本可能会存在差异。</p>
<h3 id="2-4-如果是-Groovy-呢？"><a href="#2-4-如果是-Groovy-呢？" class="headerlink" title="2.4 如果是 Groovy 呢？"></a>2.4 如果是 Groovy 呢？</h3><p>之所以这么麻烦，就是因为我们需要兼顾 Kotlin 的静态类型的特性。如果是 Groovy 版本的特性，那么问题就简单多了，你只需要在 init.gradle 当中添加以下代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">RepositoryHandler.metaClass.tencentCloud &#123;</span><br><span class="line">    delegate.maven &#123;</span><br><span class="line">      url <span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面访问 RepositoryHandler 的 tencentCloud 方法的时候就能够动态调用到这个扩展了。这实际上是 Groovy 元编程的内容，我们就不展开介绍了。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本节我们以实现一个简单的扩展为背景，先了解了一下 Kotlin DSL 的运行机制，接着又给出了在各个范围内实现扩展的方法。</p>
<p>一个很小的需求，实际上需要我们了解的背景知识还是很多的。</p>
<p>很多时候我们的学习和成长都是以点筑面，大厦固然高，但抵不住我一层一层地爬。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Gradle</tag>
        <tag>Groovy</tag>
        <tag>KTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（0）：前言</title>
    <url>//2021/09/25/Java17-Updates-00-foreword/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>2021 年 9月 23 日，Java 17 发布了。</p>
<p>作为一门历史悠久的语言，随着更新频率的提升，Java 在最近几年又逐渐焕发出活力 —— 这当然并不是 Java 做得足够好，而是大环境如此。隔壁 C++ 在经历了十几年才发布 C++ 11 之后，标准更新的频率也明显得到了提升，例如 C++ 14、C++ 17，还有 C++ 20。有意思的是，C++ 比 Java 更早地将协程纳入语言标准，尽管用起来比较费事儿，但总比不断跳票的 Loom 要更实在一些。</p>
<p>对于 Java 新特性的期待，除了前面提到的 Loom 项目当中所带来的对协程的支持以外，还有 Valhalla 项目当中对于值类型的支持。遗憾的是，这二者都没有出现在 Java 17 的更新当中。不过，Java 17 也带来不少有用的内容，例如更安全的外部函数访问 API，转正的密封类等等。</p>
<p>当然，Java 的更新有时候也是看着热闹，真正能够用起来还是需要一些时间的。毕竟想要体验这些新特性，我们还需要升级 JDK 版本。不过，这并不影响我们尽早了解 Java 版本更新的内容。接下来，我们会用一系列文章来详细介绍 Java 17 的更新内容，希望能够为大家做个参考。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（1）：更快的 LTS 节奏</title>
    <url>//2021/09/26/Java17-Updates-01-intro/</url>
    <content><![CDATA[<blockquote>
<p>2021 年 9月 23 日，Java 17 发布了，更新的内容还真不少，足足肝了我一星期才把这些内容整理完。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>朋友们大家好，我是 bennyhuo，今天我们来聊聊 Java 17 的更新。</p>
<p>Java 17 更新了，作为一个 10 年的 Java 程序员，还是有亿点点兴奋的，Kotlin 的群里面也是各种讨论 Java 的新特性。</p>
<p>我记得五六年前，谈论起当时刚刚进入人们视野不久的 Java 8，大家还是一副“我们公司还在用 Java 6” 的表情，现在想想 <a href="https://github.com/luontola/retrolambda">RetroLambda</a> 都已经是很久远的事儿了：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920110824409.png"></p>
<p>现在的 Java 8 可能大概相当于那时候的 Java 6，在使用上已经非常普遍了，甚至已经有一点儿过时：就连 Android 最近也开始从最新的 Android Studio 版本开始把 Java 11 作为默认版本了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-01/image-20210926071213288.png" alt="image-20210926071213288"></p>
<p>现在 Java 17 的发布，让 Java 11 成了 LTS 系列的次新版本，Java 8 离老破小的距离也越来越近了 —— 不仅如此，Java 官方还想要加快这个节奏，因为他们打算把 LTS 发布的节奏从三年缩短到两年。这么看来，下一个 LTS 将会是在 2023 年 9 月发布的 Java 21。</p>
<p>想当年，Java 的版本发布以前是何其佛系，版本号也是 1.x 这样一路走来，从 1.0 （1996 年） 发布到 1.5（2004年） 就花了近 10 年，然后又花了差不多 10 年到了 1.8（2014 年）。这其中从 1.5 开始启用了新的版本号命名方式，即  Java SE 5，Java SE 8 这样的叫法。直到现在，2021 年，不管 Java 有没有变化，Java 的版本号已经发生了质的飞跃。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F19CE1C.jpg"></p>
<p>从 2017 年 9 月发布 Java 9 开始，Java 进入每 6 个月一个版本的节奏。这对于开发者来讲是好事，喜欢尝鲜的开发者可以很快地在非 LTS 版本当中体验到 Java 的新特性。</p>
<p>做出这个改变的时间点是非常微妙的，因为 Kotlin 1.0 是 2016 年 2 月发布的，Google 在 2017 年 5 月官宣 Kotlin 为 Android 的一级开发语言（首选语言的宣布是在 2019 年的 IO 大会上）。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-01-intro/02EFAF65.jpg" alt="img"></p>
<p>后来我们就看到，Java 越来越像 Kotlin 了，Java 10 有了 var：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// infers ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream();         <span class="comment">// infers Stream&lt;String&gt;</span></span><br></pre></td></tr></table></figure>

<p>Java 13 有了多行字符串字面量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              &lt;HTML lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                      &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Java 14 有了 switch 表达式（12 开始预览）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ndays</span> <span class="operator">=</span> <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">    <span class="keyword">case</span> JAN, MAR, MAY, JUL, AUG, OCT, DEC -&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> APR, JUN, SEP, NOV -&gt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> FEB -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>) <span class="keyword">yield</span> <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>) <span class="keyword">yield</span> <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">yield</span> <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">yield</span> <span class="number">28</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Java 16 加入了类型判断的模式匹配（Java 14 开始预览），以下示例在效果上类似于 Kotlin 的智能类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    System.out.println( s.length() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有数据类（Java 14 开始预览）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println( p.x() );</span><br></pre></td></tr></table></figure>

<p>可以说，Java 重新焕发了生机，喜欢 Java 的开发者们再也不必等待漫长的版本更新了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F181E49.png"></p>
<p>然后更有趣的事情发生了。Java 就这么疯狂的发版发了三年之后，Kotlin 慌了，它终于在花了将近两年时间憋完 1.4 这个编译器重写的大版本之后宣布，后续每半年发一个版本。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-01-intro/02F416C6.jpg" alt="img"></p>
<p>哈哈，看来我再也不用发愁选题了。​做为一个最近专注于发 C++ 视频的 Kotlin 补刀师，连续研究了一周 Java 17 的更新，真是给我乐坏了：你们快卷起来啊。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F17BC34.jpg"></p>
<p>好了，这一篇算是这一系列的开篇，为了降低大家的阅读成本，我会把主要的更新内容，其实就是合入的 JEP 拆成了十几篇文章，后面尽快发出来。另外，有些比较有意思的内容，我也许大概率也会提供配套视频介绍，欢迎大家关注我的 Bilibili 频道：<strong>bennyhuo 不是算命的</strong>。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</title>
    <url>//2021/09/26/Java17-Updates-02-strictfp/</url>
    <content><![CDATA[<blockquote>
<p>strictfp 可能是最没有存在感的关键字了，很多人写了多年 Java 甚至都不知道它的存在。接下来，它也没有必要继续存在了。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>我们今天聊的内容来自于 <strong>JEP 306: Restore Always-Strict Floating-Point Semantics</strong>。看到这个提案的标题的时候，我就知道很多人懵了。这玩意历史感太强了，说实话我也没怎么接触过。</p>
<p>Java 17 刚发布的那天 Kotlin 的群里短暂地提到了这一条，结果大家都以为是这玩意儿：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920115213009.png"></p>
<p>看到 0.3 后面那高贵的 4 了吗，正是因为它的存在，0.1 + 0.2 跟 0.3 不一样！</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920115849919.png"></p>
<p>这恐怕没什么令人惊喜的，稍微有点儿踩坑经历的小伙伴都不会这么被坑，对吧，对吧，对吧。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-02-strictfp/062286BF.jpg"></p>
<p>说起这事儿，我以前做地图业务的时候经常需要用到经纬度，为了防止精度丢失，在计算之前都要先把经纬度乘以 10^6 转成整型。我当年刚入职腾讯地图的第一天，隔壁的大哥就因为给某常年被教做产品的聊天 APP 接入地图 SDK 时遇到了 Marker 反复横跳的事情，后来分析就是跟精度有关。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F289456.gif"></p>
<p>那么，strict fp 跟这个高贵的 4 有关系吗？如果有关系，那这次更新是特意加入了这个高贵的 4 吗？显然不应该这么搞笑。因为这个高贵的 4 其实是源自于 IEEE 754 对浮点型的定义，编程语言只要是按照标准实现了浮点型，结果都是一样的：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920120237334.png"></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920120509082.png"></p>
<p>所以这个 strict fp 是什么呢？</p>
<p>Java 从 1.2 开始引入了一个关键字：strictfp，字面意思就是严格的浮点型。这玩意儿居然还有个关键字，可见其地位还是很高的。</p>
<p>那么问题来了，为什么要引入这么个奇怪的东西呢？我翻了翻文档发现（不然还能怎样，那个时候我才刚开始学五笔。。。），在上世纪 90 年代，Java 虚拟机为了保持原有的浮点型语义，在兼容 x86 架构的处理器上执行 x87 指令集（是 x86 指令集的一个关于浮点型的子集）的情况时开销很大，性能上令人很不满意，于是加入 strictfp 来表示原有的浮点型语义（即 IEEE 754 规定的那样），而默认的浮点型则采用了更加宽松的语义，这样算是一个折中的方案。必要时使用 strictfp 很多时候就是为了确保 Java 代码的可移植性，这其实也不难理解。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-02-strictfp/0628CDCD.jpg" alt="img"></p>
<p>不过，这个问题很快得到了解决。在 SSE2 (Streaming SIMD Extensions 2) 扩展指令集随着奔腾 4 发布以后，Java 虚拟机有了更直接的方式来实现严格的浮点型语义，于是这个问题就不再存在了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-02-strictfp/9dbd94d5aa4448d2b5587089792ab426.jpeg" alt="普通而又自信的 Intel"></p>
<p>显然，对于我们绝大多数程序员来讲，特别是后来的所有 Android 开发者来讲，这个问题根本不存在，这更新简直跟没更一样。说着我还看了一眼旁边的 Apple Silicon，你说是不是呢 M1？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F3D274E.jpg"></p>
<p>当然，如果你对这个更新点感兴趣，我建议你翻一下老版本当中的 StrictMath 类。在这里，你还可以看到一些 strictfp 的使用场景 —— 而在 Java 17 当中，StrictMath 已经完全沦为 Math 的马甲了。 </p>
<p><strong>Java 16（源码来自于 Liberica JDK）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StrictMath.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="type">double</span> <span class="title function_">toRadians</span><span class="params">(<span class="type">double</span> angdeg)</span> &#123;</span><br><span class="line">    <span class="comment">// Do not delegate to Math.toRadians(angdeg) because</span></span><br><span class="line">    <span class="comment">// this method has the strictfp modifier.</span></span><br><span class="line">    <span class="keyword">return</span> angdeg * DEGREES_TO_RADIANS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 17（源码来自于 Oracle JDK）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StrictMath.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toRadians</span><span class="params">(<span class="type">double</span> angdeg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.toRadians(angdeg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也不妨看一下 Android 的实现：</p>
<p><strong>Android 30</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="type">double</span> <span class="title function_">toRadians</span><span class="params">(<span class="type">double</span> angdeg)</span> &#123;</span><br><span class="line">    <span class="comment">// Do not delegate to Math.toRadians(angdeg) because</span></span><br><span class="line">    <span class="comment">// this method has the strictfp modifier.</span></span><br><span class="line">    <span class="keyword">return</span> angdeg / <span class="number">180.0</span> * PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android 的 JDK 代码来自于 OpenJDK，连注释都没改过。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/6F46F0FB.gif"></p>
<p>好啦，关于 Java 浮点型的语义调整的更新我们就简单介绍这么多。反正说多了也没啥用，知道怎么出去吹牛就行了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Strictfp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（3）：随机数生成器来了一波稳稳的增强</title>
    <url>//2021/09/27/Java17-Updates-03-random/</url>
    <content><![CDATA[<blockquote>
<p>JDK 当中的随机数生成器其实对于普通开发者来讲基本够用，不过对于一些比较复杂的场景来讲，原有的类结构对扩展并不是很友好。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>这一条更新来自：<strong>JEP 356: Enhanced Pseudo-Random Number Generators</strong>，相比之下，这一条实用多了。</p>
<p>我们都用过随机数，不过一般情况下我们很少去认真的对待随机数的具体结果，就好像它是真的随机一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 Random 类，JDK 当中还提供了另外几个随机数的成员：</p>
<ul>
<li>ThreadLocalRandom：顾名思义，提供线程间独立的随机序列。它只有一个实例，多个线程用到这个实例，也会在线程内部各自更新状态。它同时也是 Random 的子类，不过它几乎把所有 Random 的方法又实现了一遍。</li>
<li>SplittableRandom：非线程安全，但可以 fork 的随机序列实现，适用于拆分子任务的场景。</li>
</ul>
<p>ThreadLocalRandom 继承自 Random，而 SplittableRandom 与它俩则没什么实际的关系，因此如果我们在代码当中想要动态切换 Random 和 SplittableRandom 就只能定义两个成员，并且在用到的地方做判断：</p>
<p><strong>Java 16</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SplittableRandom</span> <span class="variable">splittableRandom</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">useSplittableRandom</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (useSplittableRandom) &#123;</span><br><span class="line">   nextInt = splittableRandom.nextInt();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextInt = random.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且如果想要自己扩展随机数的算法，也只能自己去实现，原有的定义方式缺乏一个统一的接口。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/70DF0D1E.gif"></p>
<p>Java 17 为了解决这个问题，定义了几个接口：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920200204792.png"></p>
<p>这样我们就可以面向接口编程啦~</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/70DF7260.jpg"></p>
<p>另外，尽管各个实现的细节不太一样，但思路基本上一致，因此老版本当中的几个随机数的类当中存在大量重复或者相似的代码。连 JDK 都存在 CV 代码的情况，那我们为了快速实现需求 CV 代码也不丢人，对不。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/70E0D77D.jpg"></p>
<p>Java 17 把这些高度相似的逻辑抽了出来，搞了一个新的类：RandomSupport，又一个 3000 行的 Java 文件。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920200711381.png"></p>
<p>所以以前：</p>
<p>**Java 16  **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Random.java</span></span><br><span class="line"><span class="keyword">public</span> DoubleStream <span class="title function_">doubles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.doubleStream</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">RandomDoublesSpliterator</span></span><br><span class="line">         (<span class="built_in">this</span>, <span class="number">0L</span>, Long.MAX_VALUE, Double.MAX_VALUE, <span class="number">0.0</span>),</span><br><span class="line">         <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SplittableRandom.java</span></span><br><span class="line"><span class="keyword">public</span> DoubleStream <span class="title function_">doubles</span><span class="params">(<span class="type">long</span> streamSize, <span class="type">double</span> randomNumberOrigin,</span></span><br><span class="line"><span class="params">                            <span class="type">double</span> randomNumberBound)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (streamSize &lt; <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(BAD_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!(randomNumberOrigin &lt; randomNumberBound))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(BAD_RANGE);</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.doubleStream</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">RandomDoublesSpliterator</span></span><br><span class="line">         (<span class="built_in">this</span>, <span class="number">0L</span>, streamSize, randomNumberOrigin, randomNumberBound),</span><br><span class="line">         <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有相似的地方吧。我们再来看看 Java 17 的实现：</p>
<p><strong>Java  17</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Random.java</span></span><br><span class="line"><span class="keyword">public</span> DoubleStream <span class="title function_">doubles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AbstractSpliteratorGenerator.doubles(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SplittableRandom.java</span></span><br><span class="line"><span class="keyword">private</span> AbstractSplittableGeneratorProxy proxy;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> DoubleStream <span class="title function_">doubles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> proxy.doubles();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">AbstractSplittableGeneratorProxy</span> <span class="keyword">extends</span> <span class="title class_">AbstractSplittableGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SplittableRandom.<span class="built_in">this</span>.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SplittableRandom.<span class="built_in">this</span>.nextLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.util.SplittableRandom <span class="title function_">split</span><span class="params">(SplittableGenerator source)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SplittableRandom</span>(source.nextLong(), mixGamma(source.nextLong()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个 AbstractSplittableGenerator 就定义在 RandomSupport.java 当中，是 RandomSupport 一个内部类。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/70E83674.jpg"></p>
<p>你以为这就没了？不是的。提案的说明当中提到，提案的目标不是实现很多的随机数产生算法，不过这次还是添加了一些常见的实现，所以你会在 JDK 17 当中看到多了一个模块：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920201524206.png"></p>
<p>这些实现都有自己的名字，用注解标注出来，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RandomGeneratorProperties(</span></span><br><span class="line"><span class="meta">        name = &quot;L32X64MixRandom&quot;,</span></span><br><span class="line"><span class="meta">        group = &quot;LXM&quot;,</span></span><br><span class="line"><span class="meta">        i = 64, j = 1, k = 32,</span></span><br><span class="line"><span class="meta">        equidistribution = 1</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">L32X64MixRandom</span> <span class="keyword">extends</span> <span class="title class_">AbstractSplittableWithBrineGenerator</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过名字来获取它们的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">random</span> <span class="operator">=</span> RandomGenerator.of(<span class="string">&quot;L32X64MixRandom&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/70EF16B5.jpg"></p>
<p>好啦，关于随机数的更新又讲完啦。你不会又觉得这玩意没啥用吧。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-03-random/07E713C6.jpg" alt="img"></p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Random</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（4）：这波更新，居然利好 mac 用户</title>
    <url>//2021/09/27/Java17-Updates-04-mac/</url>
    <content><![CDATA[<blockquote>
<p>mac 这几年的变化还是挺大的，Java 也必须做一些适应性的变化，不然都没法外接高分显示器了。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>关于 mac 的更新一共两条，我们来一一介绍给大家。</p>
<h2 id="JEP-382-New-macOS-Rendering-Pipeline"><a href="#JEP-382-New-macOS-Rendering-Pipeline" class="headerlink" title="JEP 382: New macOS Rendering Pipeline"></a>JEP 382: New macOS Rendering Pipeline</h2><p>不知道大家在 macOS 上用 IntelliJ IDEA 或者 Android Studio 会不会觉得卡，就是在本地打字打出了远程控制的感觉的那种卡。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-04-mac/07EE223B.gif" alt="img"></p>
<p>解决办法也很简单，把窗口调小一点儿就行。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920202342410.png"></p>
<p>我有个 2015 款的 MacBook Pro，之前我用它连 4K 外接显示器写代码，发现很快电脑就发烫发热，IDE 也会卡得不成样子。一开始我以为是我的电脑快不行了，后来我发现很多用最新款 MacBook 的人也在抱怨 IntelliJ IDEA 的垃圾性能。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/0033dr8Dgy1gskvcr4481g603w02naa802.gif"></p>
<p>给 JetBrains 报 Bug，结果发现人家大哥把锅甩给了 JDK。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920204103615.png"></p>
<p>JDK 也不客气，直接用 IntelliJ IDEA 做测试：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920204435651.png"></p>
<p>简单来说就是 Mac 上以前 Java 2D 的 API 是基于 OpenGL 的，从 Java 17 开始则提供了基于最新的 Metal Framework 的实现。目前默认还是基于 OpenGL，这样对于线上的程序几乎没有负面影响，如果大家需要启用 Metal 的支持，则需要在虚拟机参数当中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dsun.java2d.metal=true</span><br></pre></td></tr></table></figure>

<p>Metal 在后面也应该会成为默认选择。</p>
<p>所以这条更新，建议使用 Mac 的小伙伴们密切关注，也建议开发 Mac 桌面程序的小伙伴尽快适配。</p>
<p>（跟我有什么关系，Windows 11 YYDS! ）</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/7103A24A.png"></p>
<p>对了，我在 Mac M1 上下载了 Java 17 的 arm64 版本（下一条将会提到），然后用 AppCode（JetBrains 全家桶当中用来写 iOS 程序的 IDE） 替换了这个 JDK，并在 JVM 参数当中配置了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dsun.java2d.metal=true</span><br><span class="line"></span><br><span class="line">--add-opens=java.desktop/java.awt.event=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/sun.font=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/java.awt=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/sun.awt=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.lang=ALL-UNNAMED</span><br><span class="line">--add-opens=java.base/java.util=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/javax.swing=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/sun.swing=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/javax.swing.plaf.basic=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/java.awt.peer=ALL-UNNAMED</span><br><span class="line">--add-opens=java.desktop/javax.swing.text.html=ALL-UNNAMED</span><br></pre></td></tr></table></figure>

<p>外接 4K 显示器以后，代码编写和代码提示的速度有了明显的提升，大家可以试试看（后面的一堆 –add-opens 是为了任意访问没有在 module 当中声明公开的 API，这个策略 Java 17 也有调整，我们后面会讲到）。</p>
<h2 id="JEP-391-macOS-AArch64-Port"><a href="#JEP-391-macOS-AArch64-Port" class="headerlink" title="JEP 391: macOS/AArch64 Port"></a>JEP 391: macOS/AArch64 Port</h2><p>噗。。。还记得我司刚给小伙伴们发了一台高贵的 Apple Silicon 的 Air 的时候，有大佬还专门写教程告诉我们去哪儿找 <a href="https://www.azul.com/downloads/?version=java-11-lts&os=macos&architecture=arm-64-bit&package=jdk">arm64 的 JDK</a>：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920204728153.png"></p>
<p>这回 Java 官方终于也支持了，直接到 <a href="https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html">Oracle 的网站</a>上就能下载，要知道 Java 16 的时候还只有 x86 的版本：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210920204910901.png"></p>
<p>哎，等等，下面的 DMG Installer 是不是丢了个 Arm 啊。。这得扣钱啊小编。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/710ABDBF.jpg"> </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这两条更新对于 mac 用户来讲还是很有用的，可能会对开发效率的提升影响比较大。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</title>
    <url>//2021/09/28/Java17-Updates-05-removed/</url>
    <content><![CDATA[<blockquote>
<p>这次更新有好几条关于移除老代码的，我们来集中介绍一下。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>这一次我们主要给大家介绍一下 Java 17 当中移除的这些老古董们。</p>
<h2 id="JEP-398-Deprecate-the-Applet-API-for-Removal"><a href="#JEP-398-Deprecate-the-Applet-API-for-Removal" class="headerlink" title="JEP 398: Deprecate the Applet API for Removal"></a>JEP 398: Deprecate the Applet API for Removal</h2><p>这一条对大家的影响几乎没有。</p>
<p>大多数 Java 程序员应该接触过 Servlet，其实在浏览器端对应的还有个 applet，但那已经是很早的时候的东西了。十几年前我开始学 Java 的时候，applet 就已经几乎没有应用场景了，谁又想在打开个网页的时候还要启动一个 Java 虚拟机呢？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-05-removed/07F84061.jpg" alt="img"></p>
<p>随着浏览器对 JavaScript 的支持越来越完善，在浏览器端开发程序的需求都可以轻松地被 JavaScript 满足。终于在 Java 9 发布的时候，applet 被标记为废弃，在 Java 17 它被进一步标记为移除了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated(since = &quot;9&quot;, forRemoval = true)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Applet</span> <span class="keyword">extends</span> <span class="title class_">Panel</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这意味着在 JDK 17 当中，我们还是可以看到 Applet 的，不过它即将在未来的版本当中彻底消失。</p>
<h2 id="JEP-407-Remove-RMI-Activation"><a href="#JEP-407-Remove-RMI-Activation" class="headerlink" title="JEP 407: Remove RMI Activation"></a>JEP 407: Remove RMI Activation</h2><p>这个是远程调用相关的一套 API，由于这个东西的维护成本越来越高，用得人越来越少，Java 官方决定把它干掉。实际上这套 API 在 Java 8 被标记为可选，Java 15 被标记为废弃，也算是留足了时间了。</p>
<p>需要注意的是，移除的只是 java.rmi.activation 包，其他远程调用的能力都不受影响。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-05-removed/07FA787F.jpg" alt="img"></p>
<h2 id="JEP-410-Remove-the-Experimental-AOT-and-JIT-Compiler"><a href="#JEP-410-Remove-the-Experimental-AOT-and-JIT-Compiler" class="headerlink" title="JEP 410: Remove the Experimental AOT and JIT Compiler"></a>JEP 410: Remove the Experimental AOT and JIT Compiler</h2><p>这里提到的 AOT（即 Ahead of time）编译器和 JIT（即 Just in time）编译器是基于 Graal 编译器（使用 Java 实现）开发而来的，它们分别在 Java 9 和 Java 10 被引入 JDK 并开始试验，不过很少有人用它们。</p>
<p>我们知道 Java 代码编译之后生成虚拟机字节码，由虚拟机负责解释执行。由于字节码并不是机器码，因此笼统的说 Java 代码的执行效率并不如 C/C++ 这样的 Native 语言（当然实际情况要看具体场景，也跟虚拟机的优化有很大的关系）。既然 Native 的机器码执行效率更高，那么我们是不是可以直接把字节码编译成机器码，然后再去执行呢？听上去确实是一个好主意。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/747224F9.gif"></p>
<p>这也就是 AOT 的由来了。移动端对于性能更加敏感，因而我们更多的时候听到 AOT 这个词是在对 Android ART 和 Flutter 的文档当中。</p>
<p>JIT 则是在运行的时候对热点代码的实时编译，这个其实 Java 虚拟机一直都有对应的实现（只不过是 C++ 写的）。</p>
<p>这里要移除的就只是基于 Graal 编译器实现的这俩个实验当中的编译器，理由呢，也很直接：没人用，还难以维护，投入产出比太低了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/74783920.gif"></p>
<p>当然，这也不是说 Java 就不能编译成 Native 二进制可执行程序直接运行，因为我们还有 <a href="https://www.graalvm.org/">GraalVM</a>，这家伙居然还支持 Node.js 和 Ruby：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210921125108617.png"></p>
<p>额，还有 Python、R 和 LLVM：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210921125151101.png"></p>
<p>还叫板 LLVM，有点儿东西哦~</p>
<h2 id="JEP-411-Deprecate-the-Security-Manager-for-Removal"><a href="#JEP-411-Deprecate-the-Security-Manager-for-Removal" class="headerlink" title="JEP 411: Deprecate the Security Manager for Removal"></a>JEP 411: Deprecate the Security Manager for Removal</h2><p>与 applet 类似，SecurityManager 也被标记为废弃且即将移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated(since=&quot;17&quot;, forRemoval=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityManager</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>一般业务开发不太会用到这个东西，我们就不过多介绍了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/7580BB3C.jpg"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java 官方在决定废弃这几个东西的时候，其实也做了广泛的调查，可能主要还是发现没什么人用吧（当然还有的是他们不希望我们用）。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Applet</tag>
        <tag>Rmi</tag>
        <tag>Aot</tag>
        <tag>Jit</tag>
        <tag>Securitymanager</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</title>
    <url>//2021/10/02/Java17-Updates-06-internals/</url>
    <content><![CDATA[<blockquote>
<p>说实话，我们总是用人家 JDK 的内部 API，是不是有点儿欺负人。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>今天我们来聊聊 <strong>JEP 403: Strongly Encapsulate JDK Internals</strong>。这一条对于使用 JDK 内部 API 的应用场景来讲会比较受影响。</p>
<p>JDK 的动作还是很慢的，它给开发者提供了相当长的过渡期。从 Java 9 引入模块化开始，JDK 对于其内部的 API 的访问限制就已经明确开始落地，只是当时我们可以通过配置启动参数 –illegal-access 来继续使用 JDK 的内部 API，其中 Java 9 - Java  15 这个参数默认 permit，Java 16 默认 deny。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-06-internals/0B223765.jpg"></p>
<p>不过，现在不可以了。在 Java 17 当中使用 –illegal-access 将会得到以下警告，并且没有任何效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Ignoring option --illegal-access=permit; support was removed in 17.0</span><br></pre></td></tr></table></figure>

<p>按照提案的说明，被严格限制的这些内部 API 包括：</p>
<ul>
<li> java.* 包下面的部分非 public 类、方法、属性，例如 Classloader 当中的 defineClass 等等。</li>
<li>sun.* 下的所有类及其成员都是内部 API。</li>
<li>绝大多数 com.sun.* 、 jdk.* 、org.* 包下面的类及其成员也是内部 API。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.beans;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WeakCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Reference&lt;V&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;K, Reference&lt;V&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123; ... &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 java.desktop 模块下有这么一个类，非常简单，就是对 WeakHashMap 做了个包装。我想要用一下它，我该怎么办呢？</p>
<p>复制一份到我的工程里面。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/738DD603.png"></p>
<p>不是，不是。。。优秀的程序员不应该 CV 代码。。。所以我直接使用它。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210921083515465.png"></p>
<p>啊，不行。那我可以反射呀~ 我可真是个小机灵鬼。这波反射下来真是无人能敌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">weakCacheClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.sun.beans.WeakCache&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">weakCache</span> <span class="operator">=</span> weakCacheClass.getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="type">var</span> <span class="variable">putMethod</span> <span class="operator">=</span> weakCacheClass.getDeclaredMethod(<span class="string">&quot;put&quot;</span>, Object.class, Object.class);</span><br><span class="line">    <span class="type">var</span> <span class="variable">getMethod</span> <span class="operator">=</span> weakCacheClass.getDeclaredMethod(<span class="string">&quot;get&quot;</span>, Object.class);</span><br><span class="line">    putMethod.invoke(weakCache, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;bennyhuo&quot;</span>);</span><br><span class="line">    System.out.println(getMethod.invoke(weakCache, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/7352D343.gif"></p>
<p>满怀欣喜的运行它。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalAccessException: <span class="keyword">class</span> <span class="title class_">com</span>.bennyhuo.java17.ReflectionsInternal cannot access <span class="keyword">class</span> <span class="title class_">com</span>.sun.beans.WeakCache (in <span class="keyword">module</span> java.desktop) because <span class="keyword">module</span> java.desktop does not export com.sun.beans to unnamed <span class="keyword">module</span> @776ec8df</span><br><span class="line">	at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:<span class="number">392</span>)</span><br><span class="line">	at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:<span class="number">674</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:<span class="number">489</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">480</span>)</span><br><span class="line">	at com.bennyhuo.java17.ReflectionsInternal.useWeakCache(ReflectionsInternal.java:<span class="number">16</span>)</span><br><span class="line">	at com.bennyhuo.java17.ReflectionsInternal.main(ReflectionsInternal.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>en？？？这让我想起了 Android P，你看这个字母 P，它的发音充满了挑衅，它的形状还有点儿像官方在嘲笑我们</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/73940E6B.gif"></p>
<p>现在 Java 17 也玩这个啊，反射都不行了啊这。。</p>
<p>Java 16 我们可以通过在运行时加入 <code>--illegal-access=permit</code> 来运行，虽然会有一堆警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># java --illegal-access=permit com.bennyhuo.java17.ReflectionsInternal</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Option --illegal-access is deprecated and will be removed in a future release.</span><br><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by com.bennyhuo.java17.ReflectionsInternal (file:/mnt/c/Users/benny/WorkSpace/Mario/SourceCode/Java17UpdatesDemo/src/) to constructor com.sun.beans.WeakCache()</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of com.bennyhuo.java17.ReflectionsInternal</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br><span class="line">bennyhuo</span><br></pre></td></tr></table></figure>

<p>不过正如我们前面所说，Java 17 当中这个参数无效了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># java --illegal-access=permit com.bennyhuo.java17.ReflectionsInternal</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Ignoring option --illegal-access=permit; support was removed in 17.0</span><br><span class="line">java.lang.IllegalAccessException: class com.bennyhuo.java17.ReflectionsInternal cannot access class com.sun.beans.WeakCache (in module java.desktop) because module java.desktop does not export com.sun.beans to unnamed module @372f7a8</span><br><span class="line">d</span><br><span class="line">        at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392)</span><br><span class="line">        at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674)</span><br><span class="line">        at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:489)</span><br><span class="line">        at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)</span><br><span class="line">        at com.bennyhuo.java17.ReflectionsInternal.useWeakCache(ReflectionsInternal.java:16)</span><br><span class="line">        at com.bennyhuo.java17.ReflectionsInternal.main(ReflectionsInternal.java:10)</span><br></pre></td></tr></table></figure>

<p>这就是上帝在关门的时候（Java 9），顺便也提醒我们窗户也马上要关上了，还不赶紧滚出去？然后上帝又花了三年把窗户也关上了（Java 17）。不过，它总算是还留了一个通气孔。。。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-06-internals/0B24BC5A.png"></p>
<p>Java 17 当中 –add-opens 仍然有效，通过开启它可以让我们的程序在运行时通过反射访问指定的类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--add-opens java.desktop/com.sun.beans=ALL-UNNAMED</span><br></pre></td></tr></table></figure>

<p>所以，上面的代码想要运行，只能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># java --add-opens java.desktop/com.sun.beans=ALL-UNNAMED com.bennyhuo.java17.ReflectionsInternal</span><br><span class="line"></span><br><span class="line">bennyhuo</span><br></pre></td></tr></table></figure>

<p>所以这波限制是要来真的，赶快跑吧！</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/739B92AC.jpg"></p>
<p>大家也可以参考 <a href="https://cr.openjdk.java.net/~mr/jigsaw/jdk8-packages-strongly-encapsulated">受影响的 API 清单</a> 来规划自己的 JDK 升级。</p>
<p>顺便说一句，著名的 Unsafe 类不在这一波制裁的名单以内，可能是 Unsafe 应用太广泛了吧，而且 Java 官方也没有找到合适的替代品来满足需求，就先放着了（Unsafe 我们在后面访问堆外内存的内容中还会有介绍）。</p>
<p>好啦，关于加强控制内部 API 的限制的更新，我们也就介绍这么多，对大家的影响嘛，应该也不大（只要不升级）。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Internal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（7）：模式匹配要支持 switch 啦</title>
    <url>//2021/10/02/Java17-Updates-07-switch/</url>
    <content><![CDATA[<blockquote>
<p>Java 的 switch 又加强啦！ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>这一次我们来聊聊 **JEP 406: Pattern Matching for switch (Preview)**。这是一个预览特性。</p>
<p>前面我们提到过 Java 16 引入了一个对于 instanceof 的模式匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)o;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个其实从效果上类似于 Kotlin 的智能类型转换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> String) &#123;</span><br><span class="line">    <span class="comment">// now `o` is smart casted to String </span></span><br><span class="line">    println(o.length())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-07-switch/0B330ECC.gif"></p>
<p>不过，模式匹配可以做的事情更多。</p>
<p>Java 17 引入了一个 preview 的特性，可以通过 switch 语句来实现类似的类型模式匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatterPatternSwitch</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个 case 语句，我们都可以使用类型模式匹配，如果 o 的类型是 Integer，那么它就可以匹配到第一个 case 分支，并且在这个分支内部可以用新变量 i 来替代 o。</p>
<p>请注意，switch 语句在 Java 14 正式支持了表达式，有些朋友可能对这个语法不是很熟悉， 每一个 case  语句后面的 <code>-&gt;</code> 都是一个表达式，并且不会落到下一个 case 分支，所以大家也不会在这里看到 break。不仅如此，switch 表达式的参数 o 的类型也做了放宽，我们在后面介绍密封类的时候还可以看到对这一点的运用。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/74379640.jpg"></p>
<p>不仅如此，这次 switch 表达式还添加了对 null 的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFooBar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span>         -&gt; System.out.println(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span> -&gt; System.out.println(<span class="string">&quot;Great&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>           -&gt; System.out.println(<span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以把 null 放到第一个分支来实现空检查了，非常方便。</p>
<p>模式匹配在 Java 的近亲 Scala 上得到了广泛的运用，当然 Scala 的模式匹配要复杂得多，下面是我从 Scala 官网摘的例子：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span>(<span class="params">sender: <span class="type">String</span>, title: <span class="type">String</span>, body: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SMS</span>(<span class="params">caller: <span class="type">String</span>, message: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiceRecording</span>(<span class="params">contactName: <span class="type">String</span>, link: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Notification</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showNotification</span></span>(notification: <span class="type">Notification</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  notification <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Email</span>(sender, title, _) =&gt; <span class="string">s&quot;You got an email from <span class="subst">$sender</span> with title: <span class="subst">$title</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SMS</span>(number, message) =&gt; <span class="string">s&quot;You got an SMS from <span class="subst">$number</span>! Message: <span class="subst">$message</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">VoiceRecording</span>(name, link) =&gt; <span class="string">s&quot;You received a Voice Recording from <span class="subst">$name</span>! Click the link to hear it: <span class="subst">$link</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case class 类似于 Java 当中的 record，或者 Kotlin 当中的 data class，我们看到下面的 match 语句当中，<code>case Email(sender, tit le, _)</code> 语句可以直接对待匹配的对象做解构。此外，还可以添加模式守卫（Pattern Guard），例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImportantNotification</span></span>(notification: <span class="type">Notification</span>, importantPeopleInfo: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">String</span> = &#123;</span><br><span class="line">  notification <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Email</span>(sender, _, _) <span class="keyword">if</span> importantPeopleInfo.contains(sender) =&gt; <span class="string">&quot;You got an email from special someone!&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SMS</span>(number, _) <span class="keyword">if</span> importantPeopleInfo.contains(number) =&gt; <span class="string">&quot;You got an SMS from special someone!&quot;</span></span><br><span class="line">    <span class="keyword">case</span> other =&gt; showNotification(other) <span class="comment">// nothing special, delegate to our original showNotification function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每一条 case 后面的 if，在匹配的时候，也需要命中 if 后面的表达式。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/74376397.png"></p>
<p>Java 在后续的发展过程当中也许也存在添加这样的语法的可能性。</p>
<p>Kotlin 在演进的过程中曾经也一度想要把 when 表达式做成模式匹配，不过可能是后面觉得模式匹配的实用价值不高（???），就没有继续做下去。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/7436CC1A.gif"></p>
<p>稍微提一下，如果想要体验预览特性，需要为 Java 编译器和 Java 运行时添加 <code>--enable-preview</code> 参数。</p>
<p>好，关于预览的 switch 模式匹配我们就先介绍这么多。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Switch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（8）：密封类终于转正</title>
    <url>//2021/10/02/Java17-Updates-08-sealedclass/</url>
    <content><![CDATA[<blockquote>
<p>Java 看 Kotlin 实现了密封类，马上给自己搞了密封类和密封接口，Kotlin 一看也立马支持了密封接口。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>我们书接上回，继续聊 Java 17 的更新。这篇我们介绍一下 <strong>JEP 409: Sealed Classes</strong>。</p>
<p>密封类从 Java 15 开始预览，Java 16 又预览了一波，终于在 Java 17 转正了（实际上 Java 16 和 17 的密封类是一样的）。</p>
<p>Kotlin 从 1.0 开始就有密封类，并且对子类定义位置的限制从父类内部（Kotlin 1.0）到同一个文件（Kotlin 1.1）再到同一个包内（Kotlin 1.5），但实际使用上没有什么特别大的变化 —— 直到 Java 也支持密封类和密封接口，Kotlin 才也对密封接口做了支持。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-08-sealedclass/0D23EF1D.jpg" alt="img"></p>
<p>从定义上来讲，二者的密封类、接口都是限制直接子类的定义，使得直接子类是可数的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.geometry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">    <span class="keyword">permits</span> com.example.polar.Circle,</span><br><span class="line">            com.example.quad.Rectangle,</span><br><span class="line">            com.example.quad.simple.Square &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>注意，在 Java 当中，密封类的子类的定义也有一些限制，如果父类在具名模块当中，那么子类必须也定义该模块内部；否则，子类就必须定义在父类相同的包当中。如果子类直接定义在父类当中的话，permits 就不用显式写出了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Root</span> &#123; ... </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于密封类的子类来讲，既可以声明为 final 来禁止被继承；也可以声明为 sealed 来使得该子类的直接子类可数；也可以声明为 non-sealed 来使得该子类的子类不受限制。因此我们说密封类可以确保其直接子类可数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B1</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B2</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">Root</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了密封类再配合前面提到的 switch 模式匹配，就很好用了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Root</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Root</span>.A();</span><br><span class="line"><span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">    <span class="keyword">case</span> Root.A a -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> Root.B b -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> Root.C c -&gt; <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对密封接口的支持也是类似的。</p>
<p>密封类实际上也是一个很有用的特性，我之前在介绍 Kotlin 的密封类的时候也已经提到过不少它的用法，例如实现递归列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> T head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> List&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Cons</span><span class="params">(T head, List&lt;T&gt; tail)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = head;</span><br><span class="line">            <span class="built_in">this</span>.tail = tail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Nil</span> <span class="keyword">implements</span> <span class="title class_">List</span>&lt;Object&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Nil</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nil</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Nil</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 List 就只能有 Cons 和 Nil 两个子类，避免它的封装被打破。接下来我们还可以给它添加一些有趣的方法，让它更像一个 List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> Cons&lt;T&gt; cons -&gt; &#123;</span><br><span class="line">                action.accept(cons.head);</span><br><span class="line">                cons.tail.forEach(action);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Nil nil -&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为 List 添加了一个默认的 forEach，这样我们就可以很轻松地迭代它了。为了方便创建 List 的实例，我们再给它添加一个便捷的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">fromArray</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> Nil.INSTANCE;</span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cons</span>&lt;T&gt;(array[array.length - <span class="number">1</span>], Nil.INSTANCE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">Cons</span>&lt;T&gt;(array[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来给出一个简单的用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> List.fromArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="comment">// 输出 1 2 3 4 5</span></span><br><span class="line">    list.forEach(i -&gt; System.out.println(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便提一句，用 Kotlin 实现这段逻辑可不要简单太多：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Nil: List&lt;<span class="built_in">Nothing</span>?&gt;()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T, <span class="keyword">val</span> next: List&lt;T&gt;): List&lt;T&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        List.Nil -&gt; <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">is</span> List.Cons&lt;T&gt; -&gt; &#123;</span><br><span class="line">            block(value)</span><br><span class="line">            next.forEach(block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">listOf</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> values.reversedArray().fold(List.Nil <span class="keyword">as</span> List&lt;T&gt;) &#123; acc, t -&gt;</span><br><span class="line">        List.Cons(t, acc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/746A07D3.gif"></p>
<p>好啦，有关密封类的更新我们就介绍这么多。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Sealed class</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</title>
    <url>//2021/10/02/Java17-Updates-09-foreignapi-memory/</url>
    <content><![CDATA[<blockquote>
<p>使用 Unsafe 直接访问堆外内存存在各种安全性问题，对于使用者的要求也比较高，不太适合在业务当中广泛使用。于是，Java 在新孵化的 API 当中提供了更安全的方案。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<h2 id="JEP-412-Foreign-Function-amp-Memory-API-Incubator"><a href="#JEP-412-Foreign-Function-amp-Memory-API-Incubator" class="headerlink" title="JEP 412: Foreign Function &amp; Memory API (Incubator)"></a>JEP 412: Foreign Function &amp; Memory API (Incubator)</h2><p>接下来，我们来聊聊访问外部资源的新 API，这些内容来自于 **JEP 412: Foreign Function &amp; Memory API (Incubator)**。这个提案主要应对的场景就是调用 Java VM 以外的函数，即 Native 函数；访问 Java VM 以外的内存，即堆外内存（off-heap memory）。</p>
<p>这不就是要抢 JNI 的饭碗吗？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/764F4997.gif"></p>
<p>对，这个提案里面提到的堆外内存和代码访问都可以用 JNI 来做到，不过 JNI 不够好用，还够不安全。</p>
<p>Java 程序员不仅需要编写大量单调乏味的胶水代码（JNI 接口），还要去编写和调试自己本不熟悉（多数 Java 程序员甚至根本不会）的 C、C++ 代码，更要命的是调试工具也没有那么好用。当然，这些都可以克服，只是 Java 和 C、C++ 的类型系统却有着本质的区别而无法直接互通，我们总是需要把传到 C、C++ 层的 Java 对象的数据用类似于反射的 API 取出来，构造新的 C、C++ 对象来使用，非常的麻烦。</p>
<p>说到这个问题，我甚至在公司内见过有人用 C++ 基于 JNI 把 Java 层的常用类型都封装了一遍，你能想象在 C++ 代码当中使用 ArrayList 的情形吗？我当时一度觉得自己精神有些恍惚。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/7657EB7E.jpg"></p>
<p>这些年来 Java 官方在这方面也没有什么实质性的进展。JNI 难用就难用吧，总算还有得用，一些开源的框架例如 JNA、JNR、JavaCPP 都是基于 JNI 做了一些简化的工作，让 Java 与 Native 语言的调用没那么令人难受。</p>
<p>你可能以为这个提案的目的也是搞一个类似的框架，其实不然。Java 官方嘛，不搞就不搞，要搞就搞一套全新的方案，让开发者用着方便，程序性能更好（至少不比 JNI 更差），普适性更强，也更安全 —— 至少，他们是这么想的。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/765D0537.jpg"></p>
<p>稍微提一下，堆外内存访问的 API 从 Java 14 就开始孵化，到 Java 17 连续肝了四个版本了已经，仍然还是 incubator；访问外部函数的 API 则从 Java 16 开始孵化，到现在算是第二轮孵化了吧。如果大家要想在自己的程序里面体验这个能力，需要给编译器和虚拟机加参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--add-modules jdk.incubator.foreign --enable-native-access ALL-UNNAME</span><br></pre></td></tr></table></figure>

<p>由于内容较多，本篇我们只介绍堆外内存的访问。外部函数访问的内容我们放到下一篇介绍。</p>
<h2 id="访问堆外内存"><a href="#访问堆外内存" class="headerlink" title="访问堆外内存"></a>访问堆外内存</h2><p>基于现在的方案，我们有三种方式能访问到堆外内存，分别是</p>
<ul>
<li><p>ByteBuffer（就是 allocateDirect），这个方式用起来相对安全，使用体验也与访问虚拟机堆内存一致，但执行效率相对一般：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Unsafe 的相关方法，这个方式在 JIT 优化之下效率较高，但非常不安全，因为它实际上可以访问到任意位置的内存，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">var</span> <span class="variable">handle</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">8</span>); <span class="comment">// 申请 8 字节内存</span></span><br><span class="line"></span><br><span class="line">unsafe.putDouble(handle, <span class="number">1024</span>); <span class="comment">// 往该内存当中写入 1024 这个 double</span></span><br><span class="line">System.out.println(unsafe.getDouble(handle)); <span class="comment">// 从该内存当中读取一个 double 出来</span></span><br><span class="line"></span><br><span class="line">unsafe.freeMemory(handle); <span class="comment">// 释放这块内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 JNI，通过 C/C++ 直接操作堆外内存。</p>
</li>
</ul>
<p>对于 Java 程序员来讲，效率较高的后两种方式都不是特别友好。</p>
<p>接下来我们看一下新的内存访问方案，它主要解决了分配、访问和作用域等几个问题。</p>
<h3 id="堆外内存分配"><a href="#堆外内存分配" class="headerlink" title="堆外内存分配"></a>堆外内存分配</h3><p>我们可以通过 MemorySegment 来做到这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemorySegment</span> <span class="variable">segment</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">100</span>, ResourceScope.newImplicitScope());</span><br></pre></td></tr></table></figure>

<p>尽管看上去跟前面的 Unsafe 类似，但这里面有很多细节上的差异，因为它对于堆外内存的访问是受限制的，就像访问数组一样更加安全。另外请注意 ResourceScope 这个参数，它会控制分配的堆外内存的作用范围，这个我们会在后面介绍。</p>
<h3 id="堆外内存访问"><a href="#堆外内存访问" class="headerlink" title="堆外内存访问"></a>堆外内存访问</h3><p>在堆外内存开辟以后，我们通常需要按照某种变量的方式去访问它，例如想要以 int 的方式读写，那么就创建一个 VarHandle 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VarHandle</span> <span class="variable">intHandle</span> <span class="operator">=</span> MemoryHandles.varHandle(<span class="type">int</span>.class, ByteOrder.nativeOrder());</span><br></pre></td></tr></table></figure>

<p>这里支持的类型就是基本类型，包括 byte、short、char、int、float、long、double。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">    intHandle.set(segment, <span class="comment">/* offset */</span> i * <span class="number">4</span>, <span class="comment">/* value to write */</span> i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 Java 的 int 占 4 个字节，因此直接对前面开辟的内存 segment 进行读写操作即可。那如果我读写的范围越界会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intHandle.set(segment, <span class="number">100</span> <span class="comment">/* out of bounds!! */</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>运行程序结果发现抛了个异常，这个异常就是 MemorySegment 抛出来的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Out of bound access on segment MemorySegment&#123; id=0x17366e0a limit: 100 &#125;; new offset = 100; new length = 4</span><br></pre></td></tr></table></figure>

<p>这样相比使用 Unsafe 访问内存的好处就在于受控制。</p>
<p>使用 Unsafe 访问堆外内存就好像直接使用 C 指针操作内存一样。C 语言主张相信程序员，所以对于 C 程序员使用指针访问内存不加任何限制。可是在内存管理这个问题上，Java 程序员并不一定像 C 程序员那么可靠。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-09-foreignapi-memory/247072E2.jpg" alt="img"></p>
<p>我们不妨再给大家看看 Unsafe 的例子，看看是不是如同操作 C 指针一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">handle</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作分配的内存之后的部分，实际上这部分内存完全不可预见</span></span><br><span class="line">unsafe.putInt(handle + <span class="number">16</span>, <span class="number">1000</span>); </span><br><span class="line"><span class="comment">// 读取非法内存</span></span><br><span class="line">System.out.println(unsafe.getInt(handle + <span class="number">16</span>)); </span><br><span class="line"></span><br><span class="line">unsafe.freeMemory(handle);</span><br><span class="line"><span class="comment">// 内存已经回收了，仍然可以读</span></span><br><span class="line">System.out.println(unsafe.getInt(handle)); </span><br></pre></td></tr></table></figure>

<p>这样我们就知道 Unsafe 是真的不 safe 啊。不仅如此，一旦忘了释放内存，就会造成内存泄漏。我们甚至无法通过 handle 来判断内存是否有效，对于已经回收的内存，handle 对象不就是野指针了嘛。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/78650EAC.jpg"></p>
<p>除了提升安全性以外，新 API 还提供了一套内存布局相关的 API：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/image-20210923070228075.png"></p>
<p>这套 API 可以降低堆外内存访问的代码复杂度，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SequenceLayout</span> <span class="variable">intArrayLayout</span> <span class="operator">=</span> MemoryLayout.sequenceLayout(<span class="number">25</span>, MemoryLayout.valueLayout(<span class="number">32</span>, ByteOrder.nativeOrder()));</span><br><span class="line"><span class="type">MemorySegment</span> <span class="variable">segment</span> <span class="operator">=</span> MemorySegment.allocateNative(intArrayLayout, newImplicitScope());</span><br><span class="line"><span class="type">VarHandle</span> <span class="variable">indexedElementHandle</span> <span class="operator">=</span> intArrayLayout.varHandle(<span class="type">int</span>.class, PathElement.sequenceElement());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intArrayLayout.elementCount().getAsLong(); i++) &#123;</span><br><span class="line">    indexedElementHandle.set(segment, (<span class="type">long</span>) i, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在开辟内存空间的时候只需要通过 SequenceLayout 描述清楚我们需要什么样的内存（32bit，Native 字节序），多少个（25 个），然后用它去开辟空间，并完成读写。</p>
<ul>
<li>PaddingLayout 会在我们需要的数据后添加额外的内存空间，主要用于内存对齐。</li>
<li>ValueLayout 用来映射基本的数值类型，例如 int、float 等等。</li>
<li>GroupLayout 可以用来组合其他的 MemoryLayout。它有两种类型，分别是 STRUCT 和 UNION。熟悉 C 语言的小伙伴们应该立刻就能明白，它在调用 C 函数的时非常有用，可以用来映射 C 的结构体和联合体。</li>
</ul>
<p>简单来说，在调用 C 函数时，我们可以很方便地使用这些 MemoryLayout 映射到 C 类型。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-09-foreignapi-memory/2476265B.png" alt="img"></p>
<h3 id="堆外内存的作用域"><a href="#堆外内存的作用域" class="headerlink" title="堆外内存的作用域"></a>堆外内存的作用域</h3><p>作用域这个东西实在是关键。</p>
<p>Java 的一大优点就是内存垃圾回收机制。内存都被虚拟机接管了，我们只需要考虑如何使用内存即可，虚拟机就像个大管家一样默默的为我们付出。这极大的降低了程序员管理内存的成本，也极大的降低了程序员在内存操作上犯错误的可能，对比我之前写 C++ 的时候经常因为某个内存错误查到半夜找不到头绪的情况，用 Java 写程序时开发效率的提升真不是一点儿半点儿。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/786BA6D8.gif"></p>
<p>要想让 Java 程序员用得舒服，那必须把堆外内存的管理也尽可能做到简单易用。为此，JDK 引入了资源作用域的概念，对应的类型就是 ResourceScope。这是一个密封接口，它有且仅有一个非密封的实现类 ResourceScopeImpl，JDK 还为这个实现类提供了三种具体的实现：</p>
<ul>
<li>GLOBAL：这实际上是一个匿名内部类对象，它是全局作用域，使用它开辟的堆外内存不会自动释放。</li>
<li>ImplicitScopeImpl：我们在前面演示新 API 的使用时已经提到过，调用 <code>ResourceScope.newImplicitScope()</code> 返回的正是 ImplicitScopeImpl。这种类型的 Scope 不能被主动关闭，不过使用它开辟的内存会在持有内存的 MemorySegment 对象不再被持有时释放。这个逻辑在 CleanerImpl 当中通过 ReferenceQueue 配合 PhantomReference 来实现。</li>
<li>SharedScope：最主要的能力就是提供了多线程共享访问的支持；是 ImplicitScopeImpl 的父类，二者的差别在于 SharedScope 可以被主动关闭，不过必须确保只能被关闭一次。</li>
<li>ConfinedScope：单线程作用域，只能在所属的线程内访问，比较适合局部环境下的内存管理。</li>
</ul>
<p>我们再来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> ResourceScope.newConfinedScope()) &#123;</span><br><span class="line">    <span class="type">MemorySegment</span> <span class="variable">memorySegment</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">100</span>, scope);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子当中我们使用 ConfinedScope 来开辟内存，由于这个 scope 在 try-resource 语句结束之后就会被关闭，因此其中开辟的内存也会在语句结束的时候理解回收。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java 17 为访问堆外内存提供了一套较为完成的 API，试图简化 Java 代码操作堆外内存的难度。从实际的使用体验来看，安全性确实可以得到一定程度上的保障，不过易用性嘛，倒是保持了 Java 的传统，这个我们在下一篇文章当中还会提及。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Direct memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</title>
    <url>//2021/10/02/Java17-Updates-10-foreignapi-callfunction/</url>
    <content><![CDATA[<blockquote>
<p>JNI 不安全还繁琐，所以 Java 搞了一套新的 API，结果把这事儿搞得更复杂了。。。  </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>我们书接上回，接着聊 <strong>JEP 412: Foreign Function &amp; Memory API (Incubator)</strong> 当中访问外部函数的内容。</p>
<h2 id="调用自定义-C-函数"><a href="#调用自定义-C-函数" class="headerlink" title="调用自定义 C 函数"></a>调用自定义 C 函数</h2><p>新 API 加载 Native 库的行为没有发生变化，还是使用 System::loadLibrary 和 System::load 来实现。</p>
<p>相比之前，JNI 需要提前通过声明 native 方法来实现与外部函数的绑定，新 API 则提供了直接在 Java 层通过函数符号来定位外部函数的能力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.loadLibrary(<span class="string">&quot;libsimple&quot;</span>);</span><br><span class="line"><span class="type">SymbolLookup</span> <span class="variable">loaderLookup</span> <span class="operator">=</span> SymbolLookup.loaderLookup();</span><br><span class="line"><span class="type">MemoryAddress</span> <span class="variable">getCLangVersion</span> <span class="operator">=</span> loaderLookup.lookup(<span class="string">&quot;GetCLangVersion&quot;</span>).get();</span><br></pre></td></tr></table></figure>

<p>对应的 C 函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetCLangVersion</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> __STDC_VERSION__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上手段，我们直接获得了外部函数的地址，接下来我们就可以使用它们来完成调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodHandle</span> <span class="variable">getClangVersionHandle</span> <span class="operator">=</span> CLinker.getInstance().downcallHandle(</span><br><span class="line">    getCLangVersion,</span><br><span class="line">    MethodType.methodType(<span class="type">int</span>.class),</span><br><span class="line">    FunctionDescriptor.of(C_INT)</span><br><span class="line">);</span><br><span class="line">System.out.println(getClangVersionHandle.invoke());</span><br></pre></td></tr></table></figure>

<p>运行程序的时候需要把编译好的 Native 库放到 java.library.path 指定的路径下，例如我把编译好的 libsimple.dll 放到了 lib/bin 目录下，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.library.path=./lib/bin</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">201112</span><br></pre></td></tr></table></figure>

<p>可以看出来，我的 C 编译器觉得自己的版本是 C11。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/2486C86A.gif" alt="img"></p>
<h2 id="调用系统-C-函数"><a href="#调用系统-C-函数" class="headerlink" title="调用系统 C 函数"></a>调用系统 C 函数</h2><p>如果是加载 C 标准库当中的函数，则应使用 CLinker::systemLookup，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemoryAddress</span> <span class="variable">strlen</span> <span class="operator">=</span> CLinker.systemLookup().lookup(<span class="string">&quot;strlen&quot;</span>).get();</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">strlenHandle</span> <span class="operator">=</span> CLinker.getInstance().downcallHandle(</span><br><span class="line">    strlen,</span><br><span class="line">    MethodType.methodType(<span class="type">int</span>.class, MemoryAddress.class),</span><br><span class="line">    FunctionDescriptor.of(C_INT, C_POINTER)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">string</span> <span class="operator">=</span> CLinker.toCString(<span class="string">&quot;Hello World!!&quot;</span>, ResourceScope.newImplicitScope());</span><br><span class="line">System.out.println(strlenHandle.invoke(string.address()));</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/24876314.jpg" alt="img"></p>
<h2 id="结构体入参"><a href="#结构体入参" class="headerlink" title="结构体入参"></a>结构体入参</h2><p>对于比较复杂的场景，例如传入结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DumpPerson</span><span class="params">(Person *person)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Person%%%lld(id=%lld, name=%s, age=%d)\n&quot;</span>,</span><br><span class="line">         <span class="keyword">sizeof</span>(Person),</span><br><span class="line">         person-&gt;id,</span><br><span class="line">         person-&gt;name,</span><br><span class="line">         person-&gt;age);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = person;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Person); ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, *p++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况我们首先需要在 Java 当中构造一个 Person 实例，然后把它的地址传给 DumpPerson，这个过程比较复杂，我们分步骤来介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemoryLayout</span> <span class="variable">personLayout</span> <span class="operator">=</span> MemoryLayout.structLayout(</span><br><span class="line">    C_LONG_LONG.withName(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">    MemoryLayout.sequenceLayout(<span class="number">10</span>, C_CHAR).withName(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">    MemoryLayout.paddingLayout(<span class="number">16</span>),</span><br><span class="line">    C_INT.withName(<span class="string">&quot;age&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>首先我们定义好内存布局，每一个成员我们可以指定一个名字，这样在后面方便定位。注意，由于 Person 的 name 只占 10 个字节（我说我是故意的你信吗），因此这里还有内存对齐问题，根据实际情况设置对应大小的 paddingLayout。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/24891F0C.png" alt="img"></p>
<p>接下来我们用这个布局来开辟堆外内存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemorySegment</span> <span class="variable">person</span> <span class="operator">=</span> MemorySegment.allocateNative(personLayout, newImplicitScope());</span><br></pre></td></tr></table></figure>

<p>下面就要初始化这个 Person 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VarHandle</span> <span class="variable">idHandle</span> <span class="operator">=</span> personLayout.varHandle(<span class="type">long</span>.class, MemoryLayout.PathElement.groupElement(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">idHandle.set(person, <span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">ageHandle</span> <span class="operator">=</span> personLayout.varHandle(<span class="type">int</span>.class, MemoryLayout.PathElement.groupElement(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">ageHandle.set(person, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>使用 id 和 name 分别定位到对应的字段，并初始化它们，这两个都比较简单。</p>
<p>接下来我们看下如何初始化一个 char[]。</p>
<p>方法1，逐个写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VarHandle</span> <span class="variable">nameHandle</span> <span class="operator">=</span> personLayout.varHandle(</span><br><span class="line">    <span class="type">byte</span>.class,</span><br><span class="line">    MemoryLayout.PathElement.groupElement(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">    MemoryLayout.PathElement.sequenceElement()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>注意我们获取 nameHandle 的方式，要先定位到 name 对应的布局，它实际上是个 sequenceLayout，所以要紧接着用 sequenceElement 来定位它。如果还有更深层次的嵌套，可以在 varHandle(…) 方法当中添加更多的参数来逐级定位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;bennyhuo&quot;</span>.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    nameHandle.set(person, i, bytes[i]);</span><br><span class="line">&#125;</span><br><span class="line">nameHandle.set(person, bytes.length, (<span class="type">byte</span>) <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>然后就是循环赋值，一个字符一个字符写入，比较直接。不过，有个细节要注意，Java 的 char 是两个字节，C 的 char 是一个字节，因此这里要用 Java 的 byte 来写入。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/248B4835.jpg" alt="img"></p>
<p>方法2，直接复制 C 字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">person.asSlice(personLayout.byteOffset(MemoryLayout.PathElement.groupElement(<span class="string">&quot;name&quot;</span>)))</span><br><span class="line">             .copyFrom(CLinker.toCString(<span class="string">&quot;bennyhuo&quot;</span>, newImplicitScope()));</span><br></pre></td></tr></table></figure>

<p>asSlice 可以通过内存偏移得到 name 这个字段的地址对应的 MemorySegment 对象，然后通过它的 copyFrom 把字符串直接全部复制过来。</p>
<p>两种方法各有优缺点。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/248B5B9E.jpg" alt="img"></p>
<p>接下来就是函数调用了，与前面几个例子基本一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemoryAddress</span> <span class="variable">dumpPerson</span> <span class="operator">=</span> loaderLookup.lookup(<span class="string">&quot;DumpPerson&quot;</span>).get();</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">dumpPersonHandle</span> <span class="operator">=</span> CLinker.getInstance().downcallHandle(</span><br><span class="line">    dumpPerson,</span><br><span class="line">    MethodType.methodType(<span class="keyword">void</span>.class, MemoryAddress.class),</span><br><span class="line">    FunctionDescriptor.ofVoid(C_POINTER)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">dumpPersonHandle.invoke(person.address());</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person%24(id=1000000, name=bennyhuo, age=30)</span><br><span class="line">64, 66, 15, 0, 0, 0, 0, 0, 98, 101, 110, 110, 121, 104, 117, 111, 0, 0, 0, 0, 30, 0, 0, 0, </span><br></pre></td></tr></table></figure>

<p>我们把内存的每一个字节都打印出来，在 Java 层也可以打印这个值，这样方便我们调试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">byte</span> b : person.toByteArray()) &#123;</span><br><span class="line">    System.out.print(b + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<p>以上是单纯的 Java 调用 C 函数的情形。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/248C0DE7.png" alt="img"></p>
<h2 id="函数指针入参"><a href="#函数指针入参" class="headerlink" title="函数指针入参"></a>函数指针入参</h2><p>很多时候我们需要在 C 代码当中调用 Java 方法，JNI 的做法就是反射，但这样会有些安全问题。 新 API 也提供了类似的手段，允许我们把 Java 方法像函数指针那样传给 C 函数，让 C 函数去调用。</p>
<p>下面我们给出一个非常简单的例子，大家重点关注如何传递 Java 方法给 C 函数。</p>
<p>我们首先给出 C 函数的定义，它的功能实际上就是遍历一个数组，调用传入的函数 on_each。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*OnEach)</span><span class="params">(<span class="type">int</span> element)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ForEach</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> length, OnEach on_each)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    on_each(<span class="built_in">array</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 层想要调用 ForEach 这个函数，最关键的地方就是构造 on_each 这个函数指针。接下来我们给出它的 Java 层的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onEach</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;onEach: &quot;</span> + element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把 onEach 转成函数指针，我们只需要通过 MethodHandles 来定位这个方法，得到一个 MethodHandle 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodHandle</span> <span class="variable">onEachHandle</span> <span class="operator">=</span> MethodHandles.lookup().findStatic(</span><br><span class="line">    ForeignApis.class, <span class="string">&quot;onEach&quot;</span>,</span><br><span class="line">    MethodType.methodType(<span class="keyword">void</span>.class, <span class="type">int</span>.class)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>接着获取这个函数的地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MemoryAddress</span> <span class="variable">onEachHandleAddress</span> <span class="operator">=</span> CLinker.getInstance().upcallStub(</span><br><span class="line">    onEachHandle, FunctionDescriptor.ofVoid(C_INT), newImplicitScope()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>再调用 CLinker 的 upcallStub 来得到它的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] originalArray = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">MemorySegment</span> <span class="variable">array</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">4</span> * <span class="number">10</span>, newImplicitScope());</span><br><span class="line">array.copyFrom(MemorySegment.ofArray(originalArray));</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryAddress</span> <span class="variable">forEach</span> <span class="operator">=</span> loaderLookup.lookup(<span class="string">&quot;ForEach&quot;</span>).get();</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">forEachHandle</span> <span class="operator">=</span> CLinker.getInstance().downcallHandle(</span><br><span class="line">    forEach,</span><br><span class="line">    MethodType.methodType(<span class="keyword">void</span>.class, MemoryAddress.class, <span class="type">int</span>.class, MemoryAddress.class),</span><br><span class="line">    FunctionDescriptor.ofVoid(C_POINTER, C_INT, C_POINTER)</span><br><span class="line">);</span><br><span class="line">forEachHandle.invoke(array.address(), originalArray.length, onEachHandleAddress);</span><br></pre></td></tr></table></figure>

<p>剩下的就是构造一个 int 数组，然后再调用 ForEach 这个 C 函数，这与前面调用其他 C 函数的方式是一致的。</p>
<p>运行结果显而易见：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onEach: 1</span><br><span class="line">onEach: 2</span><br><span class="line">onEach: 3</span><br><span class="line">onEach: 4</span><br><span class="line">onEach: 5</span><br><span class="line">onEach: 6</span><br><span class="line">onEach: 7</span><br><span class="line">onEach: 8</span><br><span class="line">onEach: 9</span><br><span class="line">onEach: 10</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-10-foreignapi-callfunction/2490A30F.png" alt="img"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章我们介绍了一下 Java 新提供的这套访问外部函数的 API，相比之下它确实比过去有了更丰富的能力，不过用起来也并不轻松。将来即便正式发布，我个人觉得也需要一些工具来处理这些模板代码的生成（例如基于注解处理器的代码生成框架），以降低使用复杂度。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/88F4535C.gif"></p>
<p>就目前的情况来讲，其实我更愿意用 JNI，不安全怎么了，小心点儿不就行了嘛。算了，写什么垃圾 Java，直接写 C++ 不香吗？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/88F3D38D.gif"></p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Foreign function api</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（11）：支持矢量运算，利好科学计算？</title>
    <url>//2021/10/02/Java17-Updates-11-vector/</url>
    <content><![CDATA[<blockquote>
<p>Java 17 将继续孵化对矢量计算的支持。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>我们这一篇来简单聊聊 **JEP 414: Vector API (Second Incubator)**，之前 Java 16 就已经开始孵化这个项目了。</p>
<p>刚开始看到这个 Vector API，我都懵了，Vector 不是不推荐用吗？后来看到提案的详细内容才明白过来，人家说的是矢量运算，不是我们熟知的那个线程安全的 vector 容器。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/8902C73F.jpg"></p>
<p>在过去，Java 确实没有提供很好的矢量运算的途径，这使得我们只能基于标量计算来构造矢量计算的算法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scalarComputation</span><span class="params">(<span class="type">float</span>[] a, <span class="type">float</span>[] b, <span class="type">float</span>[] c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -<span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是提案当中给出的例子，a、b、c 是三个相同长度的数组，c 实际上是运算结果。</p>
<p>使用新的 Vector API实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">vectorComputation</span><span class="params">(<span class="type">float</span>[] a, <span class="type">float</span>[] b, <span class="type">float</span>[] c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">upperBound</span> <span class="operator">=</span> SPECIES.loopBound(a.length);</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; upperBound; i += SPECIES.length()) &#123;</span><br><span class="line">        <span class="comment">// FloatVector va, vb, vc;</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">va</span> <span class="operator">=</span> FloatVector.fromArray(SPECIES, a, i);</span><br><span class="line">        <span class="type">var</span> <span class="variable">vb</span> <span class="operator">=</span> FloatVector.fromArray(SPECIES, b, i);</span><br><span class="line">        <span class="type">var</span> <span class="variable">vc</span> <span class="operator">=</span> va.mul(va)</span><br><span class="line">            .add(vb.mul(vb))</span><br><span class="line">            .neg();</span><br><span class="line">        vc.intoArray(c, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; a.length; i++) &#123;</span><br><span class="line">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -<span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector API 的基本思想就是批量计算，例子当中的 SPECIES 其实是根据机器来选择合适的分批大小的一个变量。我们可以注意到，在计算时 i 每次增加 SPECIES.length()，这就是分批的大小了。当然，你也可以根据实际情况自己选择，例如调用下面的方法来根据矢量的 shape 来确定大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> FloatSpecies <span class="title function_">species</span><span class="params">(VectorShape s)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(s);</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_64_BIT: <span class="keyword">return</span> (FloatSpecies) SPECIES_64;</span><br><span class="line">        <span class="keyword">case</span> S_128_BIT: <span class="keyword">return</span> (FloatSpecies) SPECIES_128;</span><br><span class="line">        <span class="keyword">case</span> S_256_BIT: <span class="keyword">return</span> (FloatSpecies) SPECIES_256;</span><br><span class="line">        <span class="keyword">case</span> S_512_BIT: <span class="keyword">return</span> (FloatSpecies) SPECIES_512;</span><br><span class="line">        <span class="keyword">case</span> S_Max_BIT: <span class="keyword">return</span> (FloatSpecies) SPECIES_MAX;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bad shape: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 FloatVector 类型，这套 API 提供了诸如 add、mul 这样的方法来方便实现矢量计算，用起来比较方便。</p>
<p>理论上来讲，这套 API 也是可以带来性能上的提升的，但我使用相同的数据调用上述矢量和标量的方法，在提前完成类加载的条件下，粗略得出以下耗时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scalar: 746000ns</span><br><span class="line">vector: 2210400ns</span><br></pre></td></tr></table></figure>

<p>可以看到新的 Vector API 居然更慢。不过这个也不能说明什么，毕竟实际的使用场景是复杂的，而且也跟 CPU 架构密切相关，我的机器是 AMD R9 5900HX，也许在 Intel 上有更好的表现呢（噗。。）。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-11-vector/24990443.png" alt="img"></p>
<p>对了，因为 Java 自身语法的限制，现在的 Vector API 大量用到了装箱和拆箱（这可能是性能消耗的大头），因此预期在 Valhalla 合入之后，基于值类型再做优化可能会得到大幅的性能提升。这么看来应当不是我的 AMD CPU 的问题。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-11-vector/249A05A5.png" alt="img"></p>
<p>不管怎么样，这套东西还在很早期的孵化阶段，API 好用就行，性能的事儿后面会解决的（反正我又不会用到)。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/893AABA9.jpg"></p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</title>
    <url>//2021/10/02/Java17-Updates-12-contextserialfilter/</url>
    <content><![CDATA[<blockquote>
<p>Java 的序列化机制虽然有些问题，不过毕竟亲儿子，更新怎么能落下呢。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/09/25/Java17-Updates-00-foreword/">Java 17 更新（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-01-intro/">Java 17 更新（1）：更快的 LTS 节奏</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/26/Java17-Updates-02-strictfp/">Java 17 更新（2）：没什么存在感的 strictfp 这回算是回光返照了</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-03-random/">Java 17 更新（3）：随机数生成器来了一波稳稳的增强</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/27/Java17-Updates-04-mac/">Java 17 更新（4）：这波更新，居然利好 mac 用户</a></li>
<li><a href="https://www.bennyhuo.com/2021/09/28/Java17-Updates-05-removed/">Java 17 更新（5）：历史包袱有点儿大，JDK 也在删代码啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-06-internals/">Java 17 更新（6）：制裁！我自己私有的 API 你们怎么随便一个人都想用？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-07-switch/">Java 17 更新（7）：模式匹配要支持 switch 啦</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-08-sealedclass/">Java 17 更新（8）：密封类终于转正</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-09-foreignapi-memory/">Java 17 更新（9）：Unsafe 不 safe，我们来一套 safe 的 API 访问堆外内存</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-10-foreignapi-callfunction/">Java 17 更新（10）：访问外部函数的新 API，JNI 要凉了？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-11-vector/">Java 17 更新（11）：支持矢量运算，利好科学计算？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/02/Java17-Updates-12-contextserialfilter/">Java 17 更新（12）：支持上下文的序列化过滤器，又一次给序列化打补丁</a></li>
</ul>
<p>接下来我们介绍 Java 17 合入的最后一个还没介绍的提案：<strong>JEP 415: Context-Specific Deserialization Filters</strong>，这是一条对于反序列化的更新。</p>
<p>Java 的序列化机制一向为人诟病，以至于 Effective Java 里面专门有几条讲 Java 序列化机制的，并且结论是“不要用它”。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/8941D48B.jpg"></p>
<p>这玩意你说咋还不废弃了呢。居然还在不断为了反序列化的安全性修修补补。</p>
<p>算了，我猜你们大概率用不到，不介绍了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/8942EB6A.jpg"></p>
<p>好吧，其实不是，这玩意儿还是很常用的，所以还是介绍一下吧。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-12-contextserialfilter/249FFAAB.png"></p>
<p>故事还要追溯到 Java 9，当时为了解决反序列化的数据的安全性问题，Java 提供了反序列化的过滤器，允许在反序列化的时候对数据做检查，这个过滤器就是 ObjectInputFilter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectInputFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@link</span> Status#ALLOWED Status.ALLOWED&#125; if accepted,</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@link</span> Status#REJECTED Status.REJECTED&#125; if rejected,</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@link</span> Status#UNDECIDED Status.UNDECIDED&#125; if undecided.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Status <span class="title function_">checkInput</span><span class="params">(FilterInfo filterInfo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它最关键的方法就是这个 checkInput，返回值则是一个枚举。</p>
<p>在每一个 ObjectInputStream 实例被创建的时候都会创建一个过滤器与之对应：</p>
<p><strong>Java 16</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过滤器实际上是 JVM 全局的过滤器，可以通过系统属性 jdk.serialFilter 来配置，也可以通 ObjectInputFilter.Config#setSerialFilter 来设置。</p>
<p>在 ObjectInputStream 创建出来之后，我们也可以通过它的 setObjectInputFilter 来对这个实例单独设置自定义的过滤器。</p>
<p>以上的特性都是 Java 9 引入的，下面我们看看 Java 17 的更新：</p>
<p><strong>Java 17</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    serialFilter = Config.getSerialFilterFactorySingleton().apply(<span class="literal">null</span>, Config.getSerialFilter());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这段代码已经很明确的展示了改动之处，那就是 getSerialFilterFactorySingleton 返回的这个对象对原有的全局过滤器做了个变换。这个对象实际上是个 <code>BinaryOperator&lt;ObjectInputFilter&gt;</code>，实现这个 FilterFactory 就可以通过实现 apply 方法来完成对原有过滤器的修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ObjectInputFilter <span class="title function_">apply</span><span class="params">(ObjectInputFilter objectInputFilter, ObjectInputFilter objectInputFilter2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果你乐意，你可以随机返回 objectInputFilter 或者返回 objectInputFilter2（草率。。。），也可以把它俩串联或者并联起来。换句话讲，我们除了可以通过设置全局过滤器，以及单独为每一个 ObjectInputStream 实例设置过滤器以外，还可以设置一个操纵过滤器的对象，这个对象可以根据上下文来判断具体返回什么样的过滤器。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates-12-contextserialfilter/24A164DA.png"></p>
<p>接下来我们再看一下提案当中给出的例子（实际的 JDK API 与提案的例子有些调整，以下代码是调整之后的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterInThread</span> <span class="keyword">implements</span> <span class="title class_">BinaryOperator</span>&lt;ObjectInputFilter&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;ObjectInputFilter&gt; filterThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObjectInputFilter <span class="title function_">apply</span><span class="params">(ObjectInputFilter curr, ObjectInputFilter next)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">filter</span> <span class="operator">=</span> filterThreadLocal.get();</span><br><span class="line">            <span class="keyword">if</span> (filter != <span class="literal">null</span>) &#123;</span><br><span class="line">                filter = ObjectInputFilter.rejectUndecidedClass(filter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                filter = ObjectInputFilter.merge(next, filter);</span><br><span class="line">                filter = ObjectInputFilter.rejectUndecidedClass(filter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                next = ObjectInputFilter.merge(next, curr);</span><br><span class="line">                next = ObjectInputFilter.rejectUndecidedClass(next);</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子其实不复杂，我最初看的时候反而被一堆注释给搞得晕头转向，所以我决定把注释都删了给你们看。。。</p>
<p>它的逻辑简单来说就是 apply 的时候如果 curr 为 null，就从的 ThreadLocal 当中取出当前线程对应的过滤器与 next 进行合并，否则就用 curr 与 next 合并。</p>
<p>但通过前面阅读代码，我们已经知道 curr 在 ObjectInputStream 创建的时候传入的一定是 null（只有在后面调用 ObjectInputStream#setObjectInputFilter 的时候 curr 才会是之前已经创建的过滤器），因此这个 FilterInThread 就可以在 ObjectInputStream 创建的时候为它添加一个线程特有的过滤器，也就是上下文相关的过滤器了。</p>
<p>实际上例子里面还提供了一个临时切换过滤器的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterInThread</span> <span class="keyword">implements</span> <span class="title class_">BinaryOperator</span>&lt;ObjectInputFilter&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWithSerialFilter</span><span class="params">(ObjectInputFilter filter, Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">prevFilter</span> <span class="operator">=</span> filterThreadLocal.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterThreadLocal.set(filter);</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            filterThreadLocal.set(prevFilter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过调用 doWithSerialFilter 来实现将 runnable 的 run 当中所有直接创建的 ObjectInputStream 都将应用传入的这个 filter 作为自己的上下文过滤器。</p>
<p>有意思吧。不过一点儿也不直接。挺简单的一个东西竟然能搞得这么别扭。。。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/Java17-Updates/00DC34EC.gif"></p>
<p>讲到这儿，我们总算是把 Java 17 的主要更新介绍了一遍。除了这些大的更新以外，还有一些小的 Bugfix 和优化，我就不一一列举了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
      </tags>
  </entry>
  <entry>
    <title>ReleasableVar，可以为空的 Kotlin 非空类型 var</title>
    <url>/2018/11/26/ReleasableVar/</url>
    <content><![CDATA[<h1 id="0-题外话：Hadi-的插件"><a href="#0-题外话：Hadi-的插件" class="headerlink" title="0. 题外话：Hadi 的插件"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p>
<ul>
<li>Nyan Process Bar</li>
<li>Presentation Assistant</li>
</ul>
<p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p>
<p>好了下面我们言归正传~</p>
<h1 id="1-描述下需求"><a href="#1-描述下需求" class="headerlink" title="1. 描述下需求"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// You cannot do that!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p>
<p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p>
<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p>
<p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用的时候也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">by</span> releasableNotNull&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-干掉反射"><a href="#3-干掉反射" class="headerlink" title="3. 干掉反射"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p>
<p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> map = releasableRefs[thisRef]</span><br><span class="line">            <span class="keyword">if</span>(map == <span class="literal">null</span>)&#123;</span><br><span class="line">                map = HashMap()</span><br><span class="line">                releasableRefs[thisRef] = map</span><br><span class="line">            &#125;</span><br><span class="line">            map[property.name] = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">            releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.isInitialized()</span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? CallableReference)?.let &#123;</span><br><span class="line">        releasableRefs[it.boundReceiver]?.<span class="keyword">get</span>(<span class="keyword">this</span>.name)?.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-怎么用？"><a href="#4-怎么用？" class="headerlink" title="4. 怎么用？"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> varInPackage = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">&quot;World&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">::varInPackage</span><br><span class="line"></span><br><span class="line">Foo()::bar</span><br></pre></td></tr></table></figure>

<p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        image.recycle()</span><br><span class="line">        ::image.release() <span class="comment">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-你想直接用？"><a href="#5-你想直接用？" class="headerlink" title="5. 你想直接用？"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure>

<p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p>
<p><a href="https://github.com/enbandari/ReleasableVar">https://github.com/enbandari/ReleasableVar</a></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>PropertyDelegate</tag>
      </tags>
  </entry>
  <entry>
    <title>[Android Studio 技巧] 快捷键的使用</title>
    <url>/2021/05/09/android-studio-shortcuts/</url>
    <content><![CDATA[<blockquote>
<p>有关 Android Studio 快捷键，看这个视频就够了 </p>
</blockquote>
<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1g64y1279B&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>





<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Android Studio</tag>
        <tag>技巧</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>注解处理器教程[全]</title>
    <url>/2018/10/03/apt-tutorials/</url>
    <content><![CDATA[<p>我在做 <a href="https://coding.imooc.com/class/232.html">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href="https://github.com/enbandari/TieGuanYin">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p>
<p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p>
<span id="more"></span>

<h1 id="视频源码"><a href="#视频源码" class="headerlink" title="视频源码"></a>视频源码</h1><p>见 Github 项目：<a href="https://github.com/enbandari/Apt-Tutorials">Apt-Tutorials</a></p>
<h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><h2 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1. 课程简介"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/l0728uxh61x.html">https://v.qq.com/x/page/l0728uxh61x.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=1">https://www.bilibili.com/video/av32905508/?p=1</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p>
<h2 id="2-搭建工程"><a href="#2-搭建工程" class="headerlink" title="2. 搭建工程"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/o07284u5rju.html">https://v.qq.com/x/page/o07284u5rju.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=2">https://www.bilibili.com/video/av32905508/?p=2</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p>
<h2 id="3-解析注解"><a href="#3-解析注解" class="headerlink" title="3. 解析注解"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/z07286r97mz.html">https://v.qq.com/x/page/z07286r97mz.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=3">https://www.bilibili.com/video/av32905508/?p=3</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p>
<h2 id="4-生成常量"><a href="#4-生成常量" class="headerlink" title="4. 生成常量"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/k0728tn7sty.html">https://v.qq.com/x/page/k0728tn7sty.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=4">https://www.bilibili.com/video/av32905508/?p=4</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p>
<h2 id="5-生成-start-方法"><a href="#5-生成-start-方法" class="headerlink" title="5. 生成 start 方法"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/x0728j7j7a6.html">https://v.qq.com/x/page/x0728j7j7a6.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=5">https://www.bilibili.com/video/av32905508/?p=5</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p>
<h2 id="6-生成注入和状态保存的方法"><a href="#6-生成注入和状态保存的方法" class="headerlink" title="6. 生成注入和状态保存的方法"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/d0728uitqdr.html">https://v.qq.com/x/page/d0728uitqdr.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=6">https://www.bilibili.com/video/av32905508/?p=6</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p>
<h2 id="7-生成-Kotlin-代码"><a href="#7-生成-Kotlin-代码" class="headerlink" title="7. 生成 Kotlin 代码"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/l0728y2inrf.html">https://v.qq.com/x/page/l0728y2inrf.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=7">https://www.bilibili.com/video/av32905508/?p=7</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p>
<p><strong>腾讯视频：</strong> </p>
<p><a href="https://v.qq.com/x/page/m072848g85p.html">https://v.qq.com/x/page/m072848g85p.html</a></p>
<p><strong>Bilibili：</strong> </p>
<p><a href="https://www.bilibili.com/video/av32905508/?p=8">https://www.bilibili.com/video/av32905508/?p=8</a></p>
<p><strong>Youtube：</strong></p>
<p><a href="https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p>
<hr>
<p>欢迎关注 Kotlin 公众号：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言版的 println？</title>
    <url>/2020/06/14/c-println/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 </p>
</blockquote>
<span id="more"></span>




<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;bennyhuo&quot;</span></span><br><span class="line">println(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure>

<p>不管什么变量类型，println 一律照单全收，是不是很方便？</p>
<p>而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。</p>
<p>有没有什么办法解决这些问题呢？</p>
<h2 id="问题一：自动换行"><a href="#问题一：自动换行" class="headerlink" title="问题一：自动换行"></a>问题一：自动换行</h2><p>printf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 <code>\n</code>，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, age);</span><br></pre></td></tr></table></figure>

<p>解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printlnf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。</p>
<p>在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 <code>va_list</code> 来承载变长参数的值，使用 <code>va_start</code> 和 <code>va_end</code> 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 <code>va_list</code> 类型的参数做为后面需要被格式化的参数。</p>
<p>用法起来嘛，还是可以的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;%d&quot;</span>, <span class="number">5</span>); <span class="comment">// 5\n</span></span><br></pre></td></tr></table></figure>

<p>不过实话这个函数定义并不是很美，看着太长了。</p>
<p>在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> printlnf(format, ...) printf(format<span class="string">&quot;\n&quot;</span>, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>额，用宏实现就这么简单？</p>
<p>首先我们注意一下 <code>format&quot;\n&quot;</code>，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *name = <span class="string">&quot;benny&quot;</span><span class="string">&quot;huo&quot;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">char</span> *name = <span class="string">&quot;bennyhuo&quot;</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;Hello %s&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>经过编译器预处理之后展开宏得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s&quot;</span><span class="string">&quot;\n&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *format = <span class="string">&quot;Hello %s&quot;</span>;</span><br><span class="line">printlnf(format, <span class="string">&quot;C&quot;</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>因为宏展开以后得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *format = <span class="string">&quot;Hello %s&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(format<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;C&quot;</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。</p>
<h2 id="问题二：支持非字符串类型直接打印"><a href="#问题二：支持非字符串类型直接打印" class="headerlink" title="问题二：支持非字符串类型直接打印"></a>问题二：支持非字符串类型直接打印</h2><p>C 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">println(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 <code>_Generic</code>，可以支持泛型！</p>
<p>妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="keyword">_Generic</span>(x,</span><br><span class="line">        <span class="type">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="type">double</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="type">char</span> * : <span class="number">4</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。</p>
<p>不得不说，这语法中透露着年代感。但不管怎样，总算能用。</p>
<p>我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">println</span><span class="params">(??? format, ...)</span> &#123;</span><br><span class="line">  <span class="keyword">_Generic</span>(format, ...);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设将 format 定义为 <code>char*</code> 类型，那么泛型的判断豪无意义，因为 <code>_Generic</code> 永远会选择 <code>char*</code> 分支的返回值。</p>
<p>既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> println(X) _Generic((X),  \</span></span><br><span class="line"><span class="meta">    int: printf(<span class="string">&quot;%d\n&quot;</span>, X), \</span></span><br><span class="line"><span class="meta">    float: printf(<span class="string">&quot;%f\n&quot;</span>, X), \</span></span><br><span class="line"><span class="meta">    char *: printf(<span class="string">&quot;%s\n&quot;</span>, X), \</span></span><br><span class="line"><span class="meta">    double : printf(<span class="string">&quot;%0.4f\n&quot;</span>, X) \</span></span><br><span class="line"><span class="meta">    )</span></span><br></pre></td></tr></table></figure>

<p>这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">println(<span class="number">3</span>);</span><br><span class="line">println(<span class="number">0.3</span>);</span><br><span class="line">println(<span class="number">34.0f</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题三：打印文件名和行号"><a href="#问题三：打印文件名和行号" class="headerlink" title="问题三：打印文件名和行号"></a>问题三：打印文件名和行号</h2><p>C 当中提供了两个宏：</p>
<ul>
<li><code>__FILE__</code>：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。</li>
<li><code>__LINE__</code>：展开之后就是所在的源代码文件行的行号，是个整型。</li>
</ul>
<p>有了这两个宏，那么实现这个功能也就不难做到了。</p>
<p>首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> printlnf(format, ...) printf(<span class="string">&quot;(%s:%d) &quot;</span>format<span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>使用效果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printlnf(<span class="string">&quot;%d&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(C:\Users\bennyhuo\WorkSpace\Demos\HelloCInClion\main.c:48) 30</span><br></pre></td></tr></table></figure>

<p>如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们通过改造 printf，得到了两套实现，其中：</p>
<ol>
<li>在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；</li>
<li>支持直接打印常见类型，得到 println 的宏实现。</li>
</ol>
<p>二者也都可以根据需要添加对文件名和行号的输出支持。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>macro</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（0）：前言</title>
    <url>//2022/03/06/cpp-coroutines-00-foreword/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<p>C++ 20 标准发布之后，协程终于正式成为 C++ 特性当中的一员。</p>
<p>作为一门本身极其复杂的语言，C++ 秉承着不劝退不开心的原则，将协程的 API 设计得非常复杂。以至于有开发者甚至发出了“这玩意根本就不是给人用的”这样的感叹。</p>
<p>等等，我们是不是搞错了，C++ 协程的 API 确实不是设计给业务开发者直接使用的。实际上，标准当中给出的 API 足够的灵活，也足够的基础，框架的开发者可以基于这些 API 将过去异步的函数改造成协程风格的版本。</p>
<p>没错，这就是 C++。</p>
<p>一门不造轮子就让人不舒服的语言，它总是在用它自己的方式逼着开发者进步。为了帮助大家认识和了解 C++ 协程的设计思路以及基本用法，我计划写几篇文章来介绍一下 C++ 协程的相关特性。</p>
<p>本人 C++ 水平有限，文章内容的安排将尽可能以介绍特性为主，涉及到的框架实现不建议在生产环境当中直接使用。</p>
<p>另外，为了方便读者阅读和实验，文章涉及到的所有源码均已上传于 <a href="https://github.com/bennyhuo/CppCoroutines">GitHub: bennyhuo/CppCoroutines</a>。</p>
<p>相信大家读完这一系列文章之后，也还是不一定会 C++ 协程 ：）</p>
<blockquote>
<p><strong>说明</strong>：C++ 23 有望基于协程提供不少有用的支持，例如与异步任务密不可分的 executor、network 等等，不过这些内容我暂时不会在后面的文章当中涉及，等 C++ 23 正式发布之后再做补充。</p>
</blockquote>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（1）：C++ 协程概览</title>
    <url>//2022/03/09/cpp-coroutines-01-intro/</url>
    <content><![CDATA[<blockquote>
<p>C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1vv4y1A7fX&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程就是一段可以<strong>挂起（suspend）</strong>和<strong>恢复（resume）</strong>的程序，一般而言，就是一个支持<strong>挂起</strong>和<strong>恢复</strong>的函数。</p>
<p>这么说比较抽象，我们下面看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fun 是一个非常普通的函数，大家对它的直观印象是什么呢？</p>
<ul>
<li>它有四行代码</li>
<li>这四行代码一行一行依次执行</li>
<li>这四行代码连续执行</li>
</ul>
<p>作为一个合格的程序员，我们的眼睛就是编译器，我们的脑子就是运行时。相信大家在看完这个函数的定义之后脑子里面已经不自主的把它运行过了：这个函数一旦开始，就无法暂停。</p>
<p>如果一个函数能够暂停，那它就可以被认为是我们开头提到的协程。所以<strong>挂起</strong>你就可以理解成暂停，<strong>恢复</strong>你就理解成从暂停的地方继续执行。</p>
<p>下面我们给出一段 C++ 协程的不完整的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">3</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">4</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Result 的定义我们后面再谈论，大家只需要知道 Result 是按照协程的规则定义的类型，在 C++ 当中，一个函数的返回值类型如果是符合协程的规则的类型，那么这个函数就是一个协程。</p>
<p>请大家留意一下这个函数体当中的 <code>co_await std::suspend_always&#123;&#125;;</code>，其中 <code>co_await</code> 是个关键字，它的出现，通常来说就会使得当前函数（协程）的执行被挂起。也就是说我们在控制台看到输出 1 以后，很可能过了很久才看到 2，这个“很久”也一般不是因为当前执行的线程被阻塞了，而是当前函数（协程）执行的位置被存起来，在将来某个时间点又读取出来继续执行的。</p>
<h2 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h2><p>很多读者在初次接触到协程这个概念的时候，总是会想得太过于复杂，以至于觉得<strong>挂起</strong>和<strong>恢复</strong>充满了神秘色彩而无法理解。这确实大可不必，你只要能理解听歌的时候可以暂停继续，能理解下载的时候可以断点续传，那你就必然可以理解协程的<strong>挂起</strong>和<strong>恢复</strong>。</p>
<p>那么问题来了，在我们现有的语言特性框架下，如何实现所谓的<strong>挂起</strong>和<strong>恢复</strong>呢？</p>
<p>我们以音频文件的播放为例，我们将其与协程的执行做对比，例如整个音频文件对比协程的函数体（即<strong>协程体</strong>），完整的对比见下表：</p>
<table>
<thead>
<tr>
<th>音频</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>音频文件</td>
<td>协程体</td>
</tr>
<tr>
<td>音频播放</td>
<td>协程执行</td>
</tr>
<tr>
<td>播放暂停</td>
<td>执行挂起</td>
</tr>
<tr>
<td>播放恢复</td>
<td>执行恢复</td>
</tr>
<tr>
<td>播放异常</td>
<td>执行异常</td>
</tr>
<tr>
<td>播放完成</td>
<td>协程返回</td>
</tr>
</tbody></table>
<p>音频暂停的时候需要记录音频暂停的位置，同时之前正在播放的音频也不会销毁（即便销毁重建，也要能够完全恢复原样）。</p>
<p>类似地，协程挂起时，我们需要记录函数执行的位置，C++ 协程会在开始执行时的第一步就使用 <code>operator new</code> 来开辟一块内存来存放这些信息，这块内存或者说这个对象又被称为<strong>协程的状态（coroutine state）</strong>。</p>
<p>协程的状态不仅会被用于存放挂起时的位置（后称为<strong>挂起点</strong>），也会在协程开始执行时存入协程体的参数值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>start_value</code> 就会被存入协程的状态当中。</p>
<p>需要注意的是，如果参数是值类型，他们的值或被移动或被复制（取决于类型自身的复制构造和移动构造的定义）到协程的状态当中；如果是引用、指针类型，那么存入协程的状态的值将会是引用或指针本身，而不是其指向的对象，这时候需要开发者自行保证协程在挂起后续恢复执行时参数引用或者指针指向的对象仍然存活。</p>
<p>与创建相对应，在协程执行完成或者被外部主动销毁之后，协程的状态也随之被销毁释放。</p>
<p>看到这里，大家也不必紧张，协程的状态的创建和销毁都是编译器帮我们处理好的，不需要我们显式的处理。</p>
<h2 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h2><p>协程的挂起是协程的灵魂。C++ 通过 <code>co_await</code> 表达式来处理协程的挂起，表达式的操作对象则为<strong>等待体（awaiter）</strong>。</p>
<p>等待体需要实现三个函数，这三个函数在挂起和恢复时分别调用。</p>
<h3 id="await-ready"><a href="#await-ready" class="headerlink" title="await_ready"></a>await_ready</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>await_ready 返回 bool 类型，如果返回 true，则表示已经就绪，无需挂起；否则表示需要挂起。</p>
<p>标准库当中提供了两个非常简单直接的等待体，<code>struct suspend_always</code> 表示总是挂起，<code>struct suspend_never</code> 表示总是不挂起。不难想到，这二者的功能主要就是依赖 await_ready 函数的返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_never</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true，总是不挂起</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_always</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回 false，总是挂起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="await-suspend"><a href="#await-suspend" class="headerlink" title="await_suspend"></a>await_suspend</h3><p>await_ready 返回 false 时，协程就挂起了。这时候协程的局部变量和挂起点都会被存入协程的状态当中，await_suspend 被调用到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">??? <span class="built_in">await_suspend</span>(std::coroutine_handle&lt;&gt; coroutine_handle);</span><br></pre></td></tr></table></figure>

<p>参数 coroutine_handle 用来表示当前协程，我们可以在稍后合适的时机通过调用 resume 来恢复执行当前协程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">coroutine_handle.<span class="built_in">resume</span>();</span><br></pre></td></tr></table></figure>

<p>注意到 await_suspend 函数的返回值类型我们没有明确给出，因为它有以下几种选项：</p>
<ul>
<li>返回 void 类型或者返回 true，表示当前协程挂起之后将执行权还给当初调用或者恢复当前协程的函数。</li>
<li>返回 false，则恢复执行当前协程。注意此时不同于 await_ready 返回 true 的情形，此时协程已经挂起，await_suspend 返回 false 相当于挂起又立即恢复。</li>
<li>返回其他协程的 coroutine_handle 对象，这时候返回的 coroutine_handle 对应的协程被恢复执行。</li>
<li>抛出异常，此时当前协程恢复执行，并在当前协程当中抛出异常。</li>
</ul>
<p>可见，await_suspend 支持的情况非常多，也相对复杂。实际上这也是 C++ 协程当中最为核心的函数之一了。</p>
<h3 id="await-resume"><a href="#await-resume" class="headerlink" title="await_resume"></a>await_resume</h3><p>协程恢复执行之后，等待体的 await_resume 函数被调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">??? <span class="built_in">await_resume</span>()；</span><br></pre></td></tr></table></figure>

<p>同样地，await_resume 的返回值类型也是不限定的，返回值将作为 <code>co_await</code> 表达式的返回值。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>了解了以上内容以后，我们可以自己定义一个非常简单的等待体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程挂起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 切换线程</span></span><br><span class="line">    std::<span class="built_in">async</span>([=]()&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">      <span class="comment">// sleep 1s</span></span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); </span><br><span class="line">      <span class="comment">// 恢复协程</span></span><br><span class="line">      coroutine_handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value 将作为 co_await 表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">co_await</span> Awaiter&#123;.value = <span class="number">1000</span>&#125; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">// 1 秒之后再执行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1000</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>其中 “1000” 在 “1” 输出 1 秒之后输出。</p>
<blockquote>
<p><strong>说明</strong>：co_await 后面的对象也可以不是等待体，这类情况需要定义其他的函数和运算符来转换成等待体。这个我们后面再讨论。</p>
</blockquote>
<h2 id="协程的返回值类型"><a href="#协程的返回值类型" class="headerlink" title="协程的返回值类型"></a>协程的返回值类型</h2><p>我们前面提到，区别一个函数是不是协程，是通过它的返回值类型来判断的。如果它的返回值类型满足协程的规则，那这个函数就会<strong>被编译成</strong>协程。</p>
<p>那么，这个<strong>协程的规则</strong>是什么呢？规则就是返回值类型能够实例化下面的模板类型 <code>_Coroutine_traits</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _Coroutine_traits &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Coroutine_traits</span>&lt;_Ret, <span class="type">void_t</span>&lt;<span class="keyword">typename</span> _Ret::promise_type&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> promise_type = <span class="keyword">typename</span> _Ret::promise_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_traits</span> : _Coroutine_traits&lt;_Ret&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>简单来说，就是返回值类型 <code>_Ret</code> 能够找到一个类型 <code>_Ret::promise_type</code> 与之相匹配。这个 <code>promise_type</code> 既可以是直接定义在 <code>_Ret</code> 当中的类型，也可以通过 <code>using</code> 指向已经存在的其他外部类型。</p>
<p>此时，我们就可以给出 <code>Result</code> 的部分实现了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="协程返回值对象的构建"><a href="#协程返回值对象的构建" class="headerlink" title="协程返回值对象的构建"></a>协程返回值对象的构建</h2><p>我们再看一下协程的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">(<span class="type">int</span> start_value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; start_value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; start_value + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时你已经了解 C++ 当中如何界定一个协程。不过你可能会产生一个新的问题，返回值是从哪儿来的？协程体当中并没有给出 Result 对象创建的代码。</p>
<p>实际上，Result 对象的创建是由 promise_type 负责的，我们需要定义一个 <code>get_return_object</code> 函数来处理对 Result 对象的创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建 Result 对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不同于一般的函数，协程的返回值并不是在返回之前才创建，而是在协程的状态创建出来之后马上就创建的。也就是说，协程的状态被创建出来之后，会立即构造 <code>promise_type</code> 对象，进而调用 <code>get_return_object</code> 来创建返回值对象。</p>
<p><code>promise_type</code> 类型的构造函数参数列表如果与协程的参数列表一致，那么构造 <code>promise_type</code> 时就会调用这个构造函数。否则，就通过默认无参构造函数来构造 <code>promise_type</code>。</p>
<h2 id="协程体的执行"><a href="#协程体的执行" class="headerlink" title="协程体的执行"></a>协程体的执行</h2><p>在协程的返回值被创建之后，协程体就要被执行了。</p>
<h3 id="initial-suspend"><a href="#initial-suspend" class="headerlink" title="initial_suspend"></a>initial_suspend</h3><p>为了方便灵活扩展，协程体执行的第一步是调用 <code>co_await promise.initial_suspend()</code>，<code>initial_suspend</code> 的返回值就是一个等待对象（awaiter），如果返回值满足挂起的条件，则协程体在最一开始就立即挂起。这个点实际上非常重要，我们可以通过控制 initial_suspend 返回的等待体来实现协程的执行调度。有关调度的内容我们后面会专门探讨。</p>
<h3 id="协程体的执行-1"><a href="#协程体的执行-1" class="headerlink" title="协程体的执行"></a>协程体的执行</h3><p>接下来执行协程体。</p>
<p>协程体当中会存在 co_await、co_yield、co_return 三种协程特有的调用，其中</p>
<ul>
<li>co_await 我们前面已经介绍过，用来将协程挂起。</li>
<li>co_yield 则是 co_await 的一个马甲，用于传值给协程的调用者或恢复者或被恢复者，我们后面会专门用一篇文章给出例子介绍它的用法。</li>
<li>co_return 则用来返回一个值或者从协程体返回。</li>
</ul>
<h4 id="协程体的返回值"><a href="#协程体的返回值" class="headerlink" title="协程体的返回值"></a>协程体的返回值</h4><p>对于返回一个值的情况，需要在 promise_type 当中定义一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">??? <span class="built_in">return_value</span>();</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，我们的 Coroutine 函数就需要使用 co_return 来返回一个整数了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1000 会作为参数传入，即 return_value 函数的参数 value 的值为 1000。</p>
<p>这时候读者可能会疑惑，这个值好像没什么用啊？大家别急，这个值可以存到 promise_type 对象当中，外部的调用者可以获取到。</p>
<h4 id="协程体返回-void"><a href="#协程体返回-void" class="headerlink" title="协程体返回 void"></a>协程体返回 void</h4><p>除了返回值的情况以外，C++ 协程当然也支持返回 void。只不过 promise_type 要定义的函数就不再是 return_value 了，而是 return_void 了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，协程内部就可以通过 co_return 来退出协程体了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Result <span class="title">Coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">co_return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="协程体抛出异常"><a href="#协程体抛出异常" class="headerlink" title="协程体抛出异常"></a>协程体抛出异常</h4><p>协程体除了正常返回以外，也可以抛出异常。异常实际上也是一种结果的类型，因此处理方式也与返回结果相似。我们只需要在 promise_type 当中定义一个函数，在异常抛出时这个函数就会被调用到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      exception_ = std::<span class="built_in">current_exception</span>(); <span class="comment">// 获取当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final-suspend"><a href="#final-suspend" class="headerlink" title="final_suspend"></a>final_suspend</h3><p>当协程执行完成或者抛出异常之后会先清理局部变量，接着调用 final_suspend 来方便开发者自行处理其他资源的销毁逻辑。final_suspend 也可以返回一个等待体使得当前协程挂起，但之后当前协程应当通过 coroutine_handle 的 destroy 函数来直接销毁，而不是 resume。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们介绍了一些 C++ 协程的各种概念和约定，看似介绍了非常多的内容，但因为示例较少又感觉什么都没介绍。大家不要着急，C++ 协程的概念基本上就这么多，剩下的文章我们都将基于一个或多个具体的场景展开来介绍如何运用 C++ 协程来解决问题。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（2）：实现一个序列生成器</title>
    <url>//2022/03/11/cpp-coroutines-02-generator/</url>
    <content><![CDATA[<blockquote>
<p>序列生成器是一个非常经典的协程应用场景。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1ug411d7Xy&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>现在我们已经了解了绝大部分 C++ 协程的特性，可以试着来实现一些小案例了。</p>
<p>简单的说，序列生成器通常的实现就是在一个协程内部通过某种方式向外部传一个值出去，并且将自己挂起，外部调用者则可以获取到这个值，并且在后续继续恢复执行序列生成器来获取下一个值。</p>
<p>显然，挂起和向外部传值的任务就需要通过 <code>co_await</code> 来完成了，外部获取值的任务就要通过协程的返回值来完成。</p>
<p>由此我们大致能想到最终程序的样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 generator 有个 next 函数，调用它时我们需要想办法让协程恢复执行，并将下一个值传出来。</p>
<p>好了，接下来我们就带着这两个问题去寻找解决办法，顺便把剩下的一点点 C++ 协程的知识补齐。</p>
<h2 id="调用者获取值"><a href="#调用者获取值" class="headerlink" title="调用者获取值"></a>调用者获取值</h2><p>截止到目前我们都没有真正尝试去调用过协程，现在是个很好的机会。我们观察一下 main 函数当中的这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generator</code> 的类型就是我们即将实现的序列生成器类型 <code>Generator</code>，结合上一篇文章当中对于协程返回值类型的介绍，我们先大致给出它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行时直接挂起等待外部调用 resume 获取下一个值</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行结束后不需要挂起</span></span><br><span class="line">    <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了简单，我们认为序列生成器当中不会抛出异常，这里不做任何处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ???.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码当中有两处我们标注为 ???，表示暂时还不知道怎么处理。</p>
<p>第一个是我们想要在 Generator 当中 resume 协程的话，需要拿到 coroutine_handle，这个要怎么做到呢？</p>
<p>这时候我希望大家一定要记住一点，promise_type 是连接协程内外的桥梁，想要拿到什么，找 promise_type 要。标准库提供了一个通过 promise_type 的对象的地址获取 coroutine_handle 的函数，它实际上是 coroutine_handle 的一个静态函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Promise</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine_handle</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(_Promise&amp; _Prom)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看来，我们只需要在 <code>get_return_object</code> 函数调用时，先获取 coroutine_handle，然后再传给即将构造出来的 Generator 即可，因此我们稍微修改一下前面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造协程的返回值类型</span></span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Generator&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> ???;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是如何获取协程内部传出来的值的问题了。同样，本着有事儿找 promise_type 的原则，我们可以直接给它定义一个 value 成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="comment">// 通过 handle 获取 promise，然后再取到 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="协程内部挂起并传值"><a href="#协程内部挂起并传值" class="headerlink" title="协程内部挂起并传值"></a>协程内部挂起并传值</h2><p>现在的问题就是如何从协程内部传值给 promise_type 了。</p>
<p>我们再来观察一下最终实现的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别需要注意的是 <code>co_await i++;</code> 这一句，我们发现 <code>co_await</code> 后面的是一个整型值，而不是我们在前面的文章当中提到的满足等待体（awaiter）条件的类型，这种情况下该怎么办呢？</p>
<p>实际上，对于 <code>co_await &lt;expr&gt;</code> 表达式当中 <code>expr</code> 的处理，C++ 有一套完善的流程：</p>
<ol>
<li>如果 promise_type 当中定义了 await_transform 函数，那么先通过 <code>promise.await_transform(expr)</code> 来对 expr 做一次转换，得到的对象称为 awaitable；否则 awaitable 就是 expr 本身。</li>
<li>接下来使用 awaitable 对象来获取等待体（awaiter）。如果 awaitable 对象有 <code>operator co_await</code> 运算符重载，那么等待体就是 <code>operator co_await(awaitable)</code>，否则等待体就是 awaitable 对象本身。</li>
</ol>
<p>听上去，我们要么给 promise_type 实现一个 <code>await_tranform(int)</code> 函数，要么就为整型实现一个 <code>operator co_await</code> 的运算符重载，二者选一个就可以了。</p>
<h3 id="方案-1：实现-operator-co-await"><a href="#方案-1：实现-operator-co-await" class="headerlink" title="方案 1：实现 operator co_await"></a>方案 1：实现 operator co_await</h3><p>这个方案就是给 int 定义 operator co_await 的重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">IntAwaiter</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;Generator::promise_type&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      handle.<span class="built_in">promise</span>().value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> IntAwaiter&#123;.value = value&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个方案对于我们这个特定的场景下是行不通的，因为在 C++ 当中我们是无法给基本类型定义运算符重载的。</p>
<p>不过，如果我们遇到的情况不是基本类型，那么运算符重载的思路就可以行得通。<code>operator co_await</code> 的重载我们将会在后面给出例子。</p>
<h3 id="方案-2：await-transform"><a href="#方案-2：await-transform" class="headerlink" title="方案 2：await_transform"></a>方案 2：await_transform</h3><p>运算符重载行不通，那就只能通过 await_tranform 来做转换了。</p>
<p>代码比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传值的同时要挂起，值存入 value 当中</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">await_transform</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">resume</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部调用者或者恢复者可以通过读取 value</span></span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义了 <code>await_transform</code> 函数之后，<code>co_await expr</code> 就相当于 <code>co_await promise.await_transform(expr)</code> 了。</p>
<p>至此，我们的例子就可以运行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h2><p>虽然我们的协程已经能够正常工作，但它仍然存在缺陷。</p>
<h3 id="问题-1：无法确定是否存在下一个元素"><a href="#问题-1：无法确定是否存在下一个元素" class="headerlink" title="问题 1：无法确定是否存在下一个元素"></a>问题 1：无法确定是否存在下一个元素</h3><p>当外部调用者或者恢复者试图调用 <code>next</code> 来获取下一个元素的时候，它其实并不知道能不能真的得到一个结果。程序也可能抛出异常：</p>
<p>如下例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 只传出 5 个值</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">co_await</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 试图读取 15 个值</span></span><br><span class="line">    std::cout &lt;&lt; gen.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的结果是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</span><br></pre></td></tr></table></figure>

<p>最后一个输出的 4 实际上是恰好遇到协程销毁之前的状态，此时 promise 当中的 value 值还是之前的 4。而当我们试图不断的去读取协程的值，程序就抛出 SIGSEGV  的错误。错误的原因你可能已经想到了，当协程体执行完之后，协程的状态就会被销毁，如果我们再访问协程的话，就相当于访问了一个野指针。</p>
<p>为了解决这个问题，我们需要增加一个 has_next 函数，用来判断是否还有新的值传出来，has_next 函数调用的时候有两种情况：</p>
<ol>
<li>已经有一个值传出来了，还没有被外部消费</li>
<li>还没有现成的值可以用，需要尝试恢复执行协程来看看还有没有下一个值传出来</li>
</ol>
<p>这里我们需要有一种有效的办法来判断 value 是不是有效的，单凭 value 本身我们其实是无法确定它的值是不是被消费了，因此我们需要加一个值来存储这个状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程执行完成之后，外部读取值时抛出的异常</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">bool</span> is_ready = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个成员 state 来记录协程执行的状态，状态的类型一共三种，只有 READY 的时候我们才能拿到值。</p>
<p>接下来改造 <code>next</code> 函数，同时增加 <code>has_next</code> 函数来描述协程是否仍然可以有值传出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程还没有执行完成，并且下一个值还没有准备好</span></span><br><span class="line">    <span class="keyword">if</span> (!handle.<span class="built_in">promise</span>().is_ready) &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">      <span class="comment">// 恢复执行之后协程执行完，这时候必然没有通过 co_await 传出值来</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此时一定有值，is_ready 为 true </span></span><br><span class="line">      <span class="comment">// 消费当前的值，重置 is_ready 为 false</span></span><br><span class="line">      handle.<span class="built_in">promise</span>().is_ready = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> handle.<span class="built_in">promise</span>().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ExhaustedException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样外部使用时就需要先通过 has_next 来判断是否有下一个值，然后再去读取了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题-2：协程状态的销毁比-Generator-对象的销毁更早"><a href="#问题-2：协程状态的销毁比-Generator-对象的销毁更早" class="headerlink" title="问题 2：协程状态的销毁比 Generator 对象的销毁更早"></a>问题 2：协程状态的销毁比 Generator 对象的销毁更早</h3><p>我们前面提到过，协程的状态在协程体执行完之后就会销毁，除非协程挂起在 <code>final_suspend</code> 调用时。</p>
<p>我们的例子当中 <code>final_suspend</code> 返回了 <code>std::suspend_never</code>，因此协程的销毁时机其实比 Generator 更早：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = <span class="built_in">sequence</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 协程已经执行完，协程的状态已经销毁</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator 对象在此仍然有效</span></span><br></pre></td></tr></table></figure>

<p>这看上去似乎问题不大，因为我们在前面通过 <code>has_next</code> 的判断保证了读取值的安全性。</p>
<p>但实际上情况并非如此。我们在 <code>has_next</code> 当中调用了 <code>coroutine_handle::done</code> 来判断协程体是否执行完成，判断之前很可能协程已经销毁，<code>coroutine_handle</code> 这时候都已经是无效的了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果协程已经执行完成，理论上协程的状态已经销毁，handle 指向的是一个无效的协程</span></span><br><span class="line">  <span class="comment">// 如果 handle 本身已经无效，因此 done 函数的调用此时也是无效的</span></span><br><span class="line">  <span class="keyword">if</span> (handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此为了让协程的状态的生成周期与 <code>Generator</code> 一致，我们必须将协程的销毁交给 <code>Generator</code> 来处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是挂起，让 Generator 来销毁</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="comment">// 销毁协程</span></span><br><span class="line">    handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="问题-3：复制对象导致协程被销毁"><a href="#问题-3：复制对象导致协程被销毁" class="headerlink" title="问题 3：复制对象导致协程被销毁"></a>问题 3：复制对象导致协程被销毁</h3><p>这个问题确切地说是<strong>问题 2</strong>的解决方案不完善引起的。</p>
<p>我们在 Generator 的析构函数当中销毁协程，这本身没有什么问题，但如果我们把 Generator 对象做一下复制，例如从一个函数当中返回，情况可能就会变得复杂。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">returns_generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> g = <span class="built_in">sequence</span>();</span><br><span class="line">  <span class="keyword">if</span> (g.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; g.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> generator = <span class="built_in">returns_generator</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; generator.<span class="built_in">next</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码乍一看似乎没什么问题，但由于我们把 <code>g</code> 当做返回值返回了，这时候 <code>g</code> 这个对象就发生了一次复制，然后临时对象被销毁。接下来的事儿大家就很容易想到了，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">-572662307</span><br><span class="line"></span><br><span class="line">Process finished with exit code -1073741819 (0xC0000005)</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们需要妥善地处理 Generator 的复制构造器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Generator</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;&amp;generator) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(generator.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Generator &amp;<span class="keyword">operator</span>=(Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只提供了右值复制构造器，对于左值复制构造器，我们直接删除掉以禁止使用。原因也很简单，对于每一个协程实例，都有且仅能有一个 Generator 实例与之对应，因此我们只支持移动对象，而不支持复制对象。</p>
<h2 id="使用-co-yield"><a href="#使用-co-yield" class="headerlink" title="使用 co_yield"></a>使用 co_yield</h2><p>序列生成器这个需求的实现其实有个更好的选择，那就是使用 <code>co_yield</code>。<code>co_yield</code> 就是专门为向外传值来设计的，如果大家对其他语言的协程有了解，也一定见到过各种 <code>yield</code> 的实现。</p>
<p>C++ 当中的 <code>co_yield expr</code> 等价于 <code>co_await promise.yield_value(expr)</code>，我们只需要将前面例子当中的 <code>await_transform</code> 函数替换成 <code>yield_value</code> 就可以使用 <code>co_yield</code> 来传值了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span>: std::exception &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 await_transform 替换为 yield_value</span></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      is_ready = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator <span class="title">sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 co_yield 来替换 co_await</span></span><br><span class="line">    <span class="keyword">co_yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到改动点非常少，运行效果与前面的例子一致。</p>
<p>尽管可以实现相同的效果，但通常情况下我们使用 <code>co_await</code> 更多的关注点在挂起自己，等待别人上，而使用 <code>co_yield</code> 则是挂起自己传值出去。因此我们应该针对合适的场景做出合适的选择。</p>
<h2 id="使用序列生成器生成斐波那契数列"><a href="#使用序列生成器生成斐波那契数列" class="headerlink" title="使用序列生成器生成斐波那契数列"></a>使用序列生成器生成斐波那契数列</h2><p>接下来我们要使用序列生成器来实现一个更有意义的例子，即斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">0</span>; <span class="comment">// fib(0)</span></span><br><span class="line">  <span class="keyword">co_yield</span> <span class="number">1</span>; <span class="comment">// fib(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a + b; <span class="comment">// fib(N), N &gt; 1</span></span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这个实现非常的直接，完全不需要考虑 fib(N - 1) 和 fib(N - 2) 的存储问题。</p>
<p>如果没有协程，我们的实现可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初值不符合整体的规律，需要单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">-1</span>)&#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      b = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> next = b;</span><br><span class="line">    b = a + b;</span><br><span class="line">    a = b - a;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用时先构造一个 Fibonacci 对象，然后调用 next 函数来获取下一个值。对比之下，协程的实现带来的好处是显而易见的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文围绕序列生成器这个经典的协程案例介绍了协程的销毁、co_await 运算符、await_transform 以及 yield_value 的用法。</p>
<p>说出来你可能不信，如果这篇文章你能够完全理解，那么相信你对 C++ 协程特性的了解已经比较全面了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</title>
    <url>//2022/03/14/cpp-coroutines-03-functional/</url>
    <content><![CDATA[<blockquote>
<p>我们还可以对序列生成器产生的数据流做进一步的筛选和处理，而这一切都可以基于协程去实现。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1dB4y1X7mY&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="序列生成器的泛化"><a href="#序列生成器的泛化" class="headerlink" title="序列生成器的泛化"></a>序列生成器的泛化</h2><p>我们已经有了一个 int 版本的 Generator，实际上我们也很容易把它泛化成模板类型，改动的地方不多，基本上把原 Generator 类型当中的 <code>int</code> 替换成模板参数 <code>T</code> 即可，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ExhaustedException</span> : std::exception &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样原来生成斐波那契数列的函数也需要稍作调整：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不过就是给 Generator 加了个模板参数而已。</p>
<h2 id="创建-Generator-的便捷函数"><a href="#创建-Generator-的便捷函数" class="headerlink" title="创建 Generator 的便捷函数"></a>创建 Generator 的便捷函数</h2><p>现在我们知道，想要创建 Generator 就需要定义一个函数或者 Lambda。不过从输出的结果上看， Generator 实际上就是一个“懒”序列，因此我们当然可以通过一个数组就能创建出 Generator 了。</p>
<p>使用数组创建 Generator 的版本实现比较简单，我们直接给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_array</span><span class="params">(T array[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 C++ 的数组作为参数时相当于指针，需要传入长度 n。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_array</span>(array, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>显然，这个写法不能令人满意。</p>
<p>我们把数组改成 std::list 如何呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from_list</span><span class="params">(std::list&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: list) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比数组，<code>std::list</code> 的版本少了一个长度参数，因为长度的信息被封装到 <code>std::list</code> 当中了。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from_list</span>(std::list&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>这个虽然有进步，但缺点也很明显，因为每次都要创建一个 <code>std::list</code>，说得直接一点儿就是每次都要多写 <code>std::list</code> 这 9 个字符。</p>
<p>这时候我们就很自然地想到了初始化列表的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="type">static</span> <span class="title">from</span><span class="params">(std::initializer_list&lt;T&gt; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t: args) &#123;</span><br><span class="line">      <span class="keyword">co_yield</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们就可以有下面的用法了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>不错，看上去需要写的内容少很多了。</p>
<p>不过，如果这对花括号也不用写的话，那就完美了。想要做到这一点，我们需要用到 C++ 17 的折叠表达式（fold expression）的特性，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...TArgs&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="type">static</span> <span class="title">from</span><span class="params">(TArgs ...args)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">co_yield</span> args, ...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的模板参数包（template parameters pack）不能用递归的方式去调用 from，因为那样的话我们会得到非常多的 Generator 对象。</p>
<p>用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>这下看上去完美多了。</p>
<h2 id="实现-map-和-flat-map"><a href="#实现-map-和-flat-map" class="headerlink" title="实现 map 和 flat_map"></a>实现 map 和 flat_map</h2><p>熟悉函数式编程的读者可能已经意识到了，我们定义的 Generator 实际上已经非常接近 Monad 的定义了。那我们是不是可以给它实现 map 和 flat_map 呢？</p>
<h3 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h3><p>map 就是将 Generator 当中的 T 映射成一个新的类型 U，得到一个新的 <code>Generator&lt;U&gt;</code>。下面我们给出第一个版本的 map 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">  Generator&lt;U&gt; <span class="title">map</span><span class="params">(std::function&lt;U(T)&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 this 当中是否有下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 使用 next 读取下一个元素</span></span><br><span class="line">      <span class="comment">// 通过 f 将其变换成 U 类型的值，再使用 co_yield 传出</span></span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <code>std::function&lt;U(T)&gt;</code> 当中的模板参数 <code>U(T)</code> 是个模板构造器，放到这里就表示这个函数的参数类型为 <code>T</code>，返回值类型为 <code>U</code>。</p>
<p>接下来我们给出用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fibonacci 是上一篇文章当中定义的函数，返回 Generator&lt;int&gt;</span></span><br><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>&lt;std::string&gt;([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过 map 函数，我们将 <code>Generator&lt;int&gt;</code> 转换成了 <code>Generator&lt;std::string&gt;</code>，外部使用 <code>generator_str</code> 就会得到字符串。</p>
<p>当然，这个实现有个小小的缺陷，那就是 map 函数的模板参数 U 必须显式提供，如上例中的 <code>&lt;std::string&gt;</code>，这是因为我们在定义 map 时用到了模板构造器，这使得类型推断变得复杂。</p>
<p>为了解决这个问题，我们就要用到模板的一些高级特性了，下面给出第二个版本的 map 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  Generator&lt;std::<span class="type">invoke_result_t</span>&lt;F, T&gt;&gt; <span class="built_in">map</span>(F f) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">f</span><span class="params">(next())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里我们直接用模板参数 <code>F</code> 来表示转换函数 f 的类型。map 本身的定义要求 <code>F</code> 的参数类型是 <code>T</code>，然后通过 <code>std::invoke_result_t&lt;F, T&gt;</code> 类获取 <code>F</code> 的返回值类型。</p>
<p>这样我们在使用时就不需要显式的传入模板参数了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Generator&lt;std::string&gt; generator_str = <span class="built_in">fibonacci</span>().<span class="built_in">map</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="实现-flat-map"><a href="#实现-flat-map" class="headerlink" title="实现 flat_map"></a>实现 flat_map</h3><p>在给出实现之前，我们需要先简单了解一下 flat_map 的概念。</p>
<p>前面提到的 map 是元素到元素的映射，而 flap_map 是元素到 Generator 的映射，然后将这些映射之后的 Generator 再展开（flat），组合成一个新的 Generator。这意味如果一个 Generator 会传出 5 个值，那么这 5 个值每一个值都会映射成一个新的 Generator，，得到的这 5 个 Generator 又会整合成一个新的 Generator。</p>
<p>由此可知，map 不会使得新 Generator 的值的个数发生变化，flat_map 会。</p>
<p>下面我们给出 flat_map 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="comment">// 返回值类型就是 F 的返回值类型</span></span><br><span class="line">  <span class="function">std::<span class="type">invoke_result_t</span>&lt;F, T&gt; <span class="title">flat_map</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="comment">// 值映射成新的 Generator</span></span><br><span class="line">      <span class="keyword">auto</span> generator = <span class="built_in">f</span>(<span class="built_in">next</span>());</span><br><span class="line">      <span class="comment">// 将新的 Generator 展开</span></span><br><span class="line">      <span class="keyword">while</span> (generator.<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> generator.<span class="built_in">next</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了加深大家的理解，我们给出一个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 返回值类型必须显式写出来，表明这个函数是个协程</span></span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="comment">// 在协程当中，我们可以使用 co_yield 传值出来</span></span><br><span class="line">        <span class="keyword">co_yield</span> j; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;* &quot;</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子的运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">* *</span><br><span class="line">* * *</span><br><span class="line">* * * *</span><br></pre></td></tr></table></figure>

<p>我们来稍微做下拆解。</p>
<ol>
<li><code>Generator&lt;int&gt;::from(1, 2, 3, 4)</code> 得到的是序列 <code>1 2 3 4</code></li>
<li>flat_map 之后，得到 <code>0 0 1 0 1 2 0 1 2 3</code></li>
</ol>
<p>由于我们在 0 的位置做了换行，因此得到的输出就是 * 组成的三角形了。</p>
<h2 id="其他有趣的函数"><a href="#其他有趣的函数" class="headerlink" title="其他有趣的函数"></a>其他有趣的函数</h2><h3 id="遍历所有值的-for-each"><a href="#遍历所有值的-for-each" class="headerlink" title="遍历所有值的 for_each"></a>遍历所有值的 for_each</h3><p>序列的最终使用，往往就是遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">for_each</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="built_in">f</span>(<span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折叠值的-fold"><a href="#折叠值的-fold" class="headerlink" title="折叠值的 fold"></a>折叠值的 fold</h3><p>Generator 会生成很多值，如果我们需要对这些值做一些整体的处理，并最终得到一个值，那么我们就需要折叠函数 fold：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  R <span class="title">fold</span><span class="params">(R initial, F f)</span> </span>&#123;</span><br><span class="line">    R acc = initial;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      acc = <span class="built_in">f</span>(acc, <span class="built_in">next</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它需要一个初始值，函数 f 接收两个参数，分别是 acc 和序列生成器当前迭代的元素，每次经过 f 做运算得到的结果会作为下次迭代的 acc 传入，直到最后 acc 作为 fold 的返回值返回。</p>
<p>我们可以很方便地使用 fold 求和或者求取阶乘，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// result: 720</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .<span class="built_in">fold</span>(<span class="number">1</span>, [](<span class="keyword">auto</span> acc, <span class="keyword">auto</span> i)&#123; </span><br><span class="line">    <span class="keyword">return</span> acc * i;  <span class="comment">// 计算阶乘</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="求和函数-sum"><a href="#求和函数-sum" class="headerlink" title="求和函数 sum"></a>求和函数 sum</h3><p>求和本身可以用前面的 fold 来实现，当然我们也可以直接给出 sum 函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      sum += <span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// result: 21</span></span><br><span class="line"><span class="keyword">auto</span> result = Generator&lt;<span class="type">double</span>&gt;::<span class="built_in">from</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6.0f</span>).<span class="built_in">sum</span>();</span><br></pre></td></tr></table></figure>

<h3 id="过滤部分值的-filter"><a href="#过滤部分值的-filter" class="headerlink" title="过滤部分值的 filter"></a>过滤部分值的 filter</h3><p>你几乎可以在任何看到 map/flat_map 的场合看到 filter，毕竟有些值我们根本不需要。</p>
<p>想要实现这个过滤，只需要一个条件判断，下面我们给出 fitler 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">filter</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = <span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截取前-n-个值的-take-n"><a href="#截取前-n-个值的-take-n" class="headerlink" title="截取前 n 个值的 take(n)"></a>截取前 n 个值的 take(n)</h3><p>序列生成器往往与<strong>懒序列</strong>同时出现，因为<strong>懒序列</strong>之所以<strong>懒</strong>，往往是因为它的长度可能很长（甚至无限，例如斐波那契数列），一次性将所有的值加载出来会比较影响性能。</p>
<p>对于这种很长的懒序列，我们最终能用到的值可能并不多，因此我们需要一个函数 <code>take(n)</code> 对序列的前 <code>n</code> 个做截取。</p>
<p>它的实现也是显而易见的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">Generator <span class="title">take</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; n &amp;&amp; <span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">co_yield</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截取到指定条件的-take-while"><a href="#截取到指定条件的-take-while" class="headerlink" title="截取到指定条件的 take_while"></a>截取到指定条件的 take_while</h3><p>take_while 的实现就好像是 filter 与 take(n) 的一个结合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  Generator <span class="title">take_while</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">has_next</span>()) &#123;</span><br><span class="line">      T value = <span class="built_in">next</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如我们想要截取小于 100 的所有斐波那契数列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fibonacci</span>().<span class="built_in">take_while</span>([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">100</span>;</span><br><span class="line">&#125;).for_each([](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>就会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55 89</span><br></pre></td></tr></table></figure>

<h2 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h2><p>前面给出了这么多函数的实现，目的主要是为了<del>凑字数</del>让大家充分理解 C++ 协程的妙处。为了进一步确认大家对于前面例子的理解程度，我们再给出一个例子，请大家思考这当中的每一个 lambda 分别调用几次，以及输出什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Generator&lt;<span class="type">int</span>&gt;::<span class="built_in">from</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    .<span class="built_in">filter</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;filter: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">map</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> i * <span class="number">3</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="built_in">flat_map</span>([](<span class="keyword">auto</span> i) -&gt; Generator&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;flat_map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="built_in">take</span>(<span class="number">3</span>)</span><br><span class="line">    .for_each([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;for_each: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>大家在分析的时候，请牢记 Generator 生成的序列是懒序列，只要最终访问到的时候才会生成。</p>
<p>这意味着中间的 map 其中根本不会主动消费 Generator，flat_map 也不会，filter 也不会，take 也不会。只有 for_each 调用的时候，才会真正需要知道 Generator 当中都有什么。</p>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter: 1</span><br><span class="line">filter: 2</span><br><span class="line">map: 2</span><br><span class="line">flat_map: 6</span><br><span class="line">for_each: 0</span><br><span class="line">for_each: 1</span><br><span class="line">for_each: 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong>：大家可以返回去再看一下我们给出的函数的实现，找一下哪些当中用到了 <code>co_yield</code>，哪些没有用到，以及这两类函数有什么区别。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对前文当中的序列生成器做了泛化，使它能够支持任意类型的序列生成。此外，我们也针对序列生成器添加了一系列的函数式的支持，以帮助读者进一步深入理解协程的工作机制。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（4）：通用异步任务 Task</title>
    <url>//2022/03/19/cpp-coroutines-04-task/</url>
    <content><![CDATA[<blockquote>
<p>协程主要用来降低异步任务的编写复杂度，异步任务各式各样，但归根结底就是一个结果的获取。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV163411g7np&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>为了方便介绍后续的内容，我们需要再定义一个类型 <code>Task</code> 来作为协程的返回值。<code>Task</code> 类型可以用来封装任何返回结果的异步行为（持续返回值的情况可能更适合使用序列生成器）。</p>
<p>实现的效果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 1 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// sleep 2 秒</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// result2 == 2</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// result3 == 3</span></span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义以 <code>Task&lt;ResultType&gt;</code> 为返回值类型的协程，并且可以在协程内部使用 <code>co_await</code> 来等待其他 <code>Task</code> 的执行。</p>
<p>外部非协程内的函数当中访问 <code>Task</code> 的结果时，我们可以通过回调或者同步阻塞调用两种方式来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步方式</span></span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步方式</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    ... <span class="comment">// i == 6</span></span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个效果，我们大致可以分析得到：</p>
<ol>
<li>需要一个结果类型来承载正常返回和异常抛出的情况。</li>
<li>需要为 <code>Task</code> 定义相应的 <code>promise_type</code> 类型来支持 <code>co_return</code> 和 <code>co_await</code>。</li>
<li>为 <code>Task</code> 实现获取结果的阻塞函数 <code>get_result</code> 或者用于获取返回值的回调 <code>then</code> 以及用于获取抛出的异常的回调 <code>catching</code>。</li>
</ol>
<h2 id="结果类型的定义"><a href="#结果类型的定义" class="headerlink" title="结果类型的定义"></a>结果类型的定义</h2><p>描述 <code>Task</code> 正常返回的结果和抛出的异常，只需要定义一个持有二者的类型即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化为默认值</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 正常返回时用结果初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(T &amp;&amp;value)</span> : _value(value) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 Task 抛异常时用异常初始化 Result</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取结果，有异常则抛出异常</span></span><br><span class="line">  <span class="function">T <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T _value&#123;&#125;;</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>Result</code> 的模板参数 <code>T</code> 对应于 <code>Task</code> 的返回值类型。有了这个结果类型，我们就可以很方便地在需要读取结果的时候调用 <code>get_or_throw</code>。</p>
<h2 id="promise-type-的定义"><a href="#promise-type-的定义" class="headerlink" title="promise_type 的定义"></a>promise_type 的定义</h2><p>promise_type 的定义自然是最为重要的部分。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>基于前面几篇文章的基础，我们能够<del>很轻松地</del>给出它的基本结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程立即执行</span></span><br><span class="line">  <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行结束后挂起，等待外部销毁。该逻辑与前面的 Generator 类似</span></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造协程的返回值对象 Task</span></span><br><span class="line">  <span class="function">Task&lt;ResultType&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将异常存入 result</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将返回值存入 result，对应于协程内部的 &#x27;co_return value&#x27;</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 使用 std::optional 可以区分协程是否执行完成</span></span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="await-transform"><a href="#await-transform" class="headerlink" title="await_transform"></a>await_transform</h3><p>光有这些还不够，我们还需要为 <code>Task</code> 添加 <code>co_await</code> 的支持。这里我们有两个选择：</p>
<ol>
<li>为 <code>Task</code> 实现 <code>co_await</code> 运算符</li>
<li>在 <code>promise_type</code> 当中定义 <code>await_transform</code></li>
</ol>
<p>从效果上来看，二者都可以做到。但区别在于，<code>await_transform</code> 是 <code>promsie_type</code> 的内部函数，可以直接访问到 <code>promise</code> 内部的状态；同时，<code>await_transform</code> 的定义也会限制协程内部对于其他类型的 <code>co_await</code> 的支持，将协程内部的挂起行为更好的管控起来，方便后续我们做统一的线程调度。因此此处我们采用 <code>await_transform</code> 来为 <code>Task</code> 提供 <code>co_await</code> 支持：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里的模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType&gt;(std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，返回了一个 <code>TaskAwaiter</code> 的对象。不过再次请大家注意，这里存在两个 <code>Task</code>，一个是 <code>TaskPromise</code> 对应的 <code>Task</code>，一个是 <code>co_await</code> 表达式的操作数 <code>Task</code>，后者是 <code>await_transform</code> 的参数。</p>
<p>下面是 <code>TaskAwaiter</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 task 执行完之后调用 resume</span></span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复执行时，被等待的 Task 已经执行完，调用 get_result 来获取结果</span></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R&gt; task;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当一个 <code>Task</code> 实例被 co_await 时，意味着它在 co_await 表达式返回之前已经执行完毕，当 <code>co_await</code> 表达式返回时，<code>Task</code> 的结果也就被取到，<code>Task</code> 实例在后续就没有意义了。因此 <code>TaskAwaiter</code> 的构造器当中接收 <code>Task &amp;&amp;</code>，防止 <code>co_await</code> 表达式之后继续对 <code>Task</code> 进行操作。</p>
<h3 id="同步阻塞获取结果"><a href="#同步阻塞获取结果" class="headerlink" title="同步阻塞获取结果"></a>同步阻塞获取结果</h3><p>为了防止 <code>result</code> 被外部随意访问，我们特意将其改为私有成员。接下来我们还需要提供相应的方式方便外部访问 <code>result</code>。</p>
<p>先来看一下如何实现同步阻塞的结果返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    <span class="comment">// 通知 get_result 当中的 wait</span></span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 result 没有值，说明协程还没有运行完，等待值被写入再返回</span></span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// 等待写入值之后调用 notify_all</span></span><br><span class="line">      completion.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有值，则直接返回（或者抛出异常）</span></span><br><span class="line">    <span class="keyword">return</span> result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::optional&lt;Result&lt;ResultType&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">  std::mutex completion_lock;</span><br><span class="line">  std::condition_variable completion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然要阻塞，就免不了用到锁（mutex）和条件变量（condition_variable），熟悉它们的读者一定觉得事情变得不那么简单了：这些工具在以往都是用在多线程并发的环境当中的。我们现在这么写其实也是为了后续应对多线程的场景，有关多线程调度的问题我们将在下一篇文章当中讨论。</p>
<h3 id="异步结果回调"><a href="#异步结果回调" class="headerlink" title="异步结果回调"></a>异步结果回调</h3><p>异步回调的实现稍微复杂一些，其实主要复杂在对于函数的运用。实际上对于回调的支持，主要就是支持回调的注册和回调的调用。根据结果类型的不同，回调又分为返回值的回调或者抛出异常的回调：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(ResultType value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;ResultType&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 加锁判断 result</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// result 已经有值</span></span><br><span class="line">      <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">      <span class="comment">// 解锁之后再调用 func</span></span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">func</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则添加回调函数，等待调用</span></span><br><span class="line">      completion_callbacks.<span class="built_in">push_back</span>(func);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调列表，我们允许对同一个 Task 添加多个回调</span></span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;ResultType&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_callbacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = result.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;callback : completion_callbacks) &#123;</span><br><span class="line">      <span class="built_in">callback</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用完成，清空回调</span></span><br><span class="line">    completion_callbacks.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，如果只是在单线程环境内运行协程，这里的异步回调的作用可能并不明显。这里只是先给出定义，待我们后续支持线程调度之后，这些回调支持就会非常有价值了。</p>
<h2 id="Task-的实现"><a href="#Task-的实现" class="headerlink" title="Task 的实现"></a>Task 的实现</h2><p>现在我们已经实现了最为关键的 <code>promise_type</code>，接下来给出 <code>Task</code> 类型的完整定义。我想各位读者一定明白，<code>Task</code> 不过就是个摆设，它的能力大多都是通过调用 <code>promise_type</code> 来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明 promise_type 为 TaskPromise 类型</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function">ResultType <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>(ResultType)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>(result.<span class="built_in">get_or_throw</span>());</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// 忽略异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略返回值</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">finally</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123; <span class="built_in">func</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(std::coroutine_handle&lt;promise_type&gt; handle)</span> <span class="keyword">noexcept</span>: handle(handle) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;&amp;task) <span class="keyword">noexcept</span>: <span class="built_in">handle</span>(std::<span class="built_in">exchange</span>(task.handle, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Task</span>(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  Task &amp;<span class="keyword">operator</span>=(Task &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle) handle.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们完成了 <code>Task</code> 的第一个通用版本的实现，这个版本的实现当中尽管我们对 <code>Task</code> 的结果做了加锁，但考虑到目前我们仍没有提供线程切换的能力，因此这实际上是一个无调度器版本的 <code>Task</code> 实现。</p>
<h2 id="Task-的-void-特化"><a href="#Task-的-void-特化" class="headerlink" title="Task 的 void 特化"></a>Task 的 void 特化</h2><p>前面讨论的 <code>Task</code> 有一个作为返回值类型的模板参数 <code>ResultType</code>。实际上有些时候我们只是希望一段任务可以异步执行完，而不关注它的结果，这时候 <code>ResultType</code> 就需要是 <code>void</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很快你就会发现问题。编译器会告诉你模板实例化错误，因为我们没法用 <code>void</code> 来声明变量；编译器还会告诉你协程体里面如果没有返回值，你应该提供为 <code>promise_type</code> 提供 <code>return_void</code> 函数。</p>
<p>看来情况没有那么简单。C++ 的模板经常会遇到这种需要特化的情况，我们只需要对之前的 <code>Task&lt;ResultType&gt;</code> 版本的定义稍作修改，就可以给出 <code>Task&lt;void&gt;</code> 的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 用 void 作为第一个模板参数实例化 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;<span class="type">void</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是 void，因此不用 return</span></span><br><span class="line">    <span class="comment">// 这时这个函数的作用就是阻塞当前线程等待协程执行完成</span></span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// func 的类型参数 void()，注意之前这个模板类型构造器还有个参数 ResultType</span></span><br><span class="line">  <span class="function">Task &amp;<span class="title">then</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 我们也会对 result 做 void 版本的实例化，这里只是检查有没有异常抛出</span></span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// ignore.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Task &amp;<span class="title">catching</span><span class="params">(std::function&lt;<span class="type">void</span>(std::exception &amp;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    handle.<span class="built_in">promise</span>().<span class="built_in">on_completed</span>([func](<span class="keyword">auto</span> result) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result.<span class="built_in">get_or_throw</span>();</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">func</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你会发现变化的只是跟结果相关的部分。相应的，<code>TaskPromise</code> 也需要做出修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Task 的模板参数</span></span><br><span class="line">  <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回值类型改成 void</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不再需要 return</span></span><br><span class="line">    result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    <span class="comment">// Result 的模板参数变化</span></span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再是 return_value 了</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(completion_lock)</span></span>;</span><br><span class="line">    result = <span class="built_in">Result</span>&lt;<span class="type">void</span>&gt;();</span><br><span class="line">    completion.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="built_in">notify_callbacks</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void </span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">on_completed</span><span class="params">(std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt; &amp;&amp;func)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 注意 Result 的模板参数 void</span></span><br><span class="line">  std::optional&lt;Result&lt;<span class="type">void</span>&gt;&gt; result;</span><br><span class="line">  std::list&lt;std::function&lt;<span class="type">void</span>(Result&lt;<span class="type">void</span>&gt;)&gt;&gt; completion_callbacks;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有 <code>Result</code> 也有对应的 <code>void</code> 实例化版本，其实就是把存储返回值相关的逻辑全部删掉，只保留异常相关的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(std::exception_ptr &amp;&amp;exception_ptr)</span> : _exception_ptr(exception_ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get_or_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_exception_ptr) &#123;</span><br><span class="line">      std::<span class="built_in">rethrow_exception</span>(_exception_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::exception_ptr _exception_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，我们进一步完善了 <code>Task</code> 对不同类型的结果的支持，理论上我们可以使用 <code>Task</code> 来构建各式各样的协程了。</p>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来我们可以试着把文章开头的代码运行一下了。为了更仔细地观察程序的执行，我们也在一些节点打印了日志：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>debug</code> 是我自定义的一个宏，可以在打印日志的时候附加上时间、线程、函数等信息，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:46:30.448 [Thread-25132] (main.cpp:40) simple_task: task start ...</span><br><span class="line">16:46:30.449 [Thread-25132] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">16:46:31.459 [Thread-25132] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">16:46:31.460 [Thread-25132] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">16:46:31.461 [Thread-25132] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">16:46:33.469 [Thread-25132] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">16:46:33.470 [Thread-25132] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">16:46:33.471 [Thread-25132] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure>

<p>由于我们的任务在执行过程中没有进行任何线程切换，因此各个 <code>Task</code> 的执行实际上是串行的，就如同我们调用普通函数一样。当然，这显然不是我们的最终目的，下一篇我们就来介绍如何给 <code>Task</code> 增加调度器的支持。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们详细介绍了无调度器版本的 <code>Task</code> 的实现。尽管程序尚未真正实现异步执行，但至少从形式上，我们已经非常接近协程最神奇的地方了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（5）：协程的调度器</title>
    <url>//2022/03/20/cpp-coroutines-05-dispatcher/</url>
    <content><![CDATA[<blockquote>
<p>协程想要实现异步，很大程度上依赖于调度器的设计。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1TW4y1k7gp&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="调度器的抽象设计"><a href="#调度器的抽象设计" class="headerlink" title="调度器的抽象设计"></a>调度器的抽象设计</h2><p>为了实现协程的异步调度，我们需要提供调度器的实现。调度器听起来有些厉害，但实际上就是负责执行一段逻辑的工具。</p>
<p>下面我们给出调度器的抽象设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExecutor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是的，你没看错，调度器本身就是这么简单。</p>
<h2 id="调度的位置"><a href="#调度的位置" class="headerlink" title="调度的位置"></a>调度的位置</h2><p>现在我们已经知道了调度器的样子，那么问题来了，怎么才能把它接入到协程当中呢？这个问题换个说法，那就是什么情况下我们需要调度，或者说什么情况下我们可以实现调度。</p>
<p>这个问题如果你不知道答案，让你随便蒙，你大概也没有什么其他的选项可以选。因为协程的本质就是挂起和恢复，因此想要实现调度，就必须在挂起和恢复上做文章。想要在 C++ 的协程的挂起和恢复上做文章，那我们就只能考虑定制 Awaiter 了。我们再来回顾一下前面提到的 TaskAwaiter 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们只保留了最核心的三个函数，其他的代码都略去了。可以看到，想要实现调度，就只能在 <code>await_suspend</code> 上面做文章，因为其他两个函数都要求同步返回。</p>
<p>实际上，按照 C++ 协程的设计，<code>await_suspend</code> 确实是用来提供调度支持的，由于这个时间点协程已经完全挂起，因此我们可以在任意一个线程上调用 <code>handle.resume()</code>，你甚至不用担心线程安全的问题。这样看来，如果有调度器的存在，代码大概会变成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调度器的类型有多种，因此专门提供一个模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 TaskAwaiter 的时候传入调度器的具体实现</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 将 resume 函数的调用交给调度器执行</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="调度器应该由谁持有"><a href="#调度器应该由谁持有" class="headerlink" title="调度器应该由谁持有"></a>调度器应该由谁持有</h2><p><code>TaskAwaiter</code> 当中的调度器实例是从外部传来的，这样设计的目的是希望把调度器的创建和绑定交给协程本身。换句话说，调度器应该属于协程。这样设计的好处就是协程内部的代码均会被调度到它对应的调度器上执行，可以确保逻辑的一致性和正确性。</p>
<p>这么看来，调度器应该与 <code>Task</code> 或者 <code>TaskPromise</code> 绑定到一起。</p>
<p>当协程创建时，我们可以以某种方式执行一个调度器，让协程的执行从头到尾都调度到这个调度器上执行。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 协程启动时就要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="comment">// 协程从 simple_task2 挂起后恢复执行，也要调度到 LooperExecutor 上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="comment">// 同上</span></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过模板参数为 <code>Task</code> 绑定了一个叫做 <code>LooperExecutor</code> 的调度器（我们现在先不去管 <code>LooperExecutor</code> 的具体实现，这个我们后面会讲），这样一来，我们希望 <code>simple_task</code> 当中所有的代码都会被调度到 <code>LooperExecutor</code> 上执行。</p>
<p>请大家参考注释的说明，我们了解到所有挂起的位置都需要在恢复时拿到同一个 <code>LooperExecutor</code> 的实例，因此我们考虑首先对 <code>TaskPromise</code> 的定义做一下修改，引入 <code>Executor</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加模板参数 Executor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 协程启动时也需要在恢复时实现调度</span></span><br><span class="line">  <span class="function">DispatchAwaiter <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DispatchAwaiter&#123;&amp;executor&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Task 类型增加模板参数 Executor 可以方便创建协程时执行调度器的类型</span></span><br><span class="line">  <span class="function">Task&lt;ResultType, Executor&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task&#123;std::coroutine_handle&lt;TaskPromise&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意模板参数</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">  TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Executor executor;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于我们在 <code>TaskPromise</code> 当中定义了 <code>await_transform</code>，因此协程当中只支持对 <code>Task</code> 类型的 <code>co_await</code> 操作，这样可以保证所有的 <code>co_await &lt;task&gt;</code> 都会在恢复执行时通过 <code>TaskAwaiter</code> 来确保后续逻辑的正确调度。</p>
<p>剩下的就是协程在启动时的 <code>initial_suspend</code> 了，这个也比较容易处理，我们给出 <code>DispatchAwaiter</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">DispatchAwaiter</span><span class="params">(AbstractExecutor *executor)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调度到协程对应的调度器上</span></span><br><span class="line">    _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此一来，协程内部的所有逻辑都可以顺利地调度到协程对应的调度器上了。</p>
<p><code>Task</code> 的改动不大，只是增加了模板参数 <code>Executor</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewThreadExecutor 是 AbstractExecutor 的子类，作为模板参数 Executor 的默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NewThreadExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将模板参数 Executor 传给 TaskPromise</span></span><br><span class="line">  <span class="keyword">using</span> promise_type = TaskPromise&lt;ResultType, Executor&gt;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还可以默认给 <code>Task</code> 指定一个调度器的实现 <code>NewThreadExecutor</code>。这些调度器可以通过指定类型在 <code>TaskPromise</code> 当中执行初始化，因为我们会保证他们都会有默认的无参构造器实现。</p>
<h2 id="调度器的实现"><a href="#调度器的实现" class="headerlink" title="调度器的实现"></a>调度器的实现</h2><p>接下来我们给出几种简单的调度器实现作为示例，读者有兴趣也可以按照自己的需要设计调度器的实现。</p>
<h3 id="NoopExecutor"><a href="#NoopExecutor" class="headerlink" title="NoopExecutor"></a>NoopExecutor</h3><p>看名字相比大家也能猜个八九不离十，这就是个什么都不干的调度器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoopExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们给 <code>Task</code> 搭配这个调度器，<code>Task</code> 的执行线程就完全取决于调用者或者恢复者所在的线程了。</p>
<h3 id="NewThreadExecutor"><a href="#NewThreadExecutor" class="headerlink" title="NewThreadExecutor"></a>NewThreadExecutor</h3><p>顾名思义，每次调度都创建一个新的线程。实现非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewThreadExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">thread</span>(func).<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncExecutor"><a href="#AsyncExecutor" class="headerlink" title="AsyncExecutor"></a>AsyncExecutor</h3><p>这个在思路上与 <code>NewThreadExecutor</code> 差别不大，只是调度时交给了 <code>std::async</code> 去执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相比之下，这个调度器可以利用 <code>std::async</code> 背后的线程调度，提升线程的利用率。</p>
<h3 id="LooperExecutor"><a href="#LooperExecutor" class="headerlink" title="LooperExecutor"></a>LooperExecutor</h3><p>LooperExecutor 稍微复杂一些，它通常出现在主线程为事件循环的场景，例如 UI 相关应用的开发场景。</p>
<p>考虑到我本身不希望引入 UI 相关的开发概念，这里直接给出一个简单的单线程事件循环，并以此来实现 LooperExecutor：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 的时候是工作状态，如果要关闭事件循环，就置为 false</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理事件循环</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前事件循环是否是工作状态，或者队列没有清空</span></span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 队列为空，需要等待新任务加入队列或者关闭事件循环的通知</span></span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="comment">// 如果队列为空，那么说明收到的是关闭的通知</span></span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="comment">// 现有逻辑下此处用 break 也可</span></span><br><span class="line">          <span class="comment">// 使用 continue 可以再次检查状态和队列，方便将来扩展</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取出第一个任务，解锁再执行。</span></span><br><span class="line">      <span class="comment">// 解锁非常：func 是外部逻辑，不需要锁保护；func 当中可能请求锁，导致死锁</span></span><br><span class="line">      <span class="keyword">auto</span> func = executable_queue.<span class="built_in">front</span>();</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    work_thread = std::<span class="built_in">thread</span>(&amp;LooperExecutor::run_loop, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LooperExecutor</span>() &#123;</span><br><span class="line">    <span class="built_in">shutdown</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 等待线程执行完，防止出现意外情况</span></span><br><span class="line">    <span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(func);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="comment">// 通知队列，主要用于队列之前为空时调用 wait 等待的情况</span></span><br><span class="line">      <span class="comment">// 通知不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">      queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改后立即生效，在 run_loop 当中就能尽早（加锁前）就检测到 is_active 的变化</span></span><br><span class="line">    is_active.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_complete) &#123;    </span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="comment">// 清空任务队列</span></span><br><span class="line">      <span class="keyword">decltype</span>(executable_queue) empty_queue;</span><br><span class="line">      std::<span class="built_in">swap</span>(executable_queue, empty_queue);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 wait 函数，避免 Looper 线程不退出</span></span><br><span class="line">    <span class="comment">// 不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span></span><br><span class="line">    queue_condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各位读者可以参考代码注释来理解其中的逻辑。简单来说就是：</p>
<ol>
<li>当队列为空时，Looper 的线程通过 <code>wait</code> 来实现阻塞等待。</li>
<li>有新任务加入时，通过 <code>notify_one</code> 来通知 <code>run_loop</code> 继续执行。</li>
</ol>
<h3 id="SharedLooperExecutor"><a href="#SharedLooperExecutor" class="headerlink" title="SharedLooperExecutor"></a>SharedLooperExecutor</h3><p>这个其实就是 <code>LooperExecutor</code> 的一个马甲，它的作用就是让各个协程共享一个 <code>LooperExecutor</code> 实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedLooperExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> LooperExecutor sharedLooperExecutor;</span><br><span class="line">    sharedLooperExecutor.<span class="built_in">execute</span>(std::<span class="built_in">move</span>(func));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>这次我们基于上一篇文章当中的 demo 加入调度器的支持：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了 Async 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会通过 std::async 上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 NewThread 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会新建一个线程来执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了 Looper 调度器</span></span><br><span class="line"><span class="comment">// 这意味着每个恢复的位置都会在同一个线程上执行</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子的代码跟上次不能说完全没有修改吧，那也是几乎没有修改，除了加了调度器的类型作为 <code>Task</code> 的模板参数。运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:46:03.305 [Thread-32620] (main.cpp:40) simple_task: task start ...</span><br><span class="line">11:46:03.307 [Thread-33524] (main.cpp:24) simple_task2: task 2 start ...</span><br><span class="line">11:46:04.310 [Thread-33524] (main.cpp:27) simple_task2: task 2 returns after 1s.</span><br><span class="line">11:46:04.312 [Thread-32620] (main.cpp:42) simple_task: returns from task2:  2</span><br><span class="line">11:46:04.313 [Thread-42232] (main.cpp:32) simple_task3: in task 3 start ...</span><br><span class="line">11:46:06.327 [Thread-42232] (main.cpp:35) simple_task3: task 3 returns after 2s.</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:44) simple_task: returns from task3:  3</span><br><span class="line">11:46:06.329 [Thread-32620] (main.cpp:51) operator (): simple task end:  6</span><br><span class="line">11:46:06.330 [Thread-30760] (main.cpp:57) main: simple task end from get:  6</span><br></pre></td></tr></table></figure>

<p>请大家仔细观察，所有 <code>simple_task</code> 函数的日志输出都在 id 为 32620 的线程上，这实际上就是我们的 Looper 线程。当然，由于 <code>simple_task2</code> 和 <code>simple_task3</code> 当中没有挂起点，因此它们只会在 <code>initial_suspend</code> 时调度一次。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们终于给 <code>Task</code> 添加了调度器的支持。如此一来，我们就可以把 <code>Task</code> 绑定到合适的线程调度器上，来应对更加复杂的业务场景了。</p>
<p>读者也可以发挥自己的想象力，按照类似的方式定义出更加有用或者有趣的调度器。当然，本文给出的调度器没有做调度优化，有兴趣的读者也可以自己尝试</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</title>
    <url>//2022/03/20/cpp-coroutines-06-sleep/</url>
    <content><![CDATA[<blockquote>
<p>如果你想要等待 100ms，你会怎么做？sleep_for(100ms) 吗？ </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV15v4y1g7Nu&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>在以往，我们想要让程序等待 100ms，我们只能调用线程的 sleep 函数来阻塞当前线程 100ms。</p>
<p>这样做确实可以让程序等待 100ms，但坏处就是这 100ms 期间，被阻塞的当前线程什么也做不了，白白占用了内存。协程出现之后，我们其实完全可以让协程在需要 sleep 的时候挂起，100ms 之后再来恢复执行，完全不需要阻塞当前线程。</p>
<p>想法不错，马上把用例给出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="comment">// 之前的写法，用 sleep_for 让当前线程睡眠 1 秒</span></span><br><span class="line">  <span class="comment">// std::this_thread::sleep_for(1s);</span></span><br><span class="line">  <span class="comment">// 等待 1 秒，注意 1s 是 chrono_literals 的字面值写法</span></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子大家已经见过多次了，之前用的是 <code>sleep_for</code> 让线程睡眠 1 秒，这次我们直接用 <code>co_await 1s</code>，看上去是不是特别的厉害？</p>
<h2 id="为-duration-实现-await-transform"><a href="#为-duration-实现-await-transform" class="headerlink" title="为 duration 实现 await_transform"></a>为 duration 实现 await_transform</h2><p>如果大家对于 C++ 11 不熟悉，可能会比较疑惑 <code>co_await 1s</code> 当中的 <code>1s</code> 是个什么东西。实际上这是 C++ 11 对字面值的一种支持，本质上就是一个运算符重载，这里的 <code>1s</code> 的类型是 <code>duration&lt;long long&gt;</code>。除了秒以外，时间的单位也可以是毫秒、纳秒、分钟、小时等等，这些 C++ 11 的 <code>duration</code> 都已经提供了完善的支持，因此我们只要对 <code>duration</code> 做支持即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入了一个新的类型 <code>SleepAwaiter</code>，它的任务有两个：</p>
<ol>
<li>确保当前协程在若干毫秒之后恢复执行。</li>
<li>确保当前协程恢复执行时要调度到对应的调度器上。</li>
</ol>
<p>不难想到，<code>std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()</code> 实际上就是把任意单位的 <code>duration</code> 转换成毫秒。</p>
<p><code>SleepAwaiter</code> 的实现也很简单，我们直接给出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的延时执行工具类，全局只需要一个实例</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      <span class="comment">// _duration 毫秒之后执行下面的代码</span></span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这当中最为关键的就是 <code>Scheduler</code> 的实现了，这个类实际上本身就是一个独立的定时任务调度器。</p>
<h2 id="定时任务调度器-Scheduler"><a href="#定时任务调度器-Scheduler" class="headerlink" title="定时任务调度器 Scheduler"></a>定时任务调度器 Scheduler</h2><p>定时任务调度器，本质上就是一个时间管理大师。任何交给它的任务都需要有优先级，优先级的计算规则当然就是延时的长短，于是我们需要用到优先级队列来存储待执行的任务。</p>
<p>等下，任务队列？这让我想起上一篇文章当中的 <code>LooperExecutor</code>，如果我们给它加上计时执行的能力，<code>Scheduler</code> 的功能就差不多完成了。换个角度看，<code>LooperExecutor</code> 其实就是 <code>Scheduler</code> 的一个特化版本，它的所有任务的延时都是 0。</p>
<h3 id="定义定时任务的描述类型"><a href="#定义定时任务的描述类型" class="headerlink" title="定义定时任务的描述类型"></a>定义定时任务的描述类型</h3><p>为了方便管理定时任务，我们需要定义一个类型 <code>DelayedExecutable</code>，它包含一个函数和它要执行的绝对时间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DelayedExecutable</span>(std::function&lt;<span class="built_in">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay) : <span class="built_in">func</span>(std::<span class="built_in">move</span>(func)) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 当前的时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出任务的计划执行时间</span></span><br><span class="line">    scheduled_time = current + delay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用时，返回从当前时间还需要多少毫秒到任务执行时间</span></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">delay</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> current = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> scheduled_time - current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_scheduled_time</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduled_time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> scheduled_time;</span><br><span class="line">  std::function&lt;<span class="type">void</span>()&gt; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定时任务的描述类 <code>DelayedExecutable</code> 非常简单，相信大家一看就明白。</p>
<p>为了将 <code>DelayedExecutable</code> 存入优先级队列当中，我们还需要给它提给一个比较大小的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayedExecutableCompare</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(DelayedExecutable &amp;left, DelayedExecutable &amp;right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">get_scheduled_time</span>() &gt; right.<span class="built_in">get_scheduled_time</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类就很简单了，直接将对 <code>DelayedExecutable</code> 的比较转换成对它们的执行时间的比较。使用这个类对 <code>DelayedExecutable</code> 进行排序时，会使得时间靠前的对象排到前面。</p>
<h3 id="实现定时任务调度器"><a href="#实现定时任务调度器" class="headerlink" title="实现定时任务调度器"></a>实现定时任务调度器</h3><p>接下来我们直接给出 <code>Scheduler</code> 的实现，由于这个类与前面的 <code>LooperExecutor</code> 很像，我们只给出不同的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable queue_condition;</span><br><span class="line">  std::mutex queue_lock;</span><br><span class="line">  <span class="comment">// 注意这里改用优先级队列</span></span><br><span class="line">  std::priority_queue&lt;DelayedExecutable, std::vector&lt;DelayedExecutable&gt;, DelayedExecutableCompare&gt; executable_queue;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; is_active;</span><br><span class="line">  std::thread work_thread;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed) || !executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="keyword">if</span> (executable_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从这里开始于 LooperExecutor 不同，这里需要判断优先级队头的任务，也就是最先要执行的任务是否需要立即执行</span></span><br><span class="line">      <span class="keyword">auto</span> executable = executable_queue.<span class="built_in">top</span>();</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> delay = executable.<span class="built_in">delay</span>();</span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队头的任务还没到执行时间，等待 delay 毫秒</span></span><br><span class="line">        <span class="keyword">auto</span> status = queue_condition.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(delay));</span><br><span class="line">        <span class="comment">// 如果等待期间没有延时比 delay 更小的任务加入，这里就会返回 timeout</span></span><br><span class="line">        <span class="keyword">if</span> (status != std::cv_status::timeout) &#123;</span><br><span class="line">          <span class="comment">// 不是 timeout，需要重新计算队头的延时</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      executable_queue.<span class="built_in">pop</span>();</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">executable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Scheduler</span>() &#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;func, <span class="type">long</span> <span class="type">long</span> delay)</span> </span>&#123;</span><br><span class="line">    delay = delay &lt; <span class="number">0</span> ? <span class="number">0</span> : delay;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(queue_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 只有队列为空或者比当前队头任务的延时更小时，需要调用 notify_one</span></span><br><span class="line">      <span class="comment">// 其他情况只需要按顺序依次执行即可</span></span><br><span class="line">      <span class="type">bool</span> need_notify = executable_queue.<span class="built_in">empty</span>() || executable_queue.<span class="built_in">top</span>().<span class="built_in">delay</span>() &gt; delay;</span><br><span class="line">      executable_queue.<span class="built_in">push</span>(<span class="built_in">DelayedExecutable</span>(std::<span class="built_in">move</span>(func), delay));</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">if</span> (need_notify) &#123;</span><br><span class="line">        queue_condition.<span class="built_in">notify_one</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">bool</span> wait_for_complete = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 与 LooperExecutor 完全相同</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">      work_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过对代码和注释的阅读，相信大家能够明白延时的实现其实是通过阻塞一个专门用于调度延时任务的线程来做到的。</p>
<p>相信有读者会有疑问：这不还是有阻塞吗？</p>
<p>没错，阻塞是免不了的。通常而言，我们也不会用一个线程去严格对应一个协程，当一个协程挂起时，执行这个协程的线程就会被空闲出来有机会去调度执行其他协程，进而让线程的利用率得到充分提升。如果有 10 个协程都需要执行延时，相较于阻塞这 10 个协程当前所在的 10 个线程而言，阻塞一个线程显然是更加经济的。</p>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们又一次在文章的最后把要实现的功能做好，现在是收获的时刻了。</p>
<p>我们先来一个开胃菜。前面我们提到过，<code>Scheduler</code> 实际上是一个完整独立的功能模块，因此我们先写个简单的用例来测试一下它的功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> scheduler = <span class="built_in">Scheduler</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">debug</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;2&quot;</span>); &#125;, <span class="number">100</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;1&quot;</span>); &#125;, <span class="number">50</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;6&quot;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;5&quot;</span>); &#125;, <span class="number">500</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;3&quot;</span>); &#125;, <span class="number">200</span>);</span><br><span class="line">scheduler.<span class="built_in">execute</span>([]() &#123; <span class="built_in">debug</span>(<span class="string">&quot;4&quot;</span>); &#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">scheduler.<span class="built_in">shutdown</span>();</span><br><span class="line">scheduler.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p>打印的数字是按照时间顺序排列的，但任务的添加却是乱序的。运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:12:54.611 [Thread-16076] (main.cpp:12) main: start</span><br><span class="line">22:12:54.673 [Thread-3252] (main.cpp:14) operator (): 1</span><br><span class="line">22:12:54.721 [Thread-3252] (main.cpp:13) operator (): 2</span><br><span class="line">22:12:54.815 [Thread-3252] (main.cpp:17) operator (): 3</span><br><span class="line">22:12:54.924 [Thread-3252] (main.cpp:18) operator (): 4</span><br><span class="line">22:12:55.113 [Thread-3252] (main.cpp:16) operator (): 5</span><br><span class="line">22:12:55.618 [Thread-3252] (main.cpp:15) operator (): 6</span><br></pre></td></tr></table></figure>
<p>可以看到 1-6 的顺序是可以保证的，前面的时间信息也可以看到延时能力基本上是符合预期的。</p>
<p>接下来，我们把前面用了好几次的 <code>Task</code> 的 demo 拿出来，加上延时，顺便也验证一下 <code>AsyncExecutor</code> 和 <code>NewThreadExecutor</code> 的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, AsyncExecutor&gt; <span class="title">simple_task2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">1</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 2 returns after 1s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, NewThreadExecutor&gt; <span class="title">simple_task3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;in task 3 start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task 3 returns after 2s.&quot;</span>);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;task start ...&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">100</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 100ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task2: &quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">500</span>ms;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;after 500ms ...&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="keyword">co_await</span> <span class="built_in">simple_task3</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;returns from task3: &quot;</span>, result3);</span><br><span class="line">  <span class="keyword">co_return</span> <span class="number">1</span> + result2 + result3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> simpleTask = <span class="built_in">simple_task</span>();</span><br><span class="line">  simpleTask.<span class="built_in">then</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end: &quot;</span>, i);</span><br><span class="line">  &#125;).<span class="built_in">catching</span>([](std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error occurred&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = simpleTask.<span class="built_in">get_result</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;simple task end from get: &quot;</span>, i);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;error: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:14:49.531 [Thread-15596] (main.cpp:41) simple_task: task start ...</span><br><span class="line">22:14:49.641 [Thread-15596] (main.cpp:44) simple_task: after 100ms ...</span><br><span class="line">22:14:49.643 [Thread-26892] (main.cpp:25) simple_task2: task 2 start ...</span><br><span class="line">22:14:50.652 [Thread-26892] (main.cpp:28) simple_task2: task 2 returns after 1s.</span><br><span class="line">22:14:50.653 [Thread-15596] (main.cpp:46) simple_task: returns from task2:  2</span><br><span class="line">22:14:51.156 [Thread-15596] (main.cpp:49) simple_task: after 500ms ...</span><br><span class="line">22:14:51.158 [Thread-16816] (main.cpp:33) simple_task3: in task 3 start ...</span><br><span class="line">22:14:53.165 [Thread-26756] (main.cpp:36) simple_task3: task 3 returns after 2s.</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:51) simple_task: returns from task3:  3</span><br><span class="line">22:14:53.166 [Thread-15596] (main.cpp:58) operator (): simple task end:  6</span><br><span class="line">22:14:53.167 [Thread-11256] (main.cpp:64) test_tasks: simple task end from get:  6</span><br></pre></td></tr></table></figure>

<p>我们把所有的 <code>sleep_for</code> 都替换成了本文实现的无阻塞的 sleep，运行效果上来看确实可以按照要求实现延时执行。</p>
<p>另外，由于这里的 <code>co_await 1s</code> 这样的操作都是挂起点，因此恢复时也会用协程的调度器去调度。可以看到，<code>simple_task2</code> 的两行日志的线程都是 <code>26892</code>，这大概是因为 <code>std::async</code> 背后是一个线程池，两次调度都调度到了同一个线程上，当然这个完全取决于 <code>std::async</code> 的实现。而 <code>simple_task3</code> 的两行日志就分别运行在 <code>16816</code> 和 <code>26756</code>，因为它的调度器是 <code>NewThreadExecutor</code>，每次都会新起一个线程来实现调度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文结合前面的 <code>Task</code> 的内容进一步给出了无阻塞式的 sleep 实现。通过本文的探讨，相信大家族在感慨 C++ 协程的设计真的是如此的灵活的同时，也进一步深入了解了 C++ 协程的用法。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</title>
    <url>//2022/03/22/cpp-coroutines-07-channel/</url>
    <content><![CDATA[<blockquote>
<p>之前我们主要关注的是协程与外部调用者的交互，这次我们也关注一下对等的协程之间的通信。 </p>
</blockquote>
<span id="more"></span>

<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1oA4y1R7jn&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><h3 id="Go-routine-的-Channel"><a href="#Go-routine-的-Channel" class="headerlink" title="Go routine 的 Channel"></a>Go routine 的 Channel</h3><p>Go routine 当中有一个重要的特性就是 Channel。我们可以向 Channel 当中写数据，也可以从中读数据。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Channel 实例</span></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line"><span class="comment">// 创建只读 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="type">int</span> = channel</span><br><span class="line"><span class="comment">// 创建只写 Channel 引用</span></span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="type">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">  fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">  <span class="comment">// 遍历 Channel</span></span><br><span class="line">  <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// 读取 Channel，值存入 i，状态存入 ok 当中</span></span><br><span class="line">    i, ok := &lt;-readChannel</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Channel 被关闭时，ok 为 false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">    <span class="comment">// 向 Channel 当中写数据</span></span><br><span class="line">    writeChannel &lt;- i</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这个例子是我写 <a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书时用到过的一个非常简单的 Go routine 的例子，它的运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure>

<p>Go 当中的 Channel 默认是没有 buffer 的，我们也可以通过 <code>make chan</code> 在初始化 Channel 的时候指定 buffer。在 buffer 已满的情况下，写入者会先挂起等待读取者后再恢复执行，反之亦然。等待的过程中，所处的协程会挂起，执行调度的线程自然也会被释放用于调度其他逻辑。</p>
<h3 id="C-协程的-Channel-实现设计"><a href="#C-协程的-Channel-实现设计" class="headerlink" title="C++ 协程的 Channel 实现设计"></a>C++ 协程的 Channel 实现设计</h3><p>Kotlin 协程当中也有 Channel，与 Go 的不同之处在于 Kotlin 的 Channel 其实是基于协程最基本的 API 在框架层面实现的，并非语言原生提供的能力。C++ 的协程显然也可以采用这个思路，实际上整个这一系列 C++ 协程的文章都是在介绍如何使用 C++ 20 标准当中提供的基本的协程 API 在构建更复杂的框架支持。</p>
<p>我们来看一下我们最终的 Channel 的用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 写入时调用 write 函数</span></span><br><span class="line">    <span class="keyword">co_await</span> channel.<span class="built_in">write</span>(i++);</span><br><span class="line">    <span class="comment">// 或者使用 &lt;&lt; 运算符</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持关闭</span></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取时使用 read 函数，表达式的值就是读取的值</span></span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="comment">// 或者使用 &gt;&gt; 运算符将读取的值写入变量当中</span></span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="comment">// 捕获 Channel 关闭时抛出的异常</span></span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 Channel 也可以在构造的时候传入 buffer 的大小，默认没有 buffer。</p>
<h2 id="co-await-表达式的支持"><a href="#co-await-表达式的支持" class="headerlink" title="co_await 表达式的支持"></a>co_await 表达式的支持</h2><p>想要支持 <code>co_await</code> 表达式，只需要为 Channel 读写函数返回的 Awaiter 类型添加相应的 <code>await_transform</code> 函数。我们姑且认为 <code>read</code> 和 <code>write</code> 两个函数的返回值类型 <code>ReaderAwaiter</code> 和 <code>WriterAwaiter</code>，接下来就添加一个非常简单的 <code>await_transform</code> 的支持：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 void 的实例化版本也是一样的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">    reader_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(WriterAwaiter&lt;_ValueType&gt; writer_awaiter)</span> </span>&#123;</span><br><span class="line">    writer_awaiter.executor = &amp;executor;</span><br><span class="line">    <span class="keyword">return</span> writer_awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Channel</code> 的 buffer 和对 <code>Channel</code> 的读写本身会决定协程是否挂起或恢复，因此这些逻辑我们都将在 <code>Channel</code> 当中给出，<code>TaskPromise</code> 能做的就是把调度器传过去，当协程恢复时使用。</p>
<h2 id="Awaiter-的实现"><a href="#Awaiter-的实现" class="headerlink" title="Awaiter 的实现"></a>Awaiter 的实现</h2><p>Awaiter 负责在挂起时将自己存入 <code>Channel</code>，并且在需要时恢复协程。因此除了前面看到需要在恢复执行协程时的调度器之外，Awaiter 还需要持有 <code>Channel</code>、需要读写的值。</p>
<p>下面是 <code>WriterAwaiter</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriterAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  <span class="comment">// 调度器不是必须的，如果没有，则直接在当前线程执行（等价于 NoopExecutor）</span></span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 写入 Channel 的值</span></span><br><span class="line">  ValueType _value;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriterAwaiter</span>(Channel&lt;ValueType&gt; *channel, ValueType value)</span><br><span class="line">    : <span class="built_in">channel</span>(channel), _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录协程 handle，恢复时用</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_writer</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中恢复该协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们将调度器调度的逻辑封装在这里</span></span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相对应的，还有 <code>ReaderAwaiter</code>，实现类似：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  <span class="comment">// 用于 channel &gt;&gt; received; 这种情况</span></span><br><span class="line">  <span class="comment">// 需要将变量的地址传入，协程恢复时写入变量内存</span></span><br><span class="line">  ValueType* p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    <span class="comment">// 将自身传给 Channel，Channel 内部会根据自身状态处理是否立即恢复或者挂起</span></span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Channel 关闭时也会将挂起的读写协程恢复</span></span><br><span class="line">    <span class="comment">// 要检查是否是关闭引起的恢复，如果是，check_closed 会抛出 Channel 关闭异常</span></span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 当中正常恢复读协程时调用 resume 函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channel 关闭时调用 resume() 函数来恢复该协程</span></span><br><span class="line">  <span class="comment">// 在 await_resume 当中，如果 Channel 关闭，会抛出 Channel 关闭异常</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单说来，Awaiter 的功能就是：</p>
<ol>
<li>负责用协程的调度器在需要时恢复协程</li>
<li>处理读写的值的传递</li>
</ol>
<h2 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h2><p>接下来我们给出 <code>Channel</code> 当中根据 buffer 的情况来处理读写两端的挂起和恢复的逻辑。</p>
<h3 id="Channel-的基本结构"><a href="#Channel-的基本结构" class="headerlink" title="Channel 的基本结构"></a>Channel 的基本结构</h3><p>我们先来看一下 <code>Channel</code> 的基本结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ChannelClosedException</span> : std::exception &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Channel is closed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_closed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经关闭，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!_is_active.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ChannelClosedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(<span class="type">int</span> capacity = <span class="number">0</span>)</span> : buffer_capacity(capacity) &#123;</span></span><br><span class="line">    _is_active.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// true 表示 Channel 尚未关闭</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _is_active.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 Channel</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> expect = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 判断如果已经关闭，则不再重复操作</span></span><br><span class="line">    <span class="comment">// 比较 _is_active 为 true 时才会完成设置操作，并且返回 true</span></span><br><span class="line">    <span class="keyword">if</span>(_is_active.<span class="built_in">compare_exchange_strong</span>(expect, <span class="literal">false</span>, std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="comment">// 清理资源</span></span><br><span class="line">      <span class="built_in">clean_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不希望 Channel 被移动或者复制</span></span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;&amp;channel) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">Channel</span>(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Channel &amp;<span class="keyword">operator</span>=(Channel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁时关闭</span></span><br><span class="line">  ~<span class="built_in">Channel</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// buffer 的容量</span></span><br><span class="line">  <span class="type">int</span> buffer_capacity;</span><br><span class="line">  std::queue&lt;ValueType&gt; buffer;</span><br><span class="line">  <span class="comment">// buffer 已满时，新来的写入者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;WriterAwaiter&lt;ValueType&gt; *&gt; writer_list;</span><br><span class="line">  <span class="comment">// buffer 为空时，新来的读取者需要挂起保存在这里等待恢复</span></span><br><span class="line">  std::list&lt;ReaderAwaiter&lt;ValueType&gt; *&gt; reader_list;</span><br><span class="line">  <span class="comment">// Channel 的状态标识</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; _is_active;</span><br><span class="line"></span><br><span class="line">  std::mutex channel_lock;</span><br><span class="line">  std::condition_variable channel_condition;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clean_up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要对已经挂起等待的协程予以恢复执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> writer : writer_list) &#123;</span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    writer_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> reader : reader_list) &#123;</span><br><span class="line">      reader-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    reader_list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 buffer</span></span><br><span class="line">    <span class="keyword">decltype</span>(buffer) empty_buffer;</span><br><span class="line">    std::<span class="built_in">swap</span>(buffer, empty_buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过了解 <code>Channel</code> 的基本结构，我们已经知道了 <code>Channel</code> 当中存了哪些信息。接下来我们就要填之前埋下的坑了：分别是在协程当中读写值用到的 <code>read</code> 和 <code>write</code> 函数，以及在挂起协程时 Awaiter 当中调用的 <code>try_push_writer</code> 和 <code>try_push_reader</code>。</p>
<h3 id="read-和-write"><a href="#read-和-write" class="headerlink" title="read 和 write"></a>read 和 write</h3><p>这两个函数也没什么实质的功能，就是把 Awaiter 创建出来，然后填充信息再返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">write</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WriterAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;&lt;(ValueType value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReaderAwaiter</span>&lt;ValueType&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>&gt;&gt;(ValueType &amp;value_ref) &#123;</span><br><span class="line">    <span class="keyword">auto</span> awaiter =  <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// 保存待赋值的变量的地址，方便后续写入</span></span><br><span class="line">    awaiter.p_value = &amp;value_ref;</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这当中除了 <code>operator&gt;&gt;</code> 的实现需要多保存一个变量的地址以外，大家只需要注意一下对于 <code>check_closed</code> 的调用即可，它的功能很简单：在 <code>Channel</code> 关闭之后调用它会抛出 <code>ChannelClosedException</code>。</p>
<h3 id="try-push-writer-和-try-push-reader"><a href="#try-push-writer-和-try-push-reader" class="headerlink" title="try_push_writer 和 try_push_reader"></a><code>try_push_writer</code> 和 <code>try_push_reader</code></h3><p>这是 <code>Channel</code> 当中最为核心的两个函数了，他们的功能正好相反。</p>
<p><code>try_push_writer</code> 调用时，意味着有一个新的写入者挂起准备写入值到 <code>Channel</code> 当中，这时候有以下几种情况：</p>
<ol>
<li><code>Channel</code> 当中有挂起的读取者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li>
<li><code>Channel</code> 的 buffer 没满，写入者把值写入 buffer，然后立即恢复执行。</li>
<li><code>Channel</code> 的 buffer 已满，则写入者被存入挂起列表（writer_list）等待新的读取者读取时再恢复。</li>
</ol>
<p>了解了思路之后，它的实现就不难写出了，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_writer</span><span class="params">(WriterAwaiter&lt;ValueType&gt; *writer_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line">  <span class="comment">// 检查有没有挂起的读取者，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!reader_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader = reader_list.<span class="built_in">front</span>();</span><br><span class="line">    reader_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader-&gt;<span class="built_in">resume</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 未满，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (buffer.<span class="built_in">size</span>() &lt; buffer_capacity) &#123;</span><br><span class="line">    buffer.<span class="built_in">push</span>(writer_awaiter-&gt;_value);</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    writer_awaiter-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 已满，对应情况 3</span></span><br><span class="line">  writer_list.<span class="built_in">push_back</span>(writer_awaiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对应的，<code>try_push_reader</code> 调用时，意味着有一个新的读取者挂起准备从 <code>Channel</code> 当中读取值，这时候有以下几种情况：</p>
<ol>
<li><code>Channel</code> 的 buffer 非空，读取者从 buffer 当中读取值，如果此时有挂起的写入者，需要去队头的写入者将值写入 buffer，然后立即恢复该写入者和当次的读取者。</li>
<li><code>Channel</code> 当中有挂起的写入者，写入者直接将要写入的值传给读取者，恢复读取者，恢复写入者</li>
<li><code>Channel</code> 的 buffer 为空，则读取者被存入挂起列表（reader_list）等待新的写入者写入时再恢复。</li>
</ol>
<p>接下来是具体的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_push_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">  <span class="built_in">check_closed</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 非空，对应情况 1</span></span><br><span class="line">  <span class="keyword">if</span> (!buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = buffer.<span class="built_in">front</span>();</span><br><span class="line">    buffer.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 有挂起的写入者要及时将其写入 buffer 并恢复执行</span></span><br><span class="line">      <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">      writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">      buffer.<span class="built_in">push</span>(writer-&gt;_value);</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">      writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有写入者挂起，对应情况 2</span></span><br><span class="line">  <span class="keyword">if</span> (!writer_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> writer = writer_list.<span class="built_in">front</span>();</span><br><span class="line">    writer_list.<span class="built_in">pop_front</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    reader_awaiter-&gt;<span class="built_in">resume</span>(writer-&gt;_value);</span><br><span class="line">    writer-&gt;<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer 为空，对应情况 3</span></span><br><span class="line">  reader_list.<span class="built_in">push_back</span>(reader_awaiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，我们已经完整给出 <code>Channel</code> 的实现。</p>
<blockquote>
<p><strong>说明</strong>：我们当然也可以在 <code>await_ready</code> 的时候提前做一次判断，如果命中第 1、2 两种情况可以直接让写入/读取协程不挂起继续执行，这样可以避免写入/读取者的无效挂起。为了方便介绍，本文就不再做相关优化了。</p>
</blockquote>
<h3 id="监听协程的提前销毁"><a href="#监听协程的提前销毁" class="headerlink" title="监听协程的提前销毁"></a>监听协程的提前销毁</h3><p>截止目前，我们给出的 <code>Channel</code> 仍然有个小小的限制，即 <code>Channel</code> 对象必须在持有 <code>Channel</code> 实例的协程退出之前关闭。</p>
<p>这主要是因为我们在 <code>Channel</code> 当中持有了已经挂起的读写协程的 <code>Awaiter</code> 的指针，一旦协程销毁，这些 <code>Awaiter</code> 也会被销毁，<code>Channel</code> 在关闭时试图恢复这些读写协程时就会出现程序崩溃（访问了野指针）。</p>
<p>为了解决这个问题，我们需要在 <code>Awaiter</code> 销毁时主动将自己的指针从 <code>Channel</code> 当中移除。以 <code>ReaderAwaiter</code> 为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现移动构造函数，主要目的是将原对象的 channel 置为空</span></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="comment">// 协程恢复，channel 已经没用了</span></span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="comment">// channel 不为空，说明协程提前被销毁了</span></span><br><span class="line">    <span class="comment">// 调用 channel 的 remove_reader 将自己直接移除</span></span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>ReaderAwaiter</code> 的析构函数当中主动检查并移除了自己的指针，避免后续 <code>Channel</code> 对自身指针的无效访问。</p>
<p>对应的，<code>Channel</code> 当中也需要增加 <code>remove_reader</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_reader</span><span class="params">(ReaderAwaiter&lt;ValueType&gt; *reader_awaiter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并发环境，修改 reader_list 的操作都需要加锁</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(channel_lock)</span></span>;</span><br><span class="line">    reader_list.<span class="built_in">remove</span>(reader_awaiter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriterAwaiter</code> 的修改类似，不再赘述。</p>
<p>这样修改之后，即使我们把正在等待读写 <code>Channel</code> 的协程提前结束销毁，也不会影响 <code>Channel</code> 的继续使用以及后续的正常关闭了。</p>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们终于又实现了一个新的玩具，现在我们来给它通电试试效果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Producer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send: &quot;</span>, i);</span><br><span class="line">    <span class="comment">// 或者使用 write 函数：co_await channel.write(i++);</span></span><br><span class="line">    <span class="built_in">co_await</span> (channel &lt;&lt; i++);</span><br><span class="line">    <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  channel.<span class="built_in">close</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;close channel, exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 或者使用 read 函数：auto received = co_await channel.read();</span></span><br><span class="line">      <span class="type">int</span> received;</span><br><span class="line">      <span class="built_in">co_await</span> (channel &gt;&gt; received);</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">2</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">Consumer2</span><span class="params">(Channel&lt;<span class="type">int</span>&gt; &amp;channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (channel.<span class="built_in">is_active</span>()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> received = <span class="keyword">co_await</span> channel.<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;receive2: &quot;</span>, received);</span><br><span class="line">      <span class="keyword">co_await</span> <span class="number">3</span>s;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">debug</span>(<span class="string">&quot;exception2: &quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;exit.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> channel = <span class="built_in">Channel</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> producer = <span class="built_in">Producer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer = <span class="built_in">Consumer</span>(channel);</span><br><span class="line">  <span class="keyword">auto</span> consumer2 = <span class="built_in">Consumer2</span>(channel);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 等待协程执行完成再退出</span></span><br><span class="line">  producer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer.<span class="built_in">get_result</span>();</span><br><span class="line">  consumer2.<span class="built_in">get_result</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子非常简单，我们用一个写入者两个接收者向 <code>Channel</code> 当中读写数据，为了让示例更加凌乱，我们还加了一点点延时，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:39:58.129 [Thread-26004] (main.cpp:15) Producer: send:  0</span><br><span class="line">08:39:58.130 [Thread-27716] (main.cpp:31) Consumer: receive:  0</span><br><span class="line">08:39:58.443 [Thread-26004] (main.cpp:15) Producer: send:  1</span><br><span class="line">08:39:58.444 [Thread-17956] (main.cpp:45) Consumer2: receive2:  1</span><br><span class="line">08:39:58.759 [Thread-26004] (main.cpp:15) Producer: send:  2</span><br><span class="line">08:39:59.071 [Thread-26004] (main.cpp:15) Producer: send:  3</span><br><span class="line">08:39:59.382 [Thread-26004] (main.cpp:15) Producer: send:  4</span><br><span class="line">08:40:00.145 [Thread-27716] (main.cpp:31) Consumer: receive:  4</span><br><span class="line">08:40:00.454 [Thread-26004] (main.cpp:15) Producer: send:  5</span><br><span class="line">08:40:01.448 [Thread-17956] (main.cpp:45) Consumer2: receive2:  5</span><br><span class="line">08:40:01.762 [Thread-26004] (main.cpp:15) Producer: send:  6</span><br><span class="line">08:40:02.152 [Thread-27716] (main.cpp:31) Consumer: receive:  6</span><br><span class="line">08:40:02.464 [Thread-26004] (main.cpp:15) Producer: send:  7</span><br><span class="line">08:40:04.164 [Thread-27716] (main.cpp:31) Consumer: receive:  7</span><br><span class="line">08:40:04.460 [Thread-17956] (main.cpp:45) Consumer2: receive2:  2</span><br><span class="line">08:40:04.475 [Thread-26004] (main.cpp:15) Producer: send:  8</span><br><span class="line">08:40:04.787 [Thread-26004] (main.cpp:15) Producer: send:  9</span><br><span class="line">08:40:06.169 [Thread-27716] (main.cpp:31) Consumer: receive:  9</span><br><span class="line">08:40:06.481 [Thread-26004] (main.cpp:22) Producer: close channel, exit.</span><br><span class="line">08:40:07.464 [Thread-17956] (main.cpp:52) Consumer2: exit.</span><br><span class="line">08:40:08.181 [Thread-27716] (main.cpp:38) Consumer: exit.</span><br></pre></td></tr></table></figure>

<p>结果我就不分析了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文给出了 C++ 协程版的 <code>Channel</code> 的 demo 实现，这进一步证明了 C++ 协程的基础 API 的设计足够灵活，能够支撑非常复杂的需求场景。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（8）：通用 Awaiter</title>
    <url>//2022/03/27/cpp-coroutines-08-awaiter/</url>
    <content><![CDATA[<blockquote>
<p>每次我们新增功能时，都需要修改 TaskPromise 增加对应的 await_transform 函数，这显然是个设计问题。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们前面在实现无阻塞 sleep 和 Channel 的时候都需要专门实现对应的 Awaiter 类型，并且在 TaskPromise 当中添加相应的 <code>await_transform</code> 函数。增加新类型这没什么问题，但如果每增加一个新功能就要对原有的 <code>TaskPromise</code> 类型做修改，这说明 <code>TaskPromise</code> 的扩展性不够好。</p>
<p>当然，有读者会说，如果我们把所有的 <code>await_transform</code> 函数都去掉，改成给对应的类型实现 <code>operator co_await</code> 来获取 Awaiter（例如 sleep 的例子当中通过 duration 转 Awaiter） 或者干脆就自己就定义成 Awaiter（例如 <code>Channel</code> 当中的 <code>ReadAwaiter</code>），这样我们就不用总是修改 <code>TaskPromise</code> 了。话虽如此，但完全由外部定义 Awaiter 对象的获取会使得调度器无法被包装正确使用，甚至我们在定义 <code>TaskPromise</code> 的时候把调度器定义成私有成员，因为我们根本不希望外部能够轻易获取到调度器的实例。</p>
<p>使用 <code>await_transform</code> 本质上就是为了保证调度器的正确应用，却带来了扩展上的问题，那这是说 C++ 协程的设计有问题吗？当然也不是。我们完全可以定义一个 Awaiter 类型，外部只需要继承这个 Awaiter 在受限的范围内自定义逻辑，完成自己的需求同时也能保证调度器的调度。</p>
<h2 id="通用的-await-transform"><a href="#通用的-await-transform" class="headerlink" title="通用的 await_transform"></a>通用的 await_transform</h2><p>了解了需求背景之后，我们只需要在 <code>TaskPromise</code> 当中定义一个更加通用版本的 <code>await_transform</code>，来为 Awaiter 提供调度器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskPromise</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">  AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">    awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看得没错，我们真的只是给这个通用的 <code>Awaiter</code> 添加了当前协程的调度器。</p>
<h2 id="Awaiter-的定义"><a href="#Awaiter-的定义" class="headerlink" title="Awaiter 的定义"></a>Awaiter 的定义</h2><p>既然 <code>Awaiter</code> 的核心是调度器，我们可以直接给出它的基本定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *executor)</span> </span>&#123;</span><br><span class="line">    _executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方便用调度器调度任意逻辑，这里也处理了调度器为空的情况</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; &amp;&amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_executor) &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>(std::<span class="built_in">move</span>(f));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作为 Awaiter 本身，当然也得有标准当中定义的基本的三个函数要求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单处理，永远挂起，当然这也是协程调度的一个潜在的优化点</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前协程的 handle，方面后面恢复</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回 co_await 的结果，当然对于 void 的情况，我们也会有特化版本</span></span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 结果对子类可见，方便灵活操作</span></span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 保存协程的 handle，恢复时会用到，私有化这个成员目的是将其逻辑封装，避免滥用</span></span><br><span class="line">  std::coroutine_handle&lt;&gt; _handle = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个函数是协程在挂起和恢复时调用的。我们将协程 <code>handle</code> 的保存和结果的返回逻辑固化，因为几乎所有的 Awaiter 都有这样的需求。不过协程的挂起后和恢复前是两个非常重要的时间点，扩展 Awaiter 时经常需要在这两个时间点实现定义化的业务逻辑，因此我们需要定义两个虚函数让子类按需实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_handle = handle;</span><br><span class="line">    <span class="comment">// 调用 after_suspend，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">after_suspend</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 before_resume，子类可以自定义这个函数来处理需要的逻辑</span></span><br><span class="line">    <span class="built_in">before_resume</span>();</span><br><span class="line">    <span class="keyword">return</span> _result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  std::optional&lt;Result&lt;R&gt;&gt; _result&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的就是协程的恢复了，这时候我们要求必须使用调度器进行调度。为了防止外部不按要求处理调度逻辑，我们将调度器和协程的 <code>handle</code> 都定义为私有成员，因此我们也需要提供相应的函数来封装协程恢复的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程恢复时，co_await 表达式返回 value</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(R value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, value]() &#123;</span><br><span class="line">      <span class="comment">// 将 value 封装到 _result 当中，await_resume 时会返回 value</span></span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;R&gt;(value));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不提供 value，但也要恢复协程，这种情况需要子类在 before_resume 当中写入 _result，或者抛出异常</span></span><br><span class="line">  <span class="comment">// 我们将会在 Channel 关闭时用到这个函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>]() &#123; _handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂起点出现异常，用异常来恢复协程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume_exception</span><span class="params">(std::exception_ptr &amp;&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch</span>([<span class="keyword">this</span>, e]() &#123;</span><br><span class="line">      _result = <span class="built_in">Result</span>&lt;R&gt;(<span class="built_in">static_cast</span>&lt;std::exception_ptr&gt;(e));</span><br><span class="line">      _handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，如果我们想要扩展新功能，只需要继承 <code>Awaiter</code>，在 <code>after_suspend</code> 当中或者之后找个合适的时机调用 <code>resume/resume_unsafe/resume_exception</code> 三个函数当中的任意一个来恢复协程即可。如果在恢复前有其他逻辑需要处理，也可以覆写 <code>before_resume</code> 来实现。</p>
<h2 id="Awaiter-的应用"><a href="#Awaiter-的应用" class="headerlink" title="Awaiter 的应用"></a>Awaiter 的应用</h2><p>接下来我们使用 <code>Awaiter</code> 对现有的几个 awaiter 类型做重构，之后再尝试基于 <code>Awaiter</code> 做一点小小的扩展。</p>
<h3 id="重构-SleepAwaiter"><a href="#重构-SleepAwaiter" class="headerlink" title="重构 SleepAwaiter"></a>重构 SleepAwaiter</h3><p><code>SleepAwaiter</code> 是最简单的一个。我们当初为了让无阻塞的 sleep 看上去更加自然，直接对 <code>duration</code> 做了支持，于是可以写出下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">co_await</span> <span class="number">300</span>ms;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>duration</code> 的支持源自于在 <code>TaskPromise</code> 当中添加了 <code>duration</code> 转 <code>SleepAwaiter</code> 的 <code>awaiter_transform</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(&amp;executor, std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不要求对 <code>duration</code> 直接支持的话，我们其实也可以这么设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">await_transform</span><span class="params">(SleepAwaiter awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保存调度器，后面调度用</span></span><br><span class="line">  awaiter._executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与我们前面给出的通用 <code>Awaiter</code> 版本的  <code>await_transform</code> 如出一辙：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传入调度器，后面调度用</span></span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们可以使用通用的 <code>Awaiter</code> 重构 <code>SleepAwaiter</code>，下面我们给出重构前和重构后的对比：</p>
<p><strong>重构前</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(AbstractExecutor *executor, <span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>, handle]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>重构后</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepAwaiter</span> : Awaiter&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="type">long</span> <span class="type">long</span> duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增一个支持 duration 的构造器，方便外部使用</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">SleepAwaiter</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _duration(std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count()) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这部分逻辑以前写在 await_suspend 当中</span></span><br><span class="line">    <span class="comment">// 现在我们写在覆写的 after_suspend 当中</span></span><br><span class="line">    <span class="comment">// 调用位置实际上没有变化，但我们不用再关心 handle 和 调度器了</span></span><br><span class="line">    <span class="type">static</span> Scheduler scheduler;</span><br><span class="line">    scheduler.<span class="built_in">execute</span>([<span class="keyword">this</span>] &#123; <span class="built_in">resume</span>(); &#125;, _duration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> _duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重构之后，我们无需单独为 <code>SleepAwaiter</code> 添加 <code>await_transform</code> 的支持，就可以写出下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">SleepAwaiter</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果觉得不够美观，也可以定义一个协程版本的函数 sleep_for：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span></span><br><span class="line"><span class="function">SleepAwaiter <span class="title">sleep_for</span><span class="params">(std::chrono::duration&lt;_Rep, _Period&gt; &amp;&amp;duration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SleepAwaiter</span>(duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写出来的代码就变成了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// co_await 300ms;</span></span><br><span class="line">    <span class="comment">// 等价于前面的 co_await 300ms</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">sleep_for</span><span class="params">(<span class="number">300</span>ms)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重构-Channel-的-Awaiter"><a href="#重构-Channel-的-Awaiter" class="headerlink" title="重构 Channel 的 Awaiter"></a>重构 Channel 的 Awaiter</h3><p>Channel 有两个 Awaiter，分别是 <code>ReaderAwaiter</code>、<code>WriterAwaiter</code>，以前者为例：</p>
<p><strong>重构前</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  AbstractExecutor *executor = <span class="literal">nullptr</span>;</span><br><span class="line">  ValueType _value;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line">  std::coroutine_handle&lt;&gt; handle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">executor</span>(std::<span class="built_in">exchange</span>(other.executor, <span class="literal">nullptr</span>)),</span><br><span class="line">        _value(other._value),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">handle</span>(other.handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; coroutine_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;handle = coroutine_handle;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(ValueType value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_value = value;</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">      executor-&gt;<span class="built_in">execute</span>([<span class="keyword">this</span>]() &#123; handle.<span class="built_in">resume</span>(); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这代码大家已经见过，这里同样贴出来只是为了让大家能够直接对比：</p>
<p><strong>重构后</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReaderAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;ValueType&gt; &#123;</span><br><span class="line">  Channel&lt;ValueType&gt; *channel;</span><br><span class="line">  ValueType *p_value = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ReaderAwaiter</span><span class="params">(Channel&lt;ValueType&gt; *channel)</span> : Awaiter&lt;ValueType&gt;(), channel(channel) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReaderAwaiter</span>(ReaderAwaiter &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;ValueType&gt;(other),</span><br><span class="line">        <span class="built_in">channel</span>(std::<span class="built_in">exchange</span>(other.channel, <span class="literal">nullptr</span>)),</span><br><span class="line">        <span class="built_in">p_value</span>(std::<span class="built_in">exchange</span>(other.p_value, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">try_push_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    channel-&gt;<span class="built_in">check_closed</span>();</span><br><span class="line">    <span class="keyword">if</span> (p_value) &#123;</span><br><span class="line">      *p_value = <span class="keyword">this</span>-&gt;_result-&gt;<span class="built_in">get_or_throw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    channel = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ReaderAwaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel) channel-&gt;<span class="built_in">remove_reader</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，调度的逻辑统一抽象到父类 <code>Awaiter</code> 当中，代码的逻辑更加紧凑了。不仅如此，之前在 <code>TaskPromise</code> 当中定义的 <code>await_transform</code> 也不需要了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不再需要</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ValueType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(ReaderAwaiter&lt;_ValueType&gt; reader_awaiter)</span> </span>&#123;</span><br><span class="line">  reader_awaiter.executor = &amp;executor;</span><br><span class="line">  <span class="keyword">return</span> reader_awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriterAwaiter</code> 同理，不再赘述。</p>
<h3 id="重构-TaskAwaiter"><a href="#重构-TaskAwaiter" class="headerlink" title="重构 TaskAwaiter"></a>重构 TaskAwaiter</h3><p><code>TaskAwaiter</code> 是用来等待其他 <code>Task</code> 的执行完成的。它同样可以用前面的通用 <code>Awaiter</code> 改造：</p>
<p><strong>重构前</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(AbstractExecutor *executor, Task&lt;Result, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _executor(executor), task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;completion) <span class="keyword">noexcept</span></span><br><span class="line">      : _executor(completion._executor), <span class="built_in">task</span>(std::<span class="built_in">exchange</span>(completion.task, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">      _executor-&gt;<span class="built_in">execute</span>([handle]() &#123;</span><br><span class="line">        handle.<span class="built_in">resume</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task.<span class="built_in">get_result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;Result, Executor&gt; task;</span><br><span class="line">  AbstractExecutor *_executor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作为对比，重构后的代码同样变得简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TaskAwaiter</span><span class="params">(Task&lt;R, Executor&gt; &amp;&amp;task)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : task(std::move(task)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), <span class="built_in">task</span>(std::<span class="built_in">move</span>(awaiter.task)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TaskAwaiter</span>(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  TaskAwaiter &amp;<span class="keyword">operator</span>=(TaskAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">finally</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">      <span class="comment">// 先不去获取结果，原因是除了正常的返回值以外，还可能是异常</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume_unsafe</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">before_resume</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有返回值，则赋值给 _result，否则直接抛异常</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_result = <span class="built_in">Result</span>(task.<span class="built_in">get_result</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Task&lt;R, Executor&gt; task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改造完成之后，如果不希望为 <code>Task</code> 增加特权支持的话，之前对 <code>TaskAwaiter</code> 的 <code>await_transform</code> 同样可以删除掉：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接删掉</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ResultType, <span class="keyword">typename</span> _Executor&gt;</span></span><br><span class="line"><span class="function">TaskAwaiter&lt;_ResultType, _Executor&gt; <span class="title">await_transform</span><span class="params">(Task&lt;_ResultType, _Executor&gt; &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;_ResultType, _Executor&gt;(&amp;executor, std::<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为 <code>Task</code> 类型增加一个函数来获取 <code>TaskAwaiter</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ResultType, <span class="keyword">typename</span> Executor = NoopExecutor&gt;</span><br><span class="line"><span class="keyword">struct</span> Task &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">as_awaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TaskAwaiter</span>&lt;ResultType, Executor&gt;(std::<span class="built_in">move</span>(*<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦调用 <code>as_awaiter</code>，我们就会将 <code>Task</code> 的内容全部转移到新创建的 <code>TaskAwaiter</code> 当中，并且返回给外部使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">int</span>, LooperExecutor&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除 TaskAwaiter&lt;&gt; await_transform(Task&lt;&gt;)</span></span><br><span class="line">  <span class="comment">// 可以采用以下方式在外部将 Task 转成 TaskAwaiter，然后再 co_await</span></span><br><span class="line">  <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">simple_task2</span>().<span class="built_in">as_awaiter</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，在我们自己实现的这套 <code>Task</code> 框架当中，<code>Task</code> 自然是“特权阶层”，我们不会真的删除为 <code>Task</code> 定制的 <code>await_transform</code>。但也不难看出，经过改造的 <code>Awaiter</code> 的子类代码量和复杂度都有降低；同时也不再需要定义专门的 <code>await_transform</code> 函数来明确支持 <code>TaskAwaiter</code>，避免了扩展性不强的尴尬。</p>
<h3 id="添加对-std-future-的扩展支持"><a href="#添加对-std-future-的扩展支持" class="headerlink" title="添加对 std::future 的扩展支持"></a>添加对 std::future 的扩展支持</h3><p>按照 C++ 标准的发展趋势来看，<code>std::future</code> 应该在将来会支持类似于 <code>Task::then</code> 这样的函数回调，那时候我们完全不需要自己独立定义一套 <code>Task</code>，只需要基于 <code>std::future</code> 进行扩展即可。</p>
<p>当然这都是后话了。现在 <code>std::future</code> 还不支持回调，我们可以另起一个线程来阻塞得等待它的结果，并在结果返回之后恢复协程的执行，这样一来，我们的 <code>Task</code> 框架也就能够支持形如 <code>co_await as_awaiter(future)</code> 这样的写法了。</p>
<p>想要做到这一点，我们只需要基于前面的 <code>Awaiter</code> 来依样画葫芦：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureAwaiter</span> : <span class="keyword">public</span> Awaiter&lt;R&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FutureAwaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _future(std::move(future)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;&amp;awaiter) <span class="keyword">noexcept</span></span><br><span class="line">      : <span class="built_in">Awaiter</span>&lt;R&gt;(awaiter), _future(std::<span class="built_in">move</span>(awaiter._future)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FutureAwaiter</span>(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  FutureAwaiter &amp;<span class="keyword">operator</span>=(FutureAwaiter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">after_suspend</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::future::get 会阻塞等待结果的返回，因此我们新起一个线程等待结果的返回</span></span><br><span class="line">    <span class="comment">// 如果后续 std::future 增加了回调，这里直接注册回调即可</span></span><br><span class="line">    std::<span class="built_in">thread</span>([<span class="keyword">this</span>]()&#123;</span><br><span class="line">      <span class="comment">// 获取结果，并恢复协程</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">resume</span>(<span class="keyword">this</span>-&gt;_future.<span class="built_in">get</span>());</span><br><span class="line">    &#125;).<span class="built_in">detach</span>(); </span><br><span class="line">    <span class="comment">// std::thread 必须 detach 或者 join 二选一</span></span><br><span class="line">    <span class="comment">// 也可以使用 std::jthread </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::future&lt;R&gt; _future;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>FutureAwaiter</code> 与 <code>TaskAwaiter</code> 除了 <code>after_suspend</code> 和 <code>before_resume</code> 处有些不同之外，几乎完全一样（当然除了这俩函数以外也基本上没有其他逻辑了）。</p>
<p>如果你愿意，你也可以定义一个 <code>as_awaiter</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span></span><br><span class="line"><span class="function">FutureAwaiter&lt;R&gt; <span class="title">as_awaiter</span><span class="params">(std::future&lt;R&gt; &amp;&amp;future)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FutureAwaiter</span>(std::<span class="built_in">move</span>(future));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在协程当中就可以使用 <code>co_await</code> 来等待 <code>std::future</code> 的返回了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">as_awaiter</span>(std::<span class="built_in">async</span>([]() &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">  &#125;));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AwaiterImpl-的类型约束"><a href="#AwaiterImpl-的类型约束" class="headerlink" title="AwaiterImpl 的类型约束"></a>AwaiterImpl 的类型约束</h2><p>本文给出的通用的 <code>await_transform</code> 有个小小的漏洞，我们不妨再次观察一下这个函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  awaiter.<span class="built_in">install_executor</span>(&amp;executor);</span><br><span class="line">  <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现，只要 <code>AwaiterImpl</code> 类型定义了协程的 <code>Awaiter</code> 类型的三个函数，并且定义有 <code>install_executor</code> 函数，在这里就可以蒙混过关，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FakeAwaiter</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">install_executor</span><span class="params">(AbstractExecutor *)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">task</span><span class="params">()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">co_await</span> <span class="title">FakeAwaiter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>FakeAwaiter</code> 的定义符合前面的模板类型 <code>AwaiteImpl</code> 的要求，但却不符合我们的预期。为了避免这种情况发生，我们必须想办法要求 <code>AwaiterImpl</code> 只能是 <code>Awaiter</code> 或者它的子类。</p>
<p>这如果是在 Java 当中，我们可以很轻松地指定泛型的上界来达到目的。但 C++ 的模板显然与 Java 泛型的设计相差较大，不能直接在定义模板参数时指定上界。不过 C++ 20 的 concept 可以用来为模板参数限定父类。</p>
<p>我们需要定义一个用来检查类关系的 concept：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl, <span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">concept</span> AwaiterImplRestriction = std::is_base_of&lt;Awaiter&lt;R&gt;, AwaiterImpl&gt;::value;</span><br></pre></td></tr></table></figure>

<p>接下来我们只需要在 <code>await_transform</code> 的模板声明后面加上这个 concept 即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span><br><span class="line"><span class="comment">// ??? 是 AwaiterImpl 继承父类 Awaiter 时传入的模板参数，但我们现在还不知道是什么</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, ???&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;  ...  &#125;</span><br></pre></td></tr></table></figure>

<p>不过这里有个问题，我们其实并不知道 <code>AwaiterImpl</code> 的实际类型在继承 <code>Awaiter</code> 时到底用了什么类型的模板参数，这怎么办呢？</p>
<p>有一个简单的办法，那就是为 <code>Awaiter</code> 声明一个内部类型 <code>ResultType</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Awaiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ResultType = R;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以使用 <code>Awaiter::ResultType</code> 来获取这个类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AwaiterImpl&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> AwaiterImplRestriction&lt;AwaiterImpl, <span class="keyword">typename</span> AwaiterImpl::ResultType&gt;</span></span><br><span class="line"><span class="function">AwaiterImpl <span class="title">await_transform</span><span class="params">(AwaiterImpl awaiter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样像前面提到的 <code>FakeAwaiter</code> 那样的类型，就不能作为 <code>co_await</code> 表达式的参数了。即便我们为 <code>FakeAwaiter</code> 声明 <code>ResultType</code> 也不行，<code>co_await FakeAwaiter()</code> 的报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">candidate template ignored: constraints not satisfied [with AwaiterImpl = FakeAwaiter] </span><br><span class="line">because &#x27;AwaiterImplRestriction&lt;FakeAwaiter, typename FakeAwaiter::ResultType&gt;&#x27; evaluated to false </span><br><span class="line">because &#x27;std::is_base_of&lt;Awaiter&lt;void&gt;, FakeAwaiter&gt;::value&#x27; evaluated to false call to &#x27;await_transform&#x27; implicitly required by &#x27;co_await&#x27; here</span><br></pre></td></tr></table></figure>

<p>可见 <code>FakeAwaiter</code> 并不能满足与 <code>Awaiter</code> 的父子类关系，因此无法作为 <code>AwaiterImpl</code> 的模板实参。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了一种实现较为通用的 Awaiter 的方法，目的在于增加现有 <code>Task</code> 框架的扩展性，避免通过频繁改动 <code>TaskPromise</code> 来新增功能。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（9）：一个简单的示例</title>
    <url>//2022/03/27/cpp-coroutines-09-http/</url>
    <content><![CDATA[<blockquote>
<p>截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在本文当中，我将使用前文实现好的 <code>Task</code> 来发起一个简单的网络请求。</p>
<p>我会借助一些已有的框架来完成这次的目标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp-httplib/0.10.4</span><br><span class="line">openssl/3.0.2</span><br><span class="line">nlohmann_json/3.10.5</span><br></pre></td></tr></table></figure>

<p>这些框架可以通过 <a href="https://www.bilibili.com/video/BV1wL411u74B/">conan</a> 很轻松的完成安装。</p>
<h3 id="示例实现"><a href="#示例实现" class="headerlink" title="示例实现"></a>示例实现</h3><p>首先我们给出发起网络请求的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用协程包装网络请求，请求的处理调度到 std::async 上</span></span><br><span class="line"><span class="function">Task&lt;std::string, AsyncExecutor&gt; <span class="title">http_get</span><span class="params">(std::string host, std::string path)</span> </span>&#123;</span><br><span class="line">  <span class="function">httplib::Client <span class="title">cli</span><span class="params">(host)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞地发起网络请求</span></span><br><span class="line">  <span class="keyword">auto</span> res = cli.<span class="built_in">Get</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="comment">// 返回响应内容，类型为 std::string</span></span><br><span class="line">    <span class="keyword">co_return</span> res-&gt;body;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">co_return</span> httplib::<span class="built_in">to_string</span>(res.<span class="built_in">error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 httplib 来完成网络请求的处理非常简单直接，我们只需要把 url 传入即可。通常我们的网络请求都会在 io 线程当中发起，因此我们将其调度到 <code>AsyncExecutor</code> 上。</p>
<p>接下来，我们再定义一个协程来调用 <code>http_get</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="type">void</span>, LooperExecutor&gt; <span class="title">test_http</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;send request...&quot;</span>); <span class="comment">// Looper 线程上执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起网络请求，切换线程，当前协程挂起，Looper 线程被释放（此时 Looper 线程可以去调度其他任务）</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="keyword">co_await</span> <span class="built_in">http_get</span>(<span class="string">&quot;https://api.github.com&quot;</span>, <span class="string">&quot;/users/bennyhuo&quot;</span>);</span><br><span class="line">    <span class="comment">// 请求返回，当前协程接着在 Looper 线程上调度执行</span></span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑处理，解析 json</span></span><br><span class="line">    <span class="keyword">auto</span> json = nlohmann::json::<span class="built_in">parse</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印 json 内容</span></span><br><span class="line">    <span class="built_in">debug</span>(json.<span class="built_in">dump</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 假装这是其他业务处理</span></span><br><span class="line">    <span class="built_in">debug</span>(json[<span class="string">&quot;login&quot;</span>], json[<span class="string">&quot;url&quot;</span>]);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">    <span class="built_in">debug</span>(e.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:10:54.046 [Thread-08056] (main.cpp:27) test_http: send request...</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:29) test_http: done.</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:31) test_http: &#123;</span><br><span class="line">  &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6336960?v=4&quot;,</span><br><span class="line">  &quot;bio&quot;: &quot;Google Developer Expert @Kotlin&quot;,</span><br><span class="line">  &quot;blog&quot;: &quot;https://www.bennyhuo.com&quot;,</span><br><span class="line">  ...  中间内容很多，省略掉 ...</span><br><span class="line">  &quot;updated_at&quot;: &quot;2022-03-23T13:51:26Z&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">&#125;</span><br><span class="line">22:10:54.953 [Thread-08056] (main.cpp:32) test_http: &quot;bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:33) test_http: &quot;https://api.github.com/users/bennyhuo&quot;</span><br><span class="line">22:10:54.954 [Thread-08056] (main.cpp:34) test_http: &quot;Google Developer Expert @Kotlin&quot;</span><br></pre></td></tr></table></figure>

<p>在这个示例当中，我们没有使用协程来解决阻塞的问题，而是将一个异步的请求封装成同步的代码。<code>test_http</code> 当中的代码全程在 Looper 线程当中执行，尽管中间穿插了一个异步网络请求，但这看上去丝毫没有影响程序的连贯性和简洁性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的内容相对轻松，因为我们终于停止了基于协程的基础 API 的探索。</p>
<p>实际上，如果你发现你用到的某些 API 提供了异步回调，你完全可以使用 <code>Awaiter</code> 对其提供 <code>co_await</code> 的支持。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>渡劫 C++ 协程（10）：后记</title>
    <url>//2022/03/27/cpp-coroutines-10-postscript/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2022/03/06/cpp-coroutines-00-foreword/">渡劫 C++ 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/09/cpp-coroutines-01-intro/">渡劫 C++ 协程（1）：C++ 协程概览</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/11/cpp-coroutines-02-generator/">渡劫 C++ 协程（2）：实现一个序列生成器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/14/cpp-coroutines-03-functional/">渡劫 C++ 协程（3）：序列生成器的泛化和函数式变换</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/19/cpp-coroutines-04-task/">渡劫 C++ 协程（4）：通用异步任务 Task</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-05-dispatcher/">渡劫 C++ 协程（5）：协程的调度器</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/20/cpp-coroutines-06-sleep/">渡劫 C++ 协程（6）：基于协程的挂起实现无阻塞的 sleep</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/22/cpp-coroutines-07-channel/">渡劫 C++ 协程（7）：用于协程之间消息传递的 Channel</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-08-awaiter/">渡劫 C++ 协程（8）：通用 Awaiter</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-09-http/">渡劫 C++ 协程（9）：一个简单的示例</a></li>
<li><a href="https://www.bennyhuo.com/2022/03/27/cpp-coroutines-10-postscript/">渡劫 C++ 协程（10）：后记</a></li>
</ul>
<p><strong>渡劫 C++ 协程</strong>系列文章本来不在我的计划范围内。</p>
<p>相较于我常用的几门语言（可能是 Kotlin、Java、Python、JavaScript）来讲，我对 C++ 的熟悉程度并不是特别高。因此尽管群里的小伙伴们经常提议讲点儿 C++ 的内容（都出了一门 C 语言课了，还讲不了 C++？），考虑到精力和经验有限，我都拒绝了。</p>
<p>不过，人生就是那么奇妙，前不久我刚好有点儿时间，也正遇到群里有小伙伴们提到 C++ 协程，就硬着头皮看了一下午，录了一期视频 <a href="https://www.bilibili.com/video/BV1z5411Z7K5">协程上手经典案例：实现一个序列生成器</a>。既然有了第一期，那就得有第二期，结果越往后越感觉我这个讲法不太对。</p>
<p>过了一段时间之后，我的<a href="https://www.bennyhuo.com/book/swift-coroutines/"><strong>闲话 Swift 协程</strong></a>系列文章完结，同时我对 C++ 协程的认知也在不断加深，那么好吧，再写一系列 C++ 协程的文章吧。在学习 Swift 协程时，我可以翻阅 Swift 的语言设计文档以及源码，整个过程还算轻松，因此称为<strong>闲话 Swift 协程</strong>；C++ 的情况就不太一样了，设计文档看着令人头疼，标准库的源码又看得我眼花缭乱，于是得名<strong>渡劫 C++ 协程</strong>。</p>
<p>我在最初做 Kotlin 协程的介绍的时候，很多朋友都在问我协程究竟能做什么，再后来不少读者在发现 Kotlin 协程的默认调度器居然是个线程池，于是就认为 “Kotlin 协程的本质就是个线程池” —— 这真的是让人哭笑不得。</p>
<p>为了让读者能够更加深刻的认识协程，我在<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a> 这本书当中花了整整一章的篇幅介绍了常见语言对协程的支持情况，对比彼此之间的差异，甚至用 Kotlin 协程的基本 API 来模拟其他语言的协程特性。</p>
<p>Kotlin 的协程和 C++ 的协程在设计分层上有着惊人的相似之处，二者在标准库当中仅仅提供了为数不多的基本 API，想要将协程运用到业务实践当中还需要有协程框架的支持。C++ 20 已经走出了第一步，这大概相当于 Kotlin 1.1 时的状态。</p>
<p>我当时为了让读者能够深入理解 Kotlin 协程框架的设计，干脆自己动手实现了一个简版的协程框架 <a href="https://github.com/bennyhuo/CoroutineLite">CoroutineLite</a>。而<strong>渡劫 C++ 协程</strong>的核心内容也是在尝试通过自己实现 C++ 的协程框架来深入理解 C++ 协程。按照这个思路，我们还可以继续深入探索，例如实现 <code>Task</code> 的取消，为 <code>Task</code> 添加父子关系以实现结构化并发等等能力，只是受限于时间和精力，我决定暂时停止这一次奇妙的探索历程。</p>
<p>如果想要在生产环境当中使用 C++ 20 提供的协程，我们可能还需要持续关注 C++ 委员会后续对协程的规划和设计。让我们期待将来 C++ 新标准对协程提供更多的支持吧。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>也许你需要这个为数据类生成 DeepCopy 方法的库</title>
    <url>/2018/12/02/deepcopy/</url>
    <content><![CDATA[<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p>
<span id="more"></span>

<h2 id="我们有什么拷贝的需求？"><a href="#我们有什么拷贝的需求？" class="headerlink" title="我们有什么拷贝的需求？"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GitUser</span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<p>它的 <code>copy</code> 方法其实就相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GitUser</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GitUser</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Project</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Owner</span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure>

<p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Project</span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></table></figure>

<p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p>
<p>所以你需要一个 DeepCopy 的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Owner</span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class="line">        <span class="keyword">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p>
<h2 id="来来来，先实现个简单的"><a href="#来来来，先实现个简单的" class="headerlink" title="来来来，先实现个简单的"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p>
<p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p>
<p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">deepCopy</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="comment">//①判断是否为数据类，不是的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>::<span class="keyword">class</span>.isData) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>::<span class="keyword">class</span>.primaryConstructor!!.let &#123; primaryConstructor -&gt;</span><br><span class="line">        primaryConstructor.parameters</span><br><span class="line">            .map &#123; parameter -&gt;</span><br><span class="line">                <span class="keyword">val</span> value =</span><br><span class="line">                    (<span class="keyword">this</span>::<span class="keyword">class</span> <span class="title class_">as</span> <span class="title">KClass</span>&lt;<span class="type">T</span>&gt;).<span class="title">declaredMemberProperties</span>.<span class="title">first</span> &#123; it.name == parameter.name &#125;.<span class="keyword">get</span>(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class="line">                <span class="keyword">if</span> ((parameter.type.classifier <span class="keyword">as</span>? KClass&lt;*&gt;)?.isData == <span class="literal">true</span>) &#123;</span><br><span class="line">                    parameter to value?.deepCopy()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter to value</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">            .let(primaryConstructor::callBy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~* </p>
<p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p>
<p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">&#x27;com.bennyhuo.kotlin:deepcopy-reflect:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p>
<h2 id="来我们再试试注解处理器"><a href="#来我们再试试注解处理器" class="headerlink" title="来我们再试试注解处理器"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p>
<p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p>
<p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4&quot;</span></span><br></pre></td></tr></table></figure>

<p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p>
<p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p>
<p>下面给大家看看例子吧：</p>
<p>首先添加依赖，配置注解处理器：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    <span class="comment">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class="line">    maven &#123; url <span class="string">&quot;https://kotlin.bintray.com/kotlinx/&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">apply plugin: <span class="string">&quot;kotlin-kapt&quot;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    kapt <span class="string">&#x27;com.bennyhuo.kotlin:deepcopy-compiler:1.1.0&#x27;</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">&#x27;com.bennyhuo.kotlin:deepcopy-annotations:1.1.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着为我们的数据类配置注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GitUser</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Project</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Owner</span>(<span class="keyword">val</span> gitUser: GitUser, <span class="keyword">val</span> project: Project)</span><br></pre></td></tr></table></figure>

<p>build 一下，生成了下面的扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">(gitUser: <span class="type">GitUser</span> = this.gitUser, project: <span class="type">Project</span> = this.project)</span></span>: Owner =</span><br><span class="line">    Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>

<p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p>
<p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Owner.<span class="title">deepCopy</span><span class="params">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>

<p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GenericParameter</span>(<span class="keyword">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">GenericParameterT</span>&lt;<span class="type">K: Number, V</span>&gt;(<span class="keyword">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">StarProjection</span>(<span class="keyword">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeepCopy</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Variances1</span>(<span class="keyword">val</span> map: HashMap&lt;String, <span class="keyword">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure>

<p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p>
<h2 id="项目详情"><a href="#项目详情" class="headerlink" title="项目详情"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href="https://github.com/enbandari/KotlinDeepCopy">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p>
<p>别犹豫了，Star 一波吧，千万别手软。</p>
<hr>
<p>转载请注明出处：微信公众号 Kotlin</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Data Class</tag>
      </tags>
  </entry>
  <entry>
    <title>要再见了吗，Kotlin Android Extension</title>
    <url>/2020/11/07/deprecated-kotlin-android-extensions/</url>
    <content><![CDATA[<blockquote>
<p>伴随了我们这么多年的 KAE，就这么要离开我们了？ </p>
</blockquote>
<span id="more"></span>




<p>前几天看到邮件说 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2">Kotlin 1.4.20-M2</a> 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？</p>
<p>紧接着我们就可以看到一行：<a href="https://youtrack.jetbrains.com/issue/KT-42121">Deprecate Kotlin Android Extensions compiler plugin</a>。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png"></p>
<p>说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。</p>
<p>非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称<strong>合成的属性</strong>。</p>
<h2 id="销毁之后的空指针"><a href="#销毁之后的空指针" class="headerlink" title="销毁之后的空指针"></a>销毁之后的空指针</h2><p>KAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。</p>
<p>这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">        textView.text = <span class="string">&quot;Crash!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> textView: TextView</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    textView = view.findViewById(R.id.textView)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line"></span><br><span class="line">    textView.text = <span class="string">&quot;Nothing happened.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码虽然看上去不怎么高明，但它至少不会 Crash。</p>
<p>Kotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。</p>
<p>就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 <code>lifecycleScope.launchWhenResumed&#123; ... &#125;</code> 就能很好的解决这个问题。</p>
<p>这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。</p>
<h2 id="张冠李戴"><a href="#张冠李戴" class="headerlink" title="张冠李戴"></a>张冠李戴</h2><p>由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。</p>
<p>例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.fragment_main.*</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">textView.text = <span class="string">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure>

<p>编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。</p>
<p>这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。</p>
<h2 id="冲突的-ID"><a href="#冲突的-ID" class="headerlink" title="冲突的 ID"></a>冲突的 ID</h2><p>还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。</p>
<p>为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 Activity 或者 Fragment 当中加载这两个 layout：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tipsView = View.inflate(view.context, R.layout.view_tips, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> warningView = View.inflate(view.context, R.layout.view_warning, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">tipsView.textView.text = <span class="string">&quot;Tips&quot;</span></span><br><span class="line">warningView.textView.text = <span class="string">&quot;Warning&quot;</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">// 添加到对应的父 View 当中</span></span><br></pre></td></tr></table></figure>

<p>那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">kotlinx.android.synthetic.main.view_tips.view.*</span><br><span class="line">kotlinx.android.synthetic.main.view_warning.view.*</span><br></pre></td></tr></table></figure>

<p>我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png" alt="image-20201107095613833"></p>
<p>运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，<code>warningView.textView</code> 其实就等价于 <code>warningView.findViewById(R.id.textView)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALOAD 4</span><br><span class="line">DUP</span><br><span class="line">LDC &quot;warningView&quot;</span><br><span class="line">GETSTATIC com/bennyhuo/helloandroid/R$id.textView : I</span><br><span class="line">INVOKEVIRTUAL android/view/View.findViewById (I)Landroid/view/View;</span><br><span class="line">CHECKCAST android/widget/TextView</span><br></pre></td></tr></table></figure>

<p>所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。</p>
<p>另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ViewTipsLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ViewWarningLayout &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> View.textView: TextView</span><br><span class="line">    <span class="keyword">get</span>() = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么使用的时候如果产生 id 冲突，就可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">with(ViewTipsLayout) &#123;</span><br><span class="line">  tipsView.textView.text = <span class="string">&quot;Tips&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">with(ViewWarningLayout) &#123;</span><br><span class="line">  warningView.textView.text = <span class="string">&quot;Warning&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这只是我们的设想了。毕竟都要废弃了。</p>
<h2 id="不支持-Compose"><a href="#不支持-Compose" class="headerlink" title="不支持 Compose"></a>不支持 Compose</h2><p>去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。</p>
<p>Anko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。</p>
<p>Kotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 <a href="https://github.com/JetBrains/skiko">skiko</a> 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 <a href="https://github.com/JetBrains/compose-jb">compose-jb</a> 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。</p>
<p>对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。</p>
<blockquote>
<p>KAE：我这么优秀！</p>
<p>Compose：你给我让开！</p>
</blockquote>
<h2 id="使用-ViewBinding-作为替代方案"><a href="#使用-ViewBinding-作为替代方案" class="headerlink" title="使用 ViewBinding 作为替代方案"></a>使用 ViewBinding 作为替代方案</h2><p>那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png"></p>
<p>Kotlin 官方建议开发者使用 Android 的 <a href="https://developer.android.com/topic/libraries/view-binding">View Binding</a> 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: ResultProfileBinding? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line"><span class="comment">// onDestroyView.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">    _binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 View 时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。</p>
<p>我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。</p>
<p>其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewBindingFragment</span>&lt;<span class="type">T: ViewBinding</span>&gt;: <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binding: T</span><br><span class="line">        <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 savedInstanceState: <span class="type">Bundle</span>?)</span></span>: T</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> T.<span class="title">onViewCreated</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateBinding(inflater, container, savedInstanceState).also &#123;</span><br><span class="line">            _binding = it</span><br><span class="line">        &#125;.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        binding.onViewCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样用的时候直接继承这个类就好了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainFragment</span> : <span class="type">ViewBindingFragment</span>&lt;<span class="type">FragmentMainBinding</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateBinding</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: FragmentMainBinding &#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentMainBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> FragmentMainBinding.<span class="title">onViewCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        textView.text = <span class="string">&quot;MainFragment&quot;</span></span><br><span class="line">        textView.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(requireContext(), <span class="string">&quot;Clicked.&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。</p>
<p>相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。</p>
<p>不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。</p>
<p>再见，KAE。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>News</tag>
        <tag>Cotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看待 Google 将 Kotlin 作为 Android 开发首选语言？</title>
    <url>/2019/05/10/google-preferred-kotlin/</url>
    <content><![CDATA[<blockquote>
<p>如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。 </p>
</blockquote>
<span id="more"></span>




<p>相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。</p>
<p>Kotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。</p>
<p>我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。</p>
<p>我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 <a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=404087761&idx=1&sn=d80625ee52f860a7a2ed4c238d2151b6">Android开发必备知识：为什么说Kotlin值得一试</a> 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。</p>
<p>Kotlin 究竟有多香呢？</p>
<p>讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。</p>
<p><strong>解放碑 50° 么，我的天！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg"></p>
<p>后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。</p>
<p>那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。</p>
<p>大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。</p>
<p>说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。</p>
<p>所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。</p>
<p>共勉吧。</p>
<hr>
<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:&#x6b;&#x66;&#x40;&#105;&#x6d;&#x6f;&#x6f;&#99;&#46;&#x63;&#x6f;&#x6d;">&#x6b;&#x66;&#x40;&#105;&#x6d;&#x6f;&#x6f;&#99;&#46;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>
<hr>
<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>快速迁移 Gradle 脚本至 KTS</title>
    <url>/2021/04/17/gradle-migrate-to-kts/</url>
    <content><![CDATA[<blockquote>
<p>接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 </p>
</blockquote>
<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1Kf4y1p7zq&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>




<p>大家可以在我的 GitHub 页面找到这个工程：<a href="https://github.com/bennyhuo/Android-LuaJavax">bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua</a>，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png" alt="提交记录"></p>
<p>因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。</p>
<p>接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。</p>
<h2 id="1-处理字符串字面量"><a href="#1-处理字符串字面量" class="headerlink" title="1. 处理字符串字面量"></a>1. 处理字符串字面量</h2><p>我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">&#x27;:app&#x27;</span>,<span class="string">&#x27;:luajava&#x27;</span>, <span class="string">&#x27;:luajavax&#x27;</span></span><br></pre></td></tr></table></figure>

<p>显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。</p>
<p>我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png" alt="使用全局正则匹配替换单引号"></p>
<ol>
<li>匹配框输入正则表达式 <code>&#39;(.*?[^\\])&#39;</code>，替换框中填写 <code>&quot;$1&quot;</code>，这里的 <code>$1</code> 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 <code>$n</code> 来表示，其中 <code>$0</code> 表示匹配到的整个字符</li>
<li>过滤文件后缀，我们只对 <code>*.gradle</code> 文件做替换</li>
<li>在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分</li>
<li>在输入框后面选择 <code>.*</code>，蓝色高亮表示启用正则匹配</li>
</ol>
<p>你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。</p>
<p>至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。</p>
<p>点击 Replace All，替换之后所有的单引号都就变成了双引号：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-给方法调用加上括号"><a href="#2-给方法调用加上括号" class="headerlink" title="2. 给方法调用加上括号"></a>2. 给方法调用加上括号</h2><p>还是以 settings.gradle 当中的这句为例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>

<p>它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。</p>
<p>处理方法，这时候你们应该很自然的就能想到全局正则匹配了：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png" alt="全局正则为方法调用加括号"></p>
<p>在这里，匹配框输入正则表达式 <code>(\w+) (([^=\&#123;\s]+)(.*))</code>，替换框中填写 <code>$1($2)</code>，其他配置与前面替换引号一样。</p>
<p>你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。</p>
<p>点击全部替换，这时候你就发现所有的方法调用都加上了括号：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include(<span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被替换成了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task(clean(<span class="attr">type:</span> Delete) &#123;)</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。</p>
<h2 id="3-开始迁移"><a href="#3-开始迁移" class="headerlink" title="3. 开始迁移"></a>3. 开始迁移</h2><h3 id="3-1-迁移-settings-gradle"><a href="#3-1-迁移-settings-gradle" class="headerlink" title="3.1 迁移 settings.gradle"></a>3.1 迁移 settings.gradle</h3><p>迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。</p>
<p>就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。</p>
<h3 id="3-2-迁移根工程下的-build-gradle"><a href="#3-2-迁移根工程下的-build-gradle" class="headerlink" title="3.2 迁移根工程下的 build.gradle"></a>3.2 迁移根工程下的 build.gradle</h3><p>我们先贴出来原来的 groovy 版本：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">&quot;1.4.30&quot;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>)</span><br><span class="line"></span><br><span class="line">        classpath(<span class="string">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class="line">        <span class="comment">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    it.afterEvaluate &#123;</span><br><span class="line">        it.with &#123;</span><br><span class="line">            <span class="keyword">if</span>(plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">                group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">                version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">                apply(<span class="attr">plugin:</span> <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task(clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e: ...\Android-Luajavax\build.gradle.kts:3:5: Unresolved reference: ext</span><br></pre></td></tr></table></figure>

<p>说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd">Project 的属性都是哪里来的？</a>），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 <code>getProperties()[&quot;ext&quot;]</code>，所以：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext.kotlin_version = <span class="string">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">extra[<span class="string">&quot;kotlin_version&quot;</span>] = <span class="string">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra</span><br><span class="line">...</span><br><span class="line">classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlin_version</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。</p>
<p>接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。</p>
<p>以下是 Groovy 原版：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.afterEvaluate &#123;</span><br><span class="line">        it.with &#123;</span><br><span class="line">            <span class="keyword">if</span>(plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">                group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">                version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">                apply(plugin: <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 <code>it.afterEvaluate</code> 改成 <code>this.afterEvaluate</code>；<code>it.with</code> 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。</p>
<p>剩下的就是 <code>apply(plugin: &quot;com.vanniktech.maven.publish&quot;)</code> 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：<code>apply(plugin = &quot;com.vanniktech.maven.publish&quot;)</code>。</p>
<p>最后就是创建任务的代码了，其实很好改，想想我们上节的内容（<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</a>），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.register&lt;Delete&gt;(<span class="string">&quot;clean&quot;</span>) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。</p>
<p>至此根工程下面的 build.gradle 改造完毕。</p>
<p>不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。</p>
<h3 id="3-3-迁移-app-模块的-build-gradle"><a href="#3-3-迁移-app-模块的-build-gradle" class="headerlink" title="3.3 迁移 app 模块的 build.gradle"></a>3.3 迁移 app 模块的 build.gradle</h3><p>我们先把完整的待改造的版本贴出来：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(<span class="number">28</span>)</span><br><span class="line">    buildToolsVersion(<span class="string">&quot;28.0.3&quot;</span>)</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId(<span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span>)</span><br><span class="line">        minSdkVersion(<span class="number">18</span>)</span><br><span class="line">        targetSdkVersion(<span class="number">28</span>)</span><br><span class="line">        versionCode(<span class="number">1</span>)</span><br><span class="line">        versionName(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled(<span class="literal">true</span>)</span><br><span class="line">            signingConfig(signingConfigs.debug)</span><br><span class="line">            proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        checkReleaseBuilds(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class="line">        <span class="comment">// but(continue the build even when errors are found:)</span></span><br><span class="line">        abortOnError(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(project(<span class="string">&quot;:luajavax&quot;</span>))</span><br><span class="line">    api(<span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span>)</span><br><span class="line"></span><br><span class="line">    api(<span class="string">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// workaround(issue #73)</span></span><br><span class="line">        exclude(<span class="attr">group:</span> <span class="string">&quot;com.google.android&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。</p>
<p>首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apply(plugin = <span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">apply(plugin = <span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">apply(plugin = <span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 <code>android &#123; ... &#125;</code> 无法直接访问。具体原理可以参考前面的视频：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd">你的 Gradle 脚本是怎么运行起来的？</a>。</p>
<p>我们需要通过 <code>plugins &#123; ... &#125;</code> 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apply(plugin = &quot;com.android.application&quot;)</span></span><br><span class="line"><span class="comment">//apply(plugin = &quot;kotlin-android&quot;)</span></span><br><span class="line"><span class="comment">//apply(plugin = &quot;kotlin-android-extensions&quot;)</span></span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 <code>android &#123; ... &#125;</code> 可以访问了。</p>
<p>接下来我们看到 Gradle 报错的是 defaultConfig 部分：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId(<span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span>) <span class="comment">// error</span></span><br><span class="line">    minSdkVersion(<span class="number">18</span>)</span><br><span class="line">    targetSdkVersion(<span class="number">28</span>) </span><br><span class="line">    versionCode(<span class="number">1</span>) <span class="comment">// error</span></span><br><span class="line">    versionName(<span class="string">&quot;1.0&quot;</span>) <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png" alt="使用代码提示查看 applicationId 的定义"></p>
<p>原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">applicationId = <span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png" alt="使用代码提示查看 versionCode 的定义"></p>
<p>后面的 versionCode 和 versionName 也是如此。</p>
<p>接下来我们看 buildTypes 这一块儿。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png" alt="buildTypes 中的报错"></p>
<p><code>release &#123; ... &#125;</code> 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。</p>
<p>这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)</a>)里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。</p>
<p>实际上我们在更早的时候介绍 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd">Project 的属性都是哪里来的？</a> 的时候就提到过，如果被访问的对象恰好是 <strong>GroovyObject</strong> 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 <strong>invokeMethod</strong> 来访问。所以关键的问题来了，<code>release &#123; ... &#125;</code> 是调用了哪个类的 <strong>invokeMethod</strong> 呢？</p>
<p>是 <code>NamedDomainObjectContainerConfigureDelegate</code> 的。在 Groovy 版本的 Gradle 脚本当中，形如 <code>buildTypes &#123; ... &#125;</code> 这样的配置代码，实际上都是通过对应的 <strong>ConfigureDelegate</strong> 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。</p>
<p>总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：</p>
<p><strong>DefaultNamedDomainObjectCollection</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DynamicInvokeResult <span class="title function_">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isConfigureMethod(name, arguments)) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[<span class="number">0</span>], getByName(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>release 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：</p>
<p><strong>NamedDomainObjectContainerConfigureDelegate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DynamicInvokeResult <span class="title function_">_configure</span><span class="params">(String name, Object[] params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.length == <span class="number">1</span> &amp;&amp; params[<span class="number">0</span>] <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.found(_container.create(name, (Closure) params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说了这么多，大家只需要记住对于已经存在的，可以使用 <strong>getByName</strong> 来获取，而不存在的，要使用 <strong>create</strong> 来创建。</p>
<p>因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    <span class="keyword">val</span> release = getByName(<span class="string">&quot;release&quot;</span>)</span><br><span class="line">    release.apply &#123;</span><br><span class="line">        isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">        signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">        proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> release <span class="keyword">by</span> getting &#123;</span><br><span class="line">    isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">    signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要创建一个叫 beta 的 BuildType，可以使用 creating：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> beta <span class="keyword">by</span> creating &#123;</span><br><span class="line">    isMinifyEnabled = <span class="literal">false</span></span><br><span class="line">    signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png" alt="添加新的 BuildType：beta"></p>
<p>好，关于 BuildType 我们就说这么多。</p>
<p>接下来报错的是 lintOptions，这个比较简单，修改如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lintOptions &#123;</span><br><span class="line">    isCheckReleaseBuilds = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class="line">    <span class="comment">// but(continue the build even when errors are found:)</span></span><br><span class="line">    isAbortOnError = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png" alt="通过类型获取任务的报错信息"></p>
<p>根据 IDE 的提示，不难想到以下的改法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.withType(JavaCompile::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.withType&lt;JavaCompile&gt; &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(project(<span class="string">&quot;:luajavax&quot;</span>))</span><br><span class="line">    api(<span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.30&quot;</span>) <span class="comment">// 后续给出替代方案，这里先硬编码</span></span><br><span class="line"></span><br><span class="line">    api(<span class="string">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// workaround(issue #73)</span></span><br><span class="line">        exclude(group = <span class="string">&quot;com.google.android&quot;</span>, module = <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。</p>
<h2 id="4-依赖版本号的替代方案"><a href="#4-依赖版本号的替代方案" class="headerlink" title="4. 依赖版本号的替代方案"></a>4. 依赖版本号的替代方案</h2><p>我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。</p>
<p>Kotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。</p>
<h3 id="4-1-Kotlin-风格的属性读写"><a href="#4-1-Kotlin-风格的属性读写" class="headerlink" title="4.1 Kotlin 风格的属性读写"></a>4.1 Kotlin 风格的属性读写</h3><p>尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 <code>extra[...]</code> 的形式定义属性，还可以采用下面的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinVersion <span class="keyword">by</span> extra(<span class="string">&quot;1.4.30&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> isRelease <span class="keyword">by</span> extra &#123;</span><br><span class="line">    getBooleanFromFile(<span class="string">&quot;config.properties&quot;</span>,<span class="string">&quot;buidType&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义之后，在当前变量所在的范围之内，还可以直接使用。</p>
<p>当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra</span><br></pre></td></tr></table></figure>

<h3 id="4-2-在-buildSrc-当中定义"><a href="#4-2-在-buildSrc-当中定义" class="headerlink" title="4.2 在 buildSrc 当中定义"></a>4.2 在 buildSrc 当中定义</h3><p>buildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `kotlin-dsl`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinVersion = <span class="string">&quot;1.4.30&quot;</span></span><br><span class="line"><span class="keyword">val</span> slf4jVersion = <span class="string">&quot;1.7.21&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。</p>
<p>使用也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">    classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlinVersion</span>&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 <a href="https://github.com/bernaferrari/GradleKotlinConverter">bernaferrari/GradleKotlinConverter</a> 这个项目，其实它的原理就是正则表达式匹配和替换。</p>
<p>本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。</p>
<p>希望对大家有帮助。谢谢大家。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Gradle</tag>
        <tag>Groovy</tag>
        <tag>KTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</title>
    <url>/2021/04/11/gradle-task-syntax/</url>
    <content><![CDATA[<blockquote>
<p>任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ </p>
</blockquote>
<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1ib4y1D74X&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>




<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它定义了一个叫做 “clean” 的任务，这个任务的类型是 Delete。</p>
<p>其中 Delete 是一个类的名字，这是 Groovy 的语法，相当于 Delete.class。这个还好，至少人家语法上支持这样做。</p>
<p>后面的 { … } 有 Kotlin 经验的小伙伴们自然也不会觉得陌生，这肯定是接收一个 Lambda （在 Groovy 当中就是 Closure）作为参数，里面的 <code>delete rootProject.buildDir</code> 则等价于 <code>delete(rootProject.buildDir)</code>，这也是 Groovy 的语法，在 Groovy 当中只要不引起歧义，函数的调用是可以去掉括号的，类似的例子有很多：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.android.tools.build:gradle:4.0.1&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 classpath 也是如此。</p>
<p>这都很容易理解。那么问题来了，<code>task clean(...)&#123; ... &#125;</code> 这是个什么语法？我们定义一个名叫 “clean” 的任务，这个任务名不应该是一个字符串字面量吗，但现在按照 Groovy 的语法，它应该等价于 <code>task(clean(...)&#123; ... &#125;)</code> ，这个 clean 看上去其实是个方法名，而不是一个常量。</p>
<p>如果大家跟我一样一开始就绞尽脑汁地去研究这个玩意究竟是什么 Groovy 语法，那你从一开始就错了。这个答案直到我们在翻阅 Gradle 源码的时候，看到有一个叫做 TaskDefinitionScriptTransformer 的类，这个类在 Gradle 脚本编译运行的第二个阶段时被调用，它和其他几个类似的 Transformer 一样，作用就是对源代码的语法树做了一些转换。</p>
<p>大家在 Gradle 源码当中找到这个类之后就会发现，注释已经写的非常清晰了，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.getExpression(<span class="number">0</span>) <span class="keyword">instanceof</span> MapExpression &amp;&amp; args.getExpression(<span class="number">1</span>) <span class="keyword">instanceof</span> VariableExpression) &#123;</span><br><span class="line">    <span class="comment">// Matches: task &lt;name-value-pairs&gt;, &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class="line">    <span class="comment">// Map to: task(&lt;name-value-pairs&gt;, &#x27;&lt;identifier&gt;&#x27;, &lt;arg&gt;?)</span></span><br><span class="line">    transformVariableExpression(call, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.getExpression(<span class="number">0</span>) <span class="keyword">instanceof</span> VariableExpression) &#123;</span><br><span class="line">    <span class="comment">// Matches: task &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class="line">    transformVariableExpression(call, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释我们可以看到，task 实际上是被当做函数来调用的，我们也确实可以在 Project 当中找到它的定义：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png" alt="image-20210411072516707"></p>
<p>这个映射实际上就是给 identifier 加了个引号，变成字符串字面量。注意到 <code>transformVariableExpression(call, 1);</code> 的第二个参数 1 对应的就是 <code>&lt;identifier&gt;</code>，第二个分支里面的位置则是 0。</p>
<p>这个方法的实现也很显而易见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transformVariableExpression</span><span class="params">(MethodCallExpression call, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">ArgumentListExpression</span> <span class="variable">args</span> <span class="operator">=</span> (ArgumentListExpression) call.getArguments();</span><br><span class="line">    <span class="comment">//拿到 identifier 对应的表达式</span></span><br><span class="line">    <span class="type">VariableExpression</span> <span class="variable">arg</span> <span class="operator">=</span> (VariableExpression) args.getExpression(index);</span><br><span class="line">    <span class="keyword">if</span> (!isDynamicVar(arg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Matches: task args?, &lt;identifier&gt;, args? or task(args?, &lt;identifier&gt;, args?)</span></span><br><span class="line">    <span class="comment">// Map to: task(args?, &#x27;&lt;identifier&gt;&#x27;, args?)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> arg.getText(); <span class="comment">// 表达式的内容就是任务名</span></span><br><span class="line">    call.setMethod(<span class="keyword">new</span> <span class="title class_">ConstantExpression</span>(<span class="string">&quot;task&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建一个以任务名为内容的字符串字面量</span></span><br><span class="line">    args.getExpressions().set(index, <span class="keyword">new</span> <span class="title class_">ConstantExpression</span>(taskName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这个转换以外，还有很多其他的情况，现在我们的问题是文章一开始提到的 <code>task clean(...)&#123; ... &#125;</code>应当属于那种转换？属于嵌套方法调用的转换。前面我们已经分析到这个写法其实可以等价于 <code>task(clean(...)&#123; ... &#125;)</code>，对应的转换在 <code>maybeTransformNestedMethodCall</code> 方法当中给出了实现，我们摘录一部分给大家了解一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">maybeTransformNestedMethodCall</span><span class="params">(MethodCallExpression nestedMethod, MethodCallExpression target)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Matches: task &lt;identifier&gt; &lt;arg-list&gt; | task &lt;string&gt; &lt;arg-list&gt;</span></span><br><span class="line">    <span class="comment">// Map to: task(&quot;&lt;identifier&gt;&quot;, &lt;arg-list&gt;) | task(&lt;string&gt;, &lt;arg-list&gt;)</span></span><br><span class="line">    <span class="type">Expression</span> <span class="variable">taskName</span> <span class="operator">=</span> nestedMethod.getMethod();</span><br><span class="line">    <span class="type">Expression</span> <span class="variable">mapArg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;Expression&gt; extraArgs = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nestedMethod.getArguments() <span class="keyword">instanceof</span> TupleExpression) &#123;</span><br><span class="line">        <span class="type">TupleExpression</span> <span class="variable">nestedArgs</span> <span class="operator">=</span> (TupleExpression) nestedMethod.getArguments();</span><br><span class="line">        <span class="keyword">if</span> (nestedArgs.getExpressions().size() == <span class="number">2</span> &amp;&amp; nestedArgs.getExpression(<span class="number">0</span>) <span class="keyword">instanceof</span> MapExpression &amp;&amp; nestedArgs.getExpression(<span class="number">1</span>) <span class="keyword">instanceof</span> ClosureExpression) &#123;</span><br><span class="line">            <span class="comment">// Matches: task &lt;identifier&gt;(&lt;options-map&gt;) &lt;closure&gt;</span></span><br><span class="line">            mapArg = nestedArgs.getExpression(<span class="number">0</span>);</span><br><span class="line">            extraArgs = nestedArgs.getExpressions().subList(<span class="number">1</span>, nestedArgs.getExpressions().size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target.setMethod(<span class="keyword">new</span> <span class="title class_">ConstantExpression</span>(<span class="string">&quot;task&quot;</span>));</span><br><span class="line">    <span class="type">ArgumentListExpression</span> <span class="variable">args</span> <span class="operator">=</span> (ArgumentListExpression) target.getArguments();</span><br><span class="line">    args.getExpressions().clear();</span><br><span class="line">    <span class="comment">// 如果有 map 参数，放到第一个</span></span><br><span class="line">    <span class="keyword">if</span> (mapArg != <span class="literal">null</span>) &#123;</span><br><span class="line">        args.addExpression(mapArg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，taskName 被当做参数传入</span></span><br><span class="line">    args.addExpression(taskName);</span><br><span class="line">    <span class="comment">// 剩下的参数</span></span><br><span class="line">    <span class="keyword">for</span> (Expression extraArg : extraArgs) &#123;</span><br><span class="line">        args.addExpression(extraArg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapArg 是否为 null，对应了 task 方法的两个重载版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Task <span class="title function_">task</span><span class="params">(String name, Closure configureClosure)</span>;</span><br><span class="line">Task <span class="title function_">task</span><span class="params">(Map&lt;String, ?&gt; args, String name, Closure configureClosure)</span>;</span><br></pre></td></tr></table></figure>

<p>这么来看，文章开头提到的创建任务的写法，实际上相当于：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span>(type: <span class="keyword">Delete</span>, <span class="string">&quot;clean&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他类似的 Transformer 大家可以自行分析。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解 Kotlin 协程》这书该怎么读？</title>
    <url>/2021/01/31/how-to-read-the-book-of-coroutines/</url>
    <content><![CDATA[<blockquote>
<p>趁着面试官还没看，赶紧深入了解一下~~ </p>
</blockquote>
<span id="more"></span>




<p>鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。</p>
<p>不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。</p>
<h2 id="本书收到的评论"><a href="#本书收到的评论" class="headerlink" title="本书收到的评论"></a>本书收到的评论</h2><p>以下来自京东自营商品的商品评价，用户关键信息已打码。</p>
<h3 id="负面评论"><a href="#负面评论" class="headerlink" title="负面评论"></a>负面评论</h3><p><strong>差评一：完全没干货</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png"></p>
<p><strong>不正经的回应</strong>：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png"></p>
<p><strong>正经的回应</strong>：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。</p>
<p><strong>差评二：一上来就讲原理，压根接受不了</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png"></p>
<p><strong>不正经的回应</strong>：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png"></p>
<p><strong>正经的回应</strong>：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。</p>
<p><strong>中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png"></p>
<p><strong>不正经的回应</strong>：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png"></p>
<p><strong>正经的回应</strong>：两个问题：</p>
<ol>
<li>代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。</li>
<li>内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？</li>
</ol>
<p><strong>中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png"></p>
<p><strong>不正经的回应</strong>：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png"></p>
<p><strong>正经的回应</strong>：也是两个问题：</p>
<ol>
<li>缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ”””  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？</li>
<li>至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。</li>
</ol>
<p><strong>中评三：篇幅太小，一笔带过，算不上深入理解</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png"></p>
<p><strong>不正经的回应</strong>：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ </p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png"></p>
<p><strong>正经的回应</strong>：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。</p>
<h3 id="正面评论"><a href="#正面评论" class="headerlink" title="正面评论"></a>正面评论</h3><p>整体上正面评论更多一些，我就挑了两个列出来：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png"></p>
<p><strong>不正经的回应</strong>：我没啥好说的，我也是这么想的(✪ω✪)！</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif" alt="img"></p>
<p><strong>正经的回应</strong>：这种时候根本正经不起来好吧！</p>
<h2 id="本书的阅读建议"><a href="#本书的阅读建议" class="headerlink" title="本书的阅读建议"></a>本书的阅读建议</h2><p>咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png"></p>
<p>而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃’▽’〃)</p>
<p>所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。</p>
<h3 id="本书的内容来源"><a href="#本书的内容来源" class="headerlink" title="本书的内容来源"></a>本书的内容来源</h3><p>要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。</p>
<p>书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：</p>
<ul>
<li><p>看过我的“<a href="https://coding.imooc.com/class/398.html">新版Kotlin从入门到精通</a>”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。<br>  <img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png"></p>
<p>  <strong>“新版Kotlin从入门到精通” 协程相关章节</strong></p>
</li>
<li><p>看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。<br>  <img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png"></p>
<p>  <strong>协程相关历史文章：关注公众号 Kotlin 回复 “协程” 获取</strong></p>
</li>
</ul>
<p>那么我写这本书是不是在重复消费以前的内容呢？</p>
<p>熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png"></p>
<p>而这次编纂成册，其实主要完成了以下两项目标：</p>
<ol>
<li><p>概念的清晰化。</p>
<p> 这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？</p>
<p> 为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。</p>
</li>
<li><p>知识的体系化。</p>
<p> 除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。</p>
<p> 为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。</p>
</li>
</ol>
<h3 id="本书的目标读者"><a href="#本书的目标读者" class="headerlink" title="本书的目标读者"></a>本书的目标读者</h3><p>本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif" alt="img"></p>
<p>话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？</p>
<p>但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。</p>
<p>而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。</p>
<p>至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif" alt="img"></p>
<p>另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。</p>
<h3 id="本书的内容安排"><a href="#本书的内容安排" class="headerlink" title="本书的内容安排"></a>本书的内容安排</h3><h4 id="第一章：搞清楚异步程序设计"><a href="#第一章：搞清楚异步程序设计" class="headerlink" title="第一章：搞清楚异步程序设计"></a>第一章：搞清楚异步程序设计</h4><ul>
<li>内容难度：※</li>
<li>阅读方式：掌握</li>
</ul>
<p>想要搞清楚协程，必须先搞清楚异步。</p>
<p>之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。</p>
<p>不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？</p>
<p>本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。</p>
<h4 id="第二章：搞清楚协程的概念"><a href="#第二章：搞清楚协程的概念" class="headerlink" title="第二章：搞清楚协程的概念"></a>第二章：搞清楚协程的概念</h4><ul>
<li>内容难度：※※</li>
<li>阅读方式：了解</li>
</ul>
<p>网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。</p>
<p>这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？</p>
<p>实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。</p>
<h4 id="第三、四章：搞清楚-Kotlin-协程的基础"><a href="#第三、四章：搞清楚-Kotlin-协程的基础" class="headerlink" title="第三、四章：搞清楚 Kotlin 协程的基础"></a>第三、四章：搞清楚 Kotlin 协程的基础</h4><ul>
<li>内容难度：第三章 ※※※ 第四章 ※※※※</li>
<li>阅读方式：第三章的内容需要理解，第四章仅供参考可跳过</li>
</ul>
<p>Kotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。</p>
<p>那这么说 Kotlin 协程的设计很失败啊。</p>
<p>其实不然。</p>
<p>协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。</p>
<p>Kotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。</p>
<p>还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。</p>
<p>没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png"></p>
<p>讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。</p>
<p>对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。</p>
<h4 id="第五、六章：搞清楚官方的协程框架"><a href="#第五、六章：搞清楚官方的协程框架" class="headerlink" title="第五、六章：搞清楚官方的协程框架"></a>第五、六章：搞清楚官方的协程框架</h4><ul>
<li>内容难度：第五章 ※※※※※ 第六章 ※※※</li>
<li>阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法</li>
</ul>
<p>官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。</p>
<p>我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。</p>
<p>当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。</p>
<p>那么问题来了，这一章算是劝退吗？</p>
<p>显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。</p>
<p>第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。</p>
<h4 id="第七、八章：搞清楚协程的使用场景"><a href="#第七、八章：搞清楚协程的使用场景" class="headerlink" title="第七、八章：搞清楚协程的使用场景"></a>第七、八章：搞清楚协程的使用场景</h4><ul>
<li>内容难度：※※※</li>
<li>阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章</li>
</ul>
<p>这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。</p>
<p>实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。</p>
<h4 id="第九章：搞清楚协程对多平台的支持情况"><a href="#第九章：搞清楚协程对多平台的支持情况" class="headerlink" title="第九章：搞清楚协程对多平台的支持情况"></a>第九章：搞清楚协程对多平台的支持情况</h4><ul>
<li>内容难度：※※※※</li>
<li>阅读方式：了解即可</li>
</ul>
<p>多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。</p>
<p>当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。</p>
<h2 id="本书的一些资源"><a href="#本书的一些资源" class="headerlink" title="本书的一些资源"></a>本书的一些资源</h2><h3 id="本书勘误"><a href="#本书勘误" class="headerlink" title="本书勘误"></a>本书勘误</h3><p>从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)</p>
<p>这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png"></p>
<p><strong>《深入理解 Kotlin 协程》勘误表</strong></p>
<p>这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 <strong>llt</strong> 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif" alt="img"></p>
<p>本书的勘误我一直在<a href="https://www.bennyhuo.com/project/kotlin-coroutines.html">我的博客当中关于本书的页面</a>上有更新。</p>
<p>哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆</p>
<h3 id="本书交流"><a href="#本书交流" class="headerlink" title="本书交流"></a>本书交流</h3><p>我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png"></p>
<p><strong>使用手机 QQ 扫描加群</strong></p>
<p>读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。</p>
<p>另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png" alt="img"></p>
<h3 id="本书源码"><a href="#本书源码" class="headerlink" title="本书源码"></a>本书源码</h3><p>本书源码在 GitHub 上完整的给了出来：<a href="https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources">DiveIntoKotlinCoroutines-Sources</a>（没想到已经 100 多个小星星了(～￣▽￣)～ ）</p>
<p>实际上如果你基础不错，自己研究一下 <a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a> 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。</p>
<p>最后，祝大家春节快乐~</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 1.4 新特性预览</title>
    <url>/2020/03/26/kotlin-1.4-preview/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 </p>
</blockquote>
<span id="more"></span>




<p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href="https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md">这里查看</a>。</p>
<p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png"></p>
<p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p>
<p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png"></p>
<p><strong><center>图 2：升级 Kotlin 插件</center></strong></p>
<p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p>
<h2 id="2-主要的语法更新"><a href="#2-主要的语法更新" class="headerlink" title="2. 主要的语法更新"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p>
<p>本文源码均已整理至 GitHub：<a href="https://github.com/enbandari/Kotlin1.4FeaturesSample">Kotlin1.4FeaturesSample</a>。</p>
<h3 id="2-1-Kotlin-接口和函数的-SAM-转换"><a href="#2-1-Kotlin-接口和函数的-SAM-转换" class="headerlink" title="2.1 Kotlin 接口和函数的 SAM 转换"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意 fun interface 是新特性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"><span class="comment">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(r: <span class="type">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure>

<p>在 1.4 以前，我们只能：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runAction(<span class="keyword">object</span>: Action&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Not good..&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runAction(Action &#123; println(<span class="string">&quot;Not good..&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure>

<p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p>
<p>现在在 1.4 当中呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runAction &#123; println(<span class="string">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br><span class="line">runRunnable &#123; println(<span class="string">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>真是妙啊。</p>
<h3 id="2-2-类型推导支持了更多的场景"><a href="#2-2-类型推导支持了更多的场景" class="headerlink" title="2.2 类型推导支持了更多的场景"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p>
<p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class="built_in">Boolean</span>&gt; = mapOf(</span><br><span class="line">    <span class="string">&quot;weak&quot;</span> to &#123; it != <span class="literal">null</span> &#125;,</span><br><span class="line">    <span class="string">&quot;medium&quot;</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class="line">    <span class="string">&quot;strong&quot;</span> to &#123; it != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;^[a-zA-Z0-9]+$&quot;</span>.toRegex().matches(it) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png"></p>
<p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p>
<p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p>
<h3 id="2-3-Lambda-表达式最后一行的智能类型转换"><a href="#2-3-Lambda-表达式最后一行的智能类型转换" class="headerlink" title="2.3 Lambda 表达式最后一行的智能类型转换"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">var</span> str = currentValue()</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        str = <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    str <span class="comment">// the Kotlin compiler knows that str is not null here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The type of &#x27;result&#x27; is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure>

<p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p>
<p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p>
<p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p>
<p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png"></p>
<p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p>
<p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p>
<p>当然，有些开发者经常会抱怨类似下面的这种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(x.length) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p>
<h3 id="2-4-带有默认参数的函数的类型支持"><a href="#2-4-带有默认参数的函数的类型支持" class="headerlink" title="2.4 带有默认参数的函数的类型支持"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: String = <span class="string">&quot;<span class="variable">$i</span>!&quot;</span></span><br></pre></td></tr></table></figure>

<p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply1</span><span class="params">(func: () -&gt; <span class="type">String</span>)</span></span>: String = func()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">apply2</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>: String = func(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(apply1(::foo))</span><br><span class="line">    println(apply2(::foo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p>
<h3 id="2-5-属性代理的类型推导"><a href="#2-5-属性代理的类型推导" class="headerlink" title="2.5 属性代理的类型推导"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$old</span> → <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    prop = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    prop = <span class="string">&quot;xyz&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prop: String? <span class="keyword">by</span> Delegates.observable&lt;String?&gt;(<span class="literal">null</span>) &#123; p, old, new -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$old</span> → <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-混合位置参数和具名参数"><a href="#2-6-混合位置参数和具名参数" class="headerlink" title="2.6 混合位置参数和具名参数"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png"></p>
<p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p>
<p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p>
<p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png"></p>
<p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p>
<p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p>
<p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p>
<h3 id="2-7-优化属性代理的编译"><a href="#2-7-优化属性代理的编译" class="headerlink" title="2.7 优化属性代理的编译"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherClass</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后生成的字节码反编译之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.bennyhuo.kotlin.MyOtherClass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getLazyProp</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p>
<p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p>
<p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherClass</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lazyProp <span class="keyword">by</span> lazy &#123; <span class="number">42</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> myProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;&lt;no name&gt;&quot;</span>) &#123;</span><br><span class="line">            kProperty, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;kProperty.name&#125;</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p>
<h3 id="2-8-参数列表最后的逗号"><a href="#2-8-参数列表最后的逗号" class="headerlink" title="2.8 参数列表最后的逗号"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(</span><br><span class="line">        <span class="string">&quot;bennyhuo&quot;</span>,</span><br><span class="line">        <span class="number">30</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png"></p>
<p><strong><center>图 7：多行编辑逗号的问题</center></strong></p>
<p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png"></p>
<p><strong><center>图 8：多行编辑所有参数</center></strong></p>
<p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png"></p>
<p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p>
<p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p>
<p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png"></p>
<p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p>
<p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p>
<h3 id="2-9-when-表达式中使用-continue-和-break"><a href="#2-9-when-表达式中使用-continue-和-break" class="headerlink" title="2.9 when 表达式中使用 continue 和 break"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p>
<h3 id="2-10-尾递归函数的优化"><a href="#2-10-尾递归函数的优化" class="headerlink" title="2.10 尾递归函数的优化"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p>
<ul>
<li>尾递归函数的默认参数的初始化顺序改为从左向右：</li>
<li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li>
</ul>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png"></p>
<p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p>
<h3 id="2-11-契约的支持"><a href="#2-11-契约的支持" class="headerlink" title="2.11 契约的支持"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p>
<p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p>
<ul>
<li>支持使用内联特化的函数来实现契约</li>
<li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li>
</ul>
<h3 id="2-12-其他的一些改动"><a href="#2-12-其他的一些改动" class="headerlink" title="2.12 其他的一些改动"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p>
<p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p>
<p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p>
<p>未来可期。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>release</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 最近怎么样了</title>
    <url>/2019/12/23/kotlin-2019-whats-new/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 </p>
</blockquote>
<span id="more"></span>




<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(action: <span class="type">Action</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    runAction &#123;</span><br><span class="line">        <span class="comment">//action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p>
<h2 id="新形势"><a href="#新形势" class="headerlink" title="新形势"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p>
<p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p>
<p><strong>TIOBE Index for December 2019</strong><br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg"></p>
<p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p>
<p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p>
<p><strong>PYPL PopularitY of Programming Language</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg"></p>
<p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p>
<p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p>
<p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg"><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p>
<h2 id="新发展"><a href="#新发展" class="headerlink" title="新发展"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href="https://developer.android.com/kotlin/ktx">KTX 的库</a>已经非常丰富，<a href="https://developer.android.com/topic/libraries/architecture/lifecycle">Lifecycle</a>、<a href="https://developer.android.com/topic/libraries/architecture/room">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href="https://github.com/square/retrofit">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href="https://github.com/square/okhttp">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href="https://github.com/Tencent/Shadow">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p>
<p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href="https://www.baeldung.com/spring-boot-kotlin-coroutines">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href="https://ktor.io/">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p>
<p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href="https://github.com/Kotlin/dukat">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p>
<p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p>
<p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href="https://docs.gradle.org/5.0/release-notes.html">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p>
<p>更重磅的是，来看看新鲜出炉的 <a href="https://github.com/Kotlin/kotlin-jupyter">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p>
<p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href="https://github.com/arrow-kt/arrow">Arrow</a>  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p>
<h2 id="一如既往的建议"><a href="#一如既往的建议" class="headerlink" title="一如既往的建议"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href="https://www.kotlincn.net/">中文 Kotlin 官网</a>，有问题可以到<a href="https://discuss.kotliner.cn/">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href="https://coding.imooc.com/class/398.html">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p>
<p>Have a nice Kotlin!</p>
<hr>
<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p>
<hr>
<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>News</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 社区资源介绍</title>
    <url>/2018/10/02/kotlin-community-cn/</url>
    <content><![CDATA[<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p>
<span id="more"></span>

<ol>
<li>**<a href="https://www.kotlincn.net/">Kotlin 中文官网</a>**，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li>
<li>**<a href="https://www.kotliner.cn/">Kotlin 中文博客</a>**，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li>
<li>**<a href="https://discuss.kotliner.cn/">Kotlin 中文论坛</a>**，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li>
<li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li>
</ol>
<p>欢迎关注 Kotlin 公众号：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg" alt="Kotlin 公众号"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Website</tag>
      </tags>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（0）：前言</title>
    <url>//2019/03/31/kotlin-coroutines-00-forword/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p>最近我因缘际会写了<a href="https://www.bennyhuo.com/book/swift-coroutines/"><strong>闲话 Swift 协程</strong></a>和<a href="https://www.bennyhuo.com/book/cpp-coroutines/"><strong>渡劫 C++ 协程</strong></a>系列文章来介绍 Swift 协程和 C++ 协程，写完之后又把它们整理成电子书的形式发布了出来。<strong>破解 Kotlin 协程</strong>系列文章自然也可以成为其中的一员。</p>
<p>这份前言是 2022 年后补的，文章则主要是 2019 年基于 Kotlin 1.3 撰写的。随着 Kotlin 协程的快速迭代，这些文章中的有些内容已经过时，读者需要在阅读的过程中自行甄别。</p>
<p>Kotlin 1.3 是在 2018 年底发布的，随着 Kotlin 协程框架的正式发布，Kotlin 官方也终于把语言层面的协程特性扶正了。协程即便在现在也不能算是一个特别容易上手的特性，更何况当时官方自己的文档还一塌糊涂呢。基于当时的情况，我持续地写了十几篇文章来介绍 Kotlin 协程的相关特性以及框架的使用，这也就是大家即将要看到的<strong>破解 Kotlin 协程</strong>系列文章了。</p>
<p>这些文章的撰写并不容易，因为所有的知识来源基本上就是 Kotlin 标准库和 Kotlin 协程库的源码。你甚至可以想象到那时候官方源码当中的注释都有可能是错的，我也几次向 Kotlin 协程库提了 issue。</p>
<p>这些文章后来也成为我在 2020 年出版的<a href="https://item.jd.com/12898592.html"><strong>《深入理解 Kotlin 协程》</strong></a>一书的第六章的主要内容基础。</p>
<blockquote>
<p><strong>说明</strong> 如果你想要深入了解 Kotlin 协程的运行机制和实现细节，建议直接阅读<a href="https://item.jd.com/12898592.html"><strong>《深入理解 Kotlin 协程》</strong></a>，书中对 Kotlin 协程的原理和实现做了详细的剖析和介绍，甚至带着读者还一步一步完成了一个简化版的协程框架。</p>
</blockquote>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（1）：入门篇</title>
    <url>//2019/04/01/basic-coroutines/</url>
    <content><![CDATA[<blockquote>
<p>假定你对协程（Coroutine）一点儿都不了解，通过阅读本文看看是否能让你明白协程是怎么一回事。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 <a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a> 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。</p>
<p>这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。</p>
<h2 id="2-需求确认"><a href="#2-需求确认" class="headerlink" title="2. 需求确认"></a>2. 需求确认</h2><p>在开始讲解协程之前，我们需要先确认几件事儿：</p>
<ol>
<li>你用过线程对吧？</li>
<li>你写过回调对吧？</li>
<li>你用过 RxJava 类似的框架吗？</li>
</ol>
<p>看下你的答案：</p>
<ul>
<li>如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；</li>
<li>如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；</li>
<li>如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~</li>
</ul>
<h2 id="3-一个常规例子"><a href="#3-一个常规例子" class="headerlink" title="3. 一个常规例子"></a>3. 一个常规例子</h2><p>我们通过 Retrofit 发送一个网络请求，其中接口如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubServiceApi</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: Call&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> url: String)</span><br></pre></td></tr></table></figure>

<p>Retrofit 初始化如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们请求网络时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">gitHubServiceApi.getUser(<span class="string">&quot;bennyhuo&quot;</span>).enqueue(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        handler.post &#123; showError(t) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        handler.post &#123; response.body()?.let(::showUser) ?: showError(NullPointerException()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？</p>
<ul>
<li>通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题</li>
<li>回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试</li>
<li>重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 <code>showError</code>，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复</li>
</ul>
<p>Kotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。</p>
<blockquote>
<p>如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 <code>SwingUtilities.invokeLater&#123; ... &#125;</code> (Java Swing)，或者 <code>setTimeout(&#123; ... &#125;, 0)</code> (Js) 等等。</p>
</blockquote>
<h2 id="4-改造成协程"><a href="#4-改造成协程" class="headerlink" title="4. 改造成协程"></a>4. 改造成协程</h2><p>你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 <code>retryWhen</code>）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。</p>
<p>对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。</p>
<h3 id="4-1-CallAdapter-的方式"><a href="#4-1-CallAdapter-的方式" class="headerlink" title="4.1 CallAdapter 的方式"></a>4.1 CallAdapter 的方式</h3><p>我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubServiceApi</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 Deferred 是 Job 的子接口。</p>
</blockquote>
<p>那么我们需要为 Retrofit 添加对 <code>Deferred</code> 的支持，这需要用到开源库：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>构造 Retrofit 实例时添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            <span class="comment">//添加对 Deferred 的支持</span></span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这时候我们发起请求就可以这么写了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">&quot;bennyhuo&quot;</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： <code>Dispatchers.Main</code> 在不同的平台上的实现不同，如果在 Android 上为 <code>HandlerDispatcher</code>，在 Java Swing 上为 <code>SwingDispatcher</code> 等等。</p>
</blockquote>
<p>首先我们通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个，依次为协程上下文、协程启动模式、协程体：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,  <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job </span><br></pre></td></tr></table></figure>

<p><strong>启动模式</strong>不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。</p>
<p><strong>上下文</strong>可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保 <code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己在 <code>launch</code> 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。</p>
<p>换句话说，在例子当中整个 <code>launch</code> 内部<strong>你看到的代码</strong>都是运行在 UI 线程的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，<code>getUser</code> 返回了一个 <code>Deferred</code> 类型，它的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么 <code>await</code> 不会阻塞 UI 线程吗？</p>
<p>答案是：不会。当然不会，不然那 <code>Deferred</code> 与 <code>Future</code> 又有什么区别呢？这里 <code>await</code> 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 <code>Continuation</code> 的接口的实例来返回结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.3 的源码其实并不是很直接，尽管我们可以再看下 <code>Result</code> 的源码，但我不想这么做。更容易理解的是之前版本的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 <code>Callback</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, Throwable t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有结果正常返回的时候，<code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常，简直与 <code>Callback</code> 一模一样。</p>
<p>所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//showUser 在 await 的 Continuation 的回调函数调用后执行</span></span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">&quot;bennyhuo&quot;</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。</p>
<p>这时候也许大家还是有问题：我并没有看到 <code>Continuation</code> 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，<code>await</code> 这个方法的签名其实并不像我们看到的那样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br></pre></td></tr></table></figure>

<p>它真实的签名其实是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 的这么个函数，所以前面的代码我们可以大致理解为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意以下不是正确的代码，仅供大家理解协程使用</span></span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    gitHubServiceApi.getUser(<span class="string">&quot;bennyhuo&quot;</span>).await(<span class="keyword">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">                showUser(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>&#123;</span><br><span class="line">                showError(exception)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 <code>await</code> 当中，大致就是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意以下并不是真实的实现，仅供大家理解协程使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">User</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    ... <span class="comment">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = ...</span><br><span class="line">        handler.post&#123; continuation.resume(user) &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: Exception) &#123;</span><br><span class="line">        handler.post&#123; continuation.resumeWithException(e) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。</p>
<h3 id="4-2-suspend-函数的方式"><a href="#4-2-suspend-函数的方式" class="headerlink" title="4.2 suspend 函数的方式"></a>4.2 suspend 函数的方式</h3><p>suspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 <code>Deferred</code> 的 <code>await</code> 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。</p>
<blockquote>
<p>Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。</p>
</blockquote>
<p>首先我们修改接口方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure>

<p>这种情况 Retrofit 会根据接口方法的声明来构造 <code>Continuation</code>，并且在内部封装了 <code>Call</code> 的异步请求（使用 enqueue），进而得到 <code>User</code> 实例，具体原理后面我们有机会再介绍。使用方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUser(<span class="string">&quot;bennyhuo&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的执行流程与 <code>Deferred.await</code> 类似，我们就不再详细分析了。</p>
<h2 id="5-协程到底是什么"><a href="#5-协程到底是什么" class="headerlink" title="5. 协程到底是什么"></a>5. 协程到底是什么</h2><p>好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。</p>
<p>而<strong>协程</strong>可以帮你优雅的处理掉这些。</p>
<p>协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
</blockquote>
<p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p>
<blockquote>
<p>关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。</p>
</blockquote>
<p>如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，<a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a> 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCompleted: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isCancelled: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看 Thread 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException  &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。</p>
<p>而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。</p>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。</p>
<p>这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（2）：协程启动篇</title>
    <url>//2019/04/08/coroutines-start-mode/</url>
    <content><![CDATA[<blockquote>
<p>现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-回想一下刚学-Thread-的时候"><a href="#1-回想一下刚学-Thread-的时候" class="headerlink" title="1. 回想一下刚学 Thread 的时候"></a>1. 回想一下刚学 Thread 的时候</h2><p>我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = <span class="keyword">object</span> : Thread()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run()</span><br><span class="line">        <span class="comment">//do what you want to do.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<p>肯定有人忘了调用 <code>start</code>，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 <code>start</code> 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 <code>stop</code> 可以用，结果他们很快发现设计 <code>stop</code> 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。</p>
<blockquote>
<p>既然 <code>stop</code> 是错误，那么总是让初学者丢掉的 <code>start</code> 是不是也是一个错误呢？</p>
</blockquote>
<p>哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>thread</code> 方法有个参数 <code>start</code> 默认为 <code>true</code>，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = thread(start = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//later on ...</span></span><br><span class="line">myThread.start()</span><br></pre></td></tr></table></figure>

<p>这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。</p>
<h2 id="2-再来看看协程的启动"><a href="#2-再来看看协程的启动" class="headerlink" title="2. 再来看看协程的启动"></a>2. 再来看看协程的启动</h2><p>说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">//do what you want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 <strong>上下文</strong>、<strong>启动模式</strong>、<strong>协程体</strong>，<strong>协程体</strong> 就好比 <code>Thread.run</code> 当中的代码，自不必说。</p>
<p>本文将为大家详细介绍 <strong>启动模式</strong>。在 Kotlin 协程当中，启动模式是一个枚举：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">CoroutineStart</span> &#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LAZY,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    ATOMIC,</span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    UNDISPATCHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>立即执行协程体</td>
</tr>
<tr>
<td>ATOMIC</td>
<td>立即执行协程体，但在开始运行之前无法取消</td>
</tr>
<tr>
<td>UNDISPATCHED</td>
<td>立即在当前线程执行协程体，直到第一个 suspend 调用</td>
</tr>
<tr>
<td>LAZY</td>
<td>只有在需要的情况下运行</td>
</tr>
</tbody></table>
<h3 id="2-1-DEFAULT"><a href="#2-1-DEFAULT" class="headerlink" title="2.1 DEFAULT"></a>2.1 DEFAULT</h3><p>四个启动模式当中我们最常用的其实是 <code>DEFAULT</code> 和 <code>LAZY</code>。</p>
<p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。</p>
</blockquote>
<p>这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">51</span>:08:<span class="number">160</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:08:<span class="number">603</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:08:<span class="number">606</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:08:<span class="number">624</span> [main] <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>也可能是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">367</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">541</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">550</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">20</span>:<span class="number">19</span>:<span class="number">06</span>:<span class="number">551</span> [main] <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。</p>
<blockquote>
<p>JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。</p>
<p>当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。</p>
<p>更多调度器的话题，我们后续还会进一步讨论。</p>
</blockquote>
<h3 id="2-2-LAZY"><a href="#2-2-LAZY" class="headerlink" title="2.2 LAZY"></a>2.2 LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， <code>launch</code> 调用后会返回一个 <code>Job</code> 实例，对于这种情况，我们可以：</p>
<ul>
<li>调用 <code>Job.start</code>，主动触发协程的调度执行</li>
<li>调用 <code>Job.join</code>，隐式的触发协程的调度执行</li>
</ul>
<p>所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 <code>await</code> 来表达对 <code>Deferred</code> 的需要。这个行为与 <code>Thread.join</code> 不一样，后者如果没有启动的话，调用 <code>join</code> 不会有任何作用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.start()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>基于此，对于上面的示例，输出的结果可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:56:28:374 [main] 1</span><br><span class="line">14:56:28:493 [main] 3</span><br><span class="line">14:56:28:511 [main] 4</span><br><span class="line">14:56:28:516 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>

<p>当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 <code>join</code>，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>因为要等待协程执行完毕，因此输出的结果一定是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:47:45:963 [main] 1</span><br><span class="line">14:47:46:054 [main] 3</span><br><span class="line">14:47:46:069 [DefaultDispatcher-worker-1] 2</span><br><span class="line">14:47:46:090 [main] 4</span><br></pre></td></tr></table></figure>

<h3 id="2-3-ATOMIC"><a href="#2-3-ATOMIC" class="headerlink" title="2.3 ATOMIC"></a>2.3 ATOMIC</h3><p><code>ATOMIC</code> 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。</p>
<p>为了搞清楚它与 <code>DEFAULT</code> 的区别，我们来看一段例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>我们创建了协程后立即 cancel，但由于是 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20:42:42:783 [main] 1</span><br><span class="line">20:42:42:879 [main] 3</span><br><span class="line">20:42:42:879 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>

<p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 <code>DEFAULT</code> 模式，那么 2 有可能会输出，也可能不会。</p>
<p>需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过<code>ATOMIC</code> 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure>

<p>我们在 2 和 3 之间加了一个 <code>delay</code>，<code>delay</code> 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 <code>ATOMIC</code> 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 <code>delay</code> 是支持 cancel 的，因此后面的 3 将不会被打印。</p>
<blockquote>
<p>我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。</p>
</blockquote>
<h3 id="2-4-UNDISPATCHED"><a href="#2-4-UNDISPATCHED" class="headerlink" title="2.4 UNDISPATCHED"></a>2.4 UNDISPATCHED</h3><p>有了前面的基础，<code>UNDISPATCHED</code> 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 <code>ATOMIC</code>，不同之处在于 <code>UNDISPATCHED</code> 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">4</span>)</span><br><span class="line">job.join()</span><br><span class="line">log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>我们还是以这样一个例子来认识下 <code>UNDISPATCHED</code> 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，<code>delay</code> 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，<code>join</code> 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:00:31:693 [main] 1</span><br><span class="line">22:00:31:782 [main @coroutine#1] 2</span><br><span class="line">22:00:31:800 [main] 4</span><br><span class="line">22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class="line">22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，<code>join</code> 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。</p>
</blockquote>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><code>log</code> 函数的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dateFormat = SimpleDateFormat(<span class="string">&quot;HH:mm:ss:SSS&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> now = &#123;</span><br><span class="line">    dateFormat.format(Date(System.currentTimeMillis()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>?)</span></span> = println(<span class="string">&quot;<span class="subst">$&#123;now()&#125;</span> [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（3）：协程调度篇</title>
    <url>//2019/04/11/coroutine-dispatchers/</url>
    <content><![CDATA[<blockquote>
<p>上一篇我们知道了协程启动的几种模式，也通过示例认识了 <code>launch</code> 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg"></p>
<h2 id="1-协程上下文"><a href="#1-协程上下文" class="headerlink" title="1. 协程上下文"></a>1. 协程上下文</h2><p>调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。</p>
<p>前面我们提到 <code>launch</code> 函数有三个参数，第一个参数叫 <strong>上下文</strong>，它的接口类型是 <code>CoroutineContext</code>，通常我们见到的上下文的类型是 <code>CombinedContext</code> 或者 <code>EmptyCoroutineContext</code>，一个表示上下文的组合，另一个表示什么都没有。我们来看下 <code>CoroutineContext</code> 的接口方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = ...</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道大家有没有发现，它简直就是一个以 <code>Key</code> 为索引的 <code>List</code>：</p>
<table>
<thead>
<tr>
<th>CoroutineContext</th>
<th>List</th>
</tr>
</thead>
<tbody><tr>
<td>get(Key)</td>
<td>get(Int)</td>
</tr>
<tr>
<td>plus(CoroutineContext)</td>
<td>plus(List)</td>
</tr>
<tr>
<td>minusKey(Key)</td>
<td>removeAt(Int)</td>
</tr>
</tbody></table>
<blockquote>
<p>表中的 <code>List.plus(List)</code> 实际上指的是扩展方法 <code>Collection&lt;T&gt;.plus(elements: Iterable&lt;T&gt;): List&lt;T&gt;</code> </p>
</blockquote>
<p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code>，每一个 <code>Element</code> 都有一个 <code>key</code>，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code> 的子接口，因此也可以作为集合出现。</p>
<p>讲到这里，大家就会明白，<code>CoroutineContext</code> 原来是个数据结构啊。如果大家对于 <code>List</code> 的递归定义比较熟悉的话，那么对于 <code>CombinedContext</code> 和 <code>EmptyCoroutineContext</code> 也就很容易理解了，例如 scala 的 <code>List</code>是这么定义的：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>] <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">List</span>[<span class="type">A</span>]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模式匹配的时候，<code>List(1,2,3,4)</code> 是可以匹配 <code>x::y</code> 的，<code>x</code> 就是 1，<code>y</code> 则是 <code>List(2,3,4)</code>。</p>
<p><code>CombinedContext</code> 的定义也非常类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CombinedContext</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> element: Element</span><br><span class="line">) : CoroutineContext, Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 <code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 <code>Key</code> 来查找，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(coroutineContext[Job]) <span class="comment">// &quot;coroutine#1&quot;:StandaloneCoroutine&#123;Active&#125;@1ff62014</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(coroutineContext[Job]) <span class="comment">// null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Job</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [Job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以我们也可以仿照 <code>Thread.currentThread()</code> 来一个获取当前 <code>Job</code> 的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Job.Key.<span class="title">currentJob</span><span class="params">()</span></span> = coroutineContext[Job]</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">coroutineJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(Job.currentJob())</span><br><span class="line">    &#125;</span><br><span class="line">    log(Job.currentJob())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(CoroutineName(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个上下文需要添加，直接用 <code>+</code> 就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main + CoroutineName(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Dispatchers.Main</code> 是调度器的一个实现，不用担心，我们很快就会认识它了。</p>
</blockquote>
<h2 id="2-协程拦截器"><a href="#2-协程拦截器" class="headerlink" title="2. 协程拦截器"></a>2. 协程拦截器</h2><p>费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。</p>
<p>它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 <code>Continuation</code> 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。</p>
<p>我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContinuationInterceptor</span>: <span class="type">ContinuationInterceptor</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = continuation.context</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;&lt;MyContinuation&gt; <span class="variable">$result</span>&quot;</span> )</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只是在回调处打了一行日志。接下来我们把用例拿出来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> job = async &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">&quot;Hello&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> result = job.await()</span><br><span class="line">        log(<span class="string">&quot;5. <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 <code>launch</code> 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 <code>async</code> 启动了一个协程，<code>async</code> 与 <code>launch</code> 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果，可以通过 <code>await</code> 方法获取。</p>
<p>可想而知，<code>result</code> 的值就是 Hello。那么这段程序运行的结果如何呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15:31:55:989 [main] &lt;MyContinuation&gt; Success(kotlin.Unit)  // ①</span><br><span class="line">15:31:55:992 [main] 1</span><br><span class="line">15:31:56:000 [main] &lt;MyContinuation&gt; Success(kotlin.Unit) // ②</span><br><span class="line">15:31:56:000 [main] 2</span><br><span class="line">15:31:56:031 [main] 4</span><br><span class="line">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit) // ③</span><br><span class="line">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello) // ④</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello</span><br><span class="line">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。</p>
</blockquote>
<p>大家可能就要奇怪了，你不是说 <code>Continuation</code> 是回调么，这里面回调调用也就一次啊（<code>await</code> 那里），怎么日志打印了四次呢？</p>
<p>别慌，我们按顺序给大家介绍。</p>
<p>首先，所有协程启动的时候，都会有一次 <code>Continuation.resumeWith</code>  的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。</p>
<p>其次，<code>delay</code> 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。</p>
<p>最后，④ 处的日志就很容易理解了，正是我们的返回结果。</p>
<p>可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 <code>delay</code>，在 JVM 上 <code>delay</code> 实际上是在一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，<code>delay</code> 就不会切线程了，毕竟人家是单线程的。</p>
<p>如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。</p>
<blockquote>
<p>思考：拦截器可以有多个吗？</p>
</blockquote>
<h2 id="3-调度器"><a href="#3-调度器" class="headerlink" title="3. 调度器"></a>3. 调度器</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>有了前面的基础，我们对于调度器的介绍就变得水到渠成了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它本身是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 <code>Dispatchers</code> 当中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> Default: CoroutineDispatcher</span><br><span class="line"><span class="keyword">val</span> Main: MainCoroutineDispatcher</span><br><span class="line"><span class="keyword">val</span> Unconfined: CoroutineDispatcher</span><br></pre></td></tr></table></figure>
<p>这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 <code>val IO: CoroutineDispatcher</code>，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。</p>
<table>
<thead>
<tr>
<th></th>
<th>Jvm</th>
<th>Js</th>
<th>Native</th>
</tr>
</thead>
<tbody><tr>
<td>Default</td>
<td>线程池</td>
<td>主线程循环</td>
<td>主线程循环</td>
</tr>
<tr>
<td>Main</td>
<td>UI 线程</td>
<td>与 Default 相同</td>
<td>与 Default 相同</td>
</tr>
<tr>
<td>Unconfined</td>
<td>直接执行</td>
<td>直接执行</td>
<td>直接执行</td>
</tr>
<tr>
<td>IO</td>
<td>线程池</td>
<td>–</td>
<td>–</td>
</tr>
</tbody></table>
<ul>
<li>IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。</li>
<li>Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。</li>
<li>Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。</li>
</ul>
<h3 id="3-2-编写-UI-相关程序"><a href="#3-2-编写-UI-相关程序" class="headerlink" title="3.2 编写 UI 相关程序"></a>3.2 编写 UI 相关程序</h3><p>Kotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123; </span><br><span class="line">    getUser &#123; user -&gt;</span><br><span class="line">        handler.post &#123;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单得给出 <code>getUser</code> 函数的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>getUser</code> 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 <code>handler.post</code> 切换到 UI 线程。上面的写法就是我们最古老的写法了。</p>
<p>后来又有了 RxJava，那么事情开始变得有趣了起来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserObservable</span><span class="params">()</span></span>: Observable&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class="line">        getUser &#123;</span><br><span class="line">            emitter.onNext(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是点击按钮的事件可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    getUserObservable()</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe &#123; user -&gt;</span><br><span class="line">                userNameView.text = user.name</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！</p>
<p>那么我们现在把这段代码过渡到协程的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按钮点击时，我们可以：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 <code>launch</code> 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。</p>
</blockquote>
<p>这里又有大家没见过的内容啦，<code>suspendCoroutine</code> 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方便后面我们调用它的 <code>resume</code> 或者 <code>resumeWithException</code> 来返回结果或者抛出异常。</p>
<blockquote>
<p>如果你重复调用 <code>resume</code> 或者 <code>resumeWithException</code> 会收获一枚 <code>IllegalStateException</code>，仔细想想这是为什么。</p>
</blockquote>
<p>对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 <code>Dispatchers.Main</code> 来确保 <code>launch</code> 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 <code>Dispatchers.Main</code> 的具体实现。</p>
<p>在 Jvm 上，<code>Main</code> 的实现也比较有意思：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> MainDispatcherLoader &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadMainDispatcher</span><span class="params">()</span></span>: MainCoroutineDispatcher &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> factories = MainDispatcherFactory::<span class="keyword">class</span>.java.let &#123; clz -&gt;</span><br><span class="line">                ServiceLoader.load(clz, clz.classLoader).toList()</span><br><span class="line">            &#125;</span><br><span class="line">            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)</span><br><span class="line">                ?: MissingMainCoroutineDispatcher(<span class="literal">null</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            MissingMainCoroutineDispatcher(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 使得 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例，有兴趣的可以去看下  kotlinx-coroutines-android 的源码实现。</p>
<blockquote>
<p>注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。</p>
</blockquote>
<h3 id="3-3-绑定到任意线程的调度器"><a href="#3-3-绑定到任意线程的调度器" class="headerlink" title="3.3 绑定到任意线程的调度器"></a>3.3 绑定到任意线程的调度器</h3><p>调度器的目的就是切线程，你不要想着我在 <code>dispatch</code> 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="string">&quot;MyThread&quot;</span>) &#125;.asCoroutineDispatcher()</span><br><span class="line">    GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的信息就表明协程运行在我们自己的线程上。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">10</span>:<span class="number">57</span>:<span class="number">130</span> [MyThread] <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">10</span>:<span class="number">57</span>:<span class="number">136</span> [MyThread] <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg"></p>
<p>我们可以通过主动关闭线程池或者调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">myDispatcher.close()</span><br></pre></td></tr></table></figure>
<p>来结束它的生命周期，再次运行程序就会正常退出了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg"></p>
<p>当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。</p>
<p>Kotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？</p>
<p><strong>废弃的两个基于线程池创建调度器的 API</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newSingleThreadContext</span><span class="params">(name: <span class="type">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newFixedThreadPoolContext</span><span class="params">(nThreads: <span class="type">Int</span>, name: <span class="type">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br></pre></td></tr></table></figure>
<p>这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。</p>
<p>其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">        .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class="line">            GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">                log(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> job = async &#123;</span><br><span class="line">                    log(<span class="number">2</span>)</span><br><span class="line">                    delay(<span class="number">1000</span>)</span><br><span class="line">                    log(<span class="number">3</span>)</span><br><span class="line">                    <span class="string">&quot;Hello&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">4</span>)</span><br><span class="line">                <span class="keyword">val</span> result = job.await()</span><br><span class="line">                log(<span class="string">&quot;5. <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">            &#125;.join()</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里面除了 <code>delay</code> 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（<code>Continuation.resume</code>）都会切线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:28:04:771 [pool-1-thread-1] 1</span><br><span class="line">16:28:04:779 [pool-1-thread-1] 4</span><br><span class="line">16:28:04:779 [pool-1-thread-2] 2</span><br><span class="line">16:28:05:790 [pool-1-thread-3] 3</span><br><span class="line">16:28:05:793 [pool-1-thread-4] 5. Hello</span><br><span class="line">16:28:05:794 [pool-1-thread-4] 6</span><br></pre></td></tr></table></figure>

<p>如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:40:14:685 [pool-1-thread-1] 1</span><br><span class="line">16:40:14:706 [pool-1-thread-1] 4</span><br><span class="line">16:40:14:710 [pool-1-thread-1] 2</span><br><span class="line">16:40:15:723 [pool-1-thread-1] 3</span><br><span class="line">16:40:15:725 [pool-1-thread-1] 5. Hello</span><br><span class="line">16:40:15:725 [pool-1-thread-1] 6</span><br></pre></td></tr></table></figure>

<p>对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 <code>delay</code> 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>10</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>耗时ms</td>
<td>1006.00</td>
<td>1004.97</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。</p>
</blockquote>
<p>也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。</p>
<p>实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。</p>
<h3 id="3-4-线程安全问题"><a href="#3-4-线程安全问题" class="headerlink" title="3.4 线程安全问题"></a>3.4 线程安全问题</h3><p>Js 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。</p>
<p>好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。</p>
<p>如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。</p>
<p>以下是一个错误的例子，大家很容易就能想明白：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    Executors.newFixedThreadPool(<span class="number">10</span>)</span><br><span class="line">            .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class="line">                List(<span class="number">1000000</span>) &#123;</span><br><span class="line">                    GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">                        i++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.forEach &#123;</span><br><span class="line">                    it.join()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:59:28:080 [main] 999593</span><br></pre></td></tr></table></figure>

<h2 id="4-suspend-main-函数如何调度？"><a href="#4-suspend-main-函数如何调度？" class="headerlink" title="4. suspend main 函数如何调度？"></a>4. suspend main 函数如何调度？</h2><p>上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？</p>
<p>我们先给出一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它等价于下面的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runSuspend &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">        &#125;.join()</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那你说这个 <code>runSuspend</code> 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">runSuspend</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> run = RunSuspend()</span><br><span class="line">    block.startCoroutine(run)</span><br><span class="line">    run.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里面的 <code>RunSuspend</code> 则是 <code>Continuation</code> 的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RunSuspend</span> : <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result: Result&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        (<span class="keyword">this</span> <span class="keyword">as</span> Object).notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span> = synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> result = <span class="keyword">this</span>.result) &#123;</span><br><span class="line">                <span class="literal">null</span> -&gt; (<span class="keyword">this</span> <span class="keyword">as</span> Object).wait()</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    result.getOrThrow() <span class="comment">// throw up failure</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。</p>
<p>通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。</p>
<blockquote>
<p>上述代码在标准库当中被修饰为 <code>internal</code>，因此我们无法直接使用它们。不过你可以把 <strong>RunSuspend.kt</strong> 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 <code>var result: Result&lt;Unit&gt;? = null</code> 可能会报错，没关系，改成 <code>private var result: Result&lt;Unit&gt;? = null</code> 就可以了。</p>
</blockquote>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（4）：异常处理篇</title>
    <url>//2019/04/23/coroutine-exceptions/</url>
    <content><![CDATA[<blockquote>
<p>异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>我们在前面一篇文章当中提到了这样一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Callback = (User) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    getUser &#123;</span><br><span class="line">        continuation.resume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并最终交给按钮点击事件或者其他事件去触发这个异步请求：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getUserBtn.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。</p>
<h2 id="2-添加异常处理逻辑"><a href="#2-添加异常处理逻辑" class="headerlink" title="2. 添加异常处理逻辑"></a>2. 添加异常处理逻辑</h2><p>首先我们加上异常回调接口函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们在改造一下我们的 <code>getUserCoroutine</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以看到，我们似乎就是完全把 <code>Callback</code> 转换成了一个 <code>Continuation</code>，在调用的时候我们只需要：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userNameView.text = getUserCoroutine().name</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        userNameView.text = <span class="string">&quot;Get User Error: <span class="variable">$e</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 <code>try ... catch ... </code> 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。</p>
<p>如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserObservable</span><span class="params">()</span></span>: Single&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Single.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class="line">        getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">                emitter.onSuccess(value)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                emitter.onError(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时大概是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getUserObservable()</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe (&#123; user -&gt;</span><br><span class="line">            userNameView.text = user.name</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            userNameView.text = <span class="string">&quot;Get User Error: <span class="variable">$it</span>&quot;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。</p>
<blockquote>
<p>也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。</p>
</blockquote>
<h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3. 全局异常处理"></a>3. 全局异常处理</h2><p>线程也好、RxJava 也好，都有全局处理异常的方式，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler &#123;t: Thread, e: Throwable -&gt;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">&quot;Thread &#x27;<span class="subst">$&#123;t.name&#125;</span>&#x27; throws an exception with message &#x27;<span class="subst">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Hey!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class="line">        <span class="comment">//handle exception here</span></span><br><span class="line">        println(<span class="string">&quot;Throws an exception with message &#x27;<span class="subst">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>协程显然也可以做到这一点。类似于通过 <code>Thread.setUncaughtExceptionHandler</code> 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code>，这样协程内部未捕获的异常就可以通过它来捕获：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        log(<span class="string">&quot;Throws an exception with message: <span class="subst">$&#123;throwable.message&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Hey!&quot;</span>)</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19:06:35:087 [main] 1</span><br><span class="line">19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!</span><br><span class="line">19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></pre></td></tr></table></figure>

<p><code>CoroutineExceptionHandler</code> 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。</p>
<p>当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalCoroutineExceptionHandler</span>: <span class="type">CoroutineExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine exception: <span class="variable">$exception</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 <code>CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全类名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure>

<p>这样协程中没有被捕获的异常就会最终交给它处理。</p>
<blockquote>
<p>Jvm 上全局 <code>CoroutineExceptionHandler</code> 的配置，本质上是对 <code>ServiceLoader</code> 的应用，之前我们在讲 <code>Dispatchers.Main</code> 的时候提到过，Jvm 上它的实现也是通过 <code>ServiceLoader</code> 来加载的。</p>
</blockquote>
<p>需要明确的一点是，通过 <code>async</code> 启动的协程出现未捕获的异常时会忽略 <code>CoroutineExceptionHandler</code>，这与 <code>launch</code> 的设计思路是不同的。</p>
<h2 id="4-异常传播"><a href="#4-异常传播" class="headerlink" title="4. 异常传播"></a>4. 异常传播</h2><p>异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 <code>GlobalScope</code>，意味着这是一个独立的顶级协程作用域，此外还有 <code>coroutineScope &#123; ... &#125;</code> 以及 <code>supervisorScope &#123; ... &#125;</code>。</p>
<ul>
<li>通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。</li>
<li>coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。</li>
<li>supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。</li>
</ul>
<p>这么说还是比较抽象，因此我们拿一些例子来分析一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">//①</span></span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            launch &#123; <span class="comment">// ②</span></span><br><span class="line">                log(<span class="number">3</span>)</span><br><span class="line">                launch &#123; <span class="comment">// ③ </span></span><br><span class="line">                    log(<span class="number">4</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Hey!!&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="number">6</span>)</span><br><span class="line">            <span class="keyword">val</span> job = launch &#123; <span class="comment">// ④</span></span><br><span class="line">                log(<span class="number">7</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="number">8</span>)</span><br><span class="line">                 job.join()</span><br><span class="line">                log(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(<span class="string">&quot;10. <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="number">11</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">&quot;12. <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这例子稍微有点儿复杂，但也不难理解，我们在一个 <code>coroutineScope</code> 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:37:36:208 [main] 1</span><br><span class="line">11:37:36:255 [main] 2</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 3</span><br><span class="line">11:37:36:325 [DefaultDispatcher-worker-1] 5</span><br><span class="line">11:37:36:326 [DefaultDispatcher-worker-3] 4</span><br><span class="line">11:37:36:331 [main] 6</span><br><span class="line">11:37:36:336 [DefaultDispatcher-worker-1] 7</span><br><span class="line">11:37:36:336 [main] 8</span><br><span class="line">11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine&#123;Cancelling&#125;@2bc92d2f</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!</span><br><span class="line">11:37:36:445 [DefaultDispatcher-worker-1] 13</span><br></pre></td></tr></table></figure>

<p>注意两个位置，一个是 10，我们调用 <code>join</code>，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 <code>CancellationException</code>，这类似于线程中对 <code>InterruptException</code> 的响应，遇到这种情况表示 <code>join</code> 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？</p>
<p>原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 <code>job.join</code> 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，<code>coroutineScope</code> 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 <code>delay</code>进行捕获，一样会收获一枚取消异常。</p>
<p>还有一个位置就是 12，这个是我们对 <code>coroutineScope</code> 整体的一个捕获，如果 <code>coroutineScope</code> 内部以为异常而结束，那么我们是可以对它直接 <code>try ... catch ...</code> 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。 </p>
<p>那么如果我们把 <code>coroutineScope</code> 换成 <code>supervisorScope</code>，其他不变，运行结果会是怎样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:52:48:632 [main] 1</span><br><span class="line">11:52:48:694 [main] 2</span><br><span class="line">11:52:48:875 [main] 6</span><br><span class="line">11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class="line">11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br><span class="line">11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4</span><br><span class="line">11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7</span><br><span class="line">11:52:48:907 [main] 8</span><br><span class="line">Exception in thread &quot;DefaultDispatcher-worker-3 @coroutine#3&quot; java.lang.ArithmeticException: Hey!!</span><br><span class="line">	at com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)</span><br><span class="line">	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11</span><br><span class="line">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13</span><br></pre></td></tr></table></figure>

<p>我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 <code>supervisorScope</code>，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。</p>
<p>这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 <code>CoroutineExceptionHandler</code>，就可以证明我们前面提到的另外一个结论：</p>
<p>首先我们定义一个 <code>CoroutineExceptionHandler</code>，我们通过上下文获取一下异常对应的协程的名字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    log(<span class="string">&quot;<span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，基于前面的例子我们为 ② 和 ③ 添加 <code>CoroutineExceptionHandler</code> 和名字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">supervisorScope &#123; <span class="comment">//①</span></span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    launch(exceptionHandler + CoroutineName(<span class="string">&quot;②&quot;</span>)) &#123; <span class="comment">// ②</span></span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        launch(exceptionHandler + CoroutineName(<span class="string">&quot;③&quot;</span>)) &#123; <span class="comment">// ③</span></span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再运行这段程序，结果就比较有意思了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们发现触发的 <code>CoroutineExceptionHandler</code> 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 <code>supervisorScope</code> 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 <code>coroutineScope</code> 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。</p>
<p>究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：</p>
<ul>
<li>对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope</li>
<li>对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动</li>
<li>对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope </li>
<li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。</li>
</ul>
<p>当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。</p>
<h3 id="5-join-和-await"><a href="#5-join-和-await" class="headerlink" title="5. join 和 await"></a>5. join 和 await</h3><p>前面我们举例子一直用的是 <code>launch</code>，启动协程其实常用的还有 <code>async</code>、<code>actor</code> 和 <code>produce</code>，其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 <code>async</code> 和 <code>produce</code>  则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。</p>
<blockquote>
<p><code>actor</code> 和 <code>produce</code> 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。</p>
</blockquote>
<p>那么消费结果指的是什么呢？对于 <code>async</code> 来讲，就是 <code>await</code>，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> value = deferred.await()</span><br><span class="line">        log(<span class="string">&quot;1. <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">&quot;2. <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个从逻辑上很好理解，我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13:25:14:693 [main] 2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>

<p>我们自己实现的 <code>getUserCoroutine</code> 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，<code>join</code> 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 <code>join</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.join()</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        log(<span class="string">&quot;2. <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就会发现，异常被吞掉了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13:26:15:034 [main] 1</span><br></pre></td></tr></table></figure>

<p>如果例子当中我们用 <code>launch</code> 替换 <code>async</code>，<code>join</code> 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， <code>launch</code> 中未捕获的异常与 <code>async</code> 的处理方式不同，<code>launch</code> 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 <code>supervisorScope</code> 中父协程不响应，那么就交给上下文中指定的 <code>CoroutineExceptionHandler</code>处理，如果没有指定，那传给全局的 <code>CoroutineExceptionHandler</code> 等等，而 <code>async</code> 则要等 <code>await</code> 来消费。</p>
<blockquote>
<p>不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 <code>async</code> 来说就算不调用 <code>await</code> 来获取这个异常，它也会在 <code>coroutineScope</code> 当中触发父协程的取消逻辑，这一点请大家注意。</p>
</blockquote>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：</p>
<ol>
<li><strong>协程内部异常处理流程</strong>：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。</li>
<li><strong>异常在作用域内的传播</strong>：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。</li>
<li> <strong>join 和 await 的不同</strong>：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。</li>
</ol>
<p>如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。</p>
<h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>join 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/1123">No CancellationException thrown when join on a crashed Job</a>。</p>
<p>当然，这个 bug 对于生成环境的影响很小，大家也不要担心。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（5）：协程取消篇</title>
    <url>//2019/04/30/coroutine-cancellation/</url>
    <content><![CDATA[<blockquote>
<p>协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-线程的中断"><a href="#1-线程的中断" class="headerlink" title="1. 线程的中断"></a>1. 线程的中断</h2><p>我们先从大家熟悉的话题讲起。线程有一个被废弃的 <code>stop</code> 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 <code>stop</code> 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，<code>stop</code> 还不让用，那该怎么办？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = thread &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">thread.stop() <span class="comment">// !!! Deprecated!!!</span></span><br></pre></td></tr></table></figure>

<p>我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = thread &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">        log(<span class="string">&quot;Interrupted, do cleaning stuff.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.interrupt()</span><br></pre></td></tr></table></figure>

<p>像 <code>sleep</code> 这样的方法调用，文档明确指出它支持 <code>InterruptedException</code>，因此当线程被标记为中断状态时，它就会抛出 <code>InterruptedException</code> ，那么我们自然就可以捕获异常并做资源清理了。</p>
<p>所以请注意所谓的协作式的任务终止，协程的取消也就是 <code>cancel</code> 机制的思路也是如此。</p>
<h2 id="2-协程类似的例子"><a href="#2-协程类似的例子" class="headerlink" title="2. 协程类似的例子"></a>2. 协程类似的例子</h2><p>我们来看一个协程取消的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = launch &#123; <span class="comment">// ①</span></span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// ②</span></span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    job1.cancel() <span class="comment">// ③</span></span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 <code>runBlocking</code> 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。<code>runBlocking</code> 会启动一个 <code>Job</code>，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。</p>
<p>这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 <code>delay</code>， <code>delay</code> 与线程的 <code>sleep</code> 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 <code>delay</code> 还没有回调的时候协程就被取消了，因为 <code>delay</code> 可以响应取消，因此 <code>delay</code> 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 <code>delay</code> 会抛一个 <code>CancellationException</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    log(<span class="string">&quot;cancelled. <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">2</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>那么输出的结果就不一样了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">06:54:56:361 [main] 1</span><br><span class="line">06:54:56:408 [main] 3</span><br><span class="line">06:54:56:411 [main] 4</span><br><span class="line">06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@e73f9ac</span><br><span class="line">06:54:56:413 [main] 2</span><br></pre></td></tr></table></figure>

<p>大家看，这与线程的中断逻辑是不是非常的类似呢？</p>
<h2 id="3-完善我们之前的例子"><a href="#3-完善我们之前的例子" class="headerlink" title="3. 完善我们之前的例子"></a>3. 完善我们之前的例子</h2><p>之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    getUser(<span class="keyword">object</span> : Callback&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(value: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加取消逻辑，那需要我们的 <code>getUser</code> 回调版本支持取消，我们看下我们的 <code>getUser</code> 是怎么实现的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> call = OkHttpClient().newCall(</span><br><span class="line">            Request.Builder()</span><br><span class="line">                    .<span class="keyword">get</span>().url(<span class="string">&quot;https://api.github.com/users/bennyhuo&quot;</span>)</span><br><span class="line">                    .build())</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            callback.onError(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            response.body()?.let &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    callback.onSuccess(User.from(it.string()))</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    callback.onError(e) <span class="comment">// 这里可能是解析异常</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;?: callback.onError(NullPointerException(<span class="string">&quot;ResponseBody is null.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发了个网络请求给 Github，让它把一个叫 <code>bennyhuo</code> 的用户信息返回来，我们知道 OkHttp 的这个 <code>Call</code> 是支持 <code>cancel</code> 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 <code>getUser</code> 好了，这样还能省掉我们自己的 <code>Callback</code> 回调过程：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    <span class="keyword">val</span> call = OkHttpClient().newCall(...)</span><br><span class="line"></span><br><span class="line">    continuation.invokeOnCancellation &#123; <span class="comment">// ①</span></span><br><span class="line">        log(<span class="string">&quot;invokeOnCancellation: cancel the request.&quot;</span>)</span><br><span class="line">        call.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : okhttp3.Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">&quot;onFailure: <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            log(<span class="string">&quot;onResponse: <span class="subst">$&#123;response.code()&#125;</span>&quot;</span>)</span><br><span class="line">            response.body()?.let &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    continuation.resume(User.from(it.string()))</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    continuation.resumeWithException(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; ?: continuation.resumeWithException(NullPointerException(<span class="string">&quot;ResponseBody is null.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里用到了 <code>suspendCancellableCoroutine</code>，而不是之前的 <code>suspendCoroutine</code>，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 <code>Continuation</code> 包装成了一个 <code>CancellableContinuation</code>，通过调用它的 <code>invokeOnCancellation</code> 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 <code>getUserCoroutine</code> 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。</p>
<p>那么我们在调用它的时候，如果遇到了取消，会怎么样呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job1 = launch &#123; <span class="comment">//①</span></span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> user = getUserCoroutine()</span><br><span class="line">    log(user)</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">job1.cancel()</span><br><span class="line">log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 <code>getUserCoroutine</code> 被挂起了，因此结果大概率是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">30</span>:<span class="number">751</span> [main] <span class="number">1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">120</span> [main] <span class="number">3</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">124</span> [main] invokeOnCancellation: cancel the request.</span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">129</span> [main] <span class="number">4</span></span><br><span class="line"><span class="number">07</span>:<span class="number">31</span>:<span class="number">31</span>:<span class="number">131</span> [OkHttp https:<span class="comment">//api.github.com/...] onFailure: java.io.IOException: Canceled</span></span><br></pre></td></tr></table></figure>

<p>我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 <code>Continuation.resume</code> 、 <code>Continuation.resumeWithException</code> 或者 <code>Continuation.resumeWith</code> 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 <code>continuation.resumeWithException(e)</code> 不会有任何副作用。</p>
<h2 id="4-再谈-Retrofit-的协程扩展"><a href="#4-再谈-Retrofit-的协程扩展" class="headerlink" title="4. 再谈 Retrofit 的协程扩展"></a>4. 再谈 Retrofit 的协程扩展</h2><h3 id="4-1-Jake-Wharton-的-Adapter-存在的问题"><a href="#4-1-Jake-Wharton-的-Adapter-存在的问题" class="headerlink" title="4.1 Jake Wharton 的 Adapter 存在的问题"></a>4.1 Jake Wharton 的 Adapter 存在的问题</h3><p>我在<a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程 - 入门篇</a> 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GitHubServiceApi</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;login&quot;</span>)</span> login: <span class="type">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory()) <span class="comment">// 这里添加 Adapter</span></span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用的时候就这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">&quot;bennyhuo&quot;</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    showUser(deferred.await())</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    showError(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要取消，我们可以直接调用 <code>deferred.cancel()</code>，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">&quot;bennyhuo&quot;</span>)</span><br><span class="line">log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">withContext(Dispatchers.IO)&#123;</span><br><span class="line">    deferred.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    showUser(deferred.await())</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    showError(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:59:54:185 [DefaultDispatcher-worker-1] 1</span><br><span class="line">12:59:54:587 [DefaultDispatcher-worker-1] 2</span><br><span class="line">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=CompletableDeferredImpl&#123;Cancelled&#125;@36699211</span><br></pre></td></tr></table></figure>

<p>这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">adapt</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> deferred = CompletableDeferred&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">      deferred.invokeOnCompletion &#123; <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">if</span> (deferred.isCancelled) &#123;</span><br><span class="line">          call.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call.enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意 ① 处，<code>invokeOnCompletion</code> 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 <code>Call</code> 的取消即可。</p>
<p>这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class="string">&quot;bennyhuo&quot;</span>)</span><br><span class="line">    log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    deferred.invokeOnCompletion &#123;</span><br><span class="line">        log(<span class="string">&quot;invokeOnCompletion, <span class="variable">$it</span>, <span class="subst">$&#123;deferred.isCancelled&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(deferred.await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>

<p>我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 <code>getUserCoroutine</code> 返回的 <code>Deferred</code> 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">332</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">1</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">829</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@19aea38c</span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">54</span>:<span class="number">846</span> [DefaultDispatcher-worker-<span class="number">1</span>] <span class="number">3</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">56</span>:<span class="number">937</span> [OkHttp https:<span class="comment">//api.github.com/...] invokeOnCompletion, null, false</span></span><br></pre></td></tr></table></figure>

<p>我们看到在调用 <code>deferred.await()</code> 的时候抛了个取消异常，这主要是因为 <code>await()</code> 所在的协程已经被我们用 <code>cancelAndJoin()</code> 取消，但从随后  <code>invokeOnCompletion</code> 的回调结果来看， <code>getUserCoroutine</code> 返回的 <code>Deferred</code>  并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。</p>
<p>所以问题究竟在哪里？在 <code>CoroutineCallAdapterFactory</code> 的实现中，为了实现异步转换，手动创建了一个 <code>CompletableDeferred</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">adapt</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> deferred = CompletableDeferred&lt;T&gt;() <span class="comment">// ①</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>CompletableDeferred</code> 本身就是一个 <code>Job</code> 的实现，它的构造可接受一个 <code>Job</code> 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 <code>GlobalScope.launch</code> 启动了一个协程一样。如果大家在 Android 当中使用 <code>MainScope</code>，那么同样因为前面说到的这个原因，导致 <code>CompletableDeferred</code> 没有办法被取消。</p>
<blockquote>
<p>@阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。</p>
</blockquote>
<p>说到这里我们再简单回顾下，作用域主要有 <code>GlobalScope</code>、<code>coroutineScope</code>、<code>supervisorScope</code>，对于取消，除了 <code>supervisorScope</code> 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 <code>MainScope</code> 就是一个调度到 UI 线程的 <code>supervisorScope</code>；<code>coroutineScope</code> 的逻辑则是父子相互取消的逻辑；而 <code>GlobalScope</code> 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。</p>
<p>那么有没有办法解决这个问题呢？</p>
<p>直接解决还是比较困难的，因为 <code>CompletableDeferred</code> 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。</p>
<h3 id="4-2-如何正确的将回调转换为协程"><a href="#4-2-如何正确的将回调转换为协程" class="headerlink" title="4.2 如何正确的将回调转换为协程"></a>4.2 如何正确的将回调转换为协程</h3><p>前面我们提到既然 <code>adapt</code> 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？</p>
<p>其实我们前面在讲 <code>getUserCoroutine</code> 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserCoroutine</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>suspendCancellableCoroutine</code> 跟最初我们提到的 <code>suspendCoroutine</code> 一样，都是要获取当前协程的 <code>Continuation</code> 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">        enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;?, response: <span class="type">Response</span>&lt;<span class="type">T</span>?&gt;)</span></span> &#123;</span><br><span class="line">                continuation.resumeWith(runCatching &#123; <span class="comment">// ①</span></span><br><span class="line">                    <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">                        response.body()</span><br><span class="line">                            ?: <span class="keyword">throw</span> NullPointerException(<span class="string">&quot;Response body is null: <span class="variable">$response</span>&quot;</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> HttpException(response)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (continuation.isCancelled) <span class="keyword">return</span> <span class="comment">// ②</span></span><br><span class="line">                continuation.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        continuation.invokeOnCancellation &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cancel()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;  <span class="comment">// ③</span></span><br><span class="line">                <span class="comment">//Ignore cancel exception </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家看着这段代码会不会很眼熟？这与我们 <code>getUserCoroutine</code> 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：</p>
<ul>
<li>① 处 <code>runCatching</code> 可以将一段代码的运行结果或者抛出的异常封装到一个 <code>Result</code> 类型当中，Kotlin 1.3 开始新增了 <code>Continuation.resumeWith(Result)</code> 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。</li>
<li>② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 <code>Continuation</code> 的取消发起的，因此这时候没必要再调用 <code>continuation.resumeWithException(t)</code> 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用  <code>continuation.resumeWithException(t)</code>  也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。</li>
<li>③ 处，尽管 <code>Call.cancel</code> 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 <code>cancel</code> 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。</li>
</ul>
<p>需要指出的是，这段代码片段源自 <a href="https://github.com/gildor/kotlin-coroutines-retrofit">gildor/kotlin-coroutines-retrofit</a> ，大家也可以直接添加依赖进行使用：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">&#x27;ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。</p>
<p>再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。</p>
<p>当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（6）：协程挂起篇</title>
    <url>//2019/05/07/coroutine-suspend/</url>
    <content><![CDATA[<blockquote>
<p>协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！） </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-先看看-delay"><a href="#1-先看看-delay" class="headerlink" title="1. 先看看 delay"></a>1. 先看看 delay</h2><p>我们刚刚学线程的时候，最常见的模拟各种延时用的就是 <code>Thread.sleep</code> 了，而在协程里面，对应的就是 <code>delay</code>。<code>sleep</code> 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 <code>delay</code> 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 <code>delay</code> 也可以是让协程休眠的一种很好的手段。</p>
<p><code>delay</code> 的源码其实很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// don&#x27;t delay</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作，你可以类比 JavaScript 的 <code>setTimeout</code>，Android 的 <code>handler.postDelay</code>，本质上就是设置了一个延时回调，时间一到就调用 <code>cont</code> 的 resume 系列方法让协程继续执行。</p>
<p>剩下的最关键的就是 <code>suspendCancellableCoroutine</code> 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 <code>delay</code> 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 <code>join</code>、<code>await</code> 等等。</p>
<h2 id="2-再来说说-suspendCancellableCoroutine"><a href="#2-再来说说-suspendCancellableCoroutine" class="headerlink" title="2. 再来说说 suspendCancellableCoroutine"></a>2. 再来说说 suspendCancellableCoroutine</h2><p>既然大家对于 <code>suspendCancellableCoroutine</code> 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">joinSuspend</span><span class="params">()</span></span> = suspendCancellableCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class="keyword">this</span>, cont).asHandler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Job.join()</code> 这个方法会首先检查调用者 <code>Job</code> 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 <code>joinSuspend</code> 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 <code>suspendCancellableCoroutine</code> 内部究竟做了什么呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCancellableCoroutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> block: (<span class="type">CancellableContinuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T =</span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        block(cancellable)</span><br><span class="line">        cancellable.getResult() <span class="comment">// 这里的类型是 Any?</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 <code>Continuation</code> 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 <code>T</code>，而传入的 lambda 的返回值类型是 <code>Any?</code>， 也就是我们看到的 <code>cancellable.getResult()</code> 的类型是 <code>Any?</code>，这是为什么？</p>
<p>我记得在协程系列文章的开篇，我就提到过 <code>suspend</code> 函数的签名，当时是以 <code>await</code> 为例的，这个方法大致相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">User</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>suspend</code> 一方面为这个方法添加了一个 <code>Continuation</code> 的参数，另一方面，原先的返回值类型 <code>User</code> 成了 <code>Continuation</code> 的泛型实参，而真正的返回值类型竟然是 <code>Any</code>。当然，这里因为定义的逻辑返回值类型 <code>User</code> 是不可空的，因此真实的返回值类型也用了 <code>Any</code> 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 <code>Any?</code> 了，这正与前面提到的 <code>cancellable.getResult()</code> 返回的这个 <code>Any?</code> 相对应。</p>
<blockquote>
<p>如果大家去查 <code>await</code> 的源码，你同样会看到这个 <code>getResult()</code> 的调用。</p>
</blockquote>
<p>简单来说就是，对于 <code>suspend</code> 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 <code>join</code> 或者 <code>await</code> 或者其他 <code>suspend</code> 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 <code>cancellable.getResult()</code> 究竟返回什么了，且看：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (trySuspend()) <span class="keyword">return</span> COROUTINE_SUSPENDED <span class="comment">// ① 触发挂起逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (state <span class="keyword">is</span> CompletedExceptionally)  <span class="comment">// ② 异常立即抛出</span></span><br><span class="line">        <span class="keyword">throw</span> recoverStackTrace(state.cause, <span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> getSuccessfulResult(state) <span class="comment">// ③ 正常结果立即返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">CoroutineSingletons</span> &#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure>
<p>这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 <code>Any</code>。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。</p>
<h2 id="3-深入挂起操作"><a href="#3-深入挂起操作" class="headerlink" title="3. 深入挂起操作"></a>3. 深入挂起操作</h2><p>既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="number">2</span>)</span><br><span class="line">        continuation.resume(<span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我写了这么一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回了这个传说中的白板 <code>COROUTINE_SUSPENDED</code>，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallCoroutine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> SuspendTestKt.hello(<span class="keyword">new</span> <span class="title class_">Continuation</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@NotNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> &#123; <span class="comment">// ①</span></span><br><span class="line">                <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">                    handleResult(o);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> (Throwable) o;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(value == IntrinsicsKt.getCOROUTINE_SUSPENDED())&#123; <span class="comment">// ②</span></span><br><span class="line">            LogKt.log(<span class="string">&quot;Suspended.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleResult(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        LogKt.log(<span class="string">&quot;The result is &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看上去比较奇怪，可能会让人困惑的有两处：</p>
<p>① 处，我们在 Kotlin 当中看到的 <code>resumeWith</code> 的参数类型是 <code>Result</code>，怎么这儿成了 <code>Object</code> 了？因为 <code>Result</code> 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 <code>Object</code> （在Kotlin 里面是 <code>Any?</code>）</p>
<p>② 处  <code>IntrinsicsKt.getCOROUTINE_SUSPENDED()</code> 就是 Kotlin 的 <code>COROUTINE_SUSPENDED</code></p>
<p>剩下的其实并不难理解，运行结果自然就是如下所示了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">07:52:55:288 [main] 1</span><br><span class="line">07:52:55:293 [main] 3</span><br><span class="line">07:52:55:296 [main] Suspended.</span><br><span class="line">07:52:56:298 [Thread-0] 2</span><br><span class="line">07:52:56:306 [Thread-0] The result is 1024</span><br></pre></td></tr></table></figure>

<p>其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只不过我们在 Kotlin 当中还是不太容易拿到 <code>hello</code> 在挂起时的真正返回值，其他的返回结果完全相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:44:08:290 [main] 1</span><br><span class="line">12:44:08:292 [main] 3</span><br><span class="line">12:44:09:296 [Thread-0] 2</span><br><span class="line">12:44:09:296 [Thread-0] 1024</span><br></pre></td></tr></table></figure>

<p>很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。</p>
<h2 id="4-深入理解协程的状态转移"><a href="#4-深入理解协程的状态转移" class="headerlink" title="4. 深入理解协程的状态转移"></a>4. 深入理解协程的状态转移</h2><p>前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnSuspended</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        continuation.resume(<span class="string">&quot;Return suspended.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnImmediately</span><span class="params">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    <span class="string">&quot;Return immediately.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 <code>join</code> 或者 <code>await</code> 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    log(returnSuspended())</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    log(<span class="number">3</span>)</span><br><span class="line">    log(returnImmediately())</span><br><span class="line">    log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:09:37:090 [main] 1</span><br><span class="line">08:09:38:096 [Thread-0] Return suspended.</span><br><span class="line">08:09:38:096 [Thread-0] 2</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>

<p>好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：</p>
<blockquote>
<p>注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span> <span class="keyword">implements</span> <span class="title class_">Continuation</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContinuationImpl</span><span class="params">(Continuation&lt;Unit&gt; completion)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.completion = completion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> o;</span><br><span class="line">            <span class="keyword">switch</span> (label) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">1</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnSuspended( <span class="built_in">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">2</span>);</span><br><span class="line">                    result = DelayKt.delay(<span class="number">1000</span>, <span class="built_in">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    LogKt.log(<span class="number">3</span>);</span><br><span class="line">                    result = SuspendFunctionsKt.returnImmediately( <span class="built_in">this</span>);</span><br><span class="line">                    label++;</span><br><span class="line">                    <span class="keyword">if</span> (isSuspended(result)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                    LogKt.log(result);</span><br><span class="line">                    LogKt.log(<span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completion.resumeWith(Unit.INSTANCE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            completion.resumeWith(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSuspended</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个 Java 类 <code>ContinuationImpl</code>，它就是一个 <code>Continuation</code> 的实现。</p>
<blockquote>
<p>实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 <code>ContinuationImpl</code> 的类，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code>，而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 <code>launch</code>启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code> 的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p>
</blockquote>
<p>有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 <code>RunSuspend</code> 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunSuspend</span> <span class="keyword">implements</span> <span class="title class_">Continuation</span>&lt;Unit&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.result = result;</span><br><span class="line">            notifyAll(); <span class="comment">// 协程已经结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.result;</span><br><span class="line">                <span class="keyword">if</span>(result == <span class="literal">null</span>) wait(); <span class="comment">// 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Throwable)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Throwable) result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的关键点在于 <code>await()</code> 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 <code>result</code> 是 <code>null</code>，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">RunSuspend</span> <span class="variable">runSuspend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunSuspend</span>();</span><br><span class="line">        <span class="type">ContinuationImpl</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationImpl</span>(runSuspend);</span><br><span class="line">        table.resumeWith(Unit.INSTANCE);</span><br><span class="line">        runSuspend.await();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这写法简直就是 suspend main 的真实面貌了。</p>
</blockquote>
<p>我们看到，作为 completion 传入的 <code>RunSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWtih</code> 的最后才会被调用，因此它的 <code>await()</code> 一旦进入阻塞态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。</p>
<p>于是这段代码的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:36:51:305 [main] 1</span><br><span class="line">08:36:52:315 [Thread-0] Return suspended.</span><br><span class="line">08:36:52:315 [Thread-0] 2</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class="line">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>

<p>我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：</p>
<ul>
<li>协程的挂起函数本质上就是一个回调，回调类型就是 <code>Continuation</code></li>
<li>协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 <code>label</code> 不断的自增来实现状态流转一样</li>
</ul>
<p>如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 <code>resumeWith</code> 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。</p>
<p>当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 <code>Sequence</code> 就是基于协程实现的，它的用法很简单，几乎与普通的 <code>Iterable</code> 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（7）：序列生成器篇</title>
    <url>//2019/05/26/coroutine-sequence/</url>
    <content><![CDATA[<blockquote>
<p>说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-认识-Sequence"><a href="#1-认识-Sequence" class="headerlink" title="1. 认识 Sequence"></a>1. 认识 Sequence</h2><p>在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。</p>
<p>下面我们给出一个斐波那契数列生成的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">val</span> fibonacci = sequence &#123;</span><br><span class="line">    yield(<span class="number">1L</span>) <span class="comment">// first Fibonacci number</span></span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1L</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        yield(next) <span class="comment">// next Fibonacci number</span></span><br><span class="line">        <span class="keyword">val</span> tmp = cur + next</span><br><span class="line">        cur = next</span><br><span class="line">        next = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fibonacci.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>

<p>这个 <code>sequence</code> 实际上也是启动了一个协程，<code>yield</code> 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 <code>COROUTINE_SUSPENDED</code>，这样协程就不再继续执行，而是等待下一次 <code>resume</code> 或者 <code>resumeWithException</code> 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 <code>next()</code> 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 <code>yield</code> 调用。</p>
<p>程序运行输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 1</span><br><span class="line">10:44:34:071 [main] 2</span><br><span class="line">10:44:34:071 [main] 3</span><br><span class="line">10:44:34:071 [main] 5</span><br></pre></td></tr></table></figure>

<p>除了使用 <code>yield(T)</code> 生成序列的下一个元素以外，我们还可以用 <code>yieldAll()</code> 来生成多个元素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> seq = sequence &#123;</span><br><span class="line">    log(<span class="string">&quot;yield 1,2,3&quot;</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    log(<span class="string">&quot;yield 4,5,6&quot;</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    log(<span class="string">&quot;yield 7,8,9&quot;</span>)</span><br><span class="line">    yieldAll(listOf(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seq.take(<span class="number">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>

<p>从运行结果我们可以看到，在读取 4 的时候才会去执行到 <code>yieldAll(listOf(4, 5, 6))</code>，而由于 7 以后都没有被访问到，<code>yieldAll(listOf(7, 8, 9))</code> 并不会被执行，这就是所谓的“懒”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:44:34:029 [main] yield 1,2,3</span><br><span class="line">10:44:34:060 [main] 1</span><br><span class="line">10:44:34:060 [main] 2</span><br><span class="line">10:44:34:060 [main] 3</span><br><span class="line">10:44:34:061 [main] yield 4,5,6</span><br><span class="line">10:44:34:061 [main] 4</span><br><span class="line">10:44:34:066 [main] 5</span><br></pre></td></tr></table></figure>

<h2 id="2-深入序列生成器"><a href="#2-深入序列生成器" class="headerlink" title="2. 深入序列生成器"></a>2. 深入序列生成器</h2><p>前面我们已经不止一次提到 <code>COROUTINE_SUSPENDED</code> 了，我们也很容易就知道 <code>yield</code> 和 <code>yieldAll</code> 都是 suspend 函数，既然能做到”懒“，那么必然在 <code>yield</code> 和 <code>yieldAll</code> 处是挂起的，因此它们的返回值一定是  <code>COROUTINE_SUSPENDED</code>，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    nextValue = value</span><br><span class="line">    state = State_Ready</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>yield</code> 的实现，我们看到了老朋友 <code>suspendCoroutineUninterceptedOrReturn</code>，还看到了 <code>COROUTINE_SUSPENDED</code>，那么挂起的问题就很好理解了。而 <code>yieldAll</code> 是如出一辙：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yieldAll</span><span class="params">(iterator: <span class="type">Iterator</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext()) <span class="keyword">return</span></span><br><span class="line">    nextIterator = iterator</span><br><span class="line">    state = State_ManyReady</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class="line">        nextStep = c</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的不同在于 <code>state</code> 的值，一个流转到了 <code>State_Ready</code>，一个是 <code>State_ManyReady</code>，也倒是很好理解嘛。</p>
<p>那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 <code>resume</code> ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 <code>next()</code> 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 <code>yield</code> 就是它的方法，我们来看看 <code>next</code> 方法的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        State_NotReady, State_ManyNotReady -&gt; <span class="keyword">return</span> nextNotReady() <span class="comment">// ①</span></span><br><span class="line">        State_ManyReady -&gt; &#123; <span class="comment">// ②</span></span><br><span class="line">            state = State_ManyNotReady</span><br><span class="line">            <span class="keyword">return</span> nextIterator!!.next()</span><br><span class="line">        &#125;</span><br><span class="line">        State_Ready -&gt; &#123; <span class="comment">// ③</span></span><br><span class="line">            state = State_NotReady</span><br><span class="line">            <span class="keyword">val</span> result = nextValue <span class="keyword">as</span> T</span><br><span class="line">            nextValue = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来依次看下这三个条件：</p>
<ul>
<li>① 是下一个元素还没有准备好的情况，调用 <code>nextNotReady</code> 会首先调用 <code>hasNext</code> 检查是否有下一个元素，检查的过程其实就是调用 <code>Continuation.resume</code>，如果有元素，就会再次调用 <code>next</code>，否则就抛异常</li>
<li>② 表示我们调用了 <code>yieldAll</code>，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代</li>
<li>③ 表示我们调用了一次 <code>yield</code>，而这个元素的值就存在 <code>nextValue</code> 当中</li>
</ul>
<p><code>hasNext</code> 的实现也不是很复杂：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            State_NotReady -&gt; &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">            State_ManyNotReady -&gt; <span class="comment">// ②</span></span><br><span class="line">                <span class="keyword">if</span> (nextIterator!!.hasNext()) &#123;</span><br><span class="line">                    state = State_ManyReady</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextIterator = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            State_Done -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// ③</span></span><br><span class="line">            State_Ready, State_ManyReady -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> exceptionalState()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state = State_Failed</span><br><span class="line">        <span class="keyword">val</span> step = nextStep!!</span><br><span class="line">        nextStep = <span class="literal">null</span></span><br><span class="line">        step.resume(<span class="built_in">Unit</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在通过 <code>next</code> 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 <code>State_NotReady</code>，下一次取元素的时候就会在 <code>next</code> 中触发到 <code>hasNext</code> 的调用，① 处什么都没有干，因此会直接落到后面的 <code>step.resume()</code>，这样就会继续执行我们序列生成器的代码，直到遇到 <code>yield</code> 或者 <code>yieldAll</code>。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。</p>
<p>协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（8）：Android 篇</title>
    <url>//2019/05/27/coroutine-android/</url>
    <content><![CDATA[<blockquote>
<p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p>本文涉及的 MainScope 以及 AutoDispose 源码：<a href="https://github.com/enbandari/kotlin-coroutines-android">kotlin-coroutines-android</a></p>
<h2 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h2><p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version&#x27;</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class="line"></span><br><span class="line">~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）</span><br><span class="line"></span><br><span class="line">```gradle</span><br><span class="line"><span class="comment">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.anko:anko-sdk27-coroutines:$anko_version&quot;</span></span><br><span class="line"><span class="comment">//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.anko:anko-coroutines:$anko_version&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单来说：</p>
<ul>
<li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li>
<li><del>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</del></li>
<li><del>anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</del></li>
</ul>
<p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p>
<h2 id="2-UI-生命周期作用域"><a href="#2-UI-生命周期作用域" class="headerlink" title="2. UI 生命周期作用域"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p>
<h3 id="2-1-使用-MainScope"><a href="#2-1-使用-MainScope" class="headerlink" title="2.1 使用 MainScope"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        log(<span class="number">1</span>)</span><br><span class="line">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="number">2</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">3</span>)</span><br><span class="line">            <span class="string">&quot;Hello1111&quot;</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        log(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>

<p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class="line">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class="line">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class="line">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure>

<p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">launchButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelButton.setOnClickListener &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">    log(<span class="string">&quot;MainScope is cancelled.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class="line">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class="line">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure>

<h3 id="2-2-构造带有作用域的抽象-Activity"><a href="#2-2-构造带有作用域的抽象-Activity" class="headerlink" title="2.2 构造带有作用域的抽象 Activity"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p>
<p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ScopedActivity</span>: <span class="type">Activity</span>(), CoroutineScope <span class="keyword">by</span> MainScope()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineActivity</span> : <span class="type">ScopedActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_coroutine)</span><br><span class="line">        launchButton.setOnClickListener &#123;</span><br><span class="line">            launch &#123; <span class="comment">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">anotherOps</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutinePresenter</span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope): CoroutineScope <span class="keyword">by</span> scope&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutinePresenter</span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">        launch &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-更友好地为-Activity-提供作用域"><a href="#2-3-更友好地为-Activity-提供作用域" class="headerlink" title="2.3 更友好地为 Activity 提供作用域"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p>
<p>首先我们定义一个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ScopedActivity</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope: CoroutineScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MainScoped</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> mainScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() = scopeMap[<span class="keyword">this</span> <span class="keyword">as</span> Activity]!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MainScoped</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class="line">        <span class="keyword">val</span> activity = <span class="keyword">this</span> <span class="keyword">as</span> Activity</span><br><span class="line">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroyScope</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scopeMap.remove(<span class="keyword">this</span> <span class="keyword">as</span> Activity)?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p>
<p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityLifecycleCallbackImpl</span>: <span class="type">Application.ActivityLifecycleCallbacks</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.createScope()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        (activity <span class="keyword">as</span>? MainScoped)?.destroyScope()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p>
<p>我们看下如何使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineActivity</span> : <span class="type">Activity</span>(), MainScoped &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        launchButton.setOnClickListener &#123;            </span><br><span class="line">            scope.launch &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以增加一些有用的方法来简化这个操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MainScoped</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withScope</span><span class="params">(block: <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span> = with(scope, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在 <code>Activity</code> 当中还可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withScope &#123;</span><br><span class="line">    launch &#123; ... &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p>
</blockquote>
<p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">api <span class="string">&#x27;com.bennyhuo.kotlin:coroutines-android-mainscope:1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Androidx-的协程支持"><a href="#2-4-Androidx-的协程支持" class="headerlink" title="2.4 Androidx 的协程支持"></a>2.4 Androidx 的协程支持</h3><p>Android 官方对于协程的支持也是非常积极的。</p>
<p>KTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:<span class="variable">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>lifecycle-runtime-ktx</code> 提供了 <code>LifecycleCoroutineScope</code> 类以及其获得方式，例如我们可以直接在 <code>MainActivity</code> 中使用 <code>lifecycleScope</code> 来获取这个实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                ...<span class="comment">// 执行协程体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这当然是因为 <code>MainActivity</code> 的父类实现了 <code>LifecycleOwner</code> 这个接口，而 <code>lifecycleScope</code> 则正是它的扩展成员。</p>
<p>如果想要在 <code>ViewModel</code> 当中使用作用域，我们需要再添加以下依赖：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:<span class="variable">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用方法类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            ... <span class="comment">// 执行协程体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ViewModel</code> 的作用域会在它的 <code>clear</code> 函数调用时取消。</p>
<h2 id="3-谨慎使用-GlobalScope"><a href="#3-谨慎使用-GlobalScope" class="headerlink" title="3. 谨慎使用 GlobalScope"></a>3. 谨慎使用 GlobalScope</h2><h3 id="3-1-GlobalScope-存在什么问题"><a href="#3-1-GlobalScope-存在什么问题" class="headerlink" title="3.1 GlobalScope 存在什么问题"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用  <code>GlobalScope</code>  启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p>
<p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClick</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="params"><span class="function">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p>
<p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MainScoped</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> View.<span class="title">onClickSuspend</span><span class="params">(handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        setOnClickListener &#123; v -&gt;</span><br><span class="line">            scope.launch &#123;   handler(v)   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p>
<p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p>
<p>当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。</p>
<h3 id="3-2-协程版-AutoDisposable"><a href="#3-2-协程版-AutoDisposable" class="headerlink" title="3.2 协程版 AutoDisposable"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p>
<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>
<p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Listener</span> <span class="keyword">extends</span> <span class="title class_">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnAttachStateChangeListener &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="built_in">this</span>.view = view;</span><br><span class="line">    <span class="built_in">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDispose</span><span class="params">()</span> &#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="params"><span class="function">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDisposableJob</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们就可以使用这个扩展了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p>
<p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">api <span class="string">&quot;com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>添加到依赖当中即可使用。</p>
<h2 id="4-合理使用调度器"><a href="#4-合理使用调度器" class="headerlink" title="4. 合理使用调度器"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p>
<p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p>
<p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>Coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（9）：Channel 篇</title>
    <url>//2019/09/16/coroutine-channel/</url>
    <content><![CDATA[<blockquote>
<p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="1-认识-Channel"><a href="#1-认识-Channel" class="headerlink" title="1. 认识 Channel"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            channel.send(i++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">            Logger.debug(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p>
<p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p>
<h2 id="2-Channel-的容量"><a href="#2-Channel-的容量" class="headerlink" title="2. Channel 的容量"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(capacity: <span class="type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class="line">        CONFLATED -&gt; ConflatedChannel()</span><br><span class="line">        <span class="keyword">else</span> -&gt; ArrayChannel(capacity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p>
<blockquote>
<p>类似的还有 String，不信你去试试</p>
</blockquote>
<p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        i++ <span class="comment">//为了方便输出日志，我们将自增放到前面</span></span><br><span class="line">        Logger.debug(<span class="string">&quot;before send <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        channel.send(i)</span><br><span class="line">        Logger.debug(<span class="string">&quot;before after <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">2000</span>) <span class="comment">//receive 之前延迟 2s</span></span><br><span class="line">        <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class="line">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class="line">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class="line">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class="line">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure>

<p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p>
<p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p>
<p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p>
<h2 id="3-迭代-Channel"><a href="#3-迭代-Channel" class="headerlink" title="3. 迭代 Channel"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = channel.iterator()</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// 挂起点</span></span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p>
<p>这个写法自然可以简化成 for each：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(element)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-produce-和-actor"><a href="#4-produce-和-actor" class="headerlink" title="4. produce 和 actor"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sendChannel: SendChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> element = receive()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p>
</blockquote>
<p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ProducerCoroutine</span>&lt;<span class="type">E</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class="line">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="literal">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">(value: <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _channel.close() <span class="comment">// 协程完成时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">(cause: <span class="type">Throwable</span>, handled: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> processed = _channel.close(cause) <span class="comment">// 协程取消时</span></span><br><span class="line">        <span class="keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p>
<p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p>
<p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p>
<h2 id="5-Channel-的关闭"><a href="#5-Channel-的关闭" class="headerlink" title="5. Channel 的关闭"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p>
<p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>)&#123;</span><br><span class="line">        channel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">&quot;send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">    Logger.debug(<span class="string">&quot;close channel. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">        Logger.debug(<span class="string">&quot;receive: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Logger.debug(<span class="string">&quot;After Consuming. ClosedForSend = <span class="subst">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class="line">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class="line">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class="line">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend =true ClosedForReceive = false</span><br><span class="line">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class="line">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class="line">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class="line">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend =true ClosedForReceive = true</span><br></pre></td></tr></table></figure>

<p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p>
<p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p>
<p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p>
<blockquote>
<p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p>
</blockquote>
<p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p>
<p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p>
<blockquote>
<p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p>
</blockquote>
<h2 id="6-BroadcastChannel"><a href="#6-BroadcastChannel" class="headerlink" title="6. BroadcastChannel"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p>
<p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastChannel = broadcastChannel&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>如果要订阅，那么只需要调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure>

<p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p>
<p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">    List(<span class="number">5</span>) &#123;</span><br><span class="line">        broadcastChannel.send(it)</span><br><span class="line">        Logger.debug(<span class="string">&quot;send <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">List(<span class="number">3</span>) &#123; index -&gt;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">            Logger.debug(<span class="string">&quot;[<span class="variable">$index</span>] receive: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.forEach &#123; it.join() &#125;</span><br><span class="line">    </span><br><span class="line">producer.join()</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class="line">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class="line">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class="line">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class="line">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class="line">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class="line">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class="line">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class="line">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure>

<p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p>
<blockquote>
<p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p>
</blockquote>
<p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> broadcast = channel.broadcast(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>其中，参数表示缓冲区的大小。</p>
<p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> ReceiveChannel<span class="type">&lt;E&gt;</span>.<span class="title">broadcast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    capacity: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class="line">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (e <span class="keyword">in</span> <span class="keyword">this</span><span class="symbol">@broadcast</span>) &#123;  <span class="comment">//这实际上就是在读取原 Channel</span></span><br><span class="line">            send(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p>
<p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p>
<p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p>
<h2 id="7-Channel-版本的序列生成器"><a href="#7-Channel-版本的序列生成器" class="headerlink" title="7. Channel 版本的序列生成器"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> channel) &#123;</span><br><span class="line">    Logger.debug(<span class="string">&quot;Got <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:33:56:073 [main @coroutine#1]  A</span><br><span class="line">22:33:56:172 [main @coroutine#1]  B</span><br><span class="line">22:33:56:173 [main]  Got 1</span><br><span class="line">22:33:56:173 [main @coroutine#1]  Done</span><br><span class="line">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure>

<p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = sequence &#123;</span><br><span class="line">    Logger.debug(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    Logger.debug(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    yield(<span class="number">2</span>)</span><br><span class="line">    Logger.debug(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger.debug(<span class="string">&quot;before sequence&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> sequence) &#123;</span><br><span class="line">    Logger.debug(<span class="string">&quot;Got <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">600</span> [main]  A</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">603</span> [main]  Got <span class="number">1</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  B</span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Got <span class="number">2</span></span><br><span class="line"><span class="number">22</span>:<span class="number">33</span>:<span class="number">55</span>:<span class="number">604</span> [main]  Done</span><br></pre></td></tr></table></figure>

<p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p>
<p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class="line">    Logger.debug(<span class="number">1</span>)</span><br><span class="line">    send(<span class="number">1</span>)</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        Logger.debug(<span class="number">2</span>)</span><br><span class="line">        send(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Logger.debug(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sequence 就不行了。</p>
<p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p>
<h2 id="8-Channel-的内部结构"><a href="#8-Channel-的内部结构" class="headerlink" title="8. Channel 的内部结构"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p>
<p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSendChannel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> queue = LockFreeLinkedListHead()</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p>
<p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">LockFreeLinkedListNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _next = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed | OpDescriptor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="keyword">this</span>) <span class="comment">// Node | Removed</span></span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p>
<p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p>
<p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p>
<p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p>
<blockquote>
<p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p>
</blockquote>
<h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（10）：Select 篇</title>
    <url>//2020/02/03/coroutine-select/</url>
    <content><![CDATA[<blockquote>
<p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<h2 id="复用多个-await"><a href="#复用多个-await" class="headerlink" title="复用多个 await"></a>复用多个 await</h2><p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromApi</span><span class="params">(login: <span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    gitHubServiceApi.getUserSuspend(login)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromLocal</span><span class="params">(login:<span class="type">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class="line">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p>
<p>接下来我们用 <code>select</code> 来解决这个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> localDeferred = getUserFromLocal(login)</span><br><span class="line">    <span class="keyword">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class="line">        localDeferred.onAwait &#123; Response(it, <span class="literal">true</span>) &#125;</span><br><span class="line">        remoteDeferred.onAwait &#123; Response(it, <span class="literal">false</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure>

<p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p>
<p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    ...</span><br><span class="line">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class="line">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class="line">        <span class="keyword">val</span> userFromApi = remoteDeferred.await()</span><br><span class="line">        cacheUser(login, userFromApi)</span><br><span class="line">        log(userFromApi)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure>

<h2 id="复用多个-Channel"><a href="#复用多个-Channel" class="headerlink" title="复用多个 Channel"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line"></span><br><span class="line">select&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">    channels.forEach &#123; channel -&gt;</span><br><span class="line">        channel.onReceive &#123; it &#125;</span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p>
<h2 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p>
<ul>
<li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    job.onJoin &#123; log(<span class="string">&quot;Join resumed!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p>
</li>
<li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">List(<span class="number">100</span>) &#123; element -&gt;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        channels.forEach &#123; channel -&gt;</span><br><span class="line">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class="string">&quot;sent on <span class="variable">$sentChannel</span>&quot;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p>
</li>
</ul>
<p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p>
<p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutines</tag>
        <tag>Select</tag>
      </tags>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（11）：Flow 篇</title>
    <url>//2020/03/14/coroutine-flow/</url>
    <content><![CDATA[<blockquote>
<p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p>
<p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p>
<h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p>
<p><strong>代码清单1： 序列生成器</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p>
<p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = sequence &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    yield(it)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// ERROR!</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p>
<p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p>
<p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p>
<p><strong>代码清单3：创建 Flow</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; </span><br><span class="line">    emit(it)</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p>
<p>Flow 也可以设定它运行时所使用的调度器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure>

<p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p>
<p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p>
<p><strong>代码清单4： 消费 Flow</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(myDispatcher) &#123;</span><br><span class="line">  intFlow.flowOn(Dispatchers.IO)</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure>

<p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[MyThread] <span class="number">1</span></span><br><span class="line">[MyThread] <span class="number">2</span></span><br><span class="line">[MyThread] <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="对比-RxJava-的线程切换"><a href="#对比-RxJava-的线程切换" class="headerlink" title="对比 RxJava 的线程切换"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p>
<p><strong>代码清单5：RxJava 的调度器切换</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).forEach &#123; e -&gt;</span><br><span class="line">    it.onNext(e)</span><br><span class="line">  &#125;</span><br><span class="line">  it.onComplete()</span><br><span class="line">&#125;.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.from(myExecutor))</span><br><span class="line">.subscribe &#123;</span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p>
<p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p>
<p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p>
<h2 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p>
<p><strong>代码清单6：Flow 可以被重复消费</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure>

<p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p>
<p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p>
<p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p>
<blockquote>
<p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p>
</blockquote>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p>
<p><strong>代码清单7：捕获 Flow 的异常</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p>
<p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p>
<p><strong>代码清单8：订阅流的完成</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class="line">  println(<span class="string">&quot;finally.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p>
<p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p>
<p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    emit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (t: Throwable)&#123;</span><br><span class="line">    println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;finally.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p>
<p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p>
<p><strong>代码清单10：RxJava 从异常中恢复</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> observable = Observable.create&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;.onErrorReturn &#123;</span><br><span class="line">  println(t)</span><br><span class="line">  <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获异常后，返回 10 作为下一个值。</p>
<p>我们在 Flow 当中也可以模拟这样的操作：</p>
<p><strong>代码清单11：Flow 从异常中恢复</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0&quot;</span>)</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; t: Throwable -&gt;</span><br><span class="line">  println(<span class="string">&quot;caught error: <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">  emit(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p>
<blockquote>
<p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/pull/1732">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p>
</blockquote>
<h2 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p>
<ol>
<li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li>
<li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li>
</ol>
<p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p>
<h2 id="分离-flow-的消费和触发"><a href="#分离-flow-的消费和触发" class="headerlink" title="分离 flow 的消费和触发"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p>
<p><strong>代码清单12：分离 Flow 的消费和触发</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFlow</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      emit(it)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.onEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">    createFlow().collect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p>
<p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  createFlow().launchIn(GlobalScope)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p>
<h2 id="Flow-的取消"><a href="#Flow-的取消" class="headerlink" title="Flow 的取消"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p>
<p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p>
<p><strong>代码清单14：Flow 的取消</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">  <span class="keyword">val</span> intFlow = flow &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).forEach &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      emit(it)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  intFlow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2500</span>)</span><br><span class="line">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>

<p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">▶ 1000ms later</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p>
<h2 id="其他-Flow-的创建方式"><a href="#其他-Flow-的创建方式" class="headerlink" title="其他 Flow 的创建方式"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow &#123; ... &#125;</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p>
<p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123; <span class="comment">// BAD!!</span></span><br><span class="line">  emit(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO)&#123;</span><br><span class="line">    emit(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">channelFlow &#123;</span><br><span class="line">  send(<span class="number">1</span>)</span><br><span class="line">  withContext(Dispatchers.IO) &#123;</span><br><span class="line">    send(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们也可以通过集合框架来创建 Flow：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asFlow()</span><br><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Flow-的背压"><a href="#Flow-的背压" class="headerlink" title="Flow 的背压"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p>
<p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p>
<p><strong>代码清单16：为 Flow 添加缓冲</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.buffer()</span><br></pre></td></tr></table></figure>

<p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p>
<p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p>
<p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p>
<p><strong>代码清单17：使用 conflate 解决背压问题</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.conflate()</span><br><span class="line">.collect &#123; value -&gt;</span><br><span class="line">  println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  delay(<span class="number">100</span>) </span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$value</span> collected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Collecting <span class="number">1</span></span><br><span class="line"><span class="number">1</span> collected</span><br><span class="line">Collecting <span class="number">99</span></span><br><span class="line"><span class="number">99</span> collected</span><br></pre></td></tr></table></figure>

<p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p>
<p>还是前面的例子，我们稍作修改：</p>
<p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">100</span>) &#123;</span><br><span class="line">    emit(it)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.collectLatest &#123; value -&gt;</span><br><span class="line">  println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  delay(<span class="number">100</span>)</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$value</span> collected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collecting 0</span><br><span class="line">Collecting 1</span><br><span class="line">...</span><br><span class="line">Collecting 97</span><br><span class="line">Collecting 98</span><br><span class="line">Collecting 99</span><br><span class="line">▶ 100ms later</span><br><span class="line">99 collected</span><br></pre></td></tr></table></figure>

<p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p>
<p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p>
<h2 id="Flow-的变换"><a href="#Flow-的变换" class="headerlink" title="Flow 的变换"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p>
<p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p>
<p><strong>代码清单19：Flow 的元素变换</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123; </span><br><span class="line">  it * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以映射成其他 Flow：</p>
<p><strong>代码清单20：Flow 的嵌套</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p>
<p><strong>代码清单21：拼接 Flow</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">  List(<span class="number">5</span>)&#123; emit(it) &#125; </span><br><span class="line">&#125;.map &#123;</span><br><span class="line">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class="line">&#125;.flattenConcat()</span><br><span class="line">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p>
<h2 id="使用-Flow-实现多路复用"><a href="#使用-Flow-实现多路复用" class="headerlink" title="使用 Flow 实现多路复用"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p>
<p>上一篇文章<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p>
<p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> login = <span class="string">&quot;...&quot;</span></span><br><span class="line">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class="line">    .map &#123; function -&gt;</span><br><span class="line">      function.call(login) ... ②</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; deferred -&gt;</span><br><span class="line">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class="line">    &#125;</span><br><span class="line">    .merge() ... ④</span><br><span class="line">    .onEach &#123; user -&gt;</span><br><span class="line">      println(<span class="string">&quot;Result: <span class="variable">$user</span>&quot;</span>)</span><br><span class="line">    &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png"></p>
<p><strong>图1：使用 merge 合并 Flow</strong></p>
<p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p>
<p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channels = List(<span class="number">10</span>) &#123; Channel&lt;<span class="built_in">Int</span>&gt;() &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> result = channels.map &#123;</span><br><span class="line">    it.consumeAsFlow()</span><br><span class="line">  &#125;</span><br><span class="line">  .merge()</span><br><span class="line">  .first()</span><br></pre></td></tr></table></figure>

<p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Flow</tag>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</title>
    <url>//2019/10/19/coroutine-why-so-called-lightweight-thread/</url>
    <content><![CDATA[<blockquote>
<p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p>
<h2 id="1-协程到底是啥？"><a href="#1-协程到底是啥？" class="headerlink" title="1. 协程到底是啥？"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p>
<p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg"></p>
<p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p>
<p>那么我们再来理一理协程的概念：</p>
<ul>
<li>挂起恢复</li>
<li>程序自己处理挂起恢复</li>
<li>程序自己处理挂起恢复来实现协程的协作运行</li>
</ul>
<p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p>
<blockquote>
<p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p>
</blockquote>
<h2 id="2-为什么协程的概念会有混乱的感觉？"><a href="#2-为什么协程的概念会有混乱的感觉？" class="headerlink" title="2. 为什么协程的概念会有混乱的感觉？"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p>
<p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~ </p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg"></p>
<p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p>
<blockquote>
<p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p>
</blockquote>
<p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href="http://docs.paralleluniverse.co/quasar/">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p>
<h2 id="3-协程有哪些主流的实现？"><a href="#3-协程有哪些主流的实现？" class="headerlink" title="3. 协程有哪些主流的实现？"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p>
<ul>
<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>
<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li>
</ul>
<p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p>
<p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。 </p>
<blockquote>
<p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p>
</blockquote>
<p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p>
<p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p>
<blockquote>
<p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p>
</blockquote>
<p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt;&#123; continuation -&gt;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">10086</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个 <code>suspend</code> 函数 <code>hello</code>，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 <code>resumeWith</code> 的 <code>continuation</code> 是哪里来的？</p>
<p>都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 <code>suspend</code> 函数，大家也会发现这些 <code>suspend</code> 函数都需要传入一个额外的 <code>Continuation</code>，就是这个意思。</p>
<p>当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 <code>suspend</code> 函数现出原形：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> helloRef = ::hello</span><br><span class="line"><span class="keyword">val</span> result = helloRef.call(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;resumeWith: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用  <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p>
<p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p>
<p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p>
<p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg"></p>
<h2 id="4-Kotlin-协程真的只是一个线程框架吗？"><a href="#4-Kotlin-协程真的只是一个线程框架吗？" class="headerlink" title="4. Kotlin 协程真的只是一个线程框架吗？"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg"></p>
<p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p>
<blockquote>
<p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p>
</blockquote>
<p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p>
<p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p>
<p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="keyword">val</span> width = myView.width</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="keyword">val</span> width = handler.postSuspend &#123;</span><br><span class="line">            myView.width</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">&quot;MyView&quot;</span>, width.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Handler.<span class="title">postSuspend</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class="line">    post &#123;</span><br><span class="line">        it.resume(block())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p>
<p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg"></p>
<h2 id="5-协程真的比线程有优势吗？"><a href="#5-协程真的比线程有优势吗？" class="headerlink" title="5. 协程真的比线程有优势吗？"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p>
<p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p>
<p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg"></p>
<p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p>
<p><strong>协程更像一种轻量级的『线程』。</strong></p>
<p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p>
<p>欸？没有写错吗？你写的可是线程啊？</p>
<p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg"></p>
<p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p>
<blockquote>
<p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p>
</blockquote>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg"></p>
<p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>破解 Kotlin 协程（13）：协程的几类常见的实现</title>
    <url>//2019/12/01/coroutine-implementations/</url>
    <content><![CDATA[<blockquote>
<p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2019/03/31/kotlin-coroutines-00-forword/">破解 Kotlin 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/01/basic-coroutines/">破解 Kotlin 协程（1）：入门篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/">破解 Kotlin 协程（2）：协程启动篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/">破解 Kotlin 协程（3）：协程调度篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/23/coroutine-exceptions/">破解 Kotlin 协程（4）：异常处理篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/04/30/coroutine-cancellation/">破解 Kotlin 协程（5）：协程取消篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/07/coroutine-suspend/">破解 Kotlin 协程（6）：协程挂起篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/26/coroutine-sequence/">破解 Kotlin 协程（7）：序列生成器篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/05/27/coroutine-android/">破解 Kotlin 协程（8）：Android 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2019/09/16/coroutine-channel/">破解 Kotlin 协程（9）：Channel 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/">破解 Kotlin 协程（10）：Select 篇 </a></li>
<li><a href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">破解 Kotlin 协程（11）：Flow 篇</a></li>
<li><a href="https://www.bennyhuo.com/2019/10/19/coroutine-why-so-called-lightweight-thread/">破解 Kotlin 协程（12）：协程为什么被称为『轻量级线程』？</a></li>
<li><a href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解 Kotlin 协程（13）：协程的几类常见的实现</a></li>
</ul>
<p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p>
<h2 id="1-协程的分类"><a href="#1-协程的分类" class="headerlink" title="1. 协程的分类"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p>
<h3 id="1-1-按调用栈分类"><a href="#1-1-按调用栈分类" class="headerlink" title="1.1 按调用栈分类"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p>
<ul>
<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>
<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li>
</ul>
<p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p>
<p>当然也有反例。</p>
<p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p>
<p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;I&#x27;m in level 0!&quot;</span>)</span><br><span class="line">    level_1() <span class="comment">// ............ ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">level_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;I&#x27;m in level 1!&quot;</span>)</span><br><span class="line">    suspendNow() <span class="comment">// ............ ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendNow</span><span class="params">()</span></span> </span><br><span class="line">        = suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p>
<p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p>
<h3 id="1-2-按调度方式分类"><a href="#1-2-按调度方式分类" class="headerlink" title="1.2 按调度方式分类"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p>
<ul>
<li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li>
<li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li>
</ul>
<p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p>
<p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href="https://luapower.com/coro">coro</a>，以及 Kotlin 协程框架中基于 <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html">Channel</a> 的通信等。</p>
<h2 id="2-协程的实现举例"><a href="#2-协程的实现举例" class="headerlink" title="2. 协程的实现举例"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p>
<h3 id="2-1-Python-的-Generator"><a href="#2-1-Python-的-Generator" class="headerlink" title="2.1 Python 的 Generator"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numbers</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span>(i) <span class="comment"># ..................... ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_generator = numbers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[0] <span class="subst">&#123;<span class="built_in">next</span>(num_generator)&#125;</span>&quot;</span>) <span class="comment"># ... ②</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[1] <span class="subst">&#123;<span class="built_in">next</span>(num_generator)&#125;</span>&quot;</span>) <span class="comment"># ... ③</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_generator: <span class="comment"># ............... ④</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[Loop] <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0] 0</span><br></pre></td></tr></table></figure>

<p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1] 1</span><br></pre></td></tr></table></figure>

<p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p>
<p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p>
<p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numbers</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        yield_here(i) <span class="comment"># ................. ①</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yield_here</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">yield</span>(i)</span><br></pre></td></tr></table></figure>

<p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p>
<blockquote>
<p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p>
</blockquote>
<h3 id="2-2-Lua-标准库的协程实现"><a href="#2-2-Lua-标准库的协程实现" class="headerlink" title="2.2 Lua 标准库的协程实现"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p>
<ul>
<li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li>
<li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li>
<li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li>
</ul>
<p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send &quot;</span>..i)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i) <span class="comment">-- ④</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End Producer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;receive &quot;</span>..value)</span><br><span class="line">        value = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>() <span class="comment">-- ⑤</span></span><br><span class="line">    <span class="keyword">until</span>(<span class="keyword">not</span> value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End Consumer&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">producerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(producer) <span class="comment">-- ①</span></span><br><span class="line">consumerCoroutine = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(consumer) <span class="comment">-- ②</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">status</span>, product = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producerCoroutine) <span class="comment">-- ③</span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(consumerCoroutine, product) <span class="comment">-- ⑥</span></span><br><span class="line"><span class="keyword">until</span>(<span class="keyword">not</span> <span class="built_in">status</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End Main&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">send 0</span><br><span class="line">receive 0</span><br></pre></td></tr></table></figure>

<p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">send 1</span><br><span class="line">receive 1</span><br><span class="line">send 2</span><br><span class="line">receive 2</span><br><span class="line">send 3</span><br><span class="line">receive 3</span><br><span class="line">End Producer</span><br><span class="line">End Consumer</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure>

<p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p>
<ul>
<li>协程的执行体，主要是指启动协程时对应的函数</li>
<li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li>
<li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li>
</ul>
<blockquote>
<p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href="https://luapower.com/coro">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p>
</blockquote>
<h3 id="2-3-Go-语言中的-go-routine"><a href="#2-3-Go-语言中的-go-routine" class="headerlink" title="2.3 Go 语言中的 go routine"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// .......... ①</span></span><br><span class="line"><span class="keyword">var</span> readChannel &lt;-<span class="keyword">chan</span> <span class="type">int</span> = channel</span><br><span class="line"><span class="keyword">var</span> writeChannel <span class="keyword">chan</span>&lt;- <span class="type">int</span> = channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// ........................ ②</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123; <span class="comment">// ... ③</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()  <span class="comment">// ............................... ④</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// writer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">        writeChannel &lt;- i <span class="comment">// .......... ⑤</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p>
<p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p>
<p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait for read</span><br><span class="line">write 0</span><br><span class="line">read 0</span><br><span class="line">write 1</span><br><span class="line">read 1</span><br><span class="line">write 2</span><br><span class="line">read 2</span><br><span class="line">read end</span><br></pre></td></tr></table></figure>

<p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p>
<p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;wait for read&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> readChannel &#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;read&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;read end&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        fmt.Println(windows.GetCurrentThreadId(), <span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">        writeChannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(writeChannel)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">181808 write 0</span><br><span class="line">183984 wait for read</span><br><span class="line">181808 read 0</span><br><span class="line">181808 write 1</span><br><span class="line">181808 write 2</span><br><span class="line">181808 read 1</span><br><span class="line">181808 read 2</span><br><span class="line">181808 read end</span><br></pre></td></tr></table></figure>

<p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p>
<blockquote>
<p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href="https://github.com/golang/sys">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p>
</blockquote>
<blockquote>
<p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p>
</blockquote>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p>
<p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Kotlin 中文论坛的使用技巧</title>
    <url>/2019/10/22/kotlin-forum-mobile/</url>
    <content><![CDATA[<blockquote>
<p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ </p>
</blockquote>
<span id="more"></span>




<p>欢迎访问 <a href="https://discuss.kotliner.cn/">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p>
<p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href="https://www.discourse.org/">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg"></p>
<p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg"></p>
<p>之后呢？我们就可以在桌面上看到：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg"></p>
<p>点击这个 icon 进入之后，就好像原生 App 一样：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg"></p>
<p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p>
<hr>
<p>经过小伙伴们之处，桌面也可以：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg"></p>
<p>然后就得到了一个桌面 APP 有木有！</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg"></p>
<hr>
<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href="mailto:&#107;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#x6f;&#x6d;">&#107;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>
<hr>
<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Website</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 1.4.30-M1 增强的内联类是个什么东西？</title>
    <url>/2021/01/18/kotlin-inline-class-improvements/</url>
    <content><![CDATA[<blockquote>
<p>内联类从 1.3 推出，一直处于实验状态。 </p>
</blockquote>
<span id="more"></span>




<p>内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。</p>
<h2 id="1-从内联函数说起"><a href="#1-从内联函数说起" class="headerlink" title="1. 从内联函数说起"></a>1. 从内联函数说起</h2><p>我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。</p>
<p>函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(max(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。</p>
<p>不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">()</span>V</span><br><span class="line"> L0</span><br><span class="line">  LINENUMBER <span class="number">6</span> L0</span><br><span class="line">  ICONST_1</span><br><span class="line">  ICONST_2</span><br><span class="line">  INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.max (II)I</span><br><span class="line">  INVOKESTATIC kotlin/io/ConsoleKt.println (I)V</span><br></pre></td></tr></table></figure>

<p>如果我们把 max 声明成内联函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>

<p>结果就不一样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">()</span>V</span><br><span class="line"> L0</span><br><span class="line">  LINENUMBER <span class="number">6</span> L0</span><br><span class="line">  ICONST_1</span><br><span class="line">  ISTORE <span class="number">0</span></span><br><span class="line">  ICONST_2</span><br><span class="line">  ISTORE <span class="number">1</span></span><br><span class="line"> L1</span><br><span class="line">  ICONST_0</span><br><span class="line">  ISTORE <span class="number">2</span></span><br><span class="line"> L2</span><br><span class="line">  LINENUMBER <span class="number">8</span> L2</span><br><span class="line"> L3</span><br><span class="line">  ILOAD <span class="number">1</span></span><br><span class="line"> L4</span><br><span class="line"> L5</span><br><span class="line">  ISTORE <span class="number">0</span></span><br><span class="line"> L6</span><br><span class="line">  LINENUMBER <span class="number">6</span> L6</span><br><span class="line"> L7</span><br><span class="line">  ICONST_0</span><br><span class="line">  ISTORE <span class="number">1</span></span><br><span class="line"> L8</span><br><span class="line">  GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">  ILOAD <span class="number">0</span></span><br><span class="line">  INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br></pre></td></tr></table></figure>

<p>这样我们就已经看不到 max 函数的调用了。</p>
<p>当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).forEach &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后大致相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">    &#123; it: <span class="built_in">Int</span> -&gt; println(it) &#125;(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 <code>&#123; it: Int -&gt; println(it) &#125;(element)</code> 其实就是前面 forEach 定义当中的 <code>action(element)</code>，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。</p>
<p>所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">    println(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且这样也更符合我们的直觉。</p>
<p>总结一下，内联函数可以减少函数对象的创建和函数调用的次数。</p>
<blockquote>
<p>提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？</p>
</blockquote>
<h2 id="2-什么是内联类"><a href="#2-什么是内联类" class="headerlink" title="2. 什么是内联类"></a>2. 什么是内联类</h2><p>内联函数可以减少对象的创建，内联类实际上也是如此。</p>
<p>内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。</p>
<p>内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>使用时大多数情况下就像普通类型那样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState.value)</span><br></pre></td></tr></table></figure>

<p>虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(value)</span><br></pre></td></tr></table></figure>

<p>因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。</p>
<p>我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isIdle</span><br><span class="line">        <span class="keyword">get</span>() = value == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isPlaying</span><span class="params">()</span></span> = value == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState.isIdle)</span><br><span class="line">println(idleState.isPlaying())</span><br></pre></td></tr></table></figure>

<p>因而就相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(PlayerState.isIdle-impl(value))</span><br><span class="line">println(PlayerState.isPlaying-impl(value))</span><br></pre></td></tr></table></figure>

<p><code>isIdle-impl</code> 和 <code>isPlaying-impl</code> 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 <code>-</code> 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。</p>
<p>我们再看一个稍微复杂的情形：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> idleState = PlayerState(<span class="number">0</span>)</span><br><span class="line">println(idleState)</span><br></pre></td></tr></table></figure>

<p>我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> value = <span class="number">0</span></span><br><span class="line">println(PlayerState(value))</span><br></pre></td></tr></table></figure>

<p>简单总结一下就是：</p>
<ol>
<li>在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。</li>
<li>编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。</li>
</ol>
<h2 id="3-内联类有什么限制？"><a href="#3-内联类有什么限制？" class="headerlink" title="3. 内联类有什么限制？"></a>3. 内联类有什么限制？</h2><p>通过前面对于内联类概念的讨论，我们已经知道内联类</p>
<ol>
<li>有且仅有一个不可变的属性</li>
<li>可以定义其他属性，但不能有状态</li>
</ol>
<p>实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">UInt</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(<span class="keyword">internal</span> <span class="keyword">val</span> <span class="keyword">data</span>: <span class="built_in">Int</span>) : Comparable&lt;UInt&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UInt</span>)</span></span>: <span class="built_in">Int</span> = uintCompare(<span class="keyword">this</span>.<span class="keyword">data</span>, other.<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：</p>
<p><strong>以下为 Kotlin 1.4.20 当中的效果</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png"></p>
<p>在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。</p>
<p>不过，1.4.30-M1 当中已经解除了这一限制，详情参见：<strong>KT-28056 Consider supporting non-public primary constructors for inline classes</strong>(<a href="https://youtrack.jetbrains.com/issue/KT-28056)%EF%BC%8C%E5%9B%A0%E8%80%8C%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%86%85%E8%81%94%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E%E4%B8%BA">https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为</a> internal 或者 private，以防止外部随意创建新实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。</p>
<p>除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png"></p>
<p>1.4.30-M1 开始解除了这一限制，详情参见：<strong>KT-28055 Consider supporting init blocks inside inline classes</strong>(<a href="https://youtrack.jetbrains.com/issue/KT-28055)%E3%80%82%E4%B8%8D%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%99%BD%E7%84%B6">https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然</a> init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。</p>
<h2 id="4-内联类有什么应用场景？"><a href="#4-内联类有什么应用场景？" class="headerlink" title="4. 内联类有什么应用场景？"></a>4. 内联类有什么应用场景？</h2><p>前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。</p>
<h3 id="4-1-加强版的类型别名"><a href="#4-1-加强版的类型别名" class="headerlink" title="4.1 加强版的类型别名"></a>4.1 加强版的类型别名</h3><p>内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Flag0</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">typealias</span> Flag1 = <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Flag0::<span class="keyword">class</span> == <span class="built_in">Int</span>::<span class="keyword">class</span>) <span class="comment">// false</span></span><br><span class="line">    println(Flag1::<span class="keyword">class</span> == <span class="built_in">Int</span>::<span class="keyword">class</span>) <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> flag0 = Flag0(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> flag1 = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-替代枚举类"><a href="#4-2-替代枚举类" class="headerlink" title="4.2 替代枚举类"></a>4.2 替代枚举类</h3><p>内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：</p>
<p><strong>内联类的写法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举类的写法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    error, idle, playing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> error = PlayerState(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> idle = PlayerState(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> playing = PlayerState(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">values</span><span class="params">()</span></span> = arrayOf(error, idle, playing)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isIdle</span><span class="params">()</span></span> = <span class="keyword">this</span> == idle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。</p>
<p>话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。</p>
<p>当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：</p>
<p><strong>使用内联类</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123; ... &#125; <span class="comment">// 必须，因为编译器无法推断出前面的条件是完备的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：</p>
<p><strong>使用枚举类</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">when</span>(state) &#123;</span><br><span class="line">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class="line">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-替代密封类"><a href="#4-3-替代密封类" class="headerlink" title="4.3 替代密封类"></a>4.3 替代密封类</h3><p>密封类用于子类可数的场景，枚举类则用于实例可数的场景。</p>
<p>我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Song</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line"><span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>

<p>如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。</p>
<p>这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？</p>
<p>其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line"><span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> state: PlayerState = Idle</span><br><span class="line">...</span><br><span class="line">state = Error(IOExeption(<span class="string">&quot;...&quot;</span>)) <span class="comment">// 必须装箱，无法内联</span></span><br><span class="line">...</span><br><span class="line">state = Playing(Song(...)) <span class="comment">// 必须装箱，无法内联</span></span><br></pre></td></tr></table></figure>

<p>这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。</p>
<p>不过，作为变通，其实我们也可以这样改写上面的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span>(<span class="keyword">val</span> state: Any?) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require(state == <span class="literal">null</span> || state <span class="keyword">is</span> Throwable || state <span class="keyword">is</span> Song)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isIdle</span><span class="params">()</span></span> = state == <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isError</span><span class="params">()</span></span> = state <span class="keyword">is</span> Throwable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isPlaying</span><span class="params">()</span></span> = state <span class="keyword">is</span> Song</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;<span class="type">out T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> value: Any?</span><br><span class="line">) : Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> isSuccess: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = value !<span class="keyword">is</span> Failure</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> isFailure: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = value <span class="keyword">is</span> Failure</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：</p>
<ol>
<li>内联类是对其他类实例的包装</li>
<li>内联类在编译时会尽可能地将实例替换成被包装的对象</li>
<li>内联类的函数（包括无状态属性）都将被编译成静态函数</li>
<li>内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用</li>
<li>内联类不能与 Java 兼容</li>
</ol>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>news</tag>
        <tag>inline class</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 新版本也有了交叉类型和联合类型？</title>
    <url>/2020/04/06/kotlin-intersect-type/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 </p>
</blockquote>
<span id="more"></span>




<p>先来看一段代码：</p>
<p><strong>代码清单 1：Kotlin 的分支表达式</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>请问 number 的类型是什么？</p>
<p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p>
<p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</p>
<p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png"></p>
<p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p>
<p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p>
<p>当然，如果你为 number 添加类型声明，例如：</p>
<p><strong>代码清单 2：为分支表达式添加类型信息</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> number: Number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p>
<blockquote>
<p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p>
</blockquote>
<h2 id="2-新类型推导算法的推导结果"><a href="#2-新类型推导算法的推导结果" class="headerlink" title="2. 新类型推导算法的推导结果"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png"></p>
<p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p>
<p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p>
<p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p>
<p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Number.<span class="title">compareTo</span><span class="params">(other: <span class="type">Number</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> number = <span class="keyword">if</span> (validation()) <span class="number">1F</span> <span class="keyword">else</span> <span class="number">2.0</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$number</span> &gt; 2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$number</span> &lt;= 2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p>
<h2 id="3-交叉类型与联合类型"><a href="#3-交叉类型与联合类型" class="headerlink" title="3. 交叉类型与联合类型"></a>3. 交叉类型与联合类型</h2><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png"></p>
<p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p>
<p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p>
<p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p>
<p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p>
<p><strong>代码清单 4：TypeScript 中的联合类型</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="title function_">fly</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">layEggs</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">layEggs</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line"><span class="comment">// OK，两个类型的公共成员</span></span><br><span class="line">pet.<span class="title function_">layEggs</span>();</span><br></pre></td></tr></table></figure>

<p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p>
<p><strong>代码清单 5：Kotlin 的联合类型</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layEggs</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pet = <span class="keyword">if</span>(validation()) <span class="keyword">object</span> : Bird&#123; ... &#125; <span class="keyword">else</span> <span class="keyword">object</span> : Fish&#123; ... &#125;</span><br><span class="line">pet.layEggs() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p>
<p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p>
<h2 id="4-为什么不直接支持交叉类型和联合类型呢？"><a href="#4-为什么不直接支持交叉类型和联合类型呢？" class="headerlink" title="4. 为什么不直接支持交叉类型和联合类型呢？"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p>
<ol>
<li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li>
<li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li>
</ol>
<p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>type</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？</title>
    <url>/2020/06/09/kotlin-map-default/</url>
    <content><![CDATA[<blockquote>
<p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 </p>
</blockquote>
<span id="more"></span>




<h3 id="1-getOrElse"><a href="#1-getOrElse" class="headerlink" title="1. getOrElse"></a>1. getOrElse</h3><p>这个比较简单，我们先来看下它的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrElse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="type">K</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">  defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: V = <span class="keyword">get</span>(key) ?: defaultValue()</span><br></pre></td></tr></table></figure>

<p>如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。</p>
<p>这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> isEnabled = config.getOrElse(<span class="string">&quot;isEnabled&quot;</span>, &#123; <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-getOrPut"><a href="#2-getOrPut" class="headerlink" title="2. getOrPut"></a>2. getOrPut</h3><p>需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：</p>
<p>我们有一个事件回调接口，不同事件用 eventId 来区分：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnEventListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onEvent</span><span class="params">(eventId: <span class="type">String</span>, <span class="keyword">data</span>: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要提供对事件回调注册的能力：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> eventListeners = HashMap&lt;String, ArrayList&lt;OnEventListener&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listenerList = eventListeners[eventId]</span><br><span class="line">    <span class="keyword">if</span> (listenerList == <span class="literal">null</span>) &#123;</span><br><span class="line">        listenerList = ArrayList()</span><br><span class="line">        eventListeners[eventId] = listenerList</span><br><span class="line">    &#125;</span><br><span class="line">    listenerList.add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个也太不 Kotlin 了。</p>
<p>好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> MutableMap<span class="type">&lt;K, V&gt;</span>.<span class="title">getOrPut</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="type">K</span>, defaultValue: () -&gt; <span class="type">V</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: V &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">get</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = defaultValue()</span><br><span class="line">        put(key, answer)</span><br><span class="line">        answer</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然如此，我们就可以简化 addOnEventListener 的实现了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addOnEventListener</span><span class="params">(eventId: <span class="type">String</span>, listener: <span class="type">OnEventListener</span>)</span></span> &#123;</span><br><span class="line">    eventListeners.getOrPut(eventId, defaultCreator).add(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式默认值"><a href="#3-隐式默认值" class="headerlink" title="3. 隐式默认值"></a>3. 隐式默认值</h3><p>除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = HashMap&lt;String, <span class="built_in">Boolean</span>&gt;().withDefault &#123; <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 <code>&#123; false &#125;</code> 的求值结果了。</p>
<p>不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config[<span class="string">&quot;isEnabled&quot;</span>] <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>用于此时我们的 config 只是一个空 Map，因此不存在 <code>isEnabled</code> 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 <code>config[&quot;isEnabled&quot;]</code> 或者说等价的 <code>config.get(&quot;isEnabled&quot;)</code> 调用并不会触发默认值的求值。</p>
<p>那我想要获得默认值要怎么做呢？</p>
<p>调用另外的一个扩展方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> isEnabled = config.getValue(<span class="string">&quot;isEnabled&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="4-默认值的提供方式"><a href="#4-默认值的提供方式" class="headerlink" title="4. 默认值的提供方式"></a>4. 默认值的提供方式</h3><p>前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？</p>
<p>其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。</p>
<p>还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p>好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构</title>
    <url>/2020/04/19/kotlin-native-android-mpp/</url>
    <content><![CDATA[<blockquote>
<p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 </p>
</blockquote>
<span id="more"></span>




<ul>
<li><a href="https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li>
<li><a href="https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li>
</ul>
<p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p>
<p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p>
<p>接下来我们就把之前的工程改造一下，工程源码见：<a href="https://github.com/enbandari/hello-kni">hello-kni</a>。</p>
<p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png"></p>
<p>接着，在 settings.gradle.kts 当中引入这个 Module：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">include(<span class="string">&quot;:app&quot;</span>, <span class="string">&quot;:nativeLib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;multiplatform&quot;</span>) version <span class="string">&quot;1.3.71&quot;</span></span><br><span class="line">    id(<span class="string">&quot;com.android.library&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p>
<p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class="string">&quot;generated&quot;</span>, <span class="string">&quot;jniLibs&quot;</span>).joinToString(File.separator))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">val</span> main <span class="keyword">by</span> getting &#123;</span><br><span class="line">            jniLibs.srcDir(jniLibDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidNativeArm32 &#123;</span><br><span class="line">        binaries &#123;</span><br><span class="line">            sharedLib(<span class="string">&quot;knlib&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class="line">                    linkTask.doLast &#123;</span><br><span class="line">                        copy &#123;</span><br><span class="line">                            from(outputFile)</span><br><span class="line">                            into(File(jniLibDir, <span class="string">&quot;armeabi-v7a&quot;</span>))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    afterEvaluate &#123;</span><br><span class="line">                        <span class="keyword">val</span> preReleaseBuild <span class="keyword">by</span> tasks.getting</span><br><span class="line">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin mpp 的工程配置非常清晰：</p>
<ol>
<li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li>
<li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li>
<li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li>
<li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li>
</ol>
<p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png"></p>
<p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p>
<p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(project(<span class="string">&quot;:nativeLib&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>kotlin-native</tag>
        <tag>mpp</tag>
      </tags>
  </entry>
  <entry>
    <title>闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？</title>
    <url>/2020/07/15/kotlin-native-introduction/</url>
    <content><![CDATA[<blockquote>
<p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~ </p>
</blockquote>
<span id="more"></span>




<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png"></p>
<p><strong><center>官方题图：Kotlin-Native 的世界</center></strong></p>
<p>Kotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png"></p>
<p><strong><center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center></strong></p>
<p>说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？</p>
<p> 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。</p>
<p> 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png"></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png"></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png"></p>
<p><strong><center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center></strong></p>
<p>就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png"></p>
<p><strong><center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center></strong></p>
<p>那 Kotlin-Native 就这么凉了？</p>
<p>据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。</p>
<p>不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）</p>
<p>这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。</p>
<p>当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。</p>
<h2 id="为什么我们需要了解下-Kotlin-Native"><a href="#为什么我们需要了解下-Kotlin-Native" class="headerlink" title="为什么我们需要了解下 Kotlin-Native"></a>为什么我们需要了解下 Kotlin-Native</h2><h3 id="零成本多平台抽象"><a href="#零成本多平台抽象" class="headerlink" title="零成本多平台抽象"></a>零成本多平台抽象</h3><p>前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png"></p>
<p>原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png"></p>
<p><strong><center>Kotlin 在 Android &amp; iOS 上共享逻辑</center></strong></p>
<p>用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：<a href="https://github.com/icerockdev/moko-widgets">moko-widgets</a>。</p>
<p>官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。</p>
<p>你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。</p>
<p>不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：<a href="https://github.com/caffeine-mgn/pw.binom.io">pw.binom.io</a>，使用这个框架可以在它支持的所有平台上写出下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;Simple Text&quot;</span>.asUTF8ByteArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = File(<span class="string">&quot;Simple File&quot;</span>)</span><br><span class="line">    FileOutputStream(file, <span class="literal">false</span>).use &#123;</span><br><span class="line">        it.write(<span class="keyword">data</span>, <span class="number">0</span>, <span class="keyword">data</span>.size)</span><br><span class="line">        it.flush()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Write data: \&quot;<span class="subst">$&#123;data.asUTF8String()&#125;</span>\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">out</span> = ByteArrayOutputStream()</span><br><span class="line">    FileInputStream(file).use &#123;</span><br><span class="line">        it.copyTo(<span class="keyword">out</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Read data: \&quot;<span class="subst">$&#123;out.toByteArray().asUTF8String()&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。</p>
<h3 id="多平台特性的持续优化"><a href="#多平台特性的持续优化" class="headerlink" title="多平台特性的持续优化"></a>多平台特性的持续优化</h3><p>1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。</p>
<p>多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。</p>
<p>这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png"></p>
<p><strong><center>结构化多平台特性示意图</center></strong></p>
<p>1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。</p>
<p>多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。</p>
<h3 id="“新基建”的时代背景"><a href="#“新基建”的时代背景" class="headerlink" title="“新基建”的时代背景"></a>“新基建”的时代背景</h3><p>前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png"></p>
<p><strong><center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center></strong></p>
<p>过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。</p>
<p>说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？</p>
<p>现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。</p>
<p>而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。</p>
<h2 id="我们该怎么学习-Kotlin-Native-呢？"><a href="#我们该怎么学习-Kotlin-Native-呢？" class="headerlink" title="我们该怎么学习 Kotlin-Native 呢？"></a>我们该怎么学习 Kotlin-Native 呢？</h2><p>先了解下 Kotlin-Native 需要的背景知识。</p>
<ol>
<li>扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。</li>
<li>C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。</li>
</ol>
<p>有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。</p>
<p>接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。</p>
<p>或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。</p>
<p>说了这么多，我后面的文章大概会写点儿什么内容呢？</p>
<ol>
<li>Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。</li>
<li>Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。</li>
<li>Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。</li>
<li>研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。</li>
<li>协程在 Kotlin-Native 上对于并发的支持。</li>
<li>Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。</li>
</ol>
<p>其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>native</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</title>
    <url>/2018/12/31/kotlin-native-jni-dynamic/</url>
    <content><![CDATA[<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p>
<span id="more"></span>

<p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="string">&quot;JNI_OnLoad&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JNI_OnLoad</span><span class="params">(vm: <span class="type">CPointer</span>&lt;<span class="type">JavaVMVar</span>&gt;, preserved: <span class="type">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class="line">    <span class="keyword">return</span> memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class="line">        <span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">&quot;Kn&quot;</span>, <span class="string">&quot;JNI_OnLoad&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(result == JNI_OK)&#123;</span><br><span class="line">            <span class="keyword">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class="line">            <span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">            jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">            jniMethod[<span class="number">0</span>].name = <span class="string">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class="line">            jniMethod[<span class="number">0</span>].signature = <span class="string">&quot;()V&quot;</span>.cstr.ptr</span><br><span class="line">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">&quot;Kn&quot;</span>, <span class="string">&quot;register say hello2, %d, %d&quot;</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class="line">        &#125;</span><br><span class="line">        JNI_VERSION_1_6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java  虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p>
<p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p>
<p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure>

<p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p>
<p>接下来我们看这句：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure>

<p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br></pre></td></tr></table></figure>

<p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure>

<p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code>  的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p>
<p>接下来我们要实现动态绑定了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jclass = env.FindClass!!(envStorage.value, <span class="string">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class="line"><span class="keyword">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class="number">1</span>)</span><br><span class="line">jniMethod[<span class="number">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class="line">jniMethod[<span class="number">0</span>].name = <span class="string">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class="line">jniMethod[<span class="number">0</span>].signature = <span class="string">&quot;()V&quot;</span>.cstr.ptr</span><br><span class="line">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p>
<p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class="comment">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv <span class="comment">/* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */</span>&gt;?, platform.android.jclass? <span class="comment">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class="comment">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class="comment">/* = kotlin.Int */</span>&gt;&gt;? <span class="comment">/* compiled code */</span></span><br></pre></td></tr></table></figure>

<p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p>
<p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p>
<p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p>
<p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni">hello-kni</a></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Kotlin-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 官网大变样？这是要干啥？</title>
    <url>/2020/02/13/kotlin-news-202002/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 </p>
</blockquote>
<span id="more"></span>




<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png"></p>
<p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p>
<p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p>
<p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png"></p>
<p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p>
<p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png"></p>
<p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href="https://kotl.in/slack">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p>
<p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p>
<p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png"></p>
<p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p>
<p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png"></p>
<p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href="https://github.com/Kotlin/kotlin-numpy">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p>
<p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png"></p>
<p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href="https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/">原文</a>] [<a href="https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/">中文翻译</a>]。</p>
<p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href="https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p>
<p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p>
<p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p>
<ul>
<li>Kotlin 1.0：2016.2</li>
<li>Kotlin 1.1：2017.3（13个月之后）</li>
<li>Kotlin 1.2：2017.11（8个月之后）</li>
<li>Kotlin 1.3：2018.10（11个月之后）</li>
</ul>
<p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>说说最近官方公布的 Kotlin 的动态</title>
    <url>/2020/10/19/kotlin-news-202010/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin 的发展可以认为是正式进入了下一个阶段。 </p>
</blockquote>
<span id="more"></span>




<p>今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。</p>
<p>不过，官方最近有些消息放出来让我有些坐不住了。</p>
<h2 id="1-Kotlin-的发版节奏"><a href="#1-Kotlin-的发版节奏" class="headerlink" title="1. Kotlin 的发版节奏"></a>1. Kotlin 的发版节奏</h2><p>过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。</p>
<p>功能优先还是版本优先？</p>
<p>显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。</p>
<p>而现如今，</p>
<p>Kotlin 经过 1.0 正式发布</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png"></p>
<p>1.1 正式支持 JavaScript 并开始试验协程</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png"></p>
<p>1.2 开始试验多平台</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png"></p>
<p>1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png"></p>
<p>1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png"></p>
<p>可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。</p>
<p>接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。</p>
<p>这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。</p>
<h2 id="2-Kotlin-的-Roadmap"><a href="#2-Kotlin-的-Roadmap" class="headerlink" title="2. Kotlin 的 Roadmap"></a>2. Kotlin 的 Roadmap</h2><p>我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。</p>
<p>再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png"></p>
<p>现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png"></p>
<p>顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。</p>
<p>这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png"></p>
<p>多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。</p>
<p>Kotlin 近期公布的 Roadmap 见：<a href="https://kotlinlang.org/roadmap.html">Kotlin Roadmap</a>，大家可以自己看看有没有自己感兴趣的内容。</p>
<h2 id="3-KMM-插件"><a href="#3-KMM-插件" class="headerlink" title="3. KMM 插件"></a>3. KMM 插件</h2><p>KMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png"></p>
<p>毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。</p>
<p>KMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。</p>
<p>不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：</p>
<ol>
<li>Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。</li>
<li>Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。</li>
<li>Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。</li>
</ol>
<p>不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。</p>
<p>至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。</p>
<p>再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Kotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。</p>
<hr>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png"></p>
<p>最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 <a href="https://kotlinlang.org/lp/event-14/">Kotlin 1.4 Online Event</a> 这个地址找到所有的视频，内容还是值得了解一下的。</p>
<p>当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Node.js 环境的 KotlinJs 工程的完美搭建</title>
    <url>/2019/03/11/kotlin-nodejs/</url>
    <content><![CDATA[<h3 id="为什么需要这样一篇文章"><a href="#为什么需要这样一篇文章" class="headerlink" title="为什么需要这样一篇文章"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p>
<p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p>
<p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p>
<ul>
<li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li>
<li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li>
<li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li>
</ul>
<p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p>
<p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg"></p>
<p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p>
<p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg"></p>
<p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg"></p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg"></p>
<p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg"></p>
<p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p>
<p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs  编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compileKotlin2Js &#123;</span><br><span class="line">    kotlinOptions.moduleKind = <span class="string">&#x27;commonjs&#x27;</span></span><br><span class="line">    kotlinOptions.sourceMap = <span class="literal">true</span></span><br><span class="line">    kotlinOptions.metaInfo = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p>
<p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib-js&quot;</span></span><br><span class="line">    testImplementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-test-js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这怎么能运行得起来呢？</p>
<p>因此我们还需要一个插件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.jetbrains.kotlin.frontend&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;https://dl.bintray.com/kotlin/kotlin-eap&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg"></p>
<p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">kotlinFrontend &#123;</span><br><span class="line">    npm &#123;</span><br><span class="line">        dependency <span class="string">&quot;style-loader&quot;</span> <span class="comment">// production dependency</span></span><br><span class="line">        devDependency <span class="string">&quot;karma&quot;</span>     <span class="comment">// development dependency</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还支持 webpack 。</p>
<p>好啦，这时候再运行咱们的程序，就会得到结果：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg"></p>
<h2 id="体验一把-KotlinJs-的协程"><a href="#体验一把-KotlinJs-的协程" class="headerlink" title="体验一把 KotlinJs 的协程"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接着，编写我们的 Kotlin 代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;[<span class="subst">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log(<span class="number">1</span>)</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        log(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> result = withContext(coroutineContext) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="number">4</span>)</span><br><span class="line">            <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;5. <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg"></p>
<p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg"></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg"></p>
<p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p>
<p>是不是很美？</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p>
<blockquote>
<p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p>
</blockquote>
<hr>
<ul>
<li>Bennyhuo 所在的组招 Android 实习生啦</li>
<li>主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生</li>
<li>Java 基础扎实者优先，熟悉 Kotlin 优先</li>
<li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li>
<li>有兴趣的小伙伴可以发简历到 <a href="mailto:&#98;&#101;&#x6e;&#110;&#x79;&#104;&#x75;&#x6f;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#101;&#x72;&#x2e;&#99;&#x6e;">&#98;&#101;&#x6e;&#110;&#x79;&#104;&#x75;&#x6f;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#101;&#x72;&#x2e;&#99;&#x6e;</a> 哈~</li>
</ul>
<hr>
<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Kotlni-Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 1.4.30-RC 密封接口来啦！</title>
    <url>/2021/01/23/kotlin-sealed-interface/</url>
    <content><![CDATA[<blockquote>
<p>密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 </p>
</blockquote>
<span id="more"></span>




<h3 id="Java-的密封接口"><a href="#Java-的密封接口" class="headerlink" title="Java 的密封接口"></a>Java 的密封接口</h3><p>我们先来看看 Java 的密封接口是怎么回事吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">PlayerState</span> <span class="keyword">permits</span> Idle, Playing, Error &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Idle</span> <span class="keyword">implements</span> <span class="title class_">PlayerState</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Playing</span> <span class="keyword">implements</span> <span class="title class_">PlayerState</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Error</span> <span class="keyword">implements</span> <span class="title class_">PlayerState</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。</p>
<p>语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 <code>permits</code>，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。</p>
<p>我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。</p>
<p>说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 <code>--enable-preview</code> 参数，具体在 Gradle 当中可参考以下配置：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">compileJava &#123;</span><br><span class="line">    it.<span class="keyword">options</span>.compilerArgs.add(<span class="string">&#x27;--enable-preview&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">compileKotlin &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        languageVersion = <span class="string">&quot;1.5&quot;</span> <span class="comment">// Kotlin 1.5 experimental</span></span><br><span class="line">        freeCompilerArgs += <span class="string">&quot;-Xjvm-enable-preview&quot;</span> <span class="comment">// for java preview </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="密封类型子类的子类"><a href="#密封类型子类的子类" class="headerlink" title="密封类型子类的子类"></a>密封类型子类的子类</h3><p>那么灵魂拷问来了，不加 final 行不行？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png"></p>
<p>三选一，</p>
<p>第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的</p>
<p>第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。</p>
<p>啊？？那这样子类不就不受限制了吗？</p>
<p>对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。</p>
<p>第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。</p>
<p>这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？</p>
<p>非也非也！</p>
<p>Kotlin 的密封类的子类，也可以有子类的！列位请看：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Song</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Options</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> t: Throwable): PlayerState()</span><br><span class="line">    <span class="keyword">object</span> Idle: PlayerState()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: Song): PlayerState()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PlayingWithOptions</span>(song: Song, <span class="keyword">val</span> options: Options): Playing(song)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Playing 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？</p>
<p>当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。</p>
<h3 id="Kotlin-的密封接口"><a href="#Kotlin-的密封接口" class="headerlink" title="Kotlin 的密封接口"></a>Kotlin 的密封接口</h3><p>好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> t: Throwable): PlayerState</span><br><span class="line">    <span class="keyword">object</span> Idle: PlayerState</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Playing</span>(<span class="keyword">val</span> song: Song): PlayerState</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PlayingWithOptions</span>(song: Song, <span class="keyword">val</span> options: Options): Playing(song)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png"></p>
<p>而且你会神奇的发现，内联类跟密封接口可以一起使用了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里！</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> t: Throwable): PlayerState</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> playerState: PlayerState = Idle</span><br><span class="line">...</span><br><span class="line">playerState = Error(...) <span class="comment">// 装箱</span></span><br></pre></td></tr></table></figure>

<p>所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。</p>
<p>稍微提一句，官方在 <a href="https://youtrack.jetbrains.com/issue/KT-42434">KT-42434 Release inline classes as Stable, secure Valhalla compatibility</a> 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 <a href="https://openjdk.java.net/projects/valhalla/">Valhalla</a> 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>news</tag>
        <tag>sealed interface</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</title>
    <url>/2020/05/08/kotlin-swift-property-delegate/</url>
    <content><![CDATA[<blockquote>
<p>Swift 的属性代理，见识一下 </p>
</blockquote>
<span id="more"></span>




<blockquote>
<p>Swift：我不是我没有别瞎说。</p>
</blockquote>
<p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p>
<h2 id="Kotlin-的属性代理（Property-Delegate）"><a href="#Kotlin-的属性代理（Property-Delegate）" class="headerlink" title="Kotlin 的属性代理（Property Delegate）"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p>
<h3 id="简化存储的读写"><a href="#简化存储的读写" class="headerlink" title="简化存储的读写"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class="line">prefs.putString(key, value)</span><br><span class="line">prefs.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="keyword">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure>

<p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p>
<p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loginName <span class="keyword">by</span> pref(context, default = <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// save &quot;bennyhuo&quot; as key &quot;loginName&quot;</span></span><br><span class="line">loginName = <span class="string">&quot;bennyhuo&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// load key &quot;loginName&quot; from SharedPreferences</span></span><br><span class="line"><span class="keyword">val</span> currentLoginName = loginName </span><br></pre></td></tr></table></figure>

<p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Preference</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> name: String, </span><br><span class="line">        <span class="keyword">val</span> default: T, <span class="keyword">val</span> prefName: String = <span class="string">&quot;default&quot;</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> prefs <span class="keyword">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), default)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findProperName</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;)</span></span> = <span class="keyword">if</span>(name.isEmpty()) property.name <span class="keyword">else</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">findPreference</span><span class="params">(name: <span class="type">String</span>, default: <span class="type">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: Any = <span class="keyword">when</span> (default) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; getString(name, default)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res <span class="keyword">as</span> U</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;U&gt;</span> <span class="title">putPreference</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; putString(name, value)</span><br><span class="line">            ...</span><br><span class="line">        &#125;.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他数据类型的支持大家可以根据需要自行扩展。</p>
<p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Preference</span>&lt;<span class="type">T</span>&gt;(...) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> findPreference(findProperName(property), default)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        putPreference(findProperName(property), value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p>
<p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href="https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt">AbsProperties.kt</a>。</p>
<p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name : String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age  : <span class="built_in">Int</span>    <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p>
<p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p>
<h3 id="控制属性的生命周期"><a href="#控制属性的生命周期" class="headerlink" title="控制属性的生命周期"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textView <span class="keyword">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure>

<p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p>
<p>我们再来看个例子。</p>
<p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> image: Bitmap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        image = <span class="literal">null</span> <span class="comment">// Error!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p>
<p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p>
<p>但如果我们用属性代理来控制对象的内部逻辑呢：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> image <span class="keyword">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        image = Bitmap.create(...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        image.recycle()</span><br><span class="line">        <span class="comment">// release the Bitmap instance.</span></span><br><span class="line">        ::image.release() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">releasableNotNull</span><span class="params">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReleasableNotNull</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span> = value != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> (getDelegate() <span class="keyword">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalAccessException(<span class="string">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p>
<p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href="https://github.com/enbandari/ReleasableVar">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p>
<blockquote>
<p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p>
</blockquote>
<h3 id="代理其他类属性或者方法"><a href="#代理其他类属性或者方法" class="headerlink" title="代理其他类属性或者方法"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p>
<p>假设我们现在有这么一类，它有一些方法和属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapped</span>(<span class="keyword">var</span> x: <span class="built_in">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> z = <span class="number">10L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setY</span><span class="params">(y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getY</span><span class="params">()</span></span> = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的实例会被包在另一个类当中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span> = ...</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = ...</span><br><span class="line">    <span class="keyword">val</span> z: <span class="built_in">Long</span> = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = wrapped.x</span><br><span class="line">        <span class="keyword">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">by</span> wrapped::x.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> KProperty0<span class="type">&lt;T&gt;</span>.<span class="title">delegator</span><span class="params">(initializedValue: <span class="type">T</span>? = <span class="literal">null</span>)</span></span></span><br><span class="line">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class="line">        = ObjectPropertyDelegate0(</span><br><span class="line">            propertyRef = <span class="keyword">this</span> <span class="keyword">as</span> PropertyReference, </span><br><span class="line">            initializedValue = initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ObjectPropertyDelegate0</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">        <span class="keyword">val</span> getter: (() -&gt; T), </span><br><span class="line">        <span class="keyword">val</span> setter: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        propertyRef: PropertyReference, </span><br><span class="line">        initializedValue: T? = <span class="literal">null</span></span><br><span class="line">        ): <span class="keyword">this</span>(</span><br><span class="line">            (propertyRef <span class="keyword">as</span> KProperty0&lt;T&gt;)::<span class="keyword">get</span>, </span><br><span class="line">            <span class="keyword">if</span> (propertyRef <span class="keyword">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class="keyword">as</span> KMutableProperty0&lt;T&gt;)::<span class="keyword">set</span> <span class="keyword">else</span> <span class="literal">null</span>, initializedValue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> getter.invoke()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        setter?.invoke(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Wrapped = Wrapped(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">by</span> wrapped::setY.delegator(defaultValue = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> yGetter <span class="keyword">by</span> wrapped::getY.delegator()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p>
<p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href="https://github.com/enbandari/ObjectPropertyDelegate">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p>
<p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="string">&quot;newName&quot;</span>))</span></span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 <code>KProperty0&lt;R&gt;</code> 实现了 <code>getValue</code> 和 <code>setValue</code> 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KProperty0<span class="type">&lt;R&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> KMutableProperty0<span class="type">&lt;R&gt;</span>.<span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">R</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">set</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 <code>KProperty0</code> 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p>
<h2 id="Swift-的属性包装器（Property-Wrapper）"><a href="#Swift-的属性包装器（Property-Wrapper）" class="headerlink" title="Swift 的属性包装器（Property Wrapper）"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p>
<p>大家也可以参考 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p>
<p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p>
<h3 id="代理-UserDefaults"><a href="#代理-UserDefaults" class="headerlink" title="代理 UserDefaults"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserDefault</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as?</span> <span class="type">T</span> <span class="operator">??</span> defaultValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="type">UserDefaults</span>.standard.set(newValue, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GlobalSettings</span> &#123;</span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p>
<p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p>
<p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p>
<p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PropertyWrapper</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: Value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Value</span>)</span></span> &#123;</span><br><span class="line">        wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableDelegate</span>&lt;<span class="type">Value</span>&gt;(</span><br><span class="line">    initializedValue: Value,</span><br><span class="line">    <span class="keyword">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> wrappedValue: Value = initializedValue</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">val</span> previous = field</span><br><span class="line">            field = value</span><br><span class="line">            changedListener(previous, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法没有什么特殊之处：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">&quot;changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">state = <span class="number">2</span> <span class="comment">// changed 0 -&gt; 2</span></span><br><span class="line">state = <span class="number">3</span> <span class="comment">// changed 2 -&gt; 3</span></span><br><span class="line">state = <span class="number">4</span> <span class="comment">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure>

<h3 id="属性包装器的-projectedValue"><a href="#属性包装器的-projectedValue" class="headerlink" title="属性包装器的 projectedValue"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isEnabled: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$isEnabled</span>) &#123;</span><br><span class="line">            isEnabled <span class="operator">?</span> <span class="type">Text</span>(<span class="string">&quot;Click to disable&quot;</span>).foregroundColor(.red)</span><br><span class="line">                : <span class="type">Text</span>(<span class="string">&quot;Click to enable&quot;</span>).foregroundColor(.green)</span><br><span class="line">        &#125;.padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png"></p>
<p><strong><center>isEnabled 为 false 时的 UI</center></strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png"></p>
<p><strong><center>isEnabled 为 true 时的 UI</center></strong></p>
<p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p>
<p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p>
<p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p>
<p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@frozen</span> <span class="keyword">@propertyWrapper</span> <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">State</span>&lt;<span class="title class_">Value</span>&gt; : <span class="title class_">DynamicProperty</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">value</span>: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initialize with the provided initial value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">initialValue</span> <span class="params">value</span>: <span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The current state value.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123; <span class="keyword">get</span> <span class="keyword">nonmutating</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Produces the binding referencing this state value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p>
<p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get property reference</span></span><br><span class="line"><span class="keyword">val</span> view = View()</span><br><span class="line"><span class="keyword">val</span> isEnabledRef = view::isEnabled</span><br><span class="line"></span><br><span class="line"><span class="comment">// operate on property reference</span></span><br><span class="line">isEnabledRef.<span class="keyword">set</span>(<span class="literal">true</span>)</span><br><span class="line">println(isEnabledRef.<span class="keyword">get</span>())</span><br></pre></td></tr></table></figure>

<p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p>
<p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserDefault</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> defaultValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">UserDefault</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GlobalSettings</span> &#123;</span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isFooFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>.wrappedValue) </span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">GlobalSettings</span>.<span class="variable">$isBarFeatureEnabled</span>.projectedValue) </span><br></pre></td></tr></table></figure>

<p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GlobalSettings</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UserDefault</span>(key: <span class="string">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> isBarFeatureEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">getIsBarFeatureEnabledWrapper</span>() -&gt; <span class="type">UserDefault</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        _isBarFeatureEnabled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p>
<p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">interface</span> <span class="title class_">KProperty0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">KProperty</span>&lt;<span class="type">R</span>&gt;, <span class="type"></span>() -&gt; R &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"><span class="keyword">val</span> delegate = ObservableDelegate(<span class="number">0</span>) &#123; previous, current -&gt;</span><br><span class="line">    println(<span class="string">&quot;changed <span class="variable">$previous</span> -&gt; <span class="variable">$current</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> state <span class="keyword">by</span> delegate</span><br></pre></td></tr></table></figure>

<p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p>
<p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p>
<p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p>
<p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>swift</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 协程版的 AutoDispose</title>
    <url>/2019/01/07/kotlin_AutoDispose/</url>
    <content><![CDATA[<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>
<p>因此大家一定会用到 Uber 的开源框架 <a href="https://github.com/uber/AutoDispose">AutoDispose</a>。</p>
<span id="more"></span>

<p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Listener</span> <span class="keyword">extends</span> <span class="title class_">MainThreadDisposable</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnAttachStateChangeListener &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableObserver observer;</span><br><span class="line"></span><br><span class="line">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class="line">    <span class="built_in">this</span>.view = view;</span><br><span class="line">    <span class="built_in">this</span>.observer = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">    <span class="comment">//看到没看到没看到没？</span></span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDispose</span><span class="params">()</span> &#123;</span><br><span class="line">    view.removeOnAttachStateChangeListener(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.onClick &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onClickAutoDisposable</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context: <span class="type">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class="line"><span class="params"><span class="function">        handler: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">v</span>: <span class="type">android</span>.<span class="type">view</span>.<span class="type">View</span>?) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; v -&gt;</span><br><span class="line">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class="line">            handler(v)</span><br><span class="line">        &#125;.asAutoDisposable(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p>
<blockquote>
<p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p>
</blockquote>
<p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Job.<span class="title">asAutoDisposable</span><span class="params">(view: <span class="type">View</span>)</span></span> = AutoDisposableJob(view, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDisposableJob</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View, <span class="keyword">private</span> <span class="keyword">val</span> wrapped: Job)</span><br><span class="line">    <span class="comment">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class="line">     : Job <span class="keyword">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//当 View 被移除的时候，取消协程</span></span><br><span class="line">        cancel()</span><br><span class="line">        view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewAttached</span><span class="params">()</span></span> =</span><br><span class="line">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isViewAttached()) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class="line">        invokeOnCompletion() &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们就可以使用这个扩展了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.onClickAutoDisposable&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> req = Request()</span><br><span class="line">        <span class="keyword">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class="line">        updateUI(resp)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>Coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</title>
    <url>/2018/12/17/kotlin_native_jni/</url>
    <content><![CDATA[<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p>
<p>后来，我发现根本不需要这么麻烦啊。</p>
<span id="more"></span>

<p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure>

<p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p>
<p>那么假如我们有下面的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String  <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p>
<p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">kotlin &#123;</span><br><span class="line">    targets &#123;</span><br><span class="line">        fromPreset(presets.androidNativeArm32, <span class="string">&#x27;HelloWorld&#x27;</span>) <span class="comment">// ① 配置为 Android 的工程</span></span><br><span class="line"></span><br><span class="line">        configure([HelloWorld]) &#123;</span><br><span class="line">            compilations.main.outputKinds <span class="string">&#x27;DYNAMIC&#x27;</span> <span class="comment">// ② 配置为动态链接库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.cinterop.*</span><br><span class="line"><span class="keyword">import</span> platform.android.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@CName(<span class="string">&quot;Java_com_example_hellojni_HelloJni_stringFromJNI&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class="string">&quot;This is from Kotlin Native!!&quot;</span>.cstr.ptr)!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p>
<p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;knlib&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> (TextView)findViewById(R.id.hello_textview);</span><br><span class="line">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure>

<p>接下来我再给大家看几个例子：</p>
<p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="string">&quot;Java_com_example_hellojni_HelloJni_sayHello&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class="string">&quot;Kn&quot;</span>, <span class="string">&quot;Hello %s&quot;</span>, <span class="string">&quot;Native&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在 Kotlin Native 当中调用 Java 的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CName(<span class="string">&quot;Java_com_example_hellojni_HelloJni_callLoop&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLoop</span><span class="params">(env: <span class="type">CPointer</span>&lt;<span class="type">JNIEnvVar</span>&gt;, thiz: <span class="type">jobject</span>)</span></span>: jstring &#123;</span><br><span class="line">    memScoped &#123;</span><br><span class="line">        <span class="keyword">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class="line">        <span class="keyword">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class="line">        <span class="keyword">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class="string">&quot;callFromNative&quot;</span>.cstr.ptr, <span class="string">&quot;()Ljava/lang/String;&quot;</span>.cstr.ptr)</span><br><span class="line">        <span class="keyword">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class="literal">null</span>) <span class="keyword">as</span> jstring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>callFromNative</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">callFromNative</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is from Java!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p>
<p>本文涉及源码参见：<a href="https://github.com/enbandari/hello-kni">hello-kni</a></p>
<hr>
<p>转载请注明出处：微信公众号 Kotlin</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>Kotlin-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin、Swift、Scala 的延迟求值</title>
    <url>/2020/05/23/lazy-evaluation/</url>
    <content><![CDATA[<blockquote>
<p>“懒”是程序员最优秀的品质之一，程序也是如此。 </p>
</blockquote>
<span id="more"></span>




<blockquote>
<p>最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~</p>
</blockquote>
<h2 id="Kotlin-的延迟求值"><a href="#Kotlin-的延迟求值" class="headerlink" title="Kotlin 的延迟求值"></a>Kotlin 的延迟求值</h2><p>Kotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。</p>
<p>这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lazyValue <span class="keyword">by</span> lazy &#123; </span><br><span class="line">    complicatedComputing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 <code>&amp;&amp;</code> 运算中的逻辑短路。代码中，it.value 的 it 是 <code>Lazy&lt;Boolean&gt;</code> 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。</p>
<p>接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnFalse</span><span class="params">()</span></span> = <span class="literal">false</span>.also &#123; println(<span class="string">&quot;returnFalse called.&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">returnTrue</span><span class="params">()</span></span> = <span class="literal">true</span>.also &#123; println(<span class="string">&quot;returnTrue called.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们调用 assertAllTrue 来看看会发生什么：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(lazy &#123; returnFalse() &#125;, lazy &#123; returnTrue() &#125;)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">returnFalse called.</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>不意外吧？我们还可以模拟 <code>||</code> 再实现一个类似的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAnyTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Lazy</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.any &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。</p>
<p>简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。</p>
<p>除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">assertAllTrue</span><span class="params">(<span class="keyword">vararg</span> conditions: () -&gt; <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> conditions.all &#123; it.invoke() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(&#123; returnFalse() &#125;, ::returnTrue, ::returnFalse)</span><br></pre></td></tr></table></figure>

<p>对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。</p>
<h2 id="Scala-的延迟求值"><a href="#Scala-的延迟求值" class="headerlink" title="Scala 的延迟求值"></a>Scala 的延迟求值</h2><p>在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。</p>
<p>Kotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeConsumingWork</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> stopTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"><span class="keyword">val</span> startTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">timeConsumingWork()</span><br><span class="line">println(stopTime - startTime)</span><br></pre></td></tr></table></figure>

<p>我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 <code>System.currentTimeMillis()</code> 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。</p>
<p>哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。</p>
<p>我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: (() =&gt; <span class="type">Boolean</span>)*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.apply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>() =&gt; Boolean</code> 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。</p>
<p>用法如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertAllTrue(returnFalse, returnTrue, () =&gt; returnFalse())</span><br></pre></td></tr></table></figure>

<p>注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 <code>() =&gt; returnFalse()</code> 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。</p>
<p>Hmmm，这么看起来跟 Kotlin 真是一模一样啊。</p>
<p>非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertBothTrue</span></span>(left: =&gt; <span class="type">Boolean</span>, right: =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    left &amp;&amp; right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。</p>
<p>函数体内的最后一行就是函数的返回值，所以 <code>left &amp;&amp; right</code> 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 <code>=&gt;</code>，说它是函数类型吧， <code>=&gt;</code> 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。</p>
<p>接下来我们看下怎么使用：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。</p>
<p>整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。</p>
<p>哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanByName</span>(<span class="params">value: =&gt; <span class="type">Boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valueByName</span></span>: <span class="type">Boolean</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllTrue</span></span>(conditions: <span class="type">BooleanByName</span>*): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    conditions.forall(_.valueByName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 <code>_.valueByName</code>），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。</p>
<h2 id="Swift-的延迟求值"><a href="#Swift-的延迟求值" class="headerlink" title="Swift 的延迟求值"></a>Swift 的延迟求值</h2><p>最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。</p>
<p>Swift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> value <span class="operator">=</span> complicatedComputing()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">complicatedComputing</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="operator">...</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 <code>lazy let value = ...</code>，Swift 编译器会抱怨说 lazy 只能修饰 var。</p>
<p>纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？</p>
<p>其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？</p>
<p>当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">private(set)</span> <span class="keyword">lazy</span> <span class="keyword">var</span> value <span class="operator">=</span> <span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。</p>
<p>接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">assertAllTrue</span>(<span class="keyword">_</span> <span class="params">conditions</span>: () -&gt; <span class="type">Bool</span> <span class="operator">...</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    conditions.allSatisfy &#123; condition <span class="keyword">in</span> condition() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。</p>
<ul>
<li>参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。</li>
<li><code>() -&gt; Bool</code> 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 … 则表示这个参数为变长参数。</li>
<li><code>&#123; condition in condition() &#125;</code> 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 <code>&#123; (condition: () -&gt; Bool) in condition() &#125;</code>，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 <code>() -&gt; Bool</code>。</li>
</ul>
<p>好，那我们下面调用一下这个函数试试看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> assertAllTrue(&#123; returnFalse() &#125;, returnTrue, returnFalse)</span><br></pre></td></tr></table></figure>

<p>第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。</p>
<p>这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">assertBothTrue</span>(<span class="keyword">_</span> <span class="params">left</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>, <span class="keyword">_</span> <span class="params">right</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    left() <span class="operator">&amp;&amp;</span> right()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那调用时有什么不一样呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> assertBothTrue(returnFalse(), returnTrue())</span><br></pre></td></tr></table></figure>

<p>我们直接传入表达式，Swift 会帮我们用 <code>&#123;&#125;</code> 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。</p>
<p>简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。</p>
<h2 id="再来一个有趣的例子"><a href="#再来一个有趣的例子" class="headerlink" title="再来一个有趣的例子"></a>再来一个有趣的例子</h2><p>当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。</p>
<p>常见的语言当中都有 <code>while</code> 循环，为什么没有 <code>whileNot</code> 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whileNot</span><span class="params">(condition: () -&gt; <span class="type">Boolean</span>, action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!condition()) &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition, action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[Kotlin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(&#123; i &lt; <span class="number">0</span> &#125;)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出就是 10 9 … 0</p>
<p>Scala 呢？</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileNot</span></span>(condition: =&gt; <span class="type">Boolean</span>)(action: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">        action</span><br><span class="line">        whileNot(condition)(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能让第二个参数用 <code>&#123; ... &#125;</code> 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[<span class="type">Scala</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">whileNot(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>矮？是不是有那味了？这看着跟 while 已经没差了。</p>
<p>下面是 Swift 的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">whileNot</span>(<span class="keyword">_</span> <span class="params">condition</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>, <span class="keyword">_</span> <span class="params">action</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>condition() &#123;</span><br><span class="line">        action()</span><br><span class="line">        whileNot(condition(), action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我似乎已经感觉到了那味儿~</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="type">Swift</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">whileNot(i <span class="operator">&lt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。</p>
<p>看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 <code>&#123;&#125;</code>，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 <code>&#123;&#125;</code> 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。</p>
<p>其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下：</p>
<ol>
<li>Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点</li>
<li>Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性</li>
<li>Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。</li>
<li>他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。</li>
<li>Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。</li>
<li>Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。</li>
</ol>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>swift</tag>
        <tag>scala</tag>
        <tag>lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>== 与 equals 居然结果不一样！</title>
    <url>/2019/03/23/nan-equals/</url>
    <content><![CDATA[<h3 id="与-equals-意见不一致的情况"><a href="#与-equals-意见不一致的情况" class="headerlink" title="== 与 equals 意见不一致的情况"></a>== 与 equals 意见不一致的情况</h3><p>Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。</p>
<p>一般情况下这种说法是没问题的，连 IDE 也都会提示你：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg"></p>
<p>要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg"></p>
<p>这回居然不提示我了！所以这里面一定有鬼！</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(equals)</span><br><span class="line">println(equals2)</span><br></pre></td></tr></table></figure>

<p>你们猜猜结果如何？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg"><br>我去，说好的 == 等价于 equals 呢？</p>
<p>完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。</p>
<span id="more"></span>

<p>以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？</p>
<blockquote>
<p>NaN = Not a Number</p>
</blockquote>
<p>NaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。</p>
<h3 id="Jvm-的为什么"><a href="#Jvm-的为什么" class="headerlink" title="Jvm 的为什么"></a>Jvm 的为什么</h3><p>下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，</p>
<p>== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg"></p>
<p>而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>floatToIntBits</code> 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。</p>
<h3 id="JavaScript-的为什么"><a href="#JavaScript-的为什么" class="headerlink" title="JavaScript 的为什么"></a>JavaScript 的为什么</h3><p>在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = kotlin_js_internal_FloatCompanionObject.<span class="property">NaN</span> === kotlin_js_internal_FloatCompanionObject.<span class="property">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> equals2 = <span class="title function_">equals</span>(kotlin_js_internal_FloatCompanionObject.<span class="property">NaN</span>, kotlin_js_internal_FloatCompanionObject.<span class="property">NaN</span>);</span><br></pre></td></tr></table></figure>

<p>而 <code>kotlin_js_internal_FloatCompanionObject.NaN</code> 又等价于 <code>Number.NaN</code>，因此上面的代码其实就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> equals_0 = <span class="title class_">Number</span>.<span class="property">NaN</span> === <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> equals2 = <span class="title function_">equals</span>(<span class="title class_">Number</span>.<span class="property">NaN</span>, <span class="title class_">Number</span>.<span class="property">NaN</span>);</span><br></pre></td></tr></table></figure>

<p>对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Kotlin</span>.<span class="property">equals</span> = <span class="keyword">function</span> (<span class="params">obj1, obj2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 == <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj1 !== obj1) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj2 !== obj2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj1.<span class="property">equals</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1.<span class="title function_">equals</span>(obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj1 === obj2 &amp;&amp; (obj1 !== <span class="number">0</span> || <span class="number">1</span> / obj1 === <span class="number">1</span> / obj2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg"></p>
<p>这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。</p>
<h3 id="其他情况的讨论"><a href="#其他情况的讨论" class="headerlink" title="其他情况的讨论"></a>其他情况的讨论</h3><p>对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。</p>
<p>实际上对于基本类型，Kotlin 的 == 和  equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。</p>
<hr>
<ul>
<li>Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~</li>
<li>腾讯地图数据业务，坐标 <strong>北京中关村</strong></li>
<li>有兴趣的小伙伴可以发简历到 <a href="mailto:&#x62;&#101;&#110;&#x6e;&#121;&#104;&#x75;&#111;&#64;&#107;&#111;&#116;&#x6c;&#x69;&#x6e;&#x65;&#x72;&#46;&#x63;&#x6e;">&#x62;&#101;&#110;&#x6e;&#121;&#104;&#x75;&#111;&#64;&#107;&#111;&#116;&#x6c;&#x69;&#x6e;&#x65;&#x72;&#46;&#x63;&#x6e;</a> 哈~</li>
</ul>
<hr>
<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程啦！</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>说一件小事</title>
    <url>//2023/03/29/new-name-and-new-journey/</url>
    <content><![CDATA[<blockquote>
<p>微信公众号 “Kotlin” 即将更名为 “霍丙乾 bennyhuo”，作为我的个人公众号为大家分享技术内容。 </p>
</blockquote>
<span id="more"></span>






<h2 id="微信公众号-“Kotlin”-是怎么来的？"><a href="#微信公众号-“Kotlin”-是怎么来的？" class="headerlink" title="微信公众号 “Kotlin” 是怎么来的？"></a>微信公众号 “Kotlin” 是怎么来的？</h2><p>过去的几年里，我一直专注于研究和推广 Kotlin。从 2016 年开始，我注册了微信公众号 “Kotlin”，用来推送我录制的 Kotlin 入门视频，并且在这个号上面定期发布 Kotlin 相关的技术文章以及组织的各类活动。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330075842.png">  </p>
<p>最初，JetBrains 没有在国内投入专门的资源来推广 Kotlin。后来圣佑加入 Kotlin，成为 JetBrains 唯一的中文技术布道师，国内的活动、社区组织也才慢慢走上正轨。同时，在 Google 的助力下，Kotlin 成为大家熟知的现代编程语言，愿意学习 Kotlin 并且愿意输出 Kotlin 内容的开发者也越来越多。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329205933.png">  </p>
<p>2020 年写完书之后，我开始研究一些与 Kotlin 关联不大的内容，顺便出了一门 C 语言课。这门课的同学经常催我出一门 C++ 的课，于是我开始在 B 站发 C++ 视频，还写了一系列“渡劫 C++ 协程”的文章。随着我涉猎的内容方向就越来越广泛，这些内容与微信公众号 “Kotlin” 的名字产生了比较大的违和感。</p>
<p>经过两年时间的探索和思考，我终于下定决心做出一些改变。我向 JetBrains 提了一下我的想法，得到了他们的赞同，于是现在我们终于有了官方的 Kotlin 微信公众号啦！如果大家希望关注 Kotlin 官方的动态，请一定关注官方公众号 “Kotlin开发者”。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329212925.png">  </p>
<p>至此，以我个人名义注册的微信公众号 “Kotlin” 已经完成了它的使命。接下来，它将作为我的个人公众号，继续向关注我的朋友们推送我的个人思考和技术分享。</p>
<h2 id="还会推送-Kotlin-相关的内容吗？"><a href="#还会推送-Kotlin-相关的内容吗？" class="headerlink" title="还会推送 Kotlin 相关的内容吗？"></a>还会推送 Kotlin 相关的内容吗？</h2><p>当然！</p>
<p>毫不客气甚至有些骄傲地说，所有编程语言里面，我最擅长的就是 Kotlin。我会持续关注 Kotlin 的最新动态和发展方向，也会与 JetBrains 的朋友们保持联系，在需要的时候参与 Kotlin 相关的活动。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214234.png">  </p>
<p>今年，我还将出版一本 Kotlin 的新书，书名暂定为《深入实践 Kotlin 元编程》，内容主要包括注解处理器、编译器插件等。这些内容基本上是我通过反复阅读 Kotlin 编译器、Jetpack Compose 等项目的源码整理出来的。与《深入理解 Kotlin 协程》类似，这本书的内容对于知识的剖析较为深入，阅读起来有一定的挑战性，相信一定能够给读者带来一些启发。届时，公众号也会推送相关的内容作为补充，方便读者了解其中的细节。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330070944.png">  </p>
<p>哦对了，我还是一名 Kotlin GDE，组织上也会要求我们定期输出相关的视频、文章。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230329214632.png">  </p>
<p>除了 Kotlin 相关的内容以外，我也会输出一些 C/C++、Java、JavaScript 甚至 Rust 相关的内容。具体什么内容可能取决于我那一段时间的兴趣和投入。</p>
<p>之前有朋友跟我说，其实这些跟 Kotlin 都有关系，因为 Kotlin 要支持多平台嘛。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230330071605.png">  </p>
<h2 id="目前主要在哪些平台输出内容？"><a href="#目前主要在哪些平台输出内容？" class="headerlink" title="目前主要在哪些平台输出内容？"></a>目前主要在哪些平台输出内容？</h2><p>目前我输出内容的形式主要是文章和视频，在公众号更名之后，发布的平台主要是以下几个：</p>
<ul>
<li>Bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>YouTube：<a href="https://www.youtube.com/channel/UCt47g8sEoUkI6R855ol3Gdw"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
<li>掘金：<a href="https://juejin.cn/user/1187128286120631"><strong>霍丙乾 bennyhuo</strong></a></li>
</ul>
<p>当然，也欢迎大家收藏我的个人主页和 GitHub：</p>
<ul>
<li>个人主页：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a> </li>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
</ul>
<p>感谢大家一如既往的支持。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>公众号</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>重构代码的时候千万小心，SAM 转换可能会引发一个奇怪的运行时类不能访问的异常</title>
    <url>/2021/06/03/sam-meets-package-visibility/</url>
    <content><![CDATA[<blockquote>
<p>SAM 转换是很香，不过还是要小心遇到坑 </p>
</blockquote>
<iframe class="bilibili"  src="//player.bilibili.com/player.html?bvid=BV1wB4y1g79W&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<span id="more"></span>




<p>SAM 转换是一个非常有用的特性，这个特性不只在 Kotlin 当中有，Java 当中也有。</p>
<p>从 Java 8 开始，Java 当中引入了对 Lambda 的支持，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">View</span>();</span><br><span class="line">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;w: &quot;</span> + width + <span class="string">&quot;, h: &quot;</span> + height);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里 View 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">OnSizeChangedListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnSizeChangedListener</span><span class="params">(OnSizeChangedListener onSizeChangedListener)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于形如 <code>OnSizeChangedListener</code> 这样具有单一方法的接口（注意，必须是接口），我们就可以用 Lambda 来简化调用处的写法，所以下面两种写法基本可以认为是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SAM 转换的写法</span></span><br><span class="line">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;w: &quot;</span> + width + <span class="string">&quot;, h: &quot;</span> + height);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类的写法</span></span><br><span class="line">view.setOnSizeChangedListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnSizeChangedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;w: &quot;</span> + width + <span class="string">&quot;, h: &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然它们不是完全等价的，区别主要是 <code>this</code> 的问题，这个我们就不展开了。</p>
<p>既然 Java 可以，Kotlin 肯定不能落后的。所以就有了下面的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class="line">    println(<span class="string">&quot;w: <span class="variable">$width</span>, h: <span class="variable">$height</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，了解了这些之后，我们就来看下今天我们想要讲的问题。</p>
<h2 id="包内可见的类？"><a href="#包内可见的类？" class="headerlink" title="包内可见的类？"></a>包内可见的类？</h2><p>对于我这样一个写了 Kotlin 5 年以上的人来讲，这个问题实在是太令人困惑了。我们先来给大家看下代码的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">samissue</span><br><span class="line">    ├── Java8Sam.java</span><br><span class="line">    ├── KotlinSam.kt</span><br><span class="line">    ├── View.java</span><br><span class="line">    └── sub</span><br><span class="line">         └── SubSam.kt</span><br></pre></td></tr></table></figure>

<p>SubSam.kt 的内容如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bennyhuo.kotlin.samissue.sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bennyhuo.kotlin.samissue.View</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class="line">        println(<span class="string">&quot;w: <span class="variable">$width</span>, h: <span class="variable">$height</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看下 View.java 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bennyhuo.kotlin.samissue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">OnSizeChangedListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnSizeChangedListener</span><span class="params">(OnSizeChangedListener onSizeChangedListener)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这代码有什么问题吗？这时候就需要各位发动自己脑子当中的编译器来反复找茬儿了。反正我第一眼看到这个代码的时候并没有意识到会有什么问题，编译也没什么毛病，就是运行时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalAccessError: class com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 cannot access its superinterface com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener (com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 and com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener are in unnamed module of loader &#x27;app&#x27;)</span><br><span class="line">	at java.base/java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)</span><br><span class="line">	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800)</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698)</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621)</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579)</span><br><span class="line">	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)</span><br><span class="line">	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)</span><br><span class="line">	at com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt:6)</span><br><span class="line">	at com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt)</span><br></pre></td></tr></table></figure>


<p>我一开始觉得可能是编译缓存导致的问题，于是花了十几分钟在 clean 和 reBuild 上，非常恼火。这代码怎么看都不像有问题，实际上我一开始没有能发现这个问题大概就是 Kotlin 写太久了，默认一切都是 public 的了。后来仔细看了下这个问题，又仔细看了下代码，瞬间捕捉到了这个细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnSizeChangedListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口是包内可见！所以 SubSam.kt 这个文件自然是不应当能够访问到它的。</p>
<p>可是问题又来了，为什么编译器没报错？因为 SAM 转换。注意这个类名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.<span class="title">bennyhuo</span>.<span class="title">kotlin</span>.<span class="title">samissue</span>.<span class="title">sub</span>.<span class="title">SubSamKt</span>$<span class="title">main</span>$1</span><br></pre></td></tr></table></figure>

<p>这是错误信息当中提示我们的，这个类其实就是我们的 Lambda 表达式经过 SAM 转换之后生成的类。这个类在编译前不存在，编译之后才生成的，它生成的时机看来是晚于类的可见性检查的，于是就成了编译期的漏网之鱼。</p>
<p>这，我觉得可以算是一个编译器的 BUG　吧。于是我去 YouTrack 提了个 BUG：<a href="https://youtrack.jetbrains.com/issue/KT-47104%E3%80%82">https://youtrack.jetbrains.com/issue/KT-47104。</a></p>
<p>解决办法其实很简单，接口改成 public 或者移入相同的包。实际上我们一般情况下也不会把接口约束成包内可见，这个问题并不会对我们造成代码设计上的影响，只是，万一遇到确实有点儿一时手足无措，发现了问题所在之后又着实尴尬。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>SAM 转换其实是 Kotlin 非常吸引人的一个特性，1.4 引入的 fun interface 则让它更加强大。不过，请大家千万注意，Lambda 不管是在 Java 还是 Kotlin 当中，编译时都大概率会生成一个类（有时候也会只生成几条指令），这往往也是引发问题的根源所在。</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>java</tag>
        <tag>sam</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 总结 - bennyhuo</title>
    <url>//2022/01/20/summary-2021/</url>
    <content><![CDATA[<blockquote>
<p>很快啊，2021 年就过去了 …… </p>
</blockquote>
<span id="more"></span>






<p>想了挺久，还是写个总结吧。毕竟 2021 年还是挺有趣的一年。</p>
<h2 id="视频内容输出"><a href="#视频内容输出" class="headerlink" title="视频内容输出"></a>视频内容输出</h2><p>从 2017 年开始，我几乎每年在慕课网上出一套课程：</p>
<ul>
<li>2017.06：<a href="https://coding.imooc.com/class/108.html">Kotlin入门与进阶</a></li>
<li>2018.06：<a href="https://coding.imooc.com/class/232.html">Kotlin高级特性与框架设计</a></li>
<li>2019.02：<a href="https://coding.imooc.com/class/317.html">破解Android高级面试</a></li>
<li>2019.05：<a href="https://www.imooc.com/learn/1128">破解Retrofit</a></li>
<li>2019.11：<a href="https://coding.imooc.com/class/398.html">新版Kotlin从入门到精通</a></li>
<li>2020.11：<a href="https://coding.imooc.com/class/463.html">C语言系统化精讲</a></li>
</ul>
<p>跟慕课网的教学经理交流，听说有的老师可以做到一个月出一门课，我说我做不到啊，光录视频剪视频我一个月都下不来。就这样每次课程的制作时间都会花去我半年的业余时间，特别累。</p>
<p>从去年（2021 年）开始，我决定短时间先不出课程了，一方面身体吃不消，另一方面我也希望多在社区上投入一些精力。</p>
<p>于是 2021 年我在 B 站发了 70 个视频：</p>
<p><strong><a href="https://space.bilibili.com/28615855">bennyhuo 不是算命的</a></strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-11-44-15.png"></p>
<p>视频内容主要涉及 <strong>Kotlin 1.5、1.6 版本更新</strong>、<strong>Kotlin 协程 1.5 版本更新（1.6 的更新视频还在计划中）</strong>、<strong>Kotlin 的一些小知识</strong>、<strong>C++ 的一些有趣的知识点介绍</strong> 、<strong>Java 17</strong>、<strong>研发效率、技巧</strong> 等等内容。</p>
<p>订阅量从年初的 300 左右增长到 5900，基本达到了我的预期（5000），<strong>谢谢大家的关注和一键三连</strong>。</p>
<h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>疫情肆虐，保护好我们身边的人是当下最重要的事情。</p>
<p>我们绝大多数的活动都转到了线上。我在 2021 年参加了三次活动，分别是：</p>
<ul>
<li>2021.07 GDG 社区说：<a href="https://www.bilibili.com/video/BV1Tf4y157ku">Kotlin 编译器插件：我们究竟在期待什么？</a></li>
<li>2021.11 Kotlin 中文开发者大会：<a href="https://www.youtube.com/watch?v=1Vi4-UMsQNA&t=12563s">Kotlin 元编程：从注解处理器(KAPT)到符号处理器(KSP)</a></li>
<li>2021.12 京津冀 GDG DevFest：<a href="https://www.bilibili.com/video/BV1JY411H7pb">Kotlin 元编程：从注解处理器(KAPT)到符号处理器(KSP)</a></li>
</ul>
<p>你可能会奇怪，年底的两次活动怎么讲了一样的题目？确实一样，但内容上第二次有了新产出，所以也不算是重复讲同样的内容了。如果你对元编程的内容感兴趣，看 GDG 那次即可，内容上增加了单测的编写，以及基于 X Processing 一套代码实现 KAPT 和 KSP 的内容介绍等内容。</p>
<h2 id="GDE-的申请"><a href="#GDE-的申请" class="headerlink" title="GDE 的申请"></a>GDE 的申请</h2><p>这一年，我终于下定决心去申请一下 GDE。Google 负责社区的 Tracy 在 2020 年的时候就提过这个事儿，但我当时忙着做 C 语言的课程，实在是抽不出精力准备。毕竟 GDE，不认认真真准备怎么能行呢，万一被拒了岂不是很憋屈。</p>
<p>我在 2021 年 7 月开始，B 站视频停更了一个月，天天做英语听力和阅读，我倒是不太担心我做的东西不被认可，我主要是担心面试官不知道我在说什么（或者我不知道他在说什么）。</p>
<p>当然，后面的故事就有趣了起来，我的一面面试官是来自胡志明市的 <a href="https://developers.google.com/community/experts/directory/profile/profile-tran-toan">Tran Toan</a>，他的英语自然是非常流利的，他也非常照顾我，面试过程基本上就是我俩在愉快地聊天，探讨 Kotlin 的各种有意思的东西。二面面试官是来自 Google 的大佬<a href="https://mobile.twitter.com/fredchung">钟辉(Fred Chung)老师</a>，相信很多小伙伴都听过他的演讲，我之前在一次 JetBrains 的活动上与他一起做分享，可以说非常幸运了。</p>
<p>整个申请的过程都得到了 GDE 项目的负责人 Lily 的帮助和鼓励。</p>
<p>对了，最近我看到有些小伙伴比较疑惑，为什么凯哥（朱凯）和涛哥（朱涛）都是 Android &amp; Kotlin GDE，而我只是 Kotlin GDE。我稍微解释一下哈，GDE 项目的方向有很多，大家可以在 <a href="https://developers.google.com/community/experts/directory">Directory of Experts worldwide</a> 这个页面看到所有的 GDE，以及大家擅长的方向：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-12-27-58.png"></p>
<p>申请的时候可以根据自身实际情况去选择相应的方向，每个方向都有相应的方向的面试官约你面试，通过了就能获得这个方向的认证。</p>
<p>理论上我也可以试试申请 Android 方向，不过我觉得我在纯 Android 领域输出的内容不多，影响力也不太够，所以就只申请了 Kotlin（免得被打脸，哈哈）。</p>
<p>大家如果对 GDE 这个项目感兴趣，也欢迎大家找我了解相关信息，如果申请过程中需要帮助，我也会尽力帮助大家。</p>
<p>顺便说一句，通过 GDE 的认证以后，可以申请 JetBrains 全家桶 License，很香。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-12-36-33.png"></p>
<h2 id="换工作"><a href="#换工作" class="headerlink" title="换工作"></a>换工作</h2><p>这大概是我在 2021 年经历得最魔幻的一件事。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-12-47-41.png"></p>
<p>我在腾讯地图工作了 6 年多，做过地图 SDK，做过车机应用，做过数据采集工具；画过 UI，调过策略，写过框架；从被人带，到没人带，到带新人；经历了从 2-1 开始到 3-2 的所有答辩，运气比较好都一次通过；拿过三星及以上的所有绩效，走的时候绩效的奖牌装了一箱子；工位从第三极 8 楼到 10 楼，到 9 楼，再到 8 楼，再到北京总部大厦吸甲醛。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-12-48-24.png"></p>
<p>在腾讯这 6 年我收获了很多，但我最后因为想要体验走路 5 分钟到公司而换到了望京。在望京的公司里面，我选了小而美的猿辅导。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-12-51-11.png"></p>
<p>后来的事情可能大家都比较清楚了。我想对我影响比较大的大概是，工位搬了，走路 5 分钟变成了走路 10 分钟 = =、</p>
<h2 id="健身环"><a href="#健身环" class="headerlink" title="健身环"></a>健身环</h2><p>我这种不爱运动的胖子很难因为爱好和乐趣去活动，于是想试试健身环。</p>
<p>一开始还真小瞧它了，但随着游戏关卡难度的提升，这玩意越来越折磨人。</p>
<p>我大概在玩了两三个月的时候，对于游戏开始时要不要调高（或调低）难度的提示感到麻烦，于是索性把难度调到了最高的 30 级。结果我想多了，调到最高难度之后，它又隔几天问一下我是不是要调低难度，我感觉我被套路了，于是我再也没有搭理它。。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-13-19-09.png"></p>
<p>终于，在上周我完成了解救堕拉攻的任务，通过了基础的 23 关。运动时间（不包括剧情衔接、选关、买道具之类的时间，大概是游戏时间的一半）30 多个小时，我差不多每天平均 10 分钟，持续了 160 多天完成。体重从 170 涨到了 180，大概是因为我的胳膊和腿更粗了吧，另外腰突的问题似乎改善了不少。</p>
<p>基础模式通过以后解锁了额外 23 关，据说这 23 关打完还会有大师 23 关，还有各种任务要做，这个游戏应该可以玩很久。</p>
<h2 id="最重要的"><a href="#最重要的" class="headerlink" title="最重要的"></a>最重要的</h2><p>小家伙出生了，非常可爱，像她妈妈一样。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-01-20-14-04-53-gm.jpg"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家在 B 站关注我：<strong>bennyhuo 不是算命的</strong>。</p>
<p>也欢迎大家关注微信公众号：<strong>Kotlin</strong>。</p>
<p>2022 继续加油。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 总结 - bennyhuo</title>
    <url>//2022/12/31/summary-2022/</url>
    <content><![CDATA[<blockquote>
<p>也还是闲不住的一年呢。 </p>
</blockquote>
<span id="more"></span>






<p>一年又过去了。这一年也还是做了很多事情的。</p>
<h2 id="视频内容输出"><a href="#视频内容输出" class="headerlink" title="视频内容输出"></a>视频内容输出</h2><p>今年继续在 B 站发视频，欢迎关注：<a href="https://space.bilibili.com/28615855"><strong>bennyhuo 不是算命的</strong></a>。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221228152123.png">  </p>
<p>相比去年（2021 年），今年的视频大多数是读书视频。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Ni4y1U714/">《深入理解 Kotlin 协程》完结 共 16 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1vv4y1A7fX/">《渡劫 C++ 协程》完结 共 7 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1UY4y1z7W7/">《TypeScript 入门》完结 共 10 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1Fu411Q7af/">《Dart 开发语言概览》完结 共 17 集</a></li>
<li><a href="https://www.bilibili.com/video/BV13T4y1k7qQ/">《现代 C++ 特性解析》更新至第六章，共 11 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1HB4y1C7zH/">《Effective Python》更新至第 15 条，共 14 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1NR4y1A7Tk/">《Rust 程序设计语言》更新至第七章，共 23 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZV4y1L7Kx/">《Jetpack Compose 从入门到实战》更新至第二章，共 12 集</a></li>
</ul>
<p>Kotlin 版本更新的视频：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1eM4y1P7cR/">Kotlin 1.6 共 6 期</a></li>
<li><a href="https://www.bilibili.com/video/BV1ma411E7ZU/">Kotlin 1.7 共 2 期</a></li>
</ul>
<p>还有一些散装的视频，比如<a href="https://www.bilibili.com/video/BV1pT4y1Y746/">“神奇的 C 语言”</a>系列，说起来 C 语言的视频播放量是真的高。</p>
<p>订阅量从年初的 5900 左右增长到接近 17500，基本达到了我年初的预期（12000），<strong>谢谢大家的关注和一键三连</strong>。不瞒各位说，我当时还定了一个挑战目标：18000，还真是恰到好处的差一点儿。</p>
<p>2023 年的想法，未更新完的读书视频当中，这几本是确定要更完的：</p>
<ul>
<li>《Effective Python》</li>
<li>《Rust 程序设计语言》</li>
<li>《现代 C++ 特性解析》</li>
</ul>
<p>此外应该也会有一些 Java 相关的视频。</p>
<p>小伙伴们问得最多的是 Flutter 不更了吗，Compose 不更了吗？统一回复：对，不更了。</p>
<h2 id="文字内容输出"><a href="#文字内容输出" class="headerlink" title="文字内容输出"></a>文字内容输出</h2><p>今年文章写得不多，也就两个合集：</p>
<ul>
<li><a href="https://www.bennyhuo.com/book/cpp-coroutines/">渡劫 C++ 协程</a></li>
<li><a href="https://www.bennyhuo.com/book/swift-coroutines/">闲话 Swift 协程</a></li>
</ul>
<p>尽管写完《深入理解 Kotlin 协程》之后我就对协程这个话题比较麻木了，不过对于其他语言的协程我还是很好奇的。C++ 和 Swift 的协程的实现与 Kotlin 协程有很多相似之处，有兴趣的朋友不妨读一下这几篇文章了解一下。</p>
<p>今年也在写书。“深入实践 Kotlin 元编程”（暂定书名）这本书目前底稿已经全部完成，我目前正在逐字逐句做校对，预计还需要一个多月才能全部交付到编辑侧完成第一遍审稿。参考《深入理解 Kotlin 协程》的时间，2023 年内出版是没什么问题的。</p>
<p>这本书的内容大概涵盖了 Kotlin 开发实践当中另一个难点。大家常听说的 APT、KSP、KCP 在这本书当中都有详细介绍。如果大家想要提前了解书的内容，可以看一下我的 GitHub 2022 年的提交记录。经常有朋友我问有没有好的 KSP 或者 KCP 的示例代码，其实我近一年维护的所有项目基本上都与之相关。</p>
<p>写书是一件苦差事，每次写书的时候都在心里说写完这本就再也不写了。也许明年可以尝试写一些小册子，搞轻松一些。“渡劫 C++ 协程” 这种我觉得就挺好。</p>
<h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>今年的社区活动，一共有三次，其中还包括一次线下活动，真是不容易。</p>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1kG411n7KH/">2022.7 Kotlin 炉边漫谈 Podcast 第二期</a>：“Kotlin 炉边漫谈” 是 Kotlin 社区推出的一款节目，每期都会邀请一些有趣的嘉宾参与闲聊。据说我是那个最不会聊天的。</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1ye4y1Y728/">2022.9.1 使用 Kotlin 多平台特性统一 JS 调用 Native 函数的体验</a>：这期分享主要介绍了 Klue 这个项目的实现思路和细节。Klue 是 Kotlin 多平台特性的一个很好的实践场景。这个项目明年应该会继续探索下去，今年之所以搁浅，实在是因为精力有限。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231150245.png">  </p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1t14y1L7SA/">2022.10.30 小猿口算 Android 项目的优化实践</a>：这期分享主要介绍了我在猿辅导公司小猿口算团队与团队其他同学一起做的各方面的工程优化。能把有趣的技术应用到公司项目当中，也是一件快事。<br><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20221231152701.png">  </p>
</li>
</ul>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>2022 年还有一些开源项目在维护。比较重要的就是下面的几个：</p>
<ul>
<li><a href="https://github.com/bennyhuo/Kotlin-Trim-Indent">Kotlin-Trim-Indent</a>：处理 Kotlin 多行字符串缩进的编译器插件。</li>
<li><a href="https://github.com/bennyhuo/KotlinDeepCopy">KotlinDeepCopy</a>：很多年的老项目了，今年又尝试了很多想法。</li>
<li><a href="https://github.com/bennyhuo/kotlin-compile-testing-extensions">kotlin-compile-testing-extensions</a>：对框架 kotlin-compile-testing 做的扩展，方便做 Kotlin 编译器相关项目的单测。</li>
<li><a href="https://github.com/bennyhuo/Klue">Klue</a>：使用 Kotlin 多平台特性对 Android/iOS 与 WebView/React Native 的互调用进行简化。</li>
</ul>
<p>今年因为写书，一直在做 Kotlin 编译器相关的尝试。明年的重心可能会放到 Klue 上面。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家在 B 站关注我：<strong>bennyhuo 不是算命的</strong>。</p>
<p>也欢迎大家关注微信公众号：<strong>bennyhuo</strong>。</p>
<p>2023 继续加油。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（0）：前言</title>
    <url>//2021/10/11/swift-coroutines-00-foreword/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<p>经过几年的打磨，Swift 已经成为一门成熟度非常高的语言。</p>
<p>作为 Kotlin 布道师，Android 从业者，我本人对 Swift 的发展也保持了持续的关注。Swift 与 Kotlin 在外形上有着极高的相似度，学习 Swift 的一些特性有时候也可以帮助我更好的理解 Kotlin 的语法。</p>
<p>在协程这个特性上，Kotlin 还是走得比较靠前，我当时在写《深入理解 Kotlin 协程》这本书的时候也查阅过 Swift 的一些第三方协程实现，不过当时因为官方一直都没有消息，因此在书中没有提及。</p>
<p>这下好了，Swift 终于在 5.5 当中正式支持了协程，作为现代语言必备的特性，Swift 总算是补齐了自己的短板。</p>
<p>我计划写几篇文章来介绍一下 Swift 协程的特性，内容会以 Swift 协程的基本概念、语法设计、使用场景等方面为基础展开，也会与大前端开发者常见的 Kotlin、JavaScript 做对比，希望能给大家一个更多元化的视角来理解这个语法特性。</p>
<blockquote>
<p><strong>说明</strong>：最初在 Xcode 13.0 刚发布的时候，Swift 协程需要 iOS 15.0、macOS 12.0 以上；随后在 Xcode 13.2 发布以后，最低版本要求降低到 iOS 13.0、 macOS Catalina（10.15），这样看来线上项目也终于有机会尝试这个新特性了。</p>
</blockquote>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（1）：Swift 协程长什么样？</title>
    <url>//2021/10/11/swift-coroutines-01-intro/</url>
    <content><![CDATA[<blockquote>
<p>2021 年 9 月 20 日，Apple 发布了 Swift 5.5，这个版本当中最亮眼的特性就是对 async await 的支持了。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>协程（Coroutines）不是一个语言特有的概念，也没有一个特别严格的定义，维基百科对它定义也只是对它最核心的非抢占式多任务调度进行了简单的描述：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
</blockquote>
<p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。</p>
<p>说起任务调度，我们很自然地想到线程。从任务载体的角度来讲，协程和线程在应用场景上的确有很大的重叠之处，协程最初也确实是被应用于操作系统的任务调度的。只不过后来抢占式的调度成为了操作系统的主流实现，因此以协程为执行任务单位的协作式的调度就很少出现在我们眼前了。我们现在提到线程，基本上指的就是操作系统的内核线程；而提到协程，绝大多数都是编程语言层面实现的任务载体 —— 我们看待一个线程，就好像一艘轮船一样，而协程似乎就是装在上面的一个集装箱。</p>
<p>从任务的承载上来讲，线程比协程更重；从调度执行的能力来讲，线程是由操作系统调度的，而协程则是由编程语言的运行时调度的。所以绝大多数的编程语言当中实现的协程都具备更加轻量和更加灵活的特点。对于高负载的服务端，协程的轻量型就表现地很突出；而对于复杂的业务逻辑，特别是与外部异步交互的场景，协程的灵活性就可以发挥作用。</p>
<p>对于 Swift 而言，主要应对的自然是简化复杂的异步逻辑。而针对类似的场景，各家实际上已经给出了近乎一致的语法：async/await。其中 async 用于修饰函数，将其声明为一个异步函数，await 则用于非阻塞地等待异步函数的结果 —— Swift 也不能免俗。</p>
<p>不过，在有大前端应用场景的语言当中（例如 JavaScript、Dart、C# 等等），有一个“邪教徒”，那就是 Kotlin。相比之下它的语法比较奇葩，只用了一个 suspend 关键字就实现了几乎前面所有的能力（甚至还能做到更多）。Swift 协程与 Kotlin 协程从实现原理上还有代码交互上都颇有渊源，这个我们留在后面专门介绍。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>为了快速了解 Swift 协程的语法，我们先给出一段代码，让大家感受一下它的样子。</p>
<p>在这个例子当中，我们使用 Alamofire 这个网络框架发起网络请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">getImageData</span>(<span class="params">url</span>: <span class="type">String</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AF</span>.request(url).responseDataAsync() <span class="comment">// 调用异步函数，挂起等待结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 responseDataAsync 函数是我对 Alamofire 框架当中的 DataRequest 做的一个扩展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">DataRequest</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">responseDecodableAsync</span>&lt;<span class="type">T</span>: <span class="type">Decodable</span>&gt;(<span class="operator">...</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的具体实现我们将在后面给出。</p>
<p>我们先请大家观察这两个函数的形式与普通函数有什么不同。我相信你很容易就能看出来，函数声明的返回值处多了个 async，而在调用函数的时候则多了个 await。使用 async 修饰的函数与普通的同步函数不同，它被称作异步函数。异步函数可以调用其他异步函数，而同步函数则不能调用异步函数。</p>
<p>正如我们前面提到的，async/await 这样的形式其实也是现在主流编程语言所支持的方式，例如：</p>
<p><strong>JavaScript</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">seconds</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">2</span>); <span class="comment">// 调用异步函数，挂起等待结果</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在 JavaScript 当中同样可以通过 async 关键字来声明一个支持挂起调用的异步函数，而在想要调用另一个异步函数的时候，则需要使用 await。从形式上来看，Swift 只是把 async 放到了函数声明的后面而已。</p>
<p>我们不妨也看一下 Kotlin 的的协程，Kotlin 当中也有异步函数的概念，只不过它选择了 suspend 这个关键字，因此我们在 Kotlin 当中更多的称这样的函数为挂起函数（其实是可挂起的函数）：</p>
<p><strong>Kotlin</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(seconds: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">asyncCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">  delay(<span class="number">2</span>) <span class="comment">// 调用 suspend 函数，异步挂起</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从语法的形式上来看，Kotlin 的 suspend 关键字在函数声明时充当了 async 的作用，把函数声明为异步函数；而在调用 suspend 函数的时候则直接相当于强加了 await，如果被调用的 suspend 函数会挂起，那么我们在这个调用点也就只能挂起当前异步函数来等待被调用的异步函数的结果返回了。实际上 Swift 的异步函数调用时也会要求使用 await，而 JavaScript 的 await 则在使用和不使用时分别有不同的含义，有关这个设计问题的讨论，我们后面再探讨。</p>
<p>所以讲到这里我希望大家能够了解两个点：</p>
<ol>
<li>这些编程语言通过 async 关键字将函数分为两类，过去的普通函数为同步函数，被修饰的函数则为异步函数。</li>
<li>调用异步函数的时候需要使用 await 关键字，使得这个异步调用拥有了挂起等待恢复的语义。</li>
</ol>
<h2 id="async-await-解决了怎样的问题？"><a href="#async-await-解决了怎样的问题？" class="headerlink" title="async/await 解决了怎样的问题？"></a>async/await 解决了怎样的问题？</h2><p>在 Swift 5.5 以前，getImageData 的实现通常依赖回调来实现结果的返回：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">getImageData</span>(<span class="params">url</span>: <span class="type">String</span>,</span><br><span class="line">                    <span class="params">onSuccess</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>) -&gt; <span class="type">Void</span>,</span><br><span class="line">                    <span class="params">onError</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="type">AF</span>.request(url).responseData &#123; response <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">            onSuccess(data)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            onError(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很自然地，我们如果想要调用这个函数，代码写出来就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">GitHubApi</span>.getImageData(</span><br><span class="line">        url: avatar_url,</span><br><span class="line">        onSuccess: &#123; data <span class="keyword">in</span></span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onError: &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>那如果我想要在回调当中再触发一些其他的异步操作，结果会怎样呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">GitHubApi</span>.getImageData(</span><br><span class="line">        url: avatar_url,</span><br><span class="line">        onSuccess: &#123; data <span class="keyword">in</span></span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">            cropImage(</span><br><span class="line">                onSuccess: &#123; croppedImage <span class="keyword">in</span></span><br><span class="line">                    saveImage(</span><br><span class="line">                        onSuccess: &#123;</span><br><span class="line">                            <span class="operator">...</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        onError: &#123;</span><br><span class="line">                            <span class="operator">...</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line">                onError: &#123;</span><br><span class="line">                    <span class="operator">...</span></span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        onError: &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>不难发现，随着逻辑复杂度的增加，代码的缩进会越来越深，可维护性也越来越差。</p>
<p>但这段代码如果用 async/await 改造一下，结果会怎样呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="type">GitHubApiAsync</span>.getImageData(url: userItem.user.avatar_url)</span><br><span class="line">    <span class="keyword">let</span> croppedImage <span class="operator">=</span> <span class="keyword">await</span> cropImage(data)</span><br><span class="line">    <span class="keyword">await</span> saveImage(croppedImage)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 getImageData 函数的同步版本相比，onSuccess 和 onError 这两个回调没有了。尽管结果仍然是异步返回的，但写起来却像是同步返回的一样。这样看来，运用 async/await 可以使回调的层级变少，从而使得代码逻辑变得更清晰。</p>
<p>实际上，对于有一个或两个分支的异步回调，我们都可以很轻松地将其转换为使用 async 修饰的异步函数，进而使用 await 来完成调用。这部分内容我们在后面会专门介绍。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过前面对协程概念的简单介绍，以及 async/await 与回调的使用对比，我们不难发现协程在简化异步代码的实现方面有着巨大的优势。知道了这一点，我们后续就可以逐步深入去了解 Swift 协程的使用场景和实现细节了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（2）：将回调改写成 async 函数</title>
    <url>//2021/10/13/swift-coroutines-02-wrap-callback/</url>
    <content><![CDATA[<blockquote>
<p>最理想的情况下，系统、第三方框架当中使用回调的 API 都最好在一夜之间改成 async 函数，显然这不太现实。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<p>我们前面已经简单介绍了 Swift 的协程，可以确认的一点是，如果你只是看了上一篇文章，那么你肯定还是不会用这一个特性。你一定还有一些疑问：</p>
<ul>
<li>异步函数是谁提供的？</li>
<li>我可以自己定义吗？</li>
<li>我该怎么正确地定义一个异步函数？</li>
</ul>
<p>异步函数谁都可以提供，不然它的应用范围就会大大受限制，因此我们既可以有机会使用到系统或者第三方框架提供的异步函数，也自然有机会自己去定义。那关键的问题就是如何定义异步函数了。</p>
<p>我们先随便定义一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">hello</span>() -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回了一个整数 1。接下来我们把它改造成异步函数，只需要加上 async 关键字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">hello</span>() <span class="keyword">async</span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它现在真的是异步的吗？当然不是，它只是长得像罢了。</p>
<p>async 关键字并不会真正带来异步，那么异步的能力是谁提供的？这时候我们就要想想，过去我们见到的异步函数都是什么样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">helloAsync</span>(<span class="params">onComplete</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        onComplete(<span class="type">Int</span>(arc4random()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的例子，我们在 helloAsync 当中通过 DispatchQueue 将代码逻辑调度到 global() 上，使得回调 onComplete 的调用脱离了 helloAsync 的调用栈。调用这个函数的样子就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">helloAsync &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Got result from callback: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么看来，我们在异步函数当中都应该有这么个切换调用栈的过程，并且有个类似于回调的东西将结果能传递出去。那在 Swift 协程当中，谁来扮演这个角色呢？</p>
<p>这里就要稍微提一下 Swift 协程的设计原理了。它采用了一种叫做 Continuation Passing Style 的设计思路（熟悉 Kotlin 的朋友是不是觉得非常熟悉？），而这个所谓的Continuation 就充当了回调的作用。我们把 Swift 标准库当中提供的 Continuation 的定义给出来，大家简单了解一下它的形式即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@frozen</span> <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">UnsafeContinuation</span>&lt;<span class="title class_">T</span>, <span class="title class_">E</span>&gt; <span class="title class_">where</span> <span class="title class_">E</span> : <span class="title class_">Error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">resume</span>(<span class="params">returning</span> <span class="params">value</span>: <span class="type">T</span>) <span class="keyword">where</span> <span class="type">E</span> <span class="operator">==</span> <span class="type">Never</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">resume</span>(<span class="params">returning</span> <span class="params">value</span>: <span class="type">T</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">resume</span>(<span class="params">throwing</span> <span class="params">error</span>: <span class="type">E</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到它实际上有两种类型的函数，一种是 returning，一种是 throwing。也就是说，对于任何一段代码逻辑，其执行的结果都无非返回结果和抛出异常两种。Continuation 其实就是描述协程当中异步代码在挂起点的状态，而当程序需要恢复执行时，调用它对应的 resume 函数即可。</p>
<p>好了，现在我们知道有了 Continuation 这个东西了，相当于我们已经知道对于 Swift 的 async 函数而言，我们可以通过 Continuation 来传递异步结果。那么下一个问题就是如何获取这个 Continuation 的实例呢？Swift 标准库提供了相应的函数来做到这一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withCheckedContinuation</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">function</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#function</span>, </span><br><span class="line">    <span class="keyword">_</span> <span class="params">body</span>: (<span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">Never</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> -&gt; <span class="type">T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withCheckedThrowingContinuation</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">function</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#function</span>, </span><br><span class="line">    <span class="keyword">_</span> <span class="params">body</span>: (<span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>如果我们的异步函数不会抛出异常，那就用 withCheckedContinuation 来获取 Continuation；如果会抛出异常，那就用 withCheckedThrowingContinuation。这么看来，改造前面的回调的方法就显而易见了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">helloAsync</span>() <span class="keyword">async</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            continuation.resume(returning: <span class="type">Int</span>(arc4random()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要抛出异常，那么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">helloAsyncThrows</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> doSomethingThrows() <span class="comment">// 可能抛异常</span></span><br><span class="line">                continuation.resume(returning: result)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                continuation.resume(throwing: error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 Swift 要求对于标记为 throws 的函数需要使用 try 关键字来调用。</p>
<p>好了，现在我们已经学会如何将异步回调转成异步函数了，距离最终的目标又近了一步。下一篇文章当中我们将介绍如何从程序入口调用异步函数，试着把程序跑起来。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（3）：在程序当中调用异步函数</title>
    <url>//2022/01/21/swift-coroutines-03-call-async-func/</url>
    <content><![CDATA[<blockquote>
<p>异步函数需要被异步函数调用，这听上去就是一个鸡生蛋蛋生鸡的问题。关键的问题在于，第一个异步函数从哪儿来？ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<p>我们现在已经知道怎么定义异步函数了，也可以很轻松的转换将现有的异步回调 API 转成异步函数。那下一个问题就是，既然普通函数不能调用异步函数，那定义好的这些异步函数该从哪儿开始调用呢？</p>
<h2 id="使用-Task"><a href="#使用-Task" class="headerlink" title="使用 Task"></a>使用 Task</h2><h3 id="Task-的创建"><a href="#Task-的创建" class="headerlink" title="Task 的创建"></a>Task 的创建</h3><p>其实从上一节我们分析如何将回调转成异步函数的时候就已经发现，异步函数的关键在于 Continuation。所以，只要调用异步函数的位置能让异步函数获取到 Continuation，那么调用异步函数的问题就解决了。Swift 标准库提供了 Task 类来提供这个能力。</p>
<p>我们给出 Task 的构造器的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> -&gt; <span class="type">Success</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Success</span>)</span><br></pre></td></tr></table></figure>

<p>它接收一个异步闭包作为参数，创建一个 Task 实例并运行这个异步闭包。而在这个闭包当中，我们就可以调用任意异步函数了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> helloAsync()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了直接构造 Task 之外，还可以调用 Task 的 detach 函数来创建一个不一样的 Task：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span>.detached (operation: &#123;</span><br><span class="line">    <span class="keyword">await</span> helloAsync()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个函数返回的也是一个 Task 实例，我们不妨看一下它的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">detached</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> -&gt; <span class="type">Success</span></span><br><span class="line">) -&gt; _Concurrency.<span class="type">Task</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">detached</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Success</span></span><br><span class="line">) -&gt; _Concurrency.<span class="type">Task</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;</span><br></pre></td></tr></table></figure>

<p>注意到它其实是 Task 的静态函数，返回值正是 Task 类型。</p>
<h3 id="两种-Task-的对比"><a href="#两种-Task-的对比" class="headerlink" title="两种 Task 的对比"></a>两种 Task 的对比</h3><p>那通过 detached 函数创建的 Task 和直接使用 Task 的构造器创建的 Task 实例有什么不同呢？我们先来看一下文档的说明：</p>
<p><strong>detached</strong> 函数的部分注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Runs the given nonthrowing operation asynchronously</span></span><br><span class="line"><span class="comment">/// as part of a new top-level task.</span></span><br></pre></td></tr></table></figure>

<p>Task 类的 <strong>init</strong> 的部分注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Runs the given nonthrowing operation asynchronously</span></span><br><span class="line"><span class="comment">/// as part of a new top-level task on behalf of the current actor.</span></span><br></pre></td></tr></table></figure>

<p>可以看到这两段说明有一个共同点：通过二者创建的 Task 都是 top-level task。这是什么意思呢？这个其实是与在 TaskGroup 当中创建子任务是相对应的，前面介绍的这两种方式创建出来的任务都是顶级任务，没有父任务。TaskGroup 的内容我们下一篇文章再介绍。</p>
<p>接下来就是区别点了，即使用 Task 直接构造的任务实例会 <code>on behalf of the current actor</code>。Actor 我们还没有介绍，不过我们姑且理解为任务启动时所在的运行环境。这里主要包括挂起的异步函数在恢复时如何调度，以及对于 TaskLocal 变量的感知上。这些内容我们后面会专门写文章介绍。</p>
<p>简单来说，通过 <code>Task &#123; ... &#125;</code> 创建的任务会对外界的状态有感知，而通过 <code>Task.detached &#123; ... &#125;</code> 创建的任务就完全是个孤儿了 —— 也正是因为这一点，官方文档里面也提醒我们一般情况下不要使用 detached 来创建任务。</p>
<p>以上创建 Task 的方式，也被称为<strong>非结构化并发</strong>。</p>
<p>这里并发的意思是，Task 都会把自己的代码块传给一个后台异步队列去执行。非结构化则与添加到 TaskGroup 当中的任务相对应，添加到 TaskGroup 当中的任务的形式被称为结构化并发，这些 Task 会随着整个 TaskGroup 的取消而取消，而相对应地，顶级任务的状态管理都只与自己有关，想要取消也必须调用 Task 的 cancel 显式地对任务进行取消。</p>
<p>现在你应该对 TaskGroup、Actor、TaskLocal 之类的概念也产生了兴趣，如果不能理解，也先不着急，我们等后面再慢慢展开介绍。</p>
<p>不管怎样，讲到这里，我们已经知道如何在程序当中使用异步函数了，下面我们给出一个完整的命令行程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">helloAsync</span>() <span class="keyword">async</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            continuation.resume(returning: <span class="type">Int</span>(arc4random()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span>.detached &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> helloAsync())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> helloAsync())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程等待 1s，防止程序提前退出导致异步任务没有执行</span></span><br><span class="line"><span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>运行这个程序可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1804289383</span><br><span class="line">846930886</span><br></pre></td></tr></table></figure>

<p>嗯，这是两个随机数。在这个例子当中，我们既没有定义 Actor，也没有定义 TaskLocal，因此创建出来的两个 Task 其实是没有什么本质的区别的。</p>
<blockquote>
<p>说明：Swift 的协程需要 macOS 12.0，iOS 15.0 及以上版本才可以运行，因此大家可以在 iOS 15.0 的设备或者模拟器上体验异步函数的调用。有趣的是，在 Windows 和 Linux 上安装 Swift 5.5 的编译器之后，上述程序是可以运行的。</p>
</blockquote>
<h2 id="Task-的结果"><a href="#Task-的结果" class="headerlink" title="Task 的结果"></a>Task 的结果</h2><p>Task 的闭包有返回值作为它的结果返回。由于 Task 是异步执行的，它的结果自然也是异步的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">Success</span> &#123; <span class="keyword">get</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在其他异步函数当中使用 await 来获取它的结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> helloAsync()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> task.value)</span><br></pre></td></tr></table></figure>

<p>由于 Task 的闭包可以抛出异常，因此对于每一个 Task 来讲，异常也是结果的一种可能。如果我们只是任性地启动了一个 Task 而不去获取它的结果的话，Task 内部抛出的任何异常都与外部无关：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">errorThrown</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Runtime Error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">taskWithError</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> errorThrown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免程序过早退出，等 1s</span></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要看看 Task 究竟抛出了什么异常，我们可以在读取它的 value 时对异常进行捕获：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">taskWithError</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> errorThrown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> task.value</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面定义的 Task 时传入的闭包会抛异常，这样一来 Task 的第二个泛型参数 Failure 就不可能是 Never。这种情况下获取 value 的操作需要使用 try 关键字。</p>
<h2 id="异步-main-函数"><a href="#异步-main-函数" class="headerlink" title="异步 main 函数"></a>异步 main 函数</h2><p>通过创建 Task 的方式适用于所有在同步函数当中需要调用异步函数的情形。当然，对于命令行程序来讲，我们还可以直接把 main 函数定义为 async 函数：</p>
<p><strong>App.swift</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">main</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们定义一个结构体（或者类），将其标注为 @main；接着定义一个静态的 main 函数，这个函数可以是同步函数也可以是异步函数。</p>
<blockquote>
<p>注意，通过这种方式，main.swift 文件要留空（或者直接删掉）。</p>
</blockquote>
<p>这样我们就可以愉快地调用异步函数了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">main</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> helloAsync())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> detachedTask <span class="operator">=</span> <span class="type">Task</span>.detached &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> helloAsync())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> helloAsync())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;detached task result: <span class="subst">\(<span class="keyword">try</span> <span class="keyword">await</span> detachedTask.value)</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task result: <span class="subst">\(<span class="keyword">try</span> <span class="keyword">await</span> task.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：异步 main 函数同样受到 macOS 运行时版本的限制，但在 Windows 和 Linux 上不受限制。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们主要介绍了如何创建调用异步函数的条件的问题，大家也可以自己体验一下 Swift 的协程了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（4）：TaskGroup 与结构化并发</title>
    <url>//2022/01/22/swift-coroutines-04-structured-concurrency/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章我们提到了结构化并发，这听上去很高级。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="TaskGroup-的基本用法"><a href="#TaskGroup-的基本用法" class="headerlink" title="TaskGroup 的基本用法"></a>TaskGroup 的基本用法</h2><p>我们现在已经知道怎么在自己的程序里面调用异步函数了。</p>
<p>不难发现，调用异步函数的关键点是创建 Task 的实例。通过 Task 的构造器或者 detach 函数创建的 Task 实例都是顶级的，这意味着这些实例都需要单独管理。在真实的业务场景中，我们难免会创建很多 Task 实例来执行不同的异步任务，但这些任务之间往往都是存在关联的，因此我们绝大多数情况下更希望这些 Task 实例是作为一个或者几个整体来统一管理的。</p>
<p>这就需要 TaskGroup 了。</p>
<p>创建 TaskGroup 的方式非常简单，使用 <code>withTaskGroup(of:returning:body:)</code> 函数即可，它的完整定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">withTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>, </span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>, </span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br></pre></td></tr></table></figure>
<p>它有三个参数，但实际上前两个其实就是泛型参数，其中</p>
<ul>
<li><code>ChildTaskResult</code> 表示这个 TaskGroup 内创建的 Task 的结果类型</li>
<li><code>GroupResult</code> TaskGroup 自身的结果类型</li>
</ul>
<p>后者其实也是第三个参数 body 的返回值类型。</p>
<p>注意到 <code>withTaskGroup</code> 是异步函数，它会在 TaskGroup 当中所有的子 Task 执行完之后再返回。我们可以在 body 当中向 TaskGroup 当中添加子 Task，用到 addTask 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addTask</span>(</span><br><span class="line">    <span class="params">priority</span>: _Concurrency.<span class="type">TaskPriority</span>? <span class="operator">=</span> <span class="literal">nil</span>, </span><br><span class="line">    <span class="params">operation</span>: <span class="keyword">@escaping</span> <span class="meta">@Sendable</span> () <span class="keyword">async</span> -&gt; <span class="type">ChildTaskResult</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>priority 是当前任务的优先级</li>
<li>operation 就是任务的执行体</li>
</ul>
<p>尽管 <code>withTaskGroup</code> 会等待子 Task 执行完，但有些情况下我们希望在 body 当中就提前等待子 Task 的执行结果，这时候我们有两种做法：</p>
<ul>
<li>如果只关心子 Task 是否执行完，可以调用 TaskGroup 的 <code>waitForAll</code> 函数。不难想到，这也是一个异步函数。</li>
<li>更常见的情况是获取子 Task 的结果，这时候我们可以直接迭代 TaskGroup，或者调用 TaskGroup 的 <code>next</code> 函数来获取下一个已完成的子 Task 的结果。注意，获取的结果的顺序取决于子 Task 完成的顺序，而不是它们添加到 TaskGroup 当中的顺序。</li>
</ul>
<h2 id="一个结构化并发的简单示例"><a href="#一个结构化并发的简单示例" class="headerlink" title="一个结构化并发的简单示例"></a>一个结构化并发的简单示例</h2><p>下面我们给大家看一个非常简单的异步分段计算的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个计算 [min, max) 范围内整数的和的闭包，注意前闭后开</span></span><br><span class="line"><span class="keyword">let</span> add <span class="operator">=</span> &#123; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> min<span class="operator">..&lt;</span>max &#123;</span><br><span class="line">        sum <span class="operator">+=</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seg <span class="operator">=</span> <span class="number">10</span> <span class="comment">// 分段大小</span></span><br><span class="line"><span class="keyword">let</span> n <span class="operator">=</span> <span class="type">Int</span>(arc4random_uniform(<span class="number">10000</span>)) <span class="comment">// 产生一个随机数，下面计算 [0, n] 内的整数和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>, returning: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 计算分段和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>(n <span class="operator">/</span> seg) &#123;</span><br><span class="line">        group.addTask &#123; add(seg <span class="operator">*</span> (i <span class="operator">-</span> <span class="number">1</span>), seg <span class="operator">*</span> i) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 n 不能被 seg 整除，计算剩余部分的和</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="operator">%</span> seg <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            add(n <span class="operator">-</span> n <span class="operator">%</span> seg, n <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 group 的子任务结果，汇总</span></span><br><span class="line">    <span class="keyword">var</span> totalSum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> result <span class="keyword">in</span> group &#123;</span><br><span class="line">        totalSum <span class="operator">+=</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>通过 <code>withTaskGroup</code> 创建了一个 TaskGroup 实例，子 Task 的结果类型和 TaskGroup 的类型都是 Int，我们将 [0, n] 的整数按照 seg 进行分段，每段整数的和通过一个子 Task 来完成计算。</p>
<p>由于子 Task 的实例我们是无法直接拿到的，因此我们需要通过 TaskGroup 的实例来获取子任务的结果。通过上面的例子我们不难发现 group 是可以被迭代的，很自然的能想到 TaskGroup 有以下函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() <span class="keyword">async</span> -&gt; <span class="type">ChildTaskResult</span>?</span><br></pre></td></tr></table></figure>

<p>并且实现了 AsyncSequence 协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TaskGroup</span> : <span class="title class_">_Concurrency</span>.<span class="title class_">AsyncSequence</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p>AsyncSequence 与 Sequence 的不同之处在于它的迭代器的 next 函数是异步函数，这就与前面 TaskGroup 的 next 函数对应上了。</p>
<p>计算 totalSum 除了使用经典的 for 循环以外，我们也可以使用 reduce：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> totalSum <span class="operator">=</span> <span class="keyword">await</span> group.reduce(<span class="number">0</span>) &#123; acc, i <span class="keyword">in</span></span><br><span class="line">    acc <span class="operator">+</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 reduce 的第一个参数是初始值，第二个参数是个闭包，它的参数 acc 是累积的结果，i 是当前的元素，返回值则会作为下一个元素调用时的 acc 传入，最终得到的就是所有子 Task 的结果的和。</p>
<h2 id="会抛异常的-TaskGroup"><a href="#会抛异常的-TaskGroup" class="headerlink" title="会抛异常的 TaskGroup"></a>会抛异常的 TaskGroup</h2><p>大家可能发现了，我们前面创建的 TaskGroup 里面的子 Task 不能抛异常。因此我们很自然的想到还有一套可以抛异常的 TaskGroup 的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withThrowingTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>, </span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>, </span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> _Concurrency.<span class="type">ThrowingTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">Error</span>&gt;) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">GroupResult</span></span><br></pre></td></tr></table></figure>

<p>通过它创建的 TaskGroup 的类型是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@frozen</span> <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">ThrowingTaskGroup</span>&lt;<span class="title class_">ChildTaskResult</span>, <span class="title class_">Failure</span>&gt; <span class="title class_">where</span> <span class="title class_">Failure</span> : <span class="title class_">Error</span></span><br></pre></td></tr></table></figure>

<p>ThrowingTaskGroup 与 TaskGroup 的本质是一致的，只不过 ThrowingTaskGroup 的所有成员函数都增加了 throws 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="number">1000000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 withThrowingTaskGroup 是 rethrows 的，如果闭包参数里面有异常抛出，调用时也需要做异常处理。例子当中调用到了 Task 的 sleep 函数，需要大家注意的是 Task 有两个 sleep 函数，带 nanoseconds 的这个版本是会抛异常的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数没有 label，没有标记为 throws，调用时不需要处理异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="keyword">_</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数有 label，标记为 throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="params">nanoseconds</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>

<p>因此这里需要使用 <code>withThrowingTaskGroup</code> 来做异常的传递。</p>
<p>除抛异常这个点以外，ThrowingTaskGroup 的用法与 TaskGroup 完全一致。</p>
<h2 id="子-Task-的异常处理"><a href="#子-Task-的异常处理" class="headerlink" title="子 Task 的异常处理"></a>子 Task 的异常处理</h2><p>在 TaskGroup 当中，子 Task 如果抛出了异常，当外部调用者试图通过 TaskGroup 实例获取它的结果时也会抛出这个异常。需要注意的是，由于子 Task 结果的获取顺序取决于实际 Task 的完成时间，因此获取结果时需要注意对单个 Task 的结果进行异常捕获，以免影响其他 Task 的结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span>)</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> errorThrown()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1500_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="operator">!</span>group.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> group.next() <span class="operator">??</span> <span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子当中，返回 0 的子 Task 抛了异常，我们在试图遍历 group 时就会遇到这个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">Runtime Error</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>而其他的子 Task 的结果是可以正常获取的。可见 TaskGroup 当中的 Task 抛异常并不会影响其他 Task 的运行。</p>
<h2 id="不要把-TaskGroup-的实例泄漏到外部"><a href="#不要把-TaskGroup-的实例泄漏到外部" class="headerlink" title="不要把 TaskGroup 的实例泄漏到外部"></a>不要把 TaskGroup 的实例泄漏到外部</h2><p>从前面的例子我们大致可以看出，Swift 的 TaskGroup 的 API 设计还是非常谨慎的，TaskGroup 的实例只有在 <code>withTaskGroup</code> 的闭包参数当中使用，外部没有办法直接获取。</p>
<p>那有没有办法能让 TaskGroup 的实例逃逸出这个闭包呢？我们来做一点儿小尝试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> taskGroup: <span class="type">TaskGroup</span>&lt;<span class="type">Int</span>&gt;?</span><br><span class="line"><span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; (group) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    taskGroup <span class="operator">=</span> group</span><br><span class="line">    group.addTask &#123; <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> group <span class="operator">=</span> taskGroup <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group is nil&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> i <span class="keyword">in</span> group &#123; </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在闭包外面定义一个变量 taskGroup，在闭包里面给 taskGroup 赋值。接下来我们在外面尝试访问以下 taskGroup 的子任务结果，运行之后就会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process finished with exit code 133 (interrupted by signal 5: SIGTRAP)</span><br></pre></td></tr></table></figure>

<p>错误发生的位置就是这里： <code>for await i in group &#123; ... &#125;</code>。</p>
<p>为什么会出现异常呢？我们前面提到过， <code>withTaskGroup</code> 会在所有的子 Task 执行完以后再返回，这是否意味着 TaskGroup 的实例也会在此时被销毁呢？</p>
<p>遇到这种问题，我们只需要翻阅一下 swift 的源码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskGroup</span>&lt;<span class="type">ChildTaskResult</span>, <span class="type">GroupResult</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">childTaskResultType</span>: <span class="type">ChildTaskResult</span>.<span class="keyword">Type</span>,</span><br><span class="line">    <span class="params">returning</span> <span class="params">returnType</span>: <span class="type">GroupResult</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">GroupResult</span>.<span class="keyword">self</span>,</span><br><span class="line">    <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span></span><br><span class="line">) <span class="keyword">async</span> -&gt; <span class="type">GroupResult</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _group <span class="operator">=</span> <span class="type">Builtin</span>.createTaskGroup(<span class="type">ChildTaskResult</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">var</span> group <span class="operator">=</span> <span class="type">TaskGroup</span>&lt;<span class="type">ChildTaskResult</span>&gt;(group: _group)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the withTaskGroup body.</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> body(<span class="operator">&amp;</span>group)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> group.awaitAllRemainingTasks()</span><br><span class="line"></span><br><span class="line">    <span class="type">Builtin</span>.destroyTaskGroup(_group)</span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，withTaskGroup 返回前会先等待所有的子 Task 执行完毕，然后将 TaskGroup 销毁。因此将 TaskGroup 的实例泄漏到外部没有任何意义。</p>
<h2 id="不要在子-Task-当中修改-TaskGroup"><a href="#不要在子-Task-当中修改-TaskGroup" class="headerlink" title="不要在子 Task 当中修改 TaskGroup"></a>不要在子 Task 当中修改 TaskGroup</h2><p>TaskGroup 泄漏到外部是危险的，这其实很容易想到。那么在子 Task 当中呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> withTaskGroup(of: <span class="type">Void</span>.<span class="keyword">self</span>) &#123; (group) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">        group.addTask &#123; <span class="comment">// error!</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inner task&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你尝试在子 Task 当中去修改 group（addTask 是 mutating func），你会得到这样的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mutation of captured parameter &#x27;group&#x27; in concurrently-executing code</span><br></pre></td></tr></table></figure>

<p>正如前面提到不能把 TaskGroup 的实例泄漏到外面一样，它也同样不能泄漏到子 Task 的执行体当中。道理也很简单，子 Task 的执行体可能会被调度到不同的线程上，这样就导致对 TaskGroup 的修改是并发的，不安全。</p>
<h2 id="async-let"><a href="#async-let" class="headerlink" title="async let"></a>async let</h2><p>除了使用 TaskGroup 添加子 Task 的方式来构造结构化并发以外，我们还有一种比较便捷的方式，那就是使用 async let。async let 一方面可以让子 Task 的创建和结果的返回变得更加简单，另一方面也可以解决子 Task 的结果不好定位的问题（因为遍历 TaskGroup 时子 Task 的结果返回顺序不确定）。</p>
<p>下面我们给出一个简单的例子来说明这个问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> info: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> followers: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">let</span> projects: [<span class="type">String</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个数据结构 User，我们现在需要通过访问网络情况来构造这样一个实例，其中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUserInfo</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getFollowers</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getProjects</span>(<span class="keyword">_</span> <span class="params">user</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三个函数将发送异步网络请求去获取对应字段的数据。如果使用 TaskGroup，代码写起来将会比较复杂：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> info(value: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> followers(value: [<span class="type">String</span>])</span><br><span class="line">    <span class="keyword">case</span> projects(value: [<span class="type">String</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getUser</span>(<span class="params">name</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> withTaskGroup(of: <span class="type">Result</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .info(value: <span class="keyword">await</span> getUserInfo(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .followers(value: <span class="keyword">await</span> getFollowers(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            .projects(value: <span class="keyword">await</span> getProjects(name))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> info: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">var</span> followers: [<span class="type">String</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">var</span> projects: [<span class="type">String</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> r <span class="keyword">in</span> group &#123;</span><br><span class="line">            <span class="keyword">switch</span> r &#123;</span><br><span class="line">            <span class="keyword">case</span> .info(value: <span class="keyword">let</span> value):</span><br><span class="line">                info <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">case</span> .followers(value: <span class="keyword">let</span> value):</span><br><span class="line">                followers <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">case</span> .projects(value: <span class="keyword">let</span> value):</span><br><span class="line">                projects <span class="operator">=</span> value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">User</span>(name: name, info: info <span class="operator">??</span> <span class="string">&quot;&quot;</span>, followers: followers <span class="operator">??</span> [], projects: projects <span class="operator">??</span> [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面多次提到对 TaskGroup 进行遍历获取子 Task 的结果时存在顺序的不确定性，为了解决这个问题我们定义了一个枚举 Result 将子 Task 的结果与枚举值进行绑定，方便后续读取结果。这个过程异常繁琐，且引入额外的类型实现结果的绑定让问题变得更加复杂。</p>
<p>如果使用 async let，这个问题就会变得非常简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUser</span>(<span class="params">name</span>: <span class="type">String</span>) <span class="keyword">async</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> info <span class="operator">=</span> getUserInfo(name)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> followers <span class="operator">=</span> getFollowers(name)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">let</span> projects <span class="operator">=</span> getProjects(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">User</span>(name: name, info: <span class="keyword">await</span> info, followers: <span class="keyword">await</span> followers, projects: <span class="keyword">await</span> projects)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async let 会创建一个子 Task 来完成后面的调用，并且把结果绑定到对应的变量当中。以 info 为例，当我们需要读取其结果时，只需要 await info 即可，这样就大大降低了我们获取异步子 Task 的结果的复杂度。</p>
<p>另外稍微提一句的是，在 Swift 当中，async 函数的调用必须使用 await 来等待这个限制会强制我们等待异步函数的结果，如果希望同时触发多个异步函数的调用，async let 能解决的问题也是有限的。例如我们想要并发获取多个 User 的数据，需要实现以下函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>:[<span class="type">String</span>]) <span class="keyword">async</span> -&gt; [<span class="type">User</span>]</span><br></pre></td></tr></table></figure>

<p>我们可以基于前面的 getUser 来实现这个函数，为了保证 User 数据的获取的并发性，我们需要同时创建多个 Task 来完成请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>:[<span class="type">String</span>]) <span class="keyword">async</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">    <span class="keyword">await</span> withTaskGroup(of: <span class="type">User</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">            group.addTask &#123;</span><br><span class="line">                <span class="keyword">await</span> getUser(name: name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> group.reduce(into: <span class="type">Array</span>&lt;<span class="type">User</span>&gt;()) &#123; (partialResult, user) <span class="keyword">in</span></span><br><span class="line">            partialResult.append(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下 async let 就显得有点儿力不从心了。</p>
<p>更进一步，如果这里要求返回的 User 跟传入的 name 能够在顺序上一一对应，使用 TaskGroup 实现就会比较麻烦，因为 TaskGroup 的结果顺序是子 Task 完成的顺序。</p>
<p>实际上，保证结果的顺序与 Task 的添加顺序一致是有实际需求的，我们也可以使用一组 Task 而不是 TaskGroup 来实现这个需求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getUsers</span>(<span class="params">names</span>: [<span class="type">String</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> tasks <span class="operator">=</span> names.map &#123; name <span class="keyword">in</span></span><br><span class="line">        <span class="type">Task</span> &#123; () -&gt; <span class="type">User</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUser(name: name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler(operation: &#123;</span><br><span class="line">        <span class="keyword">var</span> users <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">User</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks &#123;</span><br><span class="line">            users.append(<span class="keyword">try</span> <span class="keyword">await</span> task.value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users</span><br><span class="line">    &#125;, onCancel: &#123;</span><br><span class="line">        tasks.forEach &#123; task <span class="keyword">in</span> task.cancel() &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这时候我们创建的 Task 都是不隶属于 TaskGroup 的（即非结构化并发），此时我们要小心处理 Task 取消的情况，以免出现内存泄漏和逻辑错误。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们简单介绍了一下 TaskGroup 的用法，大家可以基于这些内容开始做一些简单的尝试了。结构化并发当中还有一些重要的概念我们将在接下来的几篇文章当中逐步介绍。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（5）：Task 的取消</title>
    <url>//2022/01/28/swift-coroutines-05-cancellation/</url>
    <content><![CDATA[<blockquote>
<p>但凡是个任务，就有可能被取消。取消了该怎么办呢？ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="Task-的取消就是个状态"><a href="#Task-的取消就是个状态" class="headerlink" title="Task 的取消就是个状态"></a>Task 的取消就是个状态</h2><p>Task 的取消其实非常简单，就是将 Task 标记为取消状态。那 Task 的执行体要怎么做才能让任务真正取消呢？我们先看个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure>

<p>我们创建了一个 Task，正常情况下它应该很快被执行到，因此第一行日志可以打印出来，随即进入 10s 的睡眠状态。但我们在 Task 外部等了 500ms 之后把它取消了，如果不出什么意外的话，在 Task 睡眠时它就被取消了。</p>
<p>既然任务被取消了，凭我们主观的判断，第二句日志应该是打印不出来的，但实际的情况却是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task start</span><br><span class="line">task finish</span><br><span class="line">success()</span><br></pre></td></tr></table></figure>

<p>这说明 Task 的取消只是一个状态标记，它不会强制 Task 的执行体中断，换句话说 Task 的取消并不像杀进程那样粗暴。</p>
<p>实际上，我们可以在任务的执行体当中读取到 Task 的取消状态，我们把程序稍作修改如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task start</span><br><span class="line">task finish, isCancelled: true</span><br><span class="line">success()</span><br></pre></td></tr></table></figure>

<p>可以看到，Task 确实被取消了，我们也可以读取到这个状态，如果我们需要让我们的 Task 执行体响应它的取消状态，那就需要做出这个状态的判断，并且做出响应，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个例子还不够理想，毕竟睡眠的 10s 是不能响应取消的。那如果让 sleep 函数内部也能响应取消，问题是不是就解决了？</p>
<h2 id="通过抛-CancellationError-来响应取消"><a href="#通过抛-CancellationError-来响应取消" class="headerlink" title="通过抛 CancellationError 来响应取消"></a>通过抛 CancellationError 来响应取消</h2><p>Task 的执行过程中，难免会存在多层异步函数的嵌套的情况，如果最深处的某一个函数响应了取消状态，怎样才能让外部的异步函数也能很好的配合好这个响应？这其实就是在回答上一节留下的 sleep 该如何响应取消的问题。如果想要优雅地给出这个答案，只能通过抛异常的方式了，因为任何条件分支的判断都无法实现有效的传播，而异常天然就具备这样的特性。</p>
<p>所以常见的异常响应方式非常简单，如果你在编写一个需要响应取消状态的异步函数，当你检查到 Task 被取消时，只需要抛一个 <code>CancellationError</code> 即可，大家都遵守这个规则，那么这个 Task 就能被优雅地结束。</p>
<p>实际上 Task 一共有两个 sleep 函数，我们仔细对比一下它们的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="keyword">_</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">sleep</span>(<span class="params">nanoseconds</span> <span class="params">duration</span>: <span class="type">UInt64</span>) <span class="keyword">async</span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>

<p>二者的区别有两处：</p>
<ul>
<li>参数的 label</li>
<li>是否会抛出异常</li>
</ul>
<p>第二个函数明确通过参数的 label 告诉我们参数是纳秒，同时它还会抛出异常。什么异常？自然是在 Task 被取消时抛出 <code>CancellationError</code>。这么看来我们只需要稍微调整一下代码就能完美解决问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="number">10_000_000_000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task start</span><br><span class="line">failure(Swift.CancellationError())</span><br></pre></td></tr></table></figure>

<p>符合预期。</p>
<p>实际上，如果大家仔细查阅 Swift 的文档，你就会发现第一个 sleep 函数已经被废弃了，它的问题想必大家也已经非常明白了吧。</p>
<h2 id="checkCancellation：更方便地检查取消状态"><a href="#checkCancellation：更方便地检查取消状态" class="headerlink" title="checkCancellation：更方便地检查取消状态"></a>checkCancellation：更方便地检查取消状态</h2><p>前面的例子我们算是躺赢了，但如果实际的代码是下面这样呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        doHardWork(i) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难，我们只需要加个判断嘛，这样在每次循环的开始，如果 Task 已经被取消，我们就能够及时地停止这个任务的执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Task</span>.isCancelled &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">CancellationError</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        doHardWork(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这里有个更方便的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation()</span><br><span class="line">        doHardWork(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task finish, isCancelled: <span class="subst">\(Task.isCancelled)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数也没啥神秘的，因为它的实现非常直接：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkCancellation</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">Task</span>&lt;<span class="type">Never</span>, <span class="type">Never</span>&gt;.isCancelled &#123;</span><br><span class="line">        <span class="keyword">throw</span> _Concurrency.<span class="type">CancellationError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册取消回调"><a href="#注册取消回调" class="headerlink" title="注册取消回调"></a>注册取消回调</h2><p>前面提到的响应取消的情况实际上是两种类型：</p>
<ul>
<li>调用其他支持响应取消的异步函数，在取消时它会抛出 CancellationError</li>
<li>自己的代码当中主动检查取消状态，并抛出 CancellationError（或者直接退出执行逻辑）</li>
</ul>
<p>但如果异步的逻辑封装在第三方代码当中，我们只能想办法在 Task 取消时调用第三方的取消逻辑来完成响应，这时候情况就复杂一些了。我们就以 GCD 的异步 API 为例，首先我们对 DispatchWorkItem 做个包装：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContinuationWorkItem</span>&lt;<span class="title class_">T</span>, <span class="title class_">E</span>&gt; <span class="title class_">where</span> <span class="title class_">E</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> continuation: <span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;?</span><br><span class="line">    <span class="keyword">let</span> block: (<span class="type">ContinuationWorkItem</span>) -&gt; <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> dispatchItem: <span class="type">DispatchWorkItem</span> <span class="operator">=</span> <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.continuation<span class="operator">?</span>.resume(returning: <span class="keyword">self</span>.block(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.dispatchItem.isCancelled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">block</span>: <span class="keyword">@escaping</span> (<span class="type">ContinuationWorkItem</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.block <span class="operator">=</span> block</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">installContinuation</span>(<span class="params">continuation</span>: <span class="type">CheckedContinuation</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.continuation <span class="operator">=</span> continuation</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>() &#123;</span><br><span class="line">        dispatchItem.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个包装的目的在于支持 <code>installContinuation</code>，通过获取 Task 的 continuation 来实现异步结果的返回。</p>
<p>这里还有一个细节，block 的类型与 DispatchWorkItem 的 block 多了个参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> block: (<span class="type">ContinuationWorkItem</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>这主要是为了方面我们在 block 当中可以读取到 GCD 的任务是否被取消了。</p>
<p>接下来我们试着用 Task 来封装 GCD 的异步任务，并且实现对取消的响应：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> asyncRequest <span class="operator">=</span> <span class="type">ContinuationWorkItem</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; &#123; item <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;async start&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i <span class="operator">&lt;</span> <span class="number">10</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>item.isCancelled &#123;</span><br><span class="line">            <span class="comment">// 单位 秒</span></span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.1</span>)</span><br><span class="line">            i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i = <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> item.isCancelled &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;async cancelled, <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;async finish&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="keyword">await</span> withCheckedContinuation &#123; (continuation: <span class="type">CheckedContinuation</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;) <span class="keyword">in</span></span><br><span class="line">            asyncRequest.installContinuation(continuation: continuation)</span><br><span class="line">            <span class="type">DispatchQueue</span>.global().async(execute: asyncRequest.dispatchItem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; onCancel: &#123;</span><br><span class="line">        asyncRequest.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">500_000_000</span>)</span><br><span class="line">task.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> task.result)</span><br></pre></td></tr></table></figure>

<p>asyncRequest 其实就是我们创建的对 ContinuationWorkItem 实例，它对 DispatchWorkItem 做了包装，在后面的代码当中传给了 DispatchQueue 去异步执行。为了能够及时感知到 Task 的取消状态变化，我们用到了 withTaskCancellationHandler 这个函数，它的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskCancellationHandler</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, </span><br><span class="line">    <span class="params">onCancel</span> <span class="params">handler</span>: <span class="meta">@Sendable</span> () -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>显然，这个函数也是个异步函数，它有两个参数，分别是：</p>
<ul>
<li>operation，即我们要在当前 Task 当中执行的代码逻辑</li>
<li>onCancel，在 operation 执行时，如果 Task 被取消，该回调立即执行</li>
</ul>
<p>有了这个函数，我们就可以在调用第三方异步操作时，及时感知到 Task 的取消状态，并通知第三方取消异步操作。</p>
<h2 id="TaskGroup-的取消"><a href="#TaskGroup-的取消" class="headerlink" title="TaskGroup 的取消"></a>TaskGroup 的取消</h2><p>TaskGroup 也可以被取消，很容易理解，所有从属于 TaskGroup 的 Task 在前者被取消以后也会被取消。下面我们给出一个非常简单的例子来说明这个问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> taskCount <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> withTaskGroup(of: (<span class="type">Int</span>, <span class="type">Int</span>).<span class="keyword">self</span>) &#123; group -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>taskCount &#123;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="operator">!</span><span class="type">Task</span>.isCancelled <span class="operator">&amp;&amp;</span> count <span class="operator">&lt;</span> max &#123;</span><br><span class="line">                <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span> <span class="operator">+</span> <span class="type">UInt64</span>(arc4random_uniform(<span class="number">500_000_000</span>)))</span><br><span class="line">                count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Task: <span class="subst">\(i)</span>, count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (i, count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5500_000_000</span>)</span><br><span class="line">    group.cancelAll()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> result <span class="keyword">in</span> group &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 TaskGroup 当中启动了 10 个 Task， 这些 Task 每隔约 1 ~ 1.5 秒就会令 count 加 1，最终把 Task 的序号和 count 的值返回。TaskGroup 则在启动了所有的 Task 之后 5.5 秒的时候取消，因此前面的 Task 大多只能将 count 增加到 5 左右。运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span>: <span class="number">4</span>, count: <span class="number">1</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">6</span>, count: <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">2</span>, count: <span class="number">4</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">8</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">9</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">9</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">5</span>, count: <span class="number">4</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">7</span>, count: <span class="number">4</span></span><br><span class="line">result: (<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">result: (<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">4</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">6</span>, count: <span class="number">5</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">3</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">result: (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">2</span>, count: <span class="number">5</span></span><br><span class="line"><span class="type">Task</span>: <span class="number">0</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">result: (<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Task</span>: <span class="number">1</span>, count: <span class="number">5</span></span><br><span class="line">result: (<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>我们省略了部分相似的输出，大家只需要关注包含 result 的行，其中 Task 9 返回的 count 为 4，Task 1 返回的 count 为 5。这说明 TaskGroup 在取消时其中的 Task 确实都被取消了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们重点讨论了 Task 的取消的设计，包括取消状态的概念，如何在不同情况下响应取消状态；最后也通过一个简单地例子了解了一下 TaskGroup 的取消。</p>
<p>大家只需要牢记一点，Task 的取消只是一个状态，需要内部执行逻辑的响应。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（6）：Actor 和属性隔离</title>
    <url>//2022/02/12/swift-coroutines-06-actor/</url>
    <content><![CDATA[<blockquote>
<p>异步函数大多数情况下会并发地执行在不同的线程，那么线程安全怎么来保证？ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="什么是-actor"><a href="#什么是-actor" class="headerlink" title="什么是 actor"></a>什么是 actor</h2><p>Swift 为了解决线程安全的问题，引入了一个非常有用的概念叫做 actor。Actor 模型是计算机科学领域的一个用于并行计算的数学模型，其中 actor 是模型当中的基本计算单元。</p>
<p>在 Swift 当中，actor 包含 state、mailbox、executor 三个重要的组成部分，其中：</p>
<ul>
<li>state 就是 actor 当中存储的值，它是受到 actor 保护的，访问时会有一些限制以避免数据竞争（data race）。</li>
<li>mailbox 字面意思是邮箱的意思，在这里我们可以理解成一个消息队列。外部对于 actor 的可变状态的访问需要发送一个异步消息到 mailbox 当中，actor 的 executor 会串行地执行 mailbox 当中的消息以确保 state 是线程安全的。</li>
<li>executor，actor 的逻辑（包括状态修改、访问等）执行所在的执行器。</li>
</ul>
<p>下面我们给出一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> accountNumber: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> balance: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">accountNumber</span>: <span class="type">Int</span>, <span class="params">initialDeposit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.accountNumber <span class="operator">=</span> accountNumber</span><br><span class="line">        <span class="keyword">self</span>.balance <span class="operator">=</span> initialDeposit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个 actor 叫做 BankAccount（这个例子来自 Swift 的 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md">proposal</a>)，不难看出 actor 在形式上与 class 很像，不仅如此，actor 也能像它们一样定义扩展，声明泛型，实现协议等等。</p>
<p>Actor 实际上也是引用类型，所以用起来也更像是确保了数据线程安全的 class，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> account <span class="operator">=</span> <span class="type">BankAccount</span>(accountNumber: <span class="number">1234</span>, initialDeposit: <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> account2 <span class="operator">=</span> account</span><br><span class="line"><span class="built_in">print</span>(account <span class="operator">===</span> account2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们可以用类似于 class 的方式来构造 actor，并且创建多个变量指向同一个实例，以及使用 === 来判断是否指向同一个实例。程序运行时，我们也可以看到 account 和 account2 指向的地址是相同的：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-02-05-21-51-33.png"></p>
<h2 id="Actor-的属性隔离"><a href="#Actor-的属性隔离" class="headerlink" title="Actor 的属性隔离"></a>Actor 的属性隔离</h2><p>为了描述存钱这个行为，我们可能希望在外部修改 balance 的值，如果是 struct 或者 class，这个行为并不麻烦，但对于 actor 来讲，这个修改可能是不安全的，因此不被允许。</p>
<p>那怎么办？我们前面提到修改 actor 的状态需要发邮件，actor 会在收到邮件之后一个一个处理并异步返回给你结果（有没有一种给领导发邮件审批的感觉），这个叫做 actor-isolated（即属性隔离）。</p>
<p>所以我们打开 outlook 发个邮件？当然不是，开个小玩笑。Swift 的 actor 已经把”发邮件“这个操作设计得非常简洁了，简单说就是两点：</p>
<ol>
<li>actor 的可变状态只能在 actor 内部被修改（隔离嘛）</li>
<li>发邮件其实就是一个异步函数调用的过程</li>
</ol>
<p>所以我们需要给 BankAccount 定义一个存钱的函数来完成对 balance 的修改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">deposit</span>(<span class="params">amount</span>: <span class="type">Double</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(amount <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">        balance <span class="operator">=</span> balance <span class="operator">+</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把它定义在扩展当中，接下来就可以愉快得存钱了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> account <span class="operator">=</span> <span class="type">BankAccount</span>(accountNumber: <span class="number">1234</span>, initialDeposit: <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(account.accountNumber) <span class="comment">// OK，不可变状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> account.balance) <span class="comment">// 可变状态的访问需要使用 await</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> account.deposit(amount: <span class="number">90</span>) <span class="comment">// actor 的函数调用需要 await</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> account.balance)</span><br></pre></td></tr></table></figure>

<p>这个例子当中有几个细节请大家留意：</p>
<ol>
<li>accountNumber 可以直接访问，因为它不可变。不可变就意味着不存在线程安全问题。</li>
<li>对可变的状态 balance 的访问以及对函数 deposit 的调用都是异步调用，需要用 await，因为这个访问实际上封装了发邮件的过程。</li>
</ol>
<p>接下来再给大家看一下转账的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">BankError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">transfer</span>(<span class="params">amount</span>: <span class="type">Double</span>, <span class="params">to</span> <span class="params">other</span>: <span class="type">BankAccount</span>) <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> amount <span class="operator">&gt;</span> balance &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">BankError</span>.insufficientFunds</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    balance <span class="operator">=</span> balance <span class="operator">-</span> amount</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other.balance = other.balance + amount 错误示例</span></span><br><span class="line">    <span class="keyword">await</span> other.deposit(amount: amount) <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 transfer 是 BankAccount 自己的函数，修改自己 balance 的值自然没有什么问题。但修改 other 这个 BankAccount 实例的 balance 的值却是不行的，因为 tranfer 函数执行时实际上是 self 这个实例在处理自己的邮件，这里面如果偷偷修改了 other 的 balance 的值就可能导致 other 的状态出现问题（试想一下你处理自己的邮件的时候偷偷把领导的邮件给删了，看他发现了之后骂不骂你）。</p>
<p>这个例子告诉我们，actor 的状态只能在自己实例的函数内部修改，而不能跨实例修改。</p>
<h2 id="外部函数修改-actor-的状态"><a href="#外部函数修改-actor-的状态" class="headerlink" title="外部函数修改 actor 的状态"></a>外部函数修改 actor 的状态</h2><p>前面我们反复提到 actor 的状态只能在自己的函数内部修改，是因为 actor 的函数的调用是在对应的 executor 上安全地执行的。如果外部的函数也能够满足这个调用条件，那么理论上也是安全的。</p>
<p>Swift 提供了 actor-isolated paramters 这样的特性，字面意思即满足 actor 状态隔离的参数，如果我们在定义外部函数时将需要访问的 actor 类型的参数声明为 isolated，那么我们就可以在函数内部修改这个 actor 的状态了。</p>
<p>基于这一点，我们也可以把 deposit 函数定义成顶级函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">deposit</span>(<span class="params">amount</span>: <span class="type">Double</span>, <span class="params">to</span> <span class="params">account</span>: <span class="keyword">isolated</span> <span class="type">BankAccount</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(amount <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">    account.balance <span class="operator">=</span> account.balance <span class="operator">+</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到参数 account 的类型被关键字 isolated 修饰，表明函数 deposit 的调用需要保证 account 的状态修改安全。不难想到，对于这个函数的调用，我们需要使用 await：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> deposit(amount: <span class="number">1000</span>, to: account)</span><br></pre></td></tr></table></figure>

<p>显然，这里的 isolated 参数不能有多个（至少现在是这样），不然在实现起来会比较麻烦。</p>
<h2 id="声明不需要隔离的属性或函数"><a href="#声明不需要隔离的属性或函数" class="headerlink" title="声明不需要隔离的属性或函数"></a>声明不需要隔离的属性或函数</h2><p>Actor 的属性默认都是需要被隔离保护的，但也有一些属性可能并不需要被保护，例如我们前面提到的不可变的状态。Swift 允许为 actor 声明不需要隔离的属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> : <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;Bank account #<span class="subst">\(accountNumber)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 description 被声明为 nonisolated，这样对于它的访问就不会受到 balance 那么多的限制了。</p>
<p>nonisolated 同样可以用来修饰函数，但这样的函数就不能直接访问被隔离的状态了，只能像外部函数一样使用 await 来异步访问。</p>
<p>这个特性在 Actor 实现 Protocol 的时候也显得非常有用，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BankAccount</span> : <span class="title class_">Hashable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">BankAccount</span>, <span class="params">rhs</span>: <span class="type">BankAccount</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.accountNumber <span class="operator">==</span> rhs.accountNumber</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">func</span> <span class="title function_">hash</span>(<span class="params">into</span> <span class="params">hasher</span>: <span class="keyword">inout</span> <span class="type">Hasher</span>) &#123;</span><br><span class="line">        hasher.combine(accountNumber)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            accountNumber.hashValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不加 nonisolated，编译器会给出如下提示：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/6c8656be-f0d8-432e-9bfd-94a1fbd7cd6c/media/2022-02-05-22-39-08.png"></p>
<p>顺便提一句，在早期的提案当中，你可能会见到 @actorIndependent，它后来被重命名为 nonisolated，这样在语法上与 nonmutating 也更加一致。</p>
<h2 id="Actor-与-Sendable"><a href="#Actor-与-Sendable" class="headerlink" title="Actor 与 @Sendable"></a>Actor 与 @Sendable</h2><p>在介绍协程的过程中，我们见过很多函数的闭包都被声明为 <code>@Sendable</code>，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withTaskCancellationHandler</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, </span><br><span class="line">    <span class="params">onCancel</span> <span class="params">handler</span>: <span class="meta">@Sendable</span> () -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>其中 onCancel 就被声明为 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md">@Sendable</a>，这表明只有实现了 <code>Sendable</code> 协议的类型实例才能被这个闭包所捕获。</p>
<p>Actor 天生就是线程安全的，因此也是符合 Sendable 协议的。实际上 Swift 的每一个 actor 类型都隐式地实现了一个叫做 <code>Actor</code> 的协议，而这个协议也正实现了 <code>Sendable</code> 协议。</p>
<p>我们看一下 <code>Actor</code> 的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Actor</span> : <span class="title class_">AnyObject</span>, <span class="title class_">Sendable</span> &#123;</span><br><span class="line">    <span class="keyword">nonisolated</span> <span class="keyword">var</span> unownedExecutor: _Concurrency.<span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了定义了调度器之外，它也继承了 Sendable 协议。因此如果大家遇到 @Sendable 闭包需要捕获变量的问题，不妨试一试使用 Actor 来做一层封装。</p>
<p>顺便提一句，actor 的调度器目前主要由编译器提供默认的实现。官方目前对于自定义调度器的途径还没有给出明确的支持，不过我们将在下一篇文章当中详细探索一下调度器的使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们主要介绍了 Swift 协程当中的 actor 的基本用法，并重点对属性隔离做了详细介绍。</p>
<p>有关 actor 的调度器的内容，我们将在下一篇文章当中详细介绍。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</title>
    <url>//2022/02/12/swift-coroutines-07-globalactor/</url>
    <content><![CDATA[<blockquote>
<p>我们已经知道可以使用 actor 来确保数据的线程安全，但对于数据的保护总是需要定义专门的 actor 实例是不是太麻烦了一些？ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="什么是-GlobalActor"><a href="#什么是-GlobalActor" class="headerlink" title="什么是 GlobalActor"></a>什么是 GlobalActor</h2><p>前面我们为了保护特定的状态，就把这些状态包装到一个特定的 actor 实例当中，保护的方式就是将对于这些状态的访问调度到相应的 actor 的调度器当中串行执行。</p>
<p>那么问题来了，如果我有很多分散到不同类甚至不同模块的状态，希望统一调度，该怎么办？最典型的例子就是将 UI 操作调度到主线程，UI 本身就分散在不同的组件当中，对于 UI 的操作更是如此。为了应对这种场景，Swift 在提供了 actor 的基础上又进一步提供了 GlobalActor，旨在提供全局统一的执行调度。</p>
<p>GlobalActor 是一个协议，我们来看一下它的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ActorType</span> : _Concurrency.<span class="type">Actor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="keyword">Self</span>.<span class="type">ActorType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sharedUnownedExecutor: _Concurrency.<span class="type">UnownedSerialExecutor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ActorType</code> 是实现 <code>GlobalActor</code> 协议的类型需要提供的全局唯一的 actor 的类型</li>
<li><code>shared</code> 是上述全局唯一的 actor 的实例</li>
<li><code>sharedUnownedExecutor</code> 是上述全局唯一的 actor 实例的调度器，它的值要求与 <code>shared.unownedExecutor</code> 一致</li>
</ul>
<p>所以只要确定了 <code>shared</code> 是谁，那么这个 <code>GlobalActor</code> 也就确定了。</p>
<p>此外，一个类型在实现 <code>GlobalActor</code> 时，我们还可以用 <code>@globalActor</code> 来修饰它，这样我们就可以用这个实现类去修饰需要使用该 <code>GlobalActor</code> 的实现类来隔离的函数或者属性了。这么说比较抽象，我们接下来看看官方目前提供的唯一一个 <code>GlobalActor</code> 实现是怎么定义的。</p>
<h2 id="探索-MainActor"><a href="#探索-MainActor" class="headerlink" title="探索 MainActor"></a>探索 MainActor</h2><p><code>MainActor</code> 是目前唯一一个 <code>GlobalActor</code> 的实现，它用来将对属性或者函数的访问隔离到主线程上执行。我们来看看它的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@globalActor</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">actor</span> <span class="title class_">MainActor</span>: <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">MainActor</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@inlinable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">nonisolated</span> <span class="keyword">var</span> unownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnownedSerialExecutor</span>(<span class="type">Builtin</span>.buildMainActorExecutorRef())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@inlinable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> sharedUnownedExecutor: <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnownedSerialExecutor</span>(<span class="type">Builtin</span>.buildMainActorExecutorRef())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 <code>MainActor</code> 是一个 actor 类型，这对于 <code>GlobalActor</code> 协议来说不是必须的，我们完全可以定义一个 class 来实现 <code>GlobalActor</code>，并且把一个 actor 类型关联到 <code>GlobalActor</code> 上即可。当然，如果条件允许，直接用 actor 类型来实现 <code>GlobalActor</code> 自然更方便一些。</p>
<p>我们在前面提到过，<code>sharedUnownedExecutor</code> 要与 <code>shared.unownedExecutor</code> 一致，这里很显然二者本质上都是 <code>Builtin.buildMainActorExecutorRef()</code>。</p>
<p>此外，<code>MainActor</code> 被 <code>@globalActor</code> 修饰之后，自己就可以被用于修饰属性、函数或者类型，我们给出几个简单的 <code>MainActor</code> 的例子：</p>
<p>修饰属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@MainActor</span> <span class="keyword">var</span> value: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMain</span>() &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMain</span>(<span class="params">block</span>: <span class="meta">@MainActor</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMain before&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMain after&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UiState</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">value</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 <code>@MainActor</code> 修饰的函数在调用时，如果当前不在主线程，则必须异步调度到主线程上执行；同样地，被修饰的属性在被其他线程访问时，也必须异步调度到主线程上处理。</p>
<p>被 <code>@MainActor</code> 修饰的类的构造器、属性、函数都需要调度到主线程上执行。需要注意的是，为了保证继承的一致性，被修饰的类需要满足或没有父类、或同样被 <code>@MainActor</code> 修饰、或父类是 <code>NSObject</code>；被修饰的类的子类也将会隐式获得 <code>@MainActor</code> 上的状态隔离。</p>
<p>这里的异步访问逻辑实际上与 actor 类型的状态和函数的关系相同，即被 <code>@MainActor</code> 修饰的函数内部访问同样被 <code>@MainActor</code> 修饰的属性时则不需要异步执行，就好像它们都被定义到 <code>MainActor</code> 这个 actor 类型当中一样。</p>
<p>以上使用方法和细节同样适用于其他 <code>GlobalActor</code> 的实现。</p>
<h2 id="自定义-GlobalActor-的实现"><a href="#自定义-GlobalActor-的实现" class="headerlink" title="自定义 GlobalActor 的实现"></a>自定义 GlobalActor 的实现</h2><p>了解了 <code>MainActor</code> 的定义之后，我们就可以试着给出自定义的 <code>GlobalActor</code> 实现了，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@globalActor</span> <span class="keyword">actor</span> <span class="title class_">MyActor</span>: <span class="title class_">GlobalActor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 协议当中的 associatedtype</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ActorType</span> <span class="operator">=</span> <span class="type">MyActor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 当中的 shared，返回一个全局共享的 MyActor 实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared: <span class="type">MyActor</span> <span class="operator">=</span> <span class="type">MyActor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> _sharedExecutor <span class="operator">=</span> <span class="type">MyExecutor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 GlobalActor 当中的 sharedUnownedExecutor，返回自己的调度器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedUnownedExecutor: <span class="type">UnownedSerialExecutor</span> <span class="operator">=</span> _sharedExecutor.asUnownedSerialExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示实现 Actor 协议当中的调度器，避免让编译器自动生成</span></span><br><span class="line">    <span class="keyword">let</span> unownedExecutor: <span class="type">UnownedSerialExecutor</span> <span class="operator">=</span> sharedUnownedExecutor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中自定义的调度器 <code>MyExecutor</code> 的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyExecutor</span> : <span class="title class_">SerialExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义 DispatchQueue，用于真正地调度异步函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> dispatcher: <span class="type">DispatchQueue</span> <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;MyActor&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调度时，Swift 的协程运行时会创建一个 UnownedJob 实例调用 enqueue 进行调度</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">job</span>: <span class="type">UnownedJob</span>) &#123;</span><br><span class="line">        log(<span class="string">&quot;enqueue&quot;</span>)</span><br><span class="line">        <span class="type">MyExecutor</span>.dispatcher.async &#123;</span><br><span class="line">            <span class="comment">// 执行这个 job</span></span><br><span class="line">            job._runSynchronously(on: <span class="keyword">self</span>.asUnownedSerialExecutor())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 unowned 引用，得到 UnownedSerialExecutor 实例</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asUnownedSerialExecutor</span>() -&gt; <span class="type">UnownedSerialExecutor</span> &#123;</span><br><span class="line">        <span class="type">UnownedSerialExecutor</span>(ordinary: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以简单阅读代码的注释来了解他们的作用。注意到 <code>MyActor</code> 也实现了 <code>GlobalActor</code> 协议，我们也使用 <code>@globalActor</code> 来修饰 <code>MyActor</code>，这样我们就可以用 <code>@MyActor</code> 像 <code>@MainActor</code> 那样去修饰函数、属性和类，并让它调度到我们自己实现的调度器上了。</p>
<p>有关 <code>MyActor</code> 的使用示例，我们将在下一节进一步讨论。</p>
<blockquote>
<p><strong>注意</strong> 截至本文撰写时，Swift 的最新版本为 5.5.1。当前 Swift 协程对于自定义调度器的支持还在提案阶段，细节可参见：<a href="https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md">Custom Executors</a>。</p>
</blockquote>
<h2 id="深入探讨-Actor-与协程的调度"><a href="#深入探讨-Actor-与协程的调度" class="headerlink" title="深入探讨 Actor 与协程的调度"></a>深入探讨 Actor 与协程的调度</h2><p>Swift 的协程在执行调度问题上目前还比较含蓄，文档当中很少提及异步函数的执行以及异步函数返回时如何恢复。实际上，异步函数所在的调用位置会关联一个调度器，这个调度器要么来自于所在的 Task，要么来自于当前函数所属于的 actor 实例。</p>
<p>Swift 定义了两个默认的调度器，一个是并发的，一个是串行的；另外就是我们前面提到的，用于将异步函数调度到主线程上的主线程的调度器。</p>
<p>为了搞清楚 Swift 协程究竟是如何调度的，我们用 <code>MainActor</code> 和自定义的 <code>MyActor</code> 来调度我们的异步函数，看看有什么新发现。</p>
<p>在下面的例子当中，我们使用 @MainActor 修饰函数 calledOnMain：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMain</span>() &#123;</span><br><span class="line">    log(<span class="string">&quot;onMain&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来创建一个 Task 来调用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> calledOnMain()</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用 log 这个定义的函数来打印输出，它与 print 的不同之处在于它会同时打印当前线程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x6000015c41c0</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x6000015c4080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] onMain</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x6000015c41c0</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure>

<p>可以看到，calledOnMain 被调度到了 MainThread 上执行。task start 和 task end 执行所在的线程相同（当然也可以不同，但一定是相同的调度器所属的线程），这说明 calledOnMain 返回之后 Task 又被调度与之关联的调度器上执行。</p>
<p>@MainActor 也可以被用于修饰闭包的类型，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMain</span>(<span class="params">block</span>: <span class="meta">@MainActor</span> <span class="keyword">@escaping</span> () <span class="keyword">async</span> -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们试着调用一下这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> runOnMain &#123;</span><br><span class="line">        log(<span class="string">&quot;on main&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMain before</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600000ac8380</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] on main</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMain after</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600000ac8480</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure>

<p>这次只有 block 才会被调度到 MainThread 上，因为只有它被 @MainActor 修饰。</p>
<p>从这个例子当中我们其实还能推测出调度发生的位置，即：</p>
<ul>
<li>异步函数开始执行</li>
<li>异步函数返回之处</li>
</ul>
<p>实际上除此之外，Task 开始时也可能会发生一次调度。这些都是可能的调度位置，Swift 的运行时会根据实际情况判断调度前后是不是属于同一个调度器，以决定是不是真的需要发生调度。这些也能从我们待会儿的例子当中得到印证。</p>
<p>接下来我们使用 <code>MyActor</code> 依样画葫芦，完成类似的例子：</p>
<p>首先是函数的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runOnMyExecutor</span>(<span class="params">block</span>: <span class="meta">@MyActor</span> <span class="keyword">@escaping</span> () <span class="keyword">async</span> -&gt; <span class="type">Void</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> block()</span><br><span class="line">    log(<span class="string">&quot;runOnMyExecutor end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyActor</span> <span class="keyword">func</span> <span class="title function_">calledOnMyExecutor</span>() &#123;</span><br><span class="line">    log(<span class="string">&quot;onMyExecutor&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用它们：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> calledOnMyExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> runOnMyExecutor &#123;</span><br><span class="line">        log(<span class="string">&quot;on MyExecutor before sleep&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1000_000_000</span>)</span><br><span class="line">        log(<span class="string">&quot;on MyExecutor after sleep&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] onMyExecutor</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb4040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] on <span class="type">MyExecutor</span> before sleep</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] enqueue</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] on <span class="type">MyExecutor</span> after sleep</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor end</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600003eb8040</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">3</span>, name <span class="operator">=</span> (null)&#125;] task end</span><br></pre></td></tr></table></figure>

<p>注意到 <code>calledOnMyExecutor</code> 调用时、<code>runOnMyExecutor</code> 当中的 <code>block</code> 执行时、<code>block</code> 当中的 sleep 之后恢复时分别执行了一次 <code>enqueue</code>。大家有兴趣的话也可以在其中穿插一些需要调度到主线程的函数调用，看看实际的调度情况。</p>
<h2 id="Task-与-actor-上下文"><a href="#Task-与-actor-上下文" class="headerlink" title="Task 与 actor 上下文"></a>Task 与 actor 上下文</h2><p>我们在前面介绍 Task 的构造时，讲到过可以使用 <code>init</code> 和 <code>detached</code> 两种方式来构造 Task 实例，前者会继承外部的上下文，包括 actor、TaskLocal 等，后者则不会。</p>
<p>下面的例子将会证明这其中有关 actor 的部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    log(<span class="string">&quot;task start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> runOnMain &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;task in runOnMain&quot;</span>)</span><br><span class="line">        &#125;.value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.detached &#123;</span><br><span class="line">            log(<span class="string">&quot;detached task in runOnMain&quot;</span>)</span><br><span class="line">        &#125;.value</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;task end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的介绍，我们已经知道 runOnMain 的参数 block 会被调度到 MainThread 上执行，那么其中的两个 <code>Task</code> 的日志输出理论上会有不同的表现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] task start</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] runOnMyExecutor start</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] task <span class="keyword">in</span> runOnMain</span><br><span class="line">[<span class="operator">&lt;</span><span class="type">NSThread</span>: <span class="number">0x600001520180</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">2</span>, name <span class="operator">=</span> (null)&#125;] detached task <span class="keyword">in</span> runOnMain</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] runOnMyExecutor end</span><br><span class="line">[<span class="operator">&lt;</span>_NSMainThread: <span class="number">0x600001520080</span><span class="operator">&gt;</span>&#123;number <span class="operator">=</span> <span class="number">1</span>, name <span class="operator">=</span> main&#125;] task end</span><br></pre></td></tr></table></figure>

<p>实际上也正是如此，<code>task in runOnMain</code> 打印到了 MainThread 上，而 <code>detached task in runOnMain</code> 因为通过 <code>detached</code> 创建的 <code>Task</code> 实例不会继承外部的 actor（以及其调度器），因此打印到了其他线程上（也就是默认的调度器上）。</p>
<p>Task 的两种不同的构造方式对于 TaskLocal 的继承情况同样如此，我们将在下一篇文章当中再给出对比示例。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们详细介绍了 GlobalActor 的设计初衷、实现方式以及使用方法，也探讨了 Swift 协程的调度细节，相信读者看到这里时，已经掌握了绝大多数 Swift 协程的相关知识。</p>
<p>下一篇文章我们将简单介绍一下 TaskLocal 的使用方法。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（8）：TaskLocal</title>
    <url>//2022/02/12/swift-coroutines-08-tasklocal/</url>
    <content><![CDATA[<blockquote>
<p>如果我想要定义一个变量，它的值只在 Task 内部共享，怎么做到呢？ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="TaskLocal-值的定义和使用"><a href="#TaskLocal-值的定义和使用" class="headerlink" title="TaskLocal 值的定义和使用"></a>TaskLocal 值的定义和使用</h2><p>TaskLocal 值就是 Task 私有的值，不同的 Task 对于这个变量的访问将得到不同的结果。</p>
<p>下面我们给出示例演示如何定义一个 TaskLocal 值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskLocal 值必须定义为静态的存储属性，并使用 TaskLocal 这个属性包装器（property wrapper）来包装。TaskLocal 值也受限于属性包装器的支持范围，不能定义为顶级属性。</p>
<p>变量 tag 的初始值为 <code>default</code>，属性包装器 TaskLocal 的构造器会接收这个值并存起来备用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> defaultValue: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">defaultValue</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.defaultValue <span class="operator">=</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解属性包装器的读者应该也能想到初始值的定义还可以写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@TaskLocal</span>(wrappedValue: <span class="string">&quot;default&quot;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tag: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察 TaskLocal 的定义，我们也发现它对于被包装的类型是有要求的，即要实现 Sendable 协议。</p>
<blockquote>
<p>有关 Swift 属性包装器的介绍，可以参考我之前的一篇文章：<a href="https://www.bennyhuo.com/2020/05/08/kotlin-swift-property-delegate/">Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper</a>。</p>
</blockquote>
<p>了解了定义之后，接下来看用法。</p>
<p>首先要写入值，我们只需要调用属性包装器的 withValue 函数，它的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, </span><br><span class="line">    <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>, </span><br><span class="line">    <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, </span><br><span class="line">    <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span></span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span></span><br></pre></td></tr></table></figure>

<p>调用示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in my task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 $tag 就是 tag 的属性包装器的 projectedValue，这个值正是 TaskLocal 这个属性包装器对象本身。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">TaskLocal</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>withValue 有两个参数，一个是要绑定给 tag 的值，即 <code>MyTask</code>；另一个就是一个闭包，这个绑定的值只有在这个闭包当中有效，一旦闭包执行结束，tag 绑定的值的生命周期也就结束了。</p>
<p>接下来我们尝试去读取它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">logWithTag</span>(<span class="keyword">_</span> <span class="params">message</span>: <span class="keyword">Any</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(Logger.tag)</span>): <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取的方式就显得普通而又枯燥了。写法非常直接，不过大家要明白，这个读的行为实际上是通过 TaskLocal 属性包装器完成的。</p>
<p>作为对比，我们给出一个稍微完整的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;in withValue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> logWithTag(<span class="string">&quot;out of withValue&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="keyword">in</span> withValue</span><br><span class="line">(<span class="keyword">default</span>): out of withValue</span><br></pre></td></tr></table></figure>

<h2 id="Task-对于-TaskLocal-的继承"><a href="#Task-对于-TaskLocal-的继承" class="headerlink" title="Task 对于 TaskLocal 的继承"></a>Task 对于 TaskLocal 的继承</h2><p>上一篇文章当中我们通过示例演示了 <code>init</code> 和 <code>detach</code> 构造的 Task 实例对 actor 上下文的继承，这次我们给大家再演示一下对 TaskLocal 的继承，以进一步加深大家的理解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;MyTask&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.init&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">Task</span>.detached &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;Task.detached&quot;</span>)</span><br><span class="line">    &#125;.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子相比之前的调度器的例子就更显得普通而又枯燥了，程序输出如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">MyTask</span>): <span class="type">Task</span>.<span class="keyword">init</span></span><br><span class="line">(<span class="keyword">default</span>): <span class="type">Task</span>.detached</span><br></pre></td></tr></table></figure>
<p>可以看到，通过 <code>detached</code> 创建的 Task 实例可谓是“六亲不认”，不仅不继承 actor 的上下文，也对 TaskLocal 不管不顾。另外不难想到的是，Swift 并没有提供修改外部 TaskLocal 值的 API，因此外部的 TaskLocal 值只能被继承，不能被修改。</p>
<h2 id="深入探查-TaskLocal-的存储方式"><a href="#深入探查-TaskLocal-的存储方式" class="headerlink" title="深入探查 TaskLocal 的存储方式"></a>深入探查 TaskLocal 的存储方式</h2><p>TaskLocal 值虽然看起来就是个静态存储属性，但它的值实际上是存储在 Task 相关的内存当中的。它的读写性能自然也与它的存储方式有关，因此为了确保能够正确合理的使用 TaskLocal，我们有必要了解一下它究竟是如何存储的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskLocal</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Sendable</span>&gt;: <span class="title class_">Sendable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">  <span class="operator">..</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个变量唯一，用于查找值的 key</span></span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">Builtin</span>.<span class="type">RawPointer</span> &#123;</span><br><span class="line">    <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, to: <span class="type">Builtin</span>.<span class="type">RawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 TaskLocal 值的值时调用该函数</span></span><br><span class="line">  <span class="comment">// 通过 _taskLocalValueGet 到 Task 实例当中查找对应的值</span></span><br><span class="line">  <span class="comment">// 如果没有找到，则返回 defaultValue，即初始值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">get</span>() -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> rawValue <span class="operator">=</span> _taskLocalValueGet(key: key) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.defaultValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> storagePtr <span class="operator">=</span></span><br><span class="line">        rawValue.bindMemory(to: <span class="type">Value</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Value</span>&gt;(mutating: storagePtr).pointee</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withValue</span>&lt;<span class="type">R</span>&gt;(<span class="keyword">_</span> <span class="params">valueDuringOperation</span>: <span class="type">Value</span>, <span class="params">operation</span>: () <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>,</span><br><span class="line">                           <span class="params">file</span>: <span class="type">String</span> <span class="operator">=</span> <span class="keyword">#file</span>, <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span>) <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">    _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: file, line: line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入值</span></span><br><span class="line">    _taskLocalValuePush(key: key, value: valueDuringOperation)</span><br><span class="line">    <span class="keyword">defer</span> &#123; </span><br><span class="line">        <span class="comment">// 确保在 withValue 退出的时候将值释放掉</span></span><br><span class="line">        _taskLocalValuePop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> operation()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们注意到有几个关键的函数，它们的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePush&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePush</span>&lt;<span class="type">Value</span>&gt;(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*: Key*/</span>,</span><br><span class="line">  <span class="params">value</span>: __owned <span class="type">Value</span></span><br><span class="line">) <span class="comment">// where Key: TaskLocal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValuePop&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValuePop</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@_silgen_name</span>(<span class="string">&quot;swift_task_localValueGet&quot;</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">_taskLocalValueGet</span>(</span><br><span class="line">  <span class="params">key</span>: <span class="type">Builtin</span>.<span class="type">RawPointer</span><span class="comment">/*Key*/</span></span><br><span class="line">) -&gt; <span class="type">UnsafeMutableRawPointer</span>? <span class="comment">// where Key: TaskLocal</span></span><br></pre></td></tr></table></figure>

<p>通过 _silgen_name 的值，我们可以找到他们在 C++ 当中的定义，以 <code>_taskLocalValueGet</code> 为例，我们给出 <code>swift_task_localValueGet</code> 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SWIFT_CC</span>(swift)</span><br><span class="line"><span class="function"><span class="type">static</span> OpaqueValue* <span class="title">swift_task_localValueGetImpl</span><span class="params">(<span class="type">const</span> HeapObject *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (AsyncTask *task = <span class="built_in">swift_task_getCurrent</span>()) &#123;</span><br><span class="line">    <span class="comment">// 从当前 Task 的本地存储当中读取值，AsyncTask 实际上就是 C++ 层当中 Task 对应的类型</span></span><br><span class="line">    <span class="keyword">return</span> task-&gt;<span class="built_in">localValueGet</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncTask::localValueGet</code> 本质上调用的就是 <code>TaskLocal::Storage::getValue(AsyncTask *,const HeapObject *)</code>，我们同样可以找到它的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OpaqueValue* TaskLocal::Storage::<span class="built_in">getValue</span>(AsyncTask *task,</span><br><span class="line">                                          <span class="type">const</span> HeapObject *key) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(key &amp;&amp; <span class="string">&quot;TaskLocal key must not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> item = head;</span><br><span class="line">  <span class="comment">// 遍历以 head 为头节点的链表</span></span><br><span class="line">  <span class="keyword">while</span> (item) &#123;</span><br><span class="line">    <span class="comment">// 比较 key，直到找到对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;key == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> item-&gt;<span class="built_in">getStoragePtr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = item-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，查找过程其实就是链表的遍历查找，时间复杂度为 O(n)。</p>
<p>我们再稍微观察一下插入和删除的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> TaskLocal::Storage::<span class="built_in">pushValue</span>(AsyncTask *task,</span><br><span class="line">                                   <span class="type">const</span> HeapObject *key,</span><br><span class="line">                                   <span class="comment">/* +1 */</span> OpaqueValue *value,</span><br><span class="line">                                   <span class="type">const</span> Metadata *valueType) &#123;</span><br><span class="line">  <span class="keyword">auto</span> item = Item::<span class="built_in">createLink</span>(task, key, valueType);</span><br><span class="line">  valueType-&gt;<span class="built_in">vw_initializeWithTake</span>(item-&gt;<span class="built_in">getStoragePtr</span>(), value);</span><br><span class="line">  head = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> TaskLocal::Storage::<span class="built_in">popValue</span>(AsyncTask *task) &#123;</span><br><span class="line">  <span class="keyword">auto</span> old = head;</span><br><span class="line">  head = head-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">  old-&gt;<span class="built_in">destroy</span>(task);</span><br><span class="line">  <span class="keyword">return</span> head != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现这实际上就是一个采用头插法的单链表。为什么选择这样的设计呢？</p>
<p>显然，绝大多数情况下 TaskLocal 值的数量都不会很多，同时插入的值只在 withValue 函数范围内有效也使得绝大多数查找的值都排在链表前面，因此线性查找的效率并不会存在性能问题。</p>
<p>而链表的结构也使得增删节点非常容易，使用头插法使得 withValue 函数退出时释放销毁对应的值也变得非常容易，时间复杂度只需要 O(1)。</p>
<p>另外，使用单链表来存储 TaskLocal 值还有一个好处，那就是变量遮蔽，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task1&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Logger</span>.<span class="variable">$tag</span>.withValue(<span class="string">&quot;Task3&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> logWithTag(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> logWithTag(<span class="string">&quot;22&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> logWithTag(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">Task1</span>): <span class="number">1</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">2</span></span><br><span class="line">(<span class="type">Task3</span>): <span class="number">3</span></span><br><span class="line">(<span class="type">Task2</span>): <span class="number">22</span></span><br><span class="line">(<span class="type">Task1</span>): <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>简单总结一下，TaskLocal 值是存在链表当中的，我们在使用过程中应当避免使用过多的 TaskLocal 值，也应该适当地减少对 TaskLocal 值的访问次数，以避免性能上最坏的情况出现。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对 TaskLocal 值的使用和实现机制做了剖析。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>闲话 Swift 协程（9）：异步函数与其他语言的互调用</title>
    <url>//2022/02/16/swift-coroutines-09-interop/</url>
    <content><![CDATA[<blockquote>
<p>现在很多 iOS APP 还是用 Objective-C 写的，异步函数在 Objective-C 当中怎么调用也是个问题。 </p>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-00-foreword/">闲话 Swift 协程（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/11/swift-coroutines-01-intro/">闲话 Swift 协程（1）：Swift 协程长什么样？</a></li>
<li><a href="https://www.bennyhuo.com/2021/10/13/swift-coroutines-02-wrap-callback/">闲话 Swift 协程（2）：将回调改写成 async 函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/21/swift-coroutines-03-call-async-func/">闲话 Swift 协程（3）：在程序当中调用异步函数</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/22/swift-coroutines-04-structured-concurrency/">闲话 Swift 协程（4）：TaskGroup 与结构化并发</a></li>
<li><a href="https://www.bennyhuo.com/2022/01/28/swift-coroutines-05-cancellation/">闲话 Swift 协程（5）：Task 的取消</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-06-actor/">闲话 Swift 协程（6）：Actor 和属性隔离</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-07-globalactor/">闲话 Swift 协程（7）：GlobalActor 和异步函数的调度</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/12/swift-coroutines-08-tasklocal/">闲话 Swift 协程（8）：TaskLocal</a></li>
<li><a href="https://www.bennyhuo.com/2022/02/16/swift-coroutines-09-interop/">闲话 Swift 协程（9）：异步函数与其他语言的互调用</a></li>
</ul>
<h2 id="从异步回调到异步函数"><a href="#从异步回调到异步函数" class="headerlink" title="从异步回调到异步函数"></a>从异步回调到异步函数</h2><p>截止目前，我们已经详细探讨了 Swift 协程当中的绝大多数语法设计，这其中最基本也是最重要的就是异步函数。</p>
<p>在异步函数出现之前，我们通常会为函数添加回调来实现异步结果返回，以 Swift 的网络请求库 Alamofire 为例，它的 DataRequest 有这样一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">responseData</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods,</span><br><span class="line">  <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Data</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有很多参数，不过我们只需要关心最后一个：completionHandler，它是一个闭包，接收一个参数为 <code>AFDataResponse&lt;Data&gt;</code> 的类型作为请求结果。</p>
<p>从 Swift 5.5 开始，我们可以将其包装成异步函数，添加对结果的异步返回、异常的传播以及对取消响应的支持：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">responseDataAsync</span>(</span><br><span class="line">  <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">  <span class="params">dataPreprocessor</span>: <span class="type">DataPreprocessor</span> <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultDataPreprocessor,</span><br><span class="line">  <span class="params">emptyResponseCodes</span>: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyResponseCodes,</span><br><span class="line">  <span class="params">emptyRequestMethods</span>: <span class="type">Set</span>&lt;<span class="type">HTTPMethod</span>&gt; <span class="operator">=</span> <span class="type">DataResponseSerializer</span>.defaultEmptyRequestMethods</span><br><span class="line">) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            responseData(</span><br><span class="line">                queue: queue,</span><br><span class="line">                dataPreprocessor: dataPreprocessor,</span><br><span class="line">                emptyResponseCodes: emptyResponseCodes, emptyRequestMethods: emptyRequestMethods</span><br><span class="line">            ) &#123; response <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> data): continuation.resume(returning: data)</span><br><span class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> error): continuation.resume(throwing: error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; onCancel: &#123;</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从异步回调到异步函数总是要经过这样一个包装的过程，这个过程实际上并不轻松。因此我们也更希望第三方开发者在提供异步回调的时候同时提供异步函数的版本来方便我们按需使用。</p>
<h2 id="Objective-C-的异步回调"><a href="#Objective-C-的异步回调" class="headerlink" title="Objective-C 的异步回调"></a>Objective-C 的异步回调</h2><h3 id="Objective-C-回调函数的自动转换"><a href="#Objective-C-回调函数的自动转换" class="headerlink" title="Objective-C 回调函数的自动转换"></a>Objective-C 回调函数的自动转换</h3><p>在以前的 iOS SDK 当中，接收形如 completionHandler 这样的回调的 Objective-C 函数有 1000 多个。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)signData:(NSData *)signData </span><br><span class="line">withSecureElementPass:(PKSecureElementPass *)secureElementPass </span><br><span class="line">      completion:(void (^)(NSData *signedData, NSData *signature, NSError *error))completion;</span><br></pre></td></tr></table></figure>

<p>这个函数相当于 Swift 的如下函数声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, </span><br><span class="line">    <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>, </span><br><span class="line"><span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">Data</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们对这些函数一个一个完成包装，那必然会耗费大量的时间和精力。因此，Swift 对接收类似的回调并符合一定条件的 Objective-C 函数自动做了一些转换，以上述 signData 函数为例，可以被自动转换为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sign</span>(<span class="keyword">_</span> <span class="params">signData</span>: <span class="type">Data</span>, <span class="params">using</span> <span class="params">secureElementPass</span>: <span class="type">PKSecureElementPass</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">Data</span>)</span><br></pre></td></tr></table></figure>

<p>我们来简单分析一下这个转换过程。</p>
<ol>
<li>参数 completion 被移除了。 completion 的类型是 Objective-C 的 block，可以用来处理异步结果的返回。</li>
<li>转换后的异步函数的返回值 (Data, Data)，它实际上对应于 completion 除 <code>NSError *</code> 之外的两个参数。需要注意的是，回调当中的 signedData 和 signature 的类型均为 <code>NSData *</code>，它们实际上是可以为 nil 的，单纯考虑类型的映射，它们应该映射成 Swift 的 <code>Data?</code> 类型，而在转换之后的异步函数当中则为 <code>Data</code> 类型，这是因为逻辑上如果这俩个 <code>Data</code> 返回 nil，则应该通过参数 <code>NSError *</code> 来使得异步函数抛出异常。这个细节一定要注意。</li>
<li>completion 的参数 <code>NSError *</code> 表示结果有可能会出现异常，因此转换后的异步函数是会抛出异常的，声明为 throws。</li>
</ol>
<p>那这个转换需要符合什么条件呢？</p>
<ul>
<li>函数本身和参数回调的返回值均为 void</li>
<li>回调只能被调用一次</li>
<li>函数被显式地用 swift_async 修饰或者隐式地通过参数名来推导，其中支持推导的情况包括：<ul>
<li>函数只有一个参数且它的标签为 WithCompletion、WithCompletionHandler、WithCompletionBlock、WithReplyTo、WithReply。</li>
<li>函数有多个参数，且最后一个是回调，并且它的标签为 completion，withCompletion，completionHandler，withCompletionHandler，completionBlock，withCompletionBlock，replyTo，withReplyTo，reply 或者 replyTo。</li>
<li>函数有多个参数，且最后一个参数的标签以一个参数的情况当中列出的标签结尾，最后一个参数是回调。</li>
</ul>
</li>
</ul>
<p>我们再给一个例子，请大家注意它的函数名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)getUserAsync:(NSString *)name completion:(void (^)(User *, NSError *))completion;</span><br></pre></td></tr></table></figure>

<p>转换后：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">userAsync</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">String</span>!) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">User</span>?</span><br></pre></td></tr></table></figure>

<p>对于以 get 开头的 Objective-C 函数，转换之后函数名当中的 get 被去除了。除此之外其他规则与前面提到的一致。</p>
<p>有了这个转换，很多旧 SDK 当中的 Objective-C 回调函数都可以当成 Swift 的异步函数来调用，可以极大的简化我们的开发流程。</p>
<h3 id="在-Objective-C-当中调用-Swift-的异步函数"><a href="#在-Objective-C-当中调用-Swift-的异步函数" class="headerlink" title="在 Objective-C 当中调用 Swift 的异步函数"></a>在 Objective-C 当中调用 Swift 的异步函数</h3><p>相反地，如果我们定义了 Swift 的异步函数，并且希望在 Objective-C 当中调用，则可以声明成 @objc 异步函数，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">class</span> <span class="title class_">GitHubApiAsync</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">listFollowers</span>(<span class="params">for</span> <span class="params">userName</span>: <span class="type">String</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">User</span>] &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AF</span>.request(<span class="string">&quot;<span class="subst">\(GITHUB_API_ENDPOINT)</span>/users/<span class="subst">\(userName)</span>/followers&quot;</span>).responseDecodableAsync()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GitHubApiAsync 类当中的 listFollowers 函数相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface GitHubApiAsync : NSObject</span><br><span class="line">+ (void)listFollowersFor:(NSString * _Nonnull)userName completionHandler:(void (^ _Nonnull)(NSArray&lt;User *&gt; * _Nullable, NSError * _Nullable))completionHandler;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="调用-Kotlin-的挂起函数（suspend-function）"><a href="#调用-Kotlin-的挂起函数（suspend-function）" class="headerlink" title="调用 Kotlin 的挂起函数（suspend function）"></a>调用 Kotlin 的挂起函数（suspend function）</h2><p>了解了 Swift 的异步函数如何与 Objective-C 互调用的细节之后，再来看一下 Kotlin 的挂起函数是如何支持被 Swift 调用的。当然这个特性还在实验当中，后续也可能会发生变化。</p>
<h3 id="支持-Objective-C-回调"><a href="#支持-Objective-C-回调" class="headerlink" title="支持 Objective-C 回调"></a>支持 Objective-C 回调</h3><p>Kotlin 1.4 开始引入了挂起函数对 Swift 的支持，支持的方式就是讲挂起函数转成回调，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greeting</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后会生成 Objective-C 头文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">__attribute__((swift_name(&quot;Greeting&quot;)))</span><br><span class="line">@interface SharedGreeting : SharedBase</span><br><span class="line">...</span><br><span class="line">- (NSString *)greeting __attribute__((swift_name(&quot;greeting()&quot;)));</span><br><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure>

<p>生成的类名为 <code>SharedGreeting</code>，其中 Shared 是模块名。<code>__attribute__((swift_name(&quot;Greeting&quot;)))</code> 使得这个 Objective-C 类映射到 Swift 当中的名字是 <code>Greeting</code>。</p>
<p>我们重点关注一下 greetingAsync 函数，它映射成了下面的回调形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)greetingAsyncWithCompletionHandler:(void (^)(NSString * _Nullable, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsync(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure>

<h3 id="支持-Swift-异步函数"><a href="#支持-Swift-异步函数" class="headerlink" title="支持 Swift 异步函数"></a>支持 Swift 异步函数</h3><p>Kotlin 挂起函数对于 Objective-C 回调的支持，正好命中了前面讨论的回调自动转换成 Swift 异步函数的条件，因此理论上在 Swift 5.5 当中，我们也可以直接把 Kotlin 的挂起函数当成 Swift 的异步函数去调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swift</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这里还有一些细节的问题。Kotlin 1.5.30 当中也对此做了一点点跟进，在生成的 Objective-C 头文件当中添加了对 <code>_Nullable_result</code> 的支持，这使得 Kotlin 的挂起函数在返回可空类型时，能够正确被转化成返回 optional 类型的 Swift 异步函数，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">suspend fun greetingAsyncNullable(): <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, $&#123;Platform().platform&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这个例子的返回值类型声明为 <code>String?</code>，生成的 Objective-C 函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)greetingAsyncNullableWithCompletionHandler:(void (^)(NSString * _Nullable_result, NSError * _Nullable))completionHandler __attribute__((swift_name(&quot;greetingAsyncNullable(completionHandler:)&quot;)));</span><br></pre></td></tr></table></figure>

<p>仔细对比与 greetingAsync 的差异不难发现，返回值的类型在 greetingAsyncNullable 当中被映射成了 <code>NSString * _Nullable_result</code>，而在 greetingAsync 当中则映射成了 <code>NSString * _Nullable</code>。这就不得不提一下 <code>_Nullable_result</code> 与 <code>_Nullable</code> 的差异了，前者可以令转化之后的 Swift 异步函数返回 optional 类型（对应于 Kotlin 的可空类型，nullable type），而后者则返回非 optional 类型（对应于 Kotlin 的不可空类型，nonnull type）。</p>
<h3 id="Kotlin-挂起函数的异常传播"><a href="#Kotlin-挂起函数的异常传播" class="headerlink" title="Kotlin 挂起函数的异常传播"></a>Kotlin 挂起函数的异常传播</h3><p>如果 Kotlin 的挂起函数没有声明为 <code>@Throws</code>，则只有 <code>CancellationException</code> 会被转换为 <code>NSError</code> 抛到 Swift 当中，其他的都会作为严重错误使程序退出，因此如果需要暴露给 Swift 调用，我们通常建议对于可能有异常抛出的 Kotlin 函数添加 <code>@Throws</code> 注解，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">greetingAsync</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;error from Kotlin&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$&#123;Platform().platform&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在 Swift 调用时也可以直接捕获到这个异常：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swift</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Greeting</span>().greetingAsync())</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error Domain=KotlinException Code=0 &quot;error from Kotlin&quot; UserInfo=&#123;NSLocalizedDescription=error from Kotlin, KotlinException=kotlin.IllegalArgumentException: error from Kotlin, KotlinExceptionOrigin=&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上下文零传递"><a href="#上下文零传递" class="headerlink" title="上下文零传递"></a>上下文零传递</h3><p>尽管目前 Kotlin 的挂起函数可以被当做 Swift 的异步函数去调用，但 Kotlin 侧仍没有专门仔细地针对 Swift 异步函数调用的场景进行专门的设计和定制。因此像 Swift 侧的取消状态（在 Kotlin 挂起函数中获取 Swift 的 Task 的取消状态）、调度器（Swift 的 actor 以及与 Task 绑定的调度器）、TaskLocal 变量以及 Kotlin 侧挂起函数执行时的调度器、协程上下文等状态都是没有实现传递的。</p>
<p>基于这一点，大家在使用过程中应当尽可能将函数的设计进行简化，避免场景过于复杂而引发令人难以理解的问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们探讨了 Swift 协程当中的异步函数（async function）与 Objective-C 的互调用问题，其中介绍了 Objective-C 回调自动映射成 Swift 异步函数的条件和细节，以及 Kotlin 挂起函数对 Swift 异步函数的支持。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Coroutines</tag>
        <tag>Swift</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title>父类返回子类类型的函数写法</title>
    <url>/2019/02/18/this-type/</url>
    <content><![CDATA[<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventBuilder</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisposableEventBuilder</span> : <span class="type">EventBuilder</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="built_in">Long</span> = <span class="number">0L</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(delay: <span class="type">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> = <span class="keyword">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDisposableEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">            callback.onEvent(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去也没啥大毛病，用一下吧：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60_000</span>) <span class="comment">// ERROR!! </span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p>
<blockquote>
<p>“我 X，这什么玩意儿”，你嘟囔了一句。</p>
</blockquote>
<span id="more"></span>

<p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p>
<h2 id="2-Scala-的解法"><a href="#2-Scala-的解法" class="headerlink" title="2. Scala 的解法"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> retryLimit: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retryLimit</span></span>(retryLimit: <span class="type">Int</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubBuilder</span> <span class="keyword">extends</span> <span class="title">SuperBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> delay: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delay</span></span>(delay: <span class="type">Long</span>): <span class="type">SubBuilder</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">SubBuilder</span>().retryLimit(<span class="number">3</span>).delay(<span class="number">60000</span>)</span><br></pre></td></tr></table></figure>

<p>一点儿毛病都么有。</p>
<p>Kotlin 有这个特性吗？并没有。</p>
<h2 id="3-Kotlin-的解法"><a href="#3-Kotlin-的解法" class="headerlink" title="3. Kotlin 的解法"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventBuilder</span>&lt;<span class="type">T : EventBuilder&lt;T</span>&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> retryLimit = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">retryLimit</span><span class="params">(retryLimit: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">this</span>.retryLimit = retryLimit</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: PollingEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p>
<p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisposableEventBuilder</span> : <span class="type">EventBuilder</span>&lt;<span class="type">DisposableEventBuilder</span>&gt;() &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DisposableEventBuilder().retryLimit(<span class="number">3</span>)</span><br><span class="line">        .delay(<span class="number">60_000</span>) <span class="comment">// OK!!</span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuperBuilder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SuperBuilder</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">retryLimit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">retryLimit</span><span class="params">(<span class="type">int</span> retryLimit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.retryLimit = retryLimit;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubBuilder</span> <span class="keyword">extends</span> <span class="title class_">SuperBuilder</span>&lt;SubBuilder&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SuperBuilder <span class="title function_">delay</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delay = delay;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，今天就先这样~~</p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>SelfType</tag>
      </tags>
  </entry>
  <entry>
    <title>我写了一本书，《深入理解 Kotlin 协程》</title>
    <url>/2020/06/23/understanding-kotlin-coroutines/</url>
    <content><![CDATA[<blockquote>
<p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 </p>
</blockquote>
<span id="more"></span>




<p>我研究 Kotlin 协程的过程其实主要分了三个阶段。</p>
<p><strong>第一个阶段，深入理解 Kotlin 协程的三篇文章</strong>。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine （一）</a>，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine (二）</a>，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd">深入理解 Kotlin Coroutine（三）</a>。</p>
<p>**第二个阶段，<a href="https://github.com/enbandari/CoroutineLite">CoroutineLite</a>**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作<a href="https://coding.imooc.com/class/232.html">基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计</a> 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制<a href="https://coding.imooc.com/class/398.html">Kotlin从入门到精通</a>和编写<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。</p>
<p><strong>第三个阶段，破解 Kotlin 协程系列文章</strong>。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196">Kotlin 协程文集</a>。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png"></p>
<p><strong><center>视频课程“Kotlin从入门到精通”中对协程的剖析</center></strong></p>
<p>现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。</p>
<p>这本书主要回答了以下几个常见的问题：</p>
<ol>
<li>协程是什么？Kotlin 协程又是什么？</li>
<li>Kotlin 协程的工作机制是怎样的？</li>
<li>如何将 Kotlin 协程投入生产实践当中？</li>
</ol>
<p>不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。</p>
<p>还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png"></p>
<p><strong><center>使用 JetBrains Mono 排版的代码效果</center></strong></p>
<p>书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png"></p>
<p><strong><center>《深入理解 Kotlin 协程》的插图制作</center></strong></p>
<p>环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。</p>
<p>当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。</p>
<p>可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。</p>
<p>当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。</p>
<p>感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）</p>
<hr>
<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p>
<hr>
<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>
<p><strong>扫描二维码或者点击链接<a href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p>
<hr>
<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>
<p><strong>扫描二维码或者点击链接<a href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p>
<hr>
<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>
<p><strong>扫描二维码或者点击链接<a href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>接下来的一些想法</title>
    <url>//2023/05/13/roadmap-2023/</url>
    <content><![CDATA[<blockquote>
<p>想法很多，需要慢慢花时间去落实。 </p>
</blockquote>
<span id="more"></span>







<p>朋友们好，我是 bennyhuo。</p>
<p>这篇文章我准备聊聊接下来我想做的一些事情，让关注我的朋友们能够大概知道我在公众号、B站等平台接下来会输出哪些方面的内容。</p>
<h2 id="内容选题"><a href="#内容选题" class="headerlink" title="内容选题"></a>内容选题</h2><p>内容选题会尽量专注于编程语言特性。</p>
<p>首先，最重要的就是 Kotlin 相关的专题内容。目前在考虑中的一个专题是 Kotlin 与 Swift 核心特性的对比和分析。Kotlin 方向的内容我会花比较多的时间研究，内容也会偏向于进阶。</p>
<p>其次，我会对 Java、C++ 的新特性保持关注，除了更新《Java 核心技术》的读书视频以外，目前计划中有一个专题是 Java 18-21 新特性介绍（Java 17 的新特性专题文章已经发布）。相比之下，C++ 的内容做起来会更耗费精力，毕竟 C++ 比 Java 的新特性更多，也更复杂，因此暂时会优先考虑把《现代 C++ 核心特性解析》的读书视频做完。</p>
<p>此外，《Rust 官方电子书》和 《Effective Python》 的读书视频也在持续更新。</p>
<p>暂时没有开新坑的计划，所以大家可以踏实地等我更新这些视频。</p>
<h2 id="内容形式"><a href="#内容形式" class="headerlink" title="内容形式"></a>内容形式</h2><p>前面其实已经提到了，内容的形式主要分为文章和视频。我会优先考虑视频的更新，尽量保证两天一更，不过，可能每个月会休息几天。在不适合录制视频的情况下（比如嗓子不舒服的时候），我会抽空撰写专题文章，所以文章的发布频率可能会相对低一些。</p>
<p>以上都是公开的内容。知识星球也会每月发布一期会员视频，会员视频的内容以学习思考、工作方法之类的方向为主，与公开的内容有一定的定位差异。我也在考虑将一部分专题文章放到知识星球作为会员专题文章，不过暂时还没有确定具体操作形式。</p>
<h2 id="发布平台"><a href="#发布平台" class="headerlink" title="发布平台"></a>发布平台</h2><p>在催更微信群的朋友应该知道我最近这几天一直在打磨批量发布视频的工具。这个工具目前已经支持了将视频批量发布到 B站、YouTube、抖音、微信公众号（也会同步到视频号）四个平台，因此后续的视频发布终于可以轻松实现多平台同时发布了。</p>
<p>不管你习惯使用哪个平台，你都可以通过搜索 “<strong>霍丙乾 bennyhuo</strong>” 找到我的账号，收看我的视频内容。近期，我会陆续将存量的视频发布到抖音和微信公众号上，尽快与 B 站和 YouTube 逐步实现同步。</p>
<p>文章则会按照优先级在我的个人网站（<a href="https://www.bennyhuo.com)、微信公众号和掘金发布./">https://www.bennyhuo.com）、微信公众号和掘金发布。</a></p>
<h2 id="一点愿景"><a href="#一点愿景" class="headerlink" title="一点愿景"></a>一点愿景</h2><p>我不是计算机专业毕业的，我学到的很多计算机相关的知识都来自于互联网上各位前辈的无私奉献。其中对我影响最大的是 <a href="https://space.bilibili.com/2884629">oeasy 老师</a>，他现在还在 B 站持续发布新的视频教程来帮助大家。我一直觉得能坚持做这样一件事实在是太酷了。</p>
<p>我希望把事情做得纯粹一些，因此你不会在我的公众号看到 “几年心血总结出这篇八股文”、“阿里 P8 教你面试” 之类的广告，也不会在我的视频里面看到我明示大家投币三连求关注的转场动画。</p>
<p>希望我现在发布的内容也能对大家有所帮助。十几年后说起来，有过这么个人曾经影响过你。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>规划</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>什么样的开发者才能在简历上写“精通 XXX 语言”</title>
    <url>//2023/08/29/new-book-metaprogramming/</url>
    <content><![CDATA[<blockquote>
<p>一般这么写的，都不算精通。 </p>
</blockquote>
<span id="more"></span>







<p>朋友们好，我是 bennyhuo。</p>
<p>大家肯定见过写着 “精通 XXX 语言” 的简历，我在过去几年的工作经历中就见过精通 Java、精通 C++ 甚至精通 Kotlin 的简历，这在几年前尤其流行。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215609.png"></p>
<p>当然，现在大家稍微做一些功课就会看到“千万不要在简历中写精通 XXX” 之类的警告，不知道大家有没有想过，为什么写精通就是不行呢？</p>
<h2 id="什么是精通？"><a href="#什么是精通？" class="headerlink" title="什么是精通？"></a>什么是精通？</h2><p>要搞清楚这个问题，先得搞清楚什么是精通。</p>
<blockquote>
<p><strong>精通</strong>： 透彻通晓。</p>
<p>晋 左思 《魏都赋》：“硕画精通，目无匪制，推锋积纪，鋩气弥鋭。” 唐 李咸用 《赠陈望尧》诗：“若説精通事艺长，词人争及孝廉郎。”《醒世恒言·刘小官雌雄兄弟》：“不过数月，经书词翰，无不精通。”如：他精通英语。</p>
</blockquote>
<p>这个解释非常清楚，但有一个很麻烦的问题，所谓精通其实是一个偏主观感性的描述，而不是一个可以量化的标准。</p>
<p>我举个例子，汉语是我的母语，我虽然天天说汉语，但我如果说我精通汉语，肯定有很多朋友会觉得“你不是在开玩笑吧”，但如果这话我跟火星人说，他们一定觉得没毛病。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215931.png"></p>
<p>“难以量化”就会让表述的结果非常主观，考虑到我们的文化背景讲究谦虚谨慎，于是说自己精通 Kotlin，精通 Java，就让人感觉这位候选人有些自大。</p>
<h2 id="什么样的候选人喜欢写精通？"><a href="#什么样的候选人喜欢写精通？" class="headerlink" title="什么样的候选人喜欢写精通？"></a>什么样的候选人喜欢写精通？</h2><p>从我的面试筛简历的经历来看，写精通 Kotlin、精通 Java 的候选人，无非是希望证明自己对 Kotlin 或者 Java 的掌握比较不错，能够胜任这份工作。</p>
<p>换个简单的说法，就是希望通过写自己精通 Kotlin 来证明自己会 Kotlin。是不是听起来有些不对劲？这不是典型的循环论证吗？就好像说，bennyhuo 的视频很不错，因为很有趣一样，本质上说的是一件事儿，而没有给出具体的论据。bennyhuo 的视频很不错，因为他的视频一不带节奏，二不贩卖焦虑，三我编不下去了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828220623.png"></p>
<p>总之就是要给出具体的论据来证明你的结论，而不是用一个结论来证明另一个结论，或者用一个主观的描述来证明一个客观的情况。事实上，一个无法量化的描述其实无法证明任何结论。</p>
<p>这道理很难懂吗？当然不是。那为什么前几年那么多人喜欢这么写呢？一方面，互联网快速发展的早期，招聘单位招人很多时候就是为了储备人才，筛选标准方面确实存在比较宽松的情况，这使得敢于自信地在简历上说自己精通 XXX 的候选人确实更容易蒙混过关；另一方面，可能也确实存在一些候选人没有能够拿得出手的项目，就是没得写，只好说自己擅长什么，熟练什么，精通什么了。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828220525.png"></p>
<h2 id="为什么精通成为简历上的禁忌？"><a href="#为什么精通成为简历上的禁忌？" class="headerlink" title="为什么精通成为简历上的禁忌？"></a>为什么精通成为简历上的禁忌？</h2><p>精通二字在简历中成为禁忌，除了因为这个词表述的内容难于量化以外，还有一个重要原因就是很多候选人其实甚至连普遍意义上的熟练掌握都达不到，就敢写自己精通。</p>
<p>举个例子，我曾经在面试过程中碰到过说自己精通 Java 的候选人，于是我问他 final 关键字有什么作用，他说修饰变量不可变，修饰类不能被继承，修饰方法不能被覆写。非常标准的八股答案是吧。</p>
<p>但作为一个精通 Java 的开发者，我们的回答必须融入自己的理解。修饰的变量不可变，那么</p>
<ol>
<li>我们应该在什么情况下用 final 修饰变量？</li>
<li>final 修饰的静态变量和非静态变量有什么区别？</li>
<li>final 修饰的 String 和 ArrayList 有什么区别？</li>
<li>有没有什么办法修改被 final 修饰的变量的值？</li>
<li>被 final 修饰的变量在并发中有什么作用？</li>
<li>为什么匿名内部类只能捕获 final 的局部变量？</li>
</ol>
<p>这些都可以聊，这绝对不是网上随便搜到的八股题目所能够涵盖的，也最能体现自己的水平。</p>
<p>这样的例子太多了，于是最后”精通“二字与狼来了一样，让人看到只能联想到一个字：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828221431.png"></p>
<h2 id="怎么证明自己确实精通？"><a href="#怎么证明自己确实精通？" class="headerlink" title="怎么证明自己确实精通？"></a>怎么证明自己确实精通？</h2><p>当然，也不排除确实有些候选人真的精通某一项技术。</p>
<p>讲个小故事。我之前打算从腾讯出来，找工作的时候有个面试官看了我的简历准备聊点儿 Kotlin 协程的内容，结果他犹豫了，他欲言又止最后来了一句，Kotlin 协程方面应该没啥好问的了，看你还出了一门 C 语言的课程，咱们要不聊聊 C 吧。为啥会这样呢？因为那会儿是 21 年 3 月，他看《深入理解 Kotlin 协程》这本书已经写完快一年了，而 C 语言的课程刚上线几个月，估计我已经把协程快忘光了，就别问了吧，给点儿面子。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828185307.png"></p>
<p>哈哈，开个玩笑。程序员的圈子里面，高手是非常多的，总有大佬是真的精通某些技术的，人家要写简历会怎么证明自己精通呢？</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828185605.png"></p>
<p>在讨论这个问题之前，我想先跟大家聊一下“武松打虎”的故事。武松上山前在店里吃酒，店小二说山上有只老虎非常凶狠，已经伤了多人性命，晚上千万不能上山。结果武松不听劝阻，，执意上山。作者又在武松与老虎打斗时着重描述了老虎是如何如何厉害，却很少提及武松精通什么功法。结果呢？老虎被武松打死了，武松的武力值大家瞬间就能理解，无需多言。</p>
<p>类似地，如果需要证明你精通什么技术，你需要列举你做过的相关的具体事情，例如想要证明自己精通 Kotlin，那就说说自己使用 Kotlin 做过哪些公司项目，做过哪些与 Kotlin 语言强有关的技术专项，参与过哪些开源的 Kotlin 项目，或者给 Kotlin 官方提过 PR 等等。通过介绍这些项目的细节，来展示你对 Kotlin 的掌握程度，让面试官自己推断出你“精通 Kotlin”的结论，而不是自己把结论说出来。</p>
<p>同样是那次出来找工作，有一个面试官对编译器比较感兴趣，于是问我有没有研究过 Kotlin 的编译器，我说这块儿还涉猎的比较少。不过现在不一样了，这段时间我在 GitHub 上开源了好几个 Kotlin 元编程相关的项目：</p>
<ul>
<li><a href="https://github.com/kanyun-inc/Kace">kanyun-inc/Kace</a> （公司级开源项目）</li>
<li><a href="https://github.com/bennyhuo/KotlinDeepCopy">KotlinDeepCopy</a></li>
<li><a href="https://github.com/bennyhuo/Kotlin-Trim-Indent">Kotlin-Trim-Indent</a></li>
<li><a href="https://github.com/bennyhuo/kotlin-compile-testing-extensions">kotlin-compile-testing-extensions</a></li>
<li><a href="https://github.com/bennyhuo/Klue">Klue</a></li>
</ul>
<p>不仅如此，经过两年的努力，我又写了一本书：《深入实践 Kotlin 元编程》。</p>
<p><a href="https://item.jd.com/10081757341486.html"><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828215014.png" alt="深入实践 Kotlin 元编程"></a></p>
<p><a href="https://item.jd.com/10081757341486.html">&gt;&gt;&gt;点击查看详情&lt;&lt;&lt;</a></p>
<p>这本书的内容可以说我是躺在 Kotlin 和 Java 编译器的源码上写完的。如果几年后有机会再出去面试，不管是问我 Java、Kotlin 的反射的工作机制，还是 APT 和 KSP 的实现细节，甚至 Kotlin 编译器插件的内部原理，我都能说得头头是道。</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/20230828222941.png"></p>
<p>既然如此，我觉得我在简历上写个熟练掌握 Kotlin 应该问题不大，不过显然让面试官自己得出结论效果会更好，而我只会说：</p>
<p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/48cc2b74-2ef8-40db-8418-9d9756bfdf14/media/ending.png"></p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>思考</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>现代 Java（0）：前言</title>
    <url>//2023/09/04/Java-New-00-foreword/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2023/09/04/Java-New-00-foreword/">现代 Java（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2023/09/23/Java-New-01-var/">现代 Java（1）：Java 也支持类型推断了？</a></li>
</ul>
<p>2014 年初 Java 8 就发布了，Java 迎来了其历史上继 5 之后的第二次史诗级更新。我们不妨列举一下 Java 5 和 Java 8 的主要特性来感受一下更新的力度。</p>
<p>Java 5 的主要更新：</p>
<ul>
<li>元数据，即注解（Annotation）。注解特性的引入几乎改变了 Java 开发者的开发习惯，甚至也在很大程度上影响了后来的 Kotlin。</li>
<li>泛型（Generics）。泛型的引入使得 Java 的类型系统实现了一次质的飞跃，对于编写类型安全的代码有着重要的意义。</li>
<li>并发包（java.util.concurrent）。高并发一直是 Java 开发者极其关注的话题，这也一度成为 Java 最为擅长的开发领域。Java 5 在标准库中引入并发包，极大的方便了并发程序的设计和开发，这个包甚至也成了 Java 面试中最常被问到的内容之一。</li>
</ul>
<p>Java 8 的主要更新：</p>
<ul>
<li>Lambda 表达式。这可能是 Java 迈向现代化的最为重要的一步。Lambda 表达式的支持使得开发者可以极大地简化匿名对象的使用，无论从代码可读性还是从代码简洁性上讲，都是一次质的提升。</li>
<li>SAM 转换。单一方法类型的匿名实例可以简化成 Lambda 表达式，尽管 Java 没有直接支持函数类型，但所有单一方法的类型都可以认为是函数类型。</li>
<li>流（Stream）。Java 8 的标准库中为集合类型提供了对流的支持，常见的流 API 包括 map、filter、reduce 等等。对流的支持使得 Java 更加函数化，对 Java 开发者的开发习惯和编程思维有非常大的影响，也极大的简化了数据的处理过程。</li>
<li>接口方法默认实现（Default Methods）。Java 8 开始允许在接口方法中提供默认无状态的实现，这对于 API 的设计者增加新功能且保持 ABI 兼容有着非常大的帮助。</li>
</ul>
<p>简单来说，Java 5 的发布使得 Java 的元编程能力和并发能力得到了极大的提升，而 Java 8 的发布又为 Java 带来全新的函数式编程能力，让 Java 再度焕发活力。</p>
<p>从 Java 9 开始，Java 的版本更新改为半年一次，LTS 版本则是三年一次。从 Java 17 开始，LTS 版本又改成两年一次。</p>
<p>非 LTS 版本的生命周期只有半年，而 LTS 的生命周期长达 8 年甚至更久。了解 Java 的 LTS 版本是有意义的，一般而言，我们在生产环境中应尽量使用更加有保障的 LTS 版本，以避免频繁地更改生产环境。</p>
<blockquote>
<p><strong>说明</strong>：事实上，Java 版本的升级除了语法特性的变化以外，还包含了运行环境及 Java 虚拟机的变化。相比之下，Java 虚拟机的变化对于生产环境的调优带来的影响更大、更抽象，这可能是 Java 开发者不愿意升级版本的一个最为重要原因。</p>
</blockquote>
<p>Java 的近几个 LTS 版本如下表所示：</p>
<table>
<thead>
<tr>
<th>版本号</th>
<th>发布时间</th>
<th>结束支持时间</th>
<th>核心特性</th>
</tr>
</thead>
<tbody><tr>
<td>Java 8</td>
<td>2014.3</td>
<td>2030.12</td>
<td>函数式</td>
</tr>
<tr>
<td>Java 11</td>
<td>2018.9</td>
<td>2026.9</td>
<td>局部变量类型推导</td>
</tr>
<tr>
<td>Java 17</td>
<td>2021.9</td>
<td>2029.9</td>
<td>模式匹配（Pattern Match）</td>
</tr>
<tr>
<td>Java 21</td>
<td>2023.9</td>
<td>2031.9</td>
<td>虚拟线程（Virtual Thread）</td>
</tr>
</tbody></table>
<p>需要注意的是，这里提及的核心特性也可能是该 LTS 版本之前的非 LTS 版本中引入的。例如，局部变量类型推导指使用 var 来定义变量，变量的类型通过初始化表达式来推导。该特性在 Java 10 引入，Java 11 中只是对 Lambda 表达式的参数做了支持。</p>
<p>从语法特性的角度来看，Java 17 是非常有诱惑力的。不过，相较难以量化的开发效率上的提升，架构师们往往更看重程序运行效率的提升。我们有理由相信，携带了虚拟线程和分代 ZGC 的 Java 21 将会是一个更加有说服力的版本。</p>
<p>Java 最近几年的更新无疑是令人兴奋和激动的。尽管比起它的最有力的竞争者 Kotlin 而言，Java 在语法特性上仍显得非常保守，但看看 C++ 近几年的更新就可以知道，语言特性的稳健何尝又不是对现存的 Java 开发者的一种友好呢？</p>
<p>接下来，我准备写一系列文章来介绍一下 Java 8 以来的重要语法特性更新，希望可以在一定程度上帮助大家了解现代 Java 的语法特性的发展。</p>
<p>当然，需要特别说明的是，尽管本系列文章的主角是 Java，但行文之处力求把涉及到的问题解释清楚，难免会经常横向对比其他常见的编程语言，读者如果对涉及到的其他语言不熟悉，只需大致了解即可，无须深究。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Java8</tag>
        <tag>Java21</tag>
      </tags>
  </entry>
  <entry>
    <title>现代 Java（1）：Java 也支持类型推断了？</title>
    <url>//2023/09/23/Java-New-01-var/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<span id="more"></span>



<ul>
<li><a href="https://www.bennyhuo.com/2023/09/04/Java-New-00-foreword/">现代 Java（0）：前言</a></li>
<li><a href="https://www.bennyhuo.com/2023/09/23/Java-New-01-var/">现代 Java（1）：Java 也支持类型推断了？</a></li>
</ul>
<p>类型推断是现代编程语言必备的能力，我们现在很少能够看到不支持类型推断的主流编程语言了。当然，C 语言是个例外。</p>
<p>类型推断就是编译器根据上下文信息对类型进行推算的能力。类型推断是一个极其复杂的话题，从工程应用的角度而言，我们不用过多关注其背后的数学原理。为了方便讨论，我们将类型的推断分为变量类型推断和泛型类型推断。</p>
<h2 id="变量类型推断"><a href="#变量类型推断" class="headerlink" title="变量类型推断"></a>变量类型推断</h2><p>变量的类型推断就是在变量声明时省略类型，编译器通过变量的初始化来推断其类型。</p>
<h3 id="C-的-auto"><a href="#C-的-auto" class="headerlink" title="C++ 的 auto"></a>C++ 的 auto</h3><p>变量类型推断最典型的例子莫过于 C++ 当中的这个场景了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; values;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;&gt;::iterator i = values.<span class="built_in">begin</span>(); i &lt; values.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">  ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，for 循环中的 i 的类型非常长，写起来繁琐之外，还很难写对这一度让 C++ 的开发者极度难受。不过，从 C++ 11 开始，类型推断的引入让事情变得简单了起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = values.<span class="built_in">begin</span>(); i &lt; values.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 的类型使用 <code>auto</code> 关键字替代，这样编译器就会根据 i 的初始化表达式 <code>values.begin()</code> 的类型推断出来。</p>
<h3 id="Java-的-var"><a href="#Java-的-var" class="headerlink" title="Java 的 var"></a>Java 的 var</h3><p>Java 从 Java 10 开始新增了 <code>var</code> 关键字来简化变量定义时的类型。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>这里的 <code>var</code> 相当于 <code>ArrayList&lt;String&gt;</code>。</p>
<p><code>var</code> 只能用于局部变量的定义，不能用于类成员的定义，这一点与 C++ 的 <code>auto</code> 非常相似。</p>
<blockquote>
<p><strong>说明</strong> 在 Java 正式支持 <code>var</code> 关键字之前，著名的元编程框架 <a href="https://projectlombok.org/">Lombok</a> 就通过编译时修改 Java 语法树为 Java 添加了 <code>var</code> 关键字的支持，有兴趣的读者可以参考 Lombok 的官方文档：<a href="https://projectlombok.org/features/var">https://projectlombok.org/features/var</a>。</p>
</blockquote>
<h3 id="类型后置"><a href="#类型后置" class="headerlink" title="类型后置"></a>类型后置</h3><p>C++ 和 Java 的变量声明中类型都在变量名前面，通常又被称为类型前置的形式。这类语言的特点是在语言诞生之初并没有类型推断的语法设计。</p>
<p>随着开发者对类型推断的需求的日益增长，业界编程语言设计的优秀实践的不断积累，越来越多的新语言选择了类型后置的形式。</p>
<p>下面是 Kotlin 的变量定义语法，类型后置的形式使得类型推断变得非常自然：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整的变量定义</span></span><br><span class="line"><span class="keyword">val</span> s: String = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略类型</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 的类型可以通过初始化的表达式推断出来，因此可以省略。常见的采用类型后置的语法设计的语言还包括 Scala、Swift、TypeScript、Rust 等等。</p>
<h3 id="全局类型推断"><a href="#全局类型推断" class="headerlink" title="全局类型推断"></a>全局类型推断</h3><p>绝大多数编程语言在对变量的类型进行推断时，都只对变量定义时的初始化表达式做了分析，Rust 就是个例外。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>;</span><br><span class="line">    </span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Rust 允许先把变量定义出来，在后面根据对该变量的使用情况进行变量类型的推断。示例代码中变量 <code>s</code> 在定义时并没有声明类型，也没有进行初始化，Rust 编译器通过分析后面对 <code>s</code> 的赋值，推断出 <code>s</code> 的类型是 <code>&amp;str</code>。这在 Kotlin 当中是不行的。</p>
<p>Rust 编译器通过上下文推断类型的能力在下面的例子当中用处更大。</p>
<p>作为对比，我们先给出 Kotlin 版本的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiply2 = &#123; i: <span class="built_in">Int</span> -&gt; i * <span class="number">2</span> &#125;</span><br><span class="line">multiply2(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>在这段 Kotlin 代码中，Lambda 表达式 <code>multiply2</code> 的参数 <code>i</code> 的类型必须显式地写出来，不然编译器就无法推断出 <code>multiply2</code> 的类型了。</p>
<p>接下来我们看一下等价的 Rust 代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">multiply2</span> = |i| i * <span class="number">2</span>;</span><br><span class="line"><span class="title function_ invoke__">multiply2</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>注意 <code>|i|</code> 是 Rust 的 Lambda 表达式（或者闭包）的参数列表，我们发现 <code>i</code> 的类型并不需要明确地写出来，编译器通过分析后面的实参 <code>10</code> 即可推断出 <code>i</code> 的类型为 <code>i32</code> 了。</p>
<h3 id="模板化的类型推断"><a href="#模板化的类型推断" class="headerlink" title="模板化的类型推断"></a>模板化的类型推断</h3><p><code>multiply2</code> 的例子还可以继续延伸。不管是 Kotlin 还是 Rust，<code>multiply2</code> 都是一个确定的类型，也就是说在上述代码之后追加一句 <code>multiply2(30.0)</code>，编译器就会抱怨说 <code>30.0</code> 是 <code>Double</code>（Kotlin）/ <code>f64</code>（Rust） 类型 ，而 <code>multiply2</code> 需要的是 <code>Int</code>（Kotlin）/<code>i32</code>（Rust）类型。不过，事情总有例外。</p>
<p>下面是使用 C++ 编写的等价代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply2 = [](<span class="keyword">auto</span> i) &#123; <span class="keyword">return</span> i * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="built_in">multiply2</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">multiply2</span>(<span class="number">30.0</span>);</span><br></pre></td></tr></table></figure>

<p><code>multiply2</code> 的参数 <code>i</code> 的类型是 <code>auto</code>，它自身的类型也是 <code>auto</code>，这意味着它们的类型需要编译器来推断。接下来我们分别把 <code>10</code> 和 <code>30.0</code> 传给 <code>multiply2</code>，然后我们就会发现，这都是合法的。这表明 <code>multiply2</code> 针对不同的类型会有不同的实现。对于 C++ 而言，<code>auto</code> 不仅仅是用于类型推断的关键字，很多时候我们把它当做模板的一种特殊形式来看待，似乎更容易理解。</p>
<h3 id="Java-中的-Lambda-表达式的类型推断"><a href="#Java-中的-Lambda-表达式的类型推断" class="headerlink" title="Java 中的 Lambda 表达式的类型推断"></a>Java 中的 Lambda 表达式的类型推断</h3><p>既然提到了 Lambda 表达式的类型推断，那么我们能不能用 <code>var</code> 来定义 Lambda 表达式呢？答案当然是，不能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">multiply2</span> <span class="operator">=</span> (<span class="type">int</span> i) -&gt; i * <span class="number">2</span>;</span><br><span class="line">^^^</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Error: Cannot infer type: lambda expression <span class="keyword">requires</span> an explicit target type</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>如果我们在 Java 中试图使用 <code>var</code> 来定义一个变量，并使用 Lambda 表达式来初始化，就会得到上面的错误。不过，这个错误并不是 <code>var</code> 的问题，而是 Java 对函数类型的支持问题。这个话题我们将在后面的文章中详细探讨，这里就不再展开说明了。</p>
<h3 id="分支表达式的类型推断"><a href="#分支表达式的类型推断" class="headerlink" title="分支表达式的类型推断"></a>分支表达式的类型推断</h3><p>分支表达式在现代编程语言中非常常见。C 语言甚至就已经有了分支表达式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = ...;</span><br><span class="line"><span class="type">int</span> b = ...;</span><br><span class="line"><span class="type">int</span> c = a &gt; b ? a : b;</span><br></pre></td></tr></table></figure>

<p>没错，<code>?:</code> 可能是最古老的分支表达式之一。</p>
<p>Java 当中除了 <code>?:</code> 表达式以外，还从 Java 12 开始支持了 Switch 表达式（Java 14 正式支持） ，因此 Java 中的表达式类型推断也是值得探讨的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span> -&gt; <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span> -&gt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个 switch 表达式中，四个分支表达式的值类型分别为 <code>int</code>(<code>Integer</code>)、<code>double</code>(<code>Double</code>)、<code>String</code>、<code>ArrayList&lt;String&gt;</code>。这意味着整体表达式的返回值 <code>y</code> 的类型只能是其中的一个，从数学的角度来讲，<code>y</code> 的类型为这四种类型的交集，Java 的类型系统中也确实存在交集类型的概念，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer &amp; Double &amp; String &amp; ArrayList&lt;String&gt;</span><br></pre></td></tr></table></figure>

<p>交集类型的计算结果其实就是这些类型的公共父类，因此 <code>y</code> 在编译时的类型为 <code>Serializable</code>。</p>
<p>如果没有公共父类呢？这在 Java 当中是不可能的，因为所有的类型都至少有一个公共父类是 <code>Object</code>。</p>
<p>顺便提一句，Kotlin 的推断方法也是类似的。作为对比，我们给出 Rust 的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="string">&quot;A&quot;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;B&quot;</span> =&gt; <span class="number">2.0</span>,</span><br><span class="line">           ^^^</span><br><span class="line">           ---------------------------------------------</span><br><span class="line">           `<span class="keyword">match</span>` arms have incompatible types [E0308]</span><br><span class="line">           expected integer, found floating-point number</span><br><span class="line">           ---------------------------------------------</span><br><span class="line">    <span class="string">&quot;C&quot;</span> =&gt; <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="built_in">vec!</span>[],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Rust 编译器在遇到各个分支的类型不兼容的情况时，会直接报错。实际上，C++ 的行为也是类似的。</p>
<p>为什么会有这样的差别呢？</p>
<p>我稍微做一下猜测，供大家参考。Java 和 Kotlin 的对象都是分配在堆内存上的，栈内存上只需保留一个引用，而这个引用的类型不管是什么，占用的内存大小都是固定的，因此在做分支表达式的类型推断时可以尽可能向开发者友好的方向设计。而 C++ 和 Rust 的编译器需要在编译时确定 <code>y</code> 的类型，以便于给他在栈内存上分配内存，因此遇到不兼容的类型时就只好拒绝编译了。</p>
<h2 id="泛型类型推断"><a href="#泛型类型推断" class="headerlink" title="泛型类型推断"></a>泛型类型推断</h2><p>除了对变量的类型进行推断以外，还有对泛型类型的推断。</p>
<h3 id="变量初始化表达式的泛型类型参数推断"><a href="#变量初始化表达式的泛型类型参数推断" class="headerlink" title="变量初始化表达式的泛型类型参数推断"></a>变量初始化表达式的泛型类型参数推断</h3><p>我们还是以 <code>ArrayList</code> 为例，在 Java 7 之前的版本，我们需要完整的将类型写出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>从 Java 7 开始，编译器稍微为我们做一点简化，允许我们把初始化表达式中的泛型参数省略掉了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>理由也很简单，变量的类型已经明确，后面的泛型参数 <code>String</code> 显然是冗余的。</p>
<p>不得不说，这一点 Java 做得比 C# 似乎更好一些，在 C# 中定义一个类似的 <code>List</code> 时必须完整的写出泛型参数。如果省略泛型参数，那么编译器就会报告如下错误：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">                            ^^</span><br><span class="line">                            ------------------------</span><br><span class="line">                            Type argument <span class="keyword">is</span> missing</span><br><span class="line">                            ------------------------</span><br></pre></td></tr></table></figure>

<p>当然，C# 的设计者可能觉得这里使用 <code>var</code> 会更好（就像 Java 10 之后那样）。</p>
<h3 id="方法泛型类型参数的推断"><a href="#方法泛型类型参数的推断" class="headerlink" title="方法泛型类型参数的推断"></a>方法泛型类型参数的推断</h3><p>定义在方法中的泛型参数也支持类型推断，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">identity</span><span class="params">(T t)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>identity</code> 在调用时，泛型参数 <code>T</code> 可以通过函数参数 <code>t</code> 推断出来，因此无须显式写出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> identity(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个特性还有一个更为常见的使用场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Class</code> 的泛型参数是 <code>fromJson</code> 的泛型参数 <code>T</code>，因此可以通过 <code>cls</code> 的实参类型来推断 <code>T</code> 的类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> fromJson(<span class="string">&quot;&#123;&#125;&quot;</span>, User.class);</span><br></pre></td></tr></table></figure>

<p>你可能会想，竟然有了泛型参数 <code>T</code>，我们是不是可以直接使用 <code>T.class</code> 而不用向 <code>fromJson</code> 中传入 <code>Class&lt;T&gt;</code> 了呢？当然不能，这是因为 Java 的泛型会在编译时擦除，也就是说 <code>T</code> 在运行时并不存在。</p>
<p>像绝大多数编程语言一样，Java 也可以通过方法的返回值类型来推断泛型参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> get(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>调用时，如果返回值类型已经明确，则无须显式指定泛型参数。不过，C# 却不支持通过返回值类型来推断泛型参数，例如：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">get</span>&lt;<span class="title">T</span>&gt;(<span class="params">String key</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="keyword">get</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">              ^^^</span><br><span class="line">              -------------------------------------------------</span><br><span class="line">              The type arguments <span class="keyword">for</span> method <span class="string">&#x27;T get&lt;T&gt;(string)&#x27;</span> </span><br><span class="line">              cannot be inferred <span class="keyword">from</span> the usage. </span><br><span class="line">              Try specifying the type arguments explicitly.</span><br><span class="line">              -------------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文从变量类型和泛型参数类型的推断两方面对 Java 的相关特性进行了介绍。为了方便读者对类型推断有更全面的认识，我们也列举了其他编程语言的相关特性作为参照。</p>
<p>综合来看，Java 在类型推断方面做得中规中矩，虽然没有像常见的现代编程语言那样能够做到极致，但也能够应对绝大多数的场景了。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java17</tag>
        <tag>Java8</tag>
        <tag>Java21</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 年总结</title>
    <url>//2024/01/01/summary-2023/</url>
    <content><![CDATA[<blockquote>
<p>2023 年也是充实的一年。 </p>
</blockquote>
<span id="more"></span>







<p>全民制作人们大家好，又到了一年一度的汇报时间。</p>
<h2 id="账号更名为“霍丙乾-bennyhuo”"><a href="#账号更名为“霍丙乾-bennyhuo”" class="headerlink" title="账号更名为“霍丙乾 bennyhuo”"></a>账号更名为“霍丙乾 bennyhuo”</h2><p>年初做了一件比较重要的事情，就是账号更名，主要涉及到以下几个平台：</p>
<ul>
<li>Bilibili、YouTube、掘金、抖音等：从 “bennyhuo 不是算命的” 改为 “霍丙乾 bennyhuo”</li>
<li>微信公众号：从 “Kotlin” 改为 “霍丙乾 bennyhuo”</li>
</ul>
<p>这其中涉及到几个小问题，为了不给大家造成困扰，我简单再做下解释。</p>
<h3 id="1-我的微信公众号为什么叫-“Kotlin”？"><a href="#1-我的微信公众号为什么叫-“Kotlin”？" class="headerlink" title="1. 我的微信公众号为什么叫 “Kotlin”？"></a>1. 我的微信公众号为什么叫 “Kotlin”？</h3><p>2016 年，我注册了一个名为“Kotlin”的微信公众号，用来发布 Kotlin 的推广视频。2020 年前后，JetBrains 开始在国内投入专人负责社区的建设和运营，微信公众号 “Kotlin” 则主要用于转发官方文章。当时我的主要精力 B 站账号的建设上，输出形式也以视频为主。2023 年，有一些朋友问我为什么视频不发公众号，因为我很少会将与 Kotlin 无关的视频同步到微信公众号 “Kotlin” 上。</p>
<p>思考再三，我跟 JetBrains 的朋友提了一下我的想法：我们可能需要一个真正意义上的 Kotlin 官方号。这就是我的所有账号更名的由来。</p>
<p>如果大家希望持续关注 Kotlin 的发展，强烈建议大家关注官方微信公众号 <strong>Kotlin 开发者</strong>。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101171220.png"></p>
<p>如果你平常也喜欢在 Bilibili 上看视频，也建议关注 JetBrains 的官方账号 <strong>JetBrains中国</strong>：</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101171708.png"></p>
<p>我个人也会持续关注 Kotlin 的发展，并且在 Kotlin 发布新版本之后，也会以视频的形式为大家介绍其中的新特性。</p>
<h3 id="2-为什么不统一更名为-“bennyhuo-不是算命的”？"><a href="#2-为什么不统一更名为-“bennyhuo-不是算命的”？" class="headerlink" title="2. 为什么不统一更名为 “bennyhuo 不是算命的”？"></a>2. 为什么不统一更名为 “bennyhuo 不是算命的”？</h3><p>我最初确实想统一成 “bennyhuo 不是算命的”，但微信公众号的名称中禁止出现“算命”，因此只好再选一个名字。想来想去，干脆用自己的真名好了，省事儿。</p>
<p>顺便提一句，“bennyhuo” 是我在腾讯打工的时候的“代号”。</p>
<h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><p>今年在 B 站、YouTube、抖音、微信公众号同步发视频，欢迎在你喜欢的平台搜索：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a> 并持续关注。</p>
<p>其中，B 站仍然是我视频发布的最主要的平台。2023 年全年发布视频 127 个，总计播放 60 万次。其中，所有视频累计播放在 6 月份突破了 100 万次，单稿播放最高纪录靠鸿蒙刷到了 7 万+。订阅量从年初的 17500 左右增长到接近 23500，平均每天净增长 15，<strong>谢谢大家的关注和一键三连</strong>。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20231231224603.png"></p>
<p>2023 年的视频仍然以读书视频为主。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV13T4y1k7qQ/">《现代 C++ 特性解析》更新至第十二章，共 18 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1NR4y1A7Tk/">《Rust 程序设计语言》更新至第十六章，共 33 集</a></li>
<li><a href="https://www.bilibili.com/video/BV1454y1g7Lx/">《Java 核心技术》更新至 3.6，共 35 集</a></li>
</ul>
<p>此外，还有一些编程语言版本新特性的视频：</p>
<ol>
<li>Kotlin 版本更新的视频：<ul>
<li><a href="https://www.bilibili.com/video/BV16s4y147m1/">Kotlin 1.8 共 5 期</a></li>
<li><a href="https://www.bilibili.com/video/BV1DP411k7xs/">Kotlin 1.9 共 1 期</a></li>
</ul>
</li>
<li>Java 版本更新的视频：<ul>
<li><a href="https://www.bilibili.com/video/BV1MB4y1f73i/">Java 21 共 8 期</a></li>
</ul>
</li>
</ol>
<p>年底的时候新开<a href="https://www.bilibili.com/video/BV18a4y1S7Em/">鸿蒙的坑，共计发布视频 6 个</a>：</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20231231230412.png"></p>
<p>2024 年计划将《Rust 程序设计语言》按照现在的形式继续更完。而《现代 C++ 特性解析》《Java 核心技术》就不再按照现有的形式继续读下去了，因为这几本书的内容都很多，想要更完并不容易。C++ 和 Java 相关的视频将会参考这些书籍，以一种更加紧凑的形式更新下去。至于为什么要坚持更完 Rust 那本，显然，它最简单，内容也最少。</p>
<p>后面会有鸿蒙开发教程吗？答案是：不会。成体系的内容做起来费时费力，时间精力跟不上。不过，不出意外的话，我大概率会在 2024 年投入很大的精力参与鸿蒙 NEXT 的适配工作，因此遇到一些有意思的内容还是会不断与大家分享的。</p>
<p>还会开新坑吗？答案是：可能会有，但可能不会有类似于 Rust 读书这种成体系的视频了。因为我自己的想法天天变，也实在是不太想被自己挖的坑束缚了。</p>
<p>其实核心就一个：更新视频是一件令人<strong>开心</strong>的事儿，它不能成为我的负担。</p>
<h2 id="文字内容"><a href="#文字内容" class="headerlink" title="文字内容"></a>文字内容</h2><p>今年文章写得不多，笑死，因为根本就没写。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094139.png"></p>
<p>好消息是 <strong><a href="https://item.jd.com/10081757341486.html">《深入实践 Kotlin 元编程》</a></strong> 在 2023 年 8 月出版了。这是我的第二本书，内容有一定的难度，适合有进阶需求的 Kotlin 开发者。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094107.png"></p>
<h2 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h2><p>今年的社区活动，一共有八次，分享了六个不同的主题。其中线上活动五次，线下活动三次。顺便提一句，12 月参加完天津 GDG 的活动之后自驾去海边吹冷风，特别爽。</p>
<ul>
<li>2023.12 机械工业出版社: <strong><a href="https://www.bilibili.com/video/BV14e41167CM/">我们对 Java 有哪些常见的误区？</a></strong></li>
<li>2023.11、12 GDG DevFest: <strong><a href="https://www.bilibili.com/video/BV1mN411j7tp/">使用 Kotlin 元编程技术提升开发效率</a></strong></li>
<li>2023.09 JetBrains 码上道: <strong><a href="https://www.bilibili.com/video/BV1yg4y1d7P6/">Kotlin 开发者的首“锈”:Rust 到底香不香?</a></strong></li>
<li>2023.05、06 Java 核心技术大会: <strong><a href="https://www.bilibili.com/video/BV1j8411S779/">Java 的现代化 - 包袱、挑战和革新</a></strong></li>
<li>2023.05 北京 KUG: <strong><a href="https://www.bilibili.com/video/BV1ck4y1j7Pa/">你想知道的 Jetpack Compose 的编译器黑魔法</a></strong></li>
<li>2023.04 GDG 社区说: <strong><a href="https://www.bilibili.com/video/BV1Rm4y127hj/">如何开发一款 Kotlin 编译器插件？</a></strong></li>
</ul>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101215333.png"></p>
<p>在天津 GDG 的活动上，有位现场的朋友提问，K2 编译器中还会有 PSI 吗？我当时一时没有反应过来，就说回去查证一下再来答复，结果忘了留他的联系方式，只好在这里做一下回答。</p>
<p>其实 FIR 的所有语法节点都有一个 source 的字段用来获取原始的 PSI，如果我们想要分析代码的注释，还是需要通过 PSI 来获取的。所以 PSI 不能说完全去掉了，只是被降级了。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>2023 年在开源项目上的投入不大，主要还是以维护之前的项目为主。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094759.png"></p>
<p>其中新开源项目 <a href="https://github.com/kanyun-inc/Kudos">kanyun-inc/Kudos</a>，解决了 Gson 等 JSON 框架在反序列化时不支持 Kotlin 类型空安全、构造器参数默认值等问题。</p>
<p>最近在适配鸿蒙时，还尝试为 Ktor 提供了鸿蒙的 Client 实现，参见：<a href="https://github.com/kotlin-for-ohos/ktor">kotlin-for-ohos/ktor</a>。</p>
<p>全年的统计数据可以参考：</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101094655.png"></p>
<h2 id="知识星球"><a href="#知识星球" class="headerlink" title="知识星球"></a>知识星球</h2><p>知识星球试运营一年，发布了一些会员视频，包括：</p>
<ul>
<li>《深入实践 Kotlin 元编程》的读书视频，共 12 期</li>
<li>会员月刊 共 13 期</li>
</ul>
<p>之前想开个新栏目，会员朋友们建议更新一些 LeetCode 的刷题视频。结果因为年底事儿太多，一直拖更，隔壁 AB 老师都已经更到停更了，我还没开始。这个专栏争取要在 2024 年更起来。</p>
<p>感谢各位星球会员朋友们的支持。</p>
<h2 id="初心与愿景"><a href="#初心与愿景" class="headerlink" title="初心与愿景"></a>初心与愿景</h2><h3 id="为什么做技术分享"><a href="#为什么做技术分享" class="headerlink" title="为什么做技术分享"></a>为什么做技术分享</h3><p>十多年前，我刚开始学习编程的时候，网传的各类视频教程给予了我非常大的帮助。我并不是天赋型选手，花了很长时间才学会如何通过翻阅文档和源码来学习新知识。正因为如此，我觉得技术分享是非常有意义的，对于一部分人来说会有很大的帮助。</p>
<p>当然，做技术分享也是有很多好处的，我自己也非常乐于分享。</p>
<ol>
<li>对于一个几乎没有社交活动的人来说，做技术分享是我认识一些很纯粹的朋友的重要渠道。</li>
<li>做技术分享还可以不断让自己反复对知识进行求证，反复摔打自己的知识体系，促进自己的技术成长。</li>
<li>做分享还可以锻炼自己的表达能力，让自己逐渐适应更大的舞台。</li>
<li>做分享可以提升自己的影响力，这实际上也是一种非常奇妙的体验。</li>
</ol>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101221536.png"></p>
<p>因此，我也非常建议大家尝试一下做一些分享，这仍然是一个自媒体的时代，镜头和舞台可以给到每一个人。</p>
<h3 id="什么时候开始“恰饭”？"><a href="#什么时候开始“恰饭”？" class="headerlink" title="什么时候开始“恰饭”？"></a>什么时候开始“恰饭”？</h3><p>我看视频评论的时候遇到好几次，“听声音好熟悉，跟慕课网讲 C 语言的老师是同一个人吗” 的疑问。其实之前我在慕课网发布过几门课程，不过因为个人精力和身体原因，我已经决定不再慕课网继续发布新课了。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101181024.png"></p>
<p>说起来，今年还花时间更新了一下 C 语言课，优化了一下视频的内容，增加了常见问题的答疑，之前学习过这门课的朋友可以回去看一下更新的内容是否有帮助。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101181506.png"></p>
<p>如果有朋友有兴趣在慕课网做讲师，我可以帮忙推荐给慕课网。</p>
<p>说回 B 站，我在 2023 年把视频的收益关掉了，因为实在太少了，指望靠这个买 mac studio，我估计差不多都可以买到 M10 MAX 了。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101180402.png"></p>
<p>细心的朋友们可能还会发现，我的视频里面几乎都没有明示或暗示过大家投币三连，早期还有一个统一的求关注的结尾，后来我也干脆去掉了。</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101180642.png" alt="早期的视频结尾，现在的视频已经没有了"></p>
<p>我希望被更多人关注吗？当然。</p>
<p>我希望我的视频播放量上涨吗？当然。</p>
<p>不过，我更希望我的视频纯粹一些。因此我应该不会在视频里面添加视频内容无关的引导。希望大家通过我的视频有所收获，大家投币点赞也是因为觉得这些视频值得。</p>
<p>至于后面怎么恰饭，如果真的到了需要向生活低头的时候，我大概会把我的知识星球发出来。</p>
<h3 id="微信群群规"><a href="#微信群群规" class="headerlink" title="微信群群规"></a>微信群群规</h3><p>为了方便交流，我也拉了一些微信群。熟悉的朋友们知道，我一直坚持要求大家在群里做技术交流，不要高屋建瓴的关心世界，更不要输出负能量。</p>
<p>为什么呢？因为我们的眼界有限，很多见解自以为精妙绝伦，实际上无比稚嫩；退一步讲，就算我们能讨论出有建设性的意见，我们又有什么渠道能够让意见落实呢？更多的，往往是群友们互相断章取义，发展到对人口诛笔伐，最终搞得群里乌烟瘴气。</p>
<p>技术群是为了交流技术，哪怕交流如何跟无良领导作斗争我觉得都可以接受，我甚至会帮忙出出主意，但如果只是想要宣泄不满，建议换个地方。我们都难免遭遇不公，也都难免经历委屈，除非你成为强者，否则谁又愿意听你哭诉呢？</p>
<p><img src="http://bennyhuo-1251218094.cosbj.myqcloud.com/picgo/20240101221041.png"></p>
<p>先想办法成为强者，再想怎么改变世界。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望大家在 2024 年身体健康，工作顺心。</p>
<p>2024 继续加油。</p>
<hr>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>
<ul>
<li>GitHub：<a href="https://github.com/bennyhuo">https://github.com/bennyhuo</a></li>
<li>博客：<a href="https://www.bennyhuo.com/">https://www.bennyhuo.com</a></li>
<li>bilibili：<a href="https://space.bilibili.com/28615855"><strong>霍丙乾 bennyhuo</strong></a></li>
<li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li>
</ul>
]]></content>
      <tags>
        <tag>2023</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
