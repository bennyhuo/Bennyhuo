<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.bennyhuo.com/book/kotlin-coroutines/11-flow.html"><meta property="og:site_name" content="Benny Huo 的专栏"><meta property="og:title" content="11. Flow 篇"><meta property="og:description" content="Flow 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 随着 RxJava 的流行，响应式编程模型逐步深入人心。Flow 就是 Kotlin 协程与响应式编程模型结合的产物。 本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-04-16T15:04:10.000Z"><meta property="article:author" content="Benny Huo"><meta property="article:modified_time" content="2023-04-16T15:04:10.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"11. Flow 篇","image":[""],"dateModified":"2023-04-16T15:04:10.000Z","author":[{"@type":"Person","name":"Benny Huo","url":"https://www.bennyhuo.com"}]}</script><title>11. Flow 篇 | Benny Huo 的专栏</title><meta name="description" content="Flow 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 随着 RxJava 的流行，响应式编程模型逐步深入人心。Flow 就是 Kotlin 协程与响应式编程模型结合的产物。 本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/book/assets/style-5d728c89.css" as="style"><link rel="stylesheet" href="/book/assets/style-5d728c89.css">
    <link rel="modulepreload" href="/book/assets/app-21101dcf.js"><link rel="modulepreload" href="/book/assets/framework-98842e7a.js"><link rel="modulepreload" href="/book/assets/11-flow.html-2a7c4111.js"><link rel="modulepreload" href="/book/assets/11-flow.html-01e179c6.js"><link rel="prefetch" href="/book/assets/index.html-7e02e0cc.js" as="script"><link rel="prefetch" href="/book/assets/conferences.html-240b34ea.js" as="script"><link rel="prefetch" href="/book/assets/imooc.html-0e40865e.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-8424f486.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-e65ad28f.js" as="script"><link rel="prefetch" href="/book/assets/02-strictfp.html-dbe7efd8.js" as="script"><link rel="prefetch" href="/book/assets/03-random.html-afc8df36.js" as="script"><link rel="prefetch" href="/book/assets/04-mac.html-05c29b44.js" as="script"><link rel="prefetch" href="/book/assets/05-removed.html-fee3fbd8.js" as="script"><link rel="prefetch" href="/book/assets/06-internals.html-46b3557e.js" as="script"><link rel="prefetch" href="/book/assets/07-switch.html-200bb631.js" as="script"><link rel="prefetch" href="/book/assets/08-sealedclass.html-d60f67c7.js" as="script"><link rel="prefetch" href="/book/assets/09-foreignapi-memory.html-2affd912.js" as="script"><link rel="prefetch" href="/book/assets/10-foreignapi-callfunction.html-5ca7c4dc.js" as="script"><link rel="prefetch" href="/book/assets/11-vector.html-939f629c.js" as="script"><link rel="prefetch" href="/book/assets/12-contextserialfilter.html-2be37a62.js" as="script"><link rel="prefetch" href="/book/assets/index.html-e0181c9c.js" as="script"><link rel="prefetch" href="/book/assets/000_1054415.html-c5a3bdd3.js" as="script"><link rel="prefetch" href="/book/assets/001_375593.html-68fbf1c4.js" as="script"><link rel="prefetch" href="/book/assets/002_1104674.html-4915b950.js" as="script"><link rel="prefetch" href="/book/assets/003_378177.html-92d02cf1.js" as="script"><link rel="prefetch" href="/book/assets/004_1150253.html-90601788.js" as="script"><link rel="prefetch" href="/book/assets/005_395051.html-16f53c24.js" as="script"><link rel="prefetch" href="/book/assets/006_595961.html-99900d16.js" as="script"><link rel="prefetch" href="/book/assets/007_426234.html-66410a00.js" as="script"><link rel="prefetch" href="/book/assets/008_245669.html-24c266f5.js" as="script"><link rel="prefetch" href="/book/assets/index.html-7247e465.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-093d22ff.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-770e6371.js" as="script"><link rel="prefetch" href="/book/assets/02-generator.html-2b6aab2e.js" as="script"><link rel="prefetch" href="/book/assets/03-functional.html-f11618a7.js" as="script"><link rel="prefetch" href="/book/assets/04-task.html-bb319bfb.js" as="script"><link rel="prefetch" href="/book/assets/05-dispatcher.html-4f244adc.js" as="script"><link rel="prefetch" href="/book/assets/06-sleep.html-626111a9.js" as="script"><link rel="prefetch" href="/book/assets/07-channel.html-a3d63f6b.js" as="script"><link rel="prefetch" href="/book/assets/08-awaiter.html-96037d4e.js" as="script"><link rel="prefetch" href="/book/assets/09-http.html-6f5f256a.js" as="script"><link rel="prefetch" href="/book/assets/10-postscript.html-8f9c0849.js" as="script"><link rel="prefetch" href="/book/assets/index.html-e09c29fe.js" as="script"><link rel="prefetch" href="/book/assets/00-forword.html-baa7dd6e.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-b1fe58a7.js" as="script"><link rel="prefetch" href="/book/assets/02-start-mode.html-8b676b37.js" as="script"><link rel="prefetch" href="/book/assets/03-dispatchers.html-8c35fd84.js" as="script"><link rel="prefetch" href="/book/assets/04-exceptions.html-87f97643.js" as="script"><link rel="prefetch" href="/book/assets/05-cancellation.html-5fa13e78.js" as="script"><link rel="prefetch" href="/book/assets/06-suspend.html-be716b66.js" as="script"><link rel="prefetch" href="/book/assets/07-sequence.html-2be9dfaa.js" as="script"><link rel="prefetch" href="/book/assets/08-android.html-f6fa30c3.js" as="script"><link rel="prefetch" href="/book/assets/09-channel.html-c813b442.js" as="script"><link rel="prefetch" href="/book/assets/10-select.html-0f4f1183.js" as="script"><link rel="prefetch" href="/book/assets/12-why-so-called-lightweight-thread.html-ad2eb523.js" as="script"><link rel="prefetch" href="/book/assets/13-implementations.html-eaf5fad0.js" as="script"><link rel="prefetch" href="/book/assets/index.html-abc8de6e.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-a156904e.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-9fb373ca.js" as="script"><link rel="prefetch" href="/book/assets/02-wrap-callback.html-c090e4b8.js" as="script"><link rel="prefetch" href="/book/assets/03-call-async-func.html-dfc1daf3.js" as="script"><link rel="prefetch" href="/book/assets/04-structured-concurrency.html-a43ebfba.js" as="script"><link rel="prefetch" href="/book/assets/05-cancellation.html-9d243a4e.js" as="script"><link rel="prefetch" href="/book/assets/06-actor.html-94d6373a.js" as="script"><link rel="prefetch" href="/book/assets/07-globalactor.html-191299ba.js" as="script"><link rel="prefetch" href="/book/assets/08-tasklocal.html-476ad127.js" as="script"><link rel="prefetch" href="/book/assets/09-interop.html-94882bf6.js" as="script"><link rel="prefetch" href="/book/assets/index.html-93aa55cf.js" as="script"><link rel="prefetch" href="/book/assets/404.html-8af28d87.js" as="script"><link rel="prefetch" href="/book/assets/index.html-5470c330.js" as="script"><link rel="prefetch" href="/book/assets/conferences.html-ada429cc.js" as="script"><link rel="prefetch" href="/book/assets/imooc.html-29d6f67d.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-c1e8fe5b.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-5844d02d.js" as="script"><link rel="prefetch" href="/book/assets/02-strictfp.html-436bb167.js" as="script"><link rel="prefetch" href="/book/assets/03-random.html-b3305627.js" as="script"><link rel="prefetch" href="/book/assets/04-mac.html-e730cfe0.js" as="script"><link rel="prefetch" href="/book/assets/05-removed.html-a5ede77e.js" as="script"><link rel="prefetch" href="/book/assets/06-internals.html-f453ce5e.js" as="script"><link rel="prefetch" href="/book/assets/07-switch.html-f653fa84.js" as="script"><link rel="prefetch" href="/book/assets/08-sealedclass.html-e78481f5.js" as="script"><link rel="prefetch" href="/book/assets/09-foreignapi-memory.html-b20ce813.js" as="script"><link rel="prefetch" href="/book/assets/10-foreignapi-callfunction.html-9953912e.js" as="script"><link rel="prefetch" href="/book/assets/11-vector.html-bad16107.js" as="script"><link rel="prefetch" href="/book/assets/12-contextserialfilter.html-baef5b34.js" as="script"><link rel="prefetch" href="/book/assets/index.html-394a11da.js" as="script"><link rel="prefetch" href="/book/assets/000_1054415.html-ebcc7a7a.js" as="script"><link rel="prefetch" href="/book/assets/001_375593.html-a569f787.js" as="script"><link rel="prefetch" href="/book/assets/002_1104674.html-86eb0172.js" as="script"><link rel="prefetch" href="/book/assets/003_378177.html-56b2a8d3.js" as="script"><link rel="prefetch" href="/book/assets/004_1150253.html-9a6b88ee.js" as="script"><link rel="prefetch" href="/book/assets/005_395051.html-274d22d5.js" as="script"><link rel="prefetch" href="/book/assets/006_595961.html-e6b7629e.js" as="script"><link rel="prefetch" href="/book/assets/007_426234.html-f874bd7b.js" as="script"><link rel="prefetch" href="/book/assets/008_245669.html-ffa411e5.js" as="script"><link rel="prefetch" href="/book/assets/index.html-d2cae4f8.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-aa7bbbd5.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-5d302371.js" as="script"><link rel="prefetch" href="/book/assets/02-generator.html-8938b76b.js" as="script"><link rel="prefetch" href="/book/assets/03-functional.html-2c462bf6.js" as="script"><link rel="prefetch" href="/book/assets/04-task.html-c65dea9f.js" as="script"><link rel="prefetch" href="/book/assets/05-dispatcher.html-ef1307f3.js" as="script"><link rel="prefetch" href="/book/assets/06-sleep.html-fac336d4.js" as="script"><link rel="prefetch" href="/book/assets/07-channel.html-25126c7f.js" as="script"><link rel="prefetch" href="/book/assets/08-awaiter.html-47704cc5.js" as="script"><link rel="prefetch" href="/book/assets/09-http.html-f76d4b07.js" as="script"><link rel="prefetch" href="/book/assets/10-postscript.html-e58b68f6.js" as="script"><link rel="prefetch" href="/book/assets/index.html-70d3d61b.js" as="script"><link rel="prefetch" href="/book/assets/00-forword.html-c4c9f795.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-238a6738.js" as="script"><link rel="prefetch" href="/book/assets/02-start-mode.html-54f6b61f.js" as="script"><link rel="prefetch" href="/book/assets/03-dispatchers.html-c7b90533.js" as="script"><link rel="prefetch" href="/book/assets/04-exceptions.html-2d473dc9.js" as="script"><link rel="prefetch" href="/book/assets/05-cancellation.html-3b56f1d5.js" as="script"><link rel="prefetch" href="/book/assets/06-suspend.html-1a23fc05.js" as="script"><link rel="prefetch" href="/book/assets/07-sequence.html-7a229c4d.js" as="script"><link rel="prefetch" href="/book/assets/08-android.html-055e6a88.js" as="script"><link rel="prefetch" href="/book/assets/09-channel.html-829b6090.js" as="script"><link rel="prefetch" href="/book/assets/10-select.html-67a4330d.js" as="script"><link rel="prefetch" href="/book/assets/12-why-so-called-lightweight-thread.html-80f33be3.js" as="script"><link rel="prefetch" href="/book/assets/13-implementations.html-6b6d1949.js" as="script"><link rel="prefetch" href="/book/assets/index.html-8abb9b62.js" as="script"><link rel="prefetch" href="/book/assets/00-foreword.html-d20a79a9.js" as="script"><link rel="prefetch" href="/book/assets/01-intro.html-cdfdd37b.js" as="script"><link rel="prefetch" href="/book/assets/02-wrap-callback.html-514743a0.js" as="script"><link rel="prefetch" href="/book/assets/03-call-async-func.html-9b4c73ba.js" as="script"><link rel="prefetch" href="/book/assets/04-structured-concurrency.html-ee8a0a41.js" as="script"><link rel="prefetch" href="/book/assets/05-cancellation.html-4d88f3f1.js" as="script"><link rel="prefetch" href="/book/assets/06-actor.html-2b4fda3a.js" as="script"><link rel="prefetch" href="/book/assets/07-globalactor.html-1a16a454.js" as="script"><link rel="prefetch" href="/book/assets/08-tasklocal.html-1fc9292a.js" as="script"><link rel="prefetch" href="/book/assets/09-interop.html-b3a2cb71.js" as="script"><link rel="prefetch" href="/book/assets/index.html-6cfec8fa.js" as="script"><link rel="prefetch" href="/book/assets/404.html-0e66faad.js" as="script"><link rel="prefetch" href="/book/assets/giscus-2f1671b8.js" as="script"><link rel="prefetch" href="/book/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/book/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/book/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/book/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/book/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/book/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/book/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/book/assets/photoswipe.esm-36cd6c3c.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/book/" class="brand"><img class="logo" src="https://www.bennyhuo.com/assets/avatar.jpg" alt="Benny Huo 的专栏"><!----><span class="site-name hide-in-pad">Benny Huo 的专栏</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><!----><!----><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading clickable"><!----><a href="https://www.bennyhuo.com" rel="noopener noreferrer" target="_blank" aria-label="网站首页" class="nav-link title"><!---->网站首页<!----><!----></a><!----></p><ul class="sidebar-links"></ul></section></li><li><!--[--><a href="/book/" class="nav-link sidebar-link sidebar-page" aria-label="专栏首页"><!---->专栏首页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/conferences.html" class="nav-link sidebar-link sidebar-page" aria-label="会议分享"><!---->会议分享<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/imooc.html" class="nav-link sidebar-link sidebar-page" aria-label="视频课程"><!---->视频课程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">视频连载</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">渡劫 C++ 协程</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">Java 17 版本更新</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><!----><span class="title">破解 Kotlin 协程</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/book/kotlin-coroutines/00-forword.html" class="nav-link sidebar-link sidebar-page" aria-label="0. 前言"><!---->0. 前言<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/01-intro.html" class="nav-link sidebar-link sidebar-page" aria-label="1. 入门篇"><!---->1. 入门篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/02-start-mode.html" class="nav-link sidebar-link sidebar-page" aria-label="2. 协程启动篇"><!---->2. 协程启动篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/03-dispatchers.html" class="nav-link sidebar-link sidebar-page" aria-label="3. 协程调度篇"><!---->3. 协程调度篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/04-exceptions.html" class="nav-link sidebar-link sidebar-page" aria-label="4. 异常处理篇"><!---->4. 异常处理篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/05-cancellation.html" class="nav-link sidebar-link sidebar-page" aria-label="5. 协程取消篇"><!---->5. 协程取消篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/06-suspend.html" class="nav-link sidebar-link sidebar-page" aria-label="6. 协程挂起篇"><!---->6. 协程挂起篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/07-sequence.html" class="nav-link sidebar-link sidebar-page" aria-label="7. 序列生成器篇"><!---->7. 序列生成器篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/08-android.html" class="nav-link sidebar-link sidebar-page" aria-label="8. Android 篇"><!---->8. Android 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/09-channel.html" class="nav-link sidebar-link sidebar-page" aria-label="9. Channel 篇"><!---->9. Channel 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/10-select.html" class="nav-link sidebar-link sidebar-page" aria-label="10. Select 篇"><!---->10. Select 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="11. Flow 篇"><!---->11. Flow 篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#认识-flow" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="认识 Flow"><!---->认识 Flow<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#对比-rxjava-的线程切换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对比 RxJava 的线程切换"><!---->对比 RxJava 的线程切换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#冷数据流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="冷数据流"><!---->冷数据流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#异常处理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="异常处理"><!---->异常处理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#末端操作符" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="末端操作符"><!---->末端操作符<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#分离-flow-的消费和触发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分离 flow 的消费和触发"><!---->分离 flow 的消费和触发<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的取消" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Flow 的取消"><!---->Flow 的取消<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#其他-flow-的创建方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="其他 Flow 的创建方式"><!---->其他 Flow 的创建方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的背压" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Flow 的背压"><!---->Flow 的背压<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的变换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Flow 的变换"><!---->Flow 的变换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#使用-flow-实现多路复用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="使用 Flow 实现多路复用"><!---->使用 Flow 实现多路复用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="小结"><!---->小结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#关于作者" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="关于作者"><!---->关于作者<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/12-why-so-called-lightweight-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="12. 协程为什么被称为『轻量级线程』？"><!---->12. 协程为什么被称为『轻量级线程』？<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/book/kotlin-coroutines/13-implementations.html" class="nav-link sidebar-link sidebar-page" aria-label="13. 协程的几类常见的实现"><!---->13. 协程的几类常见的实现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">闲话 Swift 协程</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->11. Flow 篇</h1><div class="page-info"><span class="page-author-info" aria-label="作者"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://www.bennyhuo.com" target="_blank" rel="noopener noreferrer">Benny Huo</a></span><span property="author" content="Benny Huo"></span></span><!----><span class="page-date-info" aria-label="写作日期"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-03-30T14:18:41.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 12 分钟</span><meta property="timeRequired" content="PT12M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#认识-flow" class="router-link-active router-link-exact-active toc-link level2">认识 Flow</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#对比-rxjava-的线程切换" class="router-link-active router-link-exact-active toc-link level2">对比 RxJava 的线程切换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#冷数据流" class="router-link-active router-link-exact-active toc-link level2">冷数据流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#异常处理" class="router-link-active router-link-exact-active toc-link level2">异常处理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#末端操作符" class="router-link-active router-link-exact-active toc-link level2">末端操作符</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#分离-flow-的消费和触发" class="router-link-active router-link-exact-active toc-link level2">分离 flow 的消费和触发</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的取消" class="router-link-active router-link-exact-active toc-link level2">Flow 的取消</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#其他-flow-的创建方式" class="router-link-active router-link-exact-active toc-link level2">其他 Flow 的创建方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的背压" class="router-link-active router-link-exact-active toc-link level2">Flow 的背压</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#flow-的变换" class="router-link-active router-link-exact-active toc-link level2">Flow 的变换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#使用-flow-实现多路复用" class="router-link-active router-link-exact-active toc-link level2">使用 Flow 实现多路复用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#小结" class="router-link-active router-link-exact-active toc-link level2">小结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/book/kotlin-coroutines/11-flow.html#关于作者" class="router-link-active router-link-exact-active toc-link level2">关于作者</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="_11-flow-篇" tabindex="-1"><a class="header-anchor" href="#_11-flow-篇" aria-hidden="true">#</a> 11. Flow 篇</h1><blockquote><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p></blockquote><p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p><p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p><h2 id="认识-flow" tabindex="-1"><a class="header-anchor" href="#认识-flow" aria-hidden="true">#</a> 认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p><p><strong>代码清单1： 序列生成器</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> ints <span class="token operator">=</span> sequence <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">yield</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p><p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> ints <span class="token operator">=</span> sequence <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">yield</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// ERROR!</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p><p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p><p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p><p><strong>代码清单3：创建 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> intFlow <span class="token operator">=</span> flow <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p><p>Flow 也可以设定它运行时所使用的调度器：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>intFlow<span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p><p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p><p><strong>代码清单4： 消费 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>myDispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  intFlow<span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">1</span>
<span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">2</span>
<span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对比-rxjava-的线程切换" tabindex="-1"><a class="header-anchor" href="#对比-rxjava-的线程切换" aria-hidden="true">#</a> 对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p><p><strong>代码清单5：RxJava 的调度器切换</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Observable<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> e <span class="token operator">-&gt;</span>
    it<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  it<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>myExecutor<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{</span>
  <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p><p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p><p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p><h2 id="冷数据流" tabindex="-1"><a class="header-anchor" href="#冷数据流" aria-hidden="true">#</a> 冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p><p><strong>代码清单6：Flow 可以被重复消费</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p><p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p><p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p><blockquote><p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p></blockquote><h2 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p><p><strong>代码清单7：捕获 Flow 的异常</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p><p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p><p><strong>代码清单8：订阅流的完成</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onCompletion</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable<span class="token operator">?</span> <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;finally.&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p><p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p><p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span> 
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>t<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;finally.&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p><p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p><p><strong>代码清单10：RxJava 从异常中恢复</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> observable <span class="token operator">=</span> Observable<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onErrorReturn</span> <span class="token punctuation">{</span>
  <span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
  <span class="token number">10</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>捕获异常后，返回 10 作为下一个值。</p><p>我们在 Flow 当中也可以模拟这样的操作：</p><p><strong>代码清单11：Flow 从异常中恢复</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p><blockquote><p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href="https://github.com/Kotlin/kotlinx.coroutines/pull/1732" target="_blank" rel="noopener noreferrer">Breaking change: Experimental Flow.onCompletion contract for cause #1732<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p></blockquote><h2 id="末端操作符" tabindex="-1"><a class="header-anchor" href="#末端操作符" aria-hidden="true">#</a> 末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p><ol><li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li><li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li></ol><p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p><h2 id="分离-flow-的消费和触发" tabindex="-1"><a class="header-anchor" href="#分离-flow-的消费和触发" aria-hidden="true">#</a> 分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p><p><strong>代码清单12：分离 Flow 的消费和触发</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> flow<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
      <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p><p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">launchIn</span><span class="token punctuation">(</span>GlobalScope<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p><h2 id="flow-的取消" tabindex="-1"><a class="header-anchor" href="#flow-的取消" aria-hidden="true">#</a> Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p><p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p><p><strong>代码清单14：Flow 的取消</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
  <span class="token keyword">val</span> intFlow <span class="token operator">=</span> flow <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
      <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2500</span><span class="token punctuation">)</span>
job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token number">1</span>
▶ 1000ms later
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p><h2 id="其他-flow-的创建方式" tabindex="-1"><a class="header-anchor" href="#其他-flow-的创建方式" aria-hidden="true">#</a> 其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow { ... }</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p><p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span> <span class="token comment">// BAD!!</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>channelFlow <span class="token punctuation">{</span>
  <span class="token function">send</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，我们也可以通过集合框架来创建 Flow：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="flow-的背压" tabindex="-1"><a class="header-anchor" href="#flow-的背压" aria-hidden="true">#</a> Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p><p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p><p><strong>代码清单16：为 Flow 添加缓冲</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p><p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p><p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p><p><strong>代码清单17：使用 conflate 解决背压问题</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">conflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> value <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Collecting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> 
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string"> collected&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Collecting <span class="token number">1</span>
<span class="token number">1</span> collected
Collecting <span class="token number">99</span>
<span class="token number">99</span> collected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><p>还是前面的例子，我们稍作修改：</p><p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collectLatest</span> <span class="token punctuation">{</span> value <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Collecting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string"> collected&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Collecting 0
Collecting 1
...
Collecting 97
Collecting 98
Collecting 99
▶ 100ms later
99 collected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p><p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p><h2 id="flow-的变换" tabindex="-1"><a class="header-anchor" href="#flow-的变换" aria-hidden="true">#</a> Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p><p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p><p><strong>代码清单19：Flow 的元素变换</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> 
  it <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以映射成其他 Flow：</p><p><strong>代码清单20：Flow 的嵌套</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
  flow <span class="token punctuation">{</span> <span class="token function">List</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p><p><strong>代码清单21：拼接 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
  flow <span class="token punctuation">{</span> <span class="token function">List</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">flattenConcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p><h2 id="使用-flow-实现多路复用" tabindex="-1"><a class="header-anchor" href="#使用-flow-实现多路复用" aria-hidden="true">#</a> 使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p><p>上一篇文章<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/" target="_blank" rel="noopener noreferrer">破解 Kotlin 协程(10) - Select 篇<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中对 await 的复用我们可以用 Flow 实现如下：</p><p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>coroutineScope <span class="token punctuation">{</span>
  <span class="token keyword">val</span> login <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;...&quot;</span></span>
  <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token operator">::</span>getUserFromApi<span class="token punctuation">,</span> <span class="token operator">::</span>getUserFromLocal<span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ①
    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> function <span class="token operator">-&gt;</span>
      function<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>login<span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ②
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> deferred <span class="token operator">-&gt;</span>
      flow <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>deferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">..</span><span class="token punctuation">.</span> ③
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ④
    <span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{</span> user <span class="token operator">-&gt;</span>
      <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">user</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">launchIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png" alt=""></p><p><strong>图1：使用 merge 合并 Flow</strong></p><p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href="https://www.bennyhuo.com/2020/02/03/coroutine-select/" target="_blank" rel="noopener noreferrer">破解 Kotlin 协程(10) - Select 篇<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，我们给出 Flow 的实现版本：</p><p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> channels <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> channels<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
    it<span class="token punctuation">.</span><span class="token function">consumeAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，预计 2023 Q3）；前腾讯高级工程师，现就职于猿辅导</p><ul><li>GitHub：https://github.com/bennyhuo</li><li>博客：https://www.bennyhuo.com</li><li>bilibili：<a href="https://space.bilibili.com/28615855" target="_blank" rel="noopener noreferrer"><strong>霍丙乾 bennyhuo</strong><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li>微信公众号：<strong>霍丙乾 bennyhuo</strong></li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: bennyhuo@kotliner.cn">bennyhuo</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/book/kotlin-coroutines/10-select.html" class="nav-link prev" aria-label="10. Select 篇"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->10. Select 篇</div></a><a href="/book/kotlin-coroutines/12-why-so-called-lightweight-thread.html" class="nav-link next" aria-label="12. 协程为什么被称为『轻量级线程』？"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">12. 协程为什么被称为『轻量级线程』？<!----></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><!----><div class="copyright">bennyhuo@2018-2023</div></footer></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/book/assets/app-21101dcf.js" defer></script>
  </body>
</html>
