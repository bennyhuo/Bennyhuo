import{_ as o,X as c,Y as l,$ as a,Z as n,a0 as s,a1 as u,D as t}from"./framework-98842e7a.js";const i={},k=n("h1",{id:"_5-协程的调度器",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_5-协程的调度器","aria-hidden":"true"},"#"),s(" 5. 协程的调度器")],-1),r=n("blockquote",null,[n("p",null,"协程想要实现异步，很大程度上依赖于调度器的设计。")],-1),d=u(`<h2 id="调度器的抽象设计" tabindex="-1"><a class="header-anchor" href="#调度器的抽象设计" aria-hidden="true">#</a> 调度器的抽象设计</h2><p>为了实现协程的异步调度，我们需要提供调度器的实现。调度器听起来有些厉害，但实际上就是负责执行一段逻辑的工具。</p><p>下面我们给出调度器的抽象设计：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">AbstractExecutor</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是的，你没看错，调度器本身就是这么简单。</p><h2 id="调度的位置" tabindex="-1"><a class="header-anchor" href="#调度的位置" aria-hidden="true">#</a> 调度的位置</h2><p>现在我们已经知道了调度器的样子，那么问题来了，怎么才能把它接入到协程当中呢？这个问题换个说法，那就是什么情况下我们需要调度，或者说什么情况下我们可以实现调度。</p><p>这个问题如果你不知道答案，让你随便蒙，你大概也没有什么其他的选项可以选。因为协程的本质就是挂起和恢复，因此想要实现调度，就必须在挂起和恢复上做文章。想要在 C++ 的协程的挂起和恢复上做文章，那我们就只能考虑定制 Awaiter 了。我们再来回顾一下前面提到的 TaskAwaiter 的定义：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Result</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TaskAwaiter</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

  <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> handle<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    task<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  Result <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> task<span class="token punctuation">.</span><span class="token function">get_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只保留了最核心的三个函数，其他的代码都略去了。可以看到，想要实现调度，就只能在 <code>await_suspend</code> 上面做文章，因为其他两个函数都要求同步返回。</p><p>实际上，按照 C++ 协程的设计，<code>await_suspend</code> 确实是用来提供调度支持的，由于这个时间点协程已经完全挂起，因此我们可以在任意一个线程上调用 <code>handle.resume()</code>，你甚至不用担心线程安全的问题。这样看来，如果有调度器的存在，代码大概会变成下面这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 调度器的类型有多种，因此专门提供一个模板参数 Executor</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Result</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Executor</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TaskAwaiter</span> <span class="token punctuation">{</span>

  <span class="token comment">// 构造 TaskAwaiter 的时候传入调度器的具体实现</span>
  <span class="token keyword">explicit</span> <span class="token function">TaskAwaiter</span><span class="token punctuation">(</span>AbstractExecutor <span class="token operator">*</span>executor<span class="token punctuation">,</span> Task<span class="token operator">&lt;</span>Result<span class="token punctuation">,</span> Executor<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>task<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
      <span class="token operator">:</span> <span class="token function">_executor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">task</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> handle<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    task<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将 resume 函数的调用交给调度器执行</span>
      _executor<span class="token operator">-&gt;</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  Task<span class="token operator">&lt;</span>Result<span class="token punctuation">,</span> Executor<span class="token operator">&gt;</span> task<span class="token punctuation">;</span>
  AbstractExecutor <span class="token operator">*</span>_executor<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="调度器应该由谁持有" tabindex="-1"><a class="header-anchor" href="#调度器应该由谁持有" aria-hidden="true">#</a> 调度器应该由谁持有</h2><p><code>TaskAwaiter</code> 当中的调度器实例是从外部传来的，这样设计的目的是希望把调度器的创建和绑定交给协程本身。换句话说，调度器应该属于协程。这样设计的好处就是协程内部的代码均会被调度到它对应的调度器上执行，可以确保逻辑的一致性和正确性。</p><p>这么看来，调度器应该与 <code>Task</code> 或者 <code>TaskPromise</code> 绑定到一起。</p><p>当协程创建时，我们可以以某种方式执行一个调度器，让协程的执行从头到尾都调度到这个调度器上执行。例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> LooperExecutor<span class="token operator">&gt;</span> <span class="token function">simple_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 协程启动时就要调度到 LooperExecutor 上</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;task start ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">simple_task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 协程从 simple_task2 挂起后恢复执行，也要调度到 LooperExecutor 上</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;returns from task2: &quot;</span><span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> result3 <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">simple_task3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 同上</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;returns from task3: &quot;</span><span class="token punctuation">,</span> result3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">co_return</span> <span class="token number">1</span> <span class="token operator">+</span> result2 <span class="token operator">+</span> result3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们通过模板参数为 <code>Task</code> 绑定了一个叫做 <code>LooperExecutor</code> 的调度器（我们现在先不去管 <code>LooperExecutor</code> 的具体实现，这个我们后面会讲），这样一来，我们希望 <code>simple_task</code> 当中所有的代码都会被调度到 <code>LooperExecutor</code> 上执行。</p><p>请大家参考注释的说明，我们了解到所有挂起的位置都需要在恢复时拿到同一个 <code>LooperExecutor</code> 的实例，因此我们考虑首先对 <code>TaskPromise</code> 的定义做一下修改，引入 <code>Executor</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 增加模板参数 Executor</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ResultType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Executor</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TaskPromise</span> <span class="token punctuation">{</span>
  <span class="token comment">// 协程启动时也需要在恢复时实现调度</span>
  DispatchAwaiter <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> DispatchAwaiter<span class="token punctuation">{</span><span class="token operator">&amp;</span>executor<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  std<span class="token double-colon punctuation">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token comment">// Task 类型增加模板参数 Executor 可以方便创建协程时执行调度器的类型</span>
  Task<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> Executor<span class="token operator">&gt;</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Task<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">coroutine_handle</span><span class="token operator">&lt;</span>TaskPromise<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 注意模板参数</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_ResultType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Executor</span><span class="token operator">&gt;</span>
  TaskAwaiter<span class="token operator">&lt;</span>_ResultType<span class="token punctuation">,</span> _Executor<span class="token operator">&gt;</span> <span class="token function">await_transform</span><span class="token punctuation">(</span>Task<span class="token operator">&lt;</span>_ResultType<span class="token punctuation">,</span> _Executor<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">TaskAwaiter</span><span class="token generic class-name"><span class="token operator">&lt;</span>_ResultType<span class="token punctuation">,</span> _Executor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>executor<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  Executor executor<span class="token punctuation">;</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于我们在 <code>TaskPromise</code> 当中定义了 <code>await_transform</code>，因此协程当中只支持对 <code>Task</code> 类型的 <code>co_await</code> 操作，这样可以保证所有的 <code>co_await &lt;task&gt;</code> 都会在恢复执行时通过 <code>TaskAwaiter</code> 来确保后续逻辑的正确调度。</p><p>剩下的就是协程在启动时的 <code>initial_suspend</code> 了，这个也比较容易处理，我们给出 <code>DispatchAwaiter</code> 的定义：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">DispatchAwaiter</span> <span class="token punctuation">{</span>

  <span class="token keyword">explicit</span> <span class="token function">DispatchAwaiter</span><span class="token punctuation">(</span>AbstractExecutor <span class="token operator">*</span>executor<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
      <span class="token operator">:</span> <span class="token function">_executor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> handle<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调度到协程对应的调度器上</span>
    _executor<span class="token operator">-&gt;</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  AbstractExecutor <span class="token operator">*</span>_executor<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此一来，协程内部的所有逻辑都可以顺利地调度到协程对应的调度器上了。</p><p><code>Task</code> 的改动不大，只是增加了模板参数 <code>Executor</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// NewThreadExecutor 是 AbstractExecutor 的子类，作为模板参数 Executor 的默认值</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ResultType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Executor</span> <span class="token operator">=</span> NewThreadExecutor<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>

  <span class="token comment">// 将模板参数 Executor 传给 TaskPromise</span>
  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> TaskPromise<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> Executor<span class="token operator">&gt;</span><span class="token punctuation">;</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以默认给 <code>Task</code> 指定一个调度器的实现 <code>NewThreadExecutor</code>。这些调度器可以通过指定类型在 <code>TaskPromise</code> 当中执行初始化，因为我们会保证他们都会有默认的无参构造器实现。</p><h2 id="调度器的实现" tabindex="-1"><a class="header-anchor" href="#调度器的实现" aria-hidden="true">#</a> 调度器的实现</h2><p>接下来我们给出几种简单的调度器实现作为示例，读者有兴趣也可以按照自己的需要设计调度器的实现。</p><h3 id="noopexecutor" tabindex="-1"><a class="header-anchor" href="#noopexecutor" aria-hidden="true">#</a> NoopExecutor</h3><p>看名字相比大家也能猜个八九不离十，这就是个什么都不干的调度器：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">NoopExecutor</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractExecutor</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们给 <code>Task</code> 搭配这个调度器，<code>Task</code> 的执行线程就完全取决于调用者或者恢复者所在的线程了。</p><h3 id="newthreadexecutor" tabindex="-1"><a class="header-anchor" href="#newthreadexecutor" aria-hidden="true">#</a> NewThreadExecutor</h3><p>顾名思义，每次调度都创建一个新的线程。实现非常简单：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">NewThreadExecutor</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractExecutor</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="asyncexecutor" tabindex="-1"><a class="header-anchor" href="#asyncexecutor" aria-hidden="true">#</a> AsyncExecutor</h3><p>这个在思路上与 <code>NewThreadExecutor</code> 差别不大，只是调度时交给了 <code>std::async</code> 去执行：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">AsyncExecutor</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractExecutor</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> future <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比之下，这个调度器可以利用 <code>std::async</code> 背后的线程调度，提升线程的利用率。</p><h3 id="looperexecutor" tabindex="-1"><a class="header-anchor" href="#looperexecutor" aria-hidden="true">#</a> LooperExecutor</h3><p>LooperExecutor 稍微复杂一些，它通常出现在主线程为事件循环的场景，例如 UI 相关应用的开发场景。</p><p>考虑到我本身不希望引入 UI 相关的开发概念，这里直接给出一个简单的单线程事件循环，并以此来实现 LooperExecutor：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">LooperExecutor</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractExecutor</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>condition_variable queue_condition<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>mutex queue_lock<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> executable_queue<span class="token punctuation">;</span>

  <span class="token comment">// true 的时候是工作状态，如果要关闭事件循环，就置为 false</span>
  std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> is_active<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>thread work_thread<span class="token punctuation">;</span>

  <span class="token comment">// 处理事件循环</span>
  <span class="token keyword">void</span> <span class="token function">run_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查当前事件循环是否是工作状态，或者队列没有清空</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>is_active<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>executable_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>unique_lock <span class="token function">lock</span><span class="token punctuation">(</span>queue_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>executable_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 队列为空，需要等待新任务加入队列或者关闭事件循环的通知</span>
        queue_condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果队列为空，那么说明收到的是关闭的通知</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executable_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 现有逻辑下此处用 break 也可</span>
          <span class="token comment">// 使用 continue 可以再次检查状态和队列，方便将来扩展</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 取出第一个任务，解锁再执行。</span>
      <span class="token comment">// 解锁非常：func 是外部逻辑，不需要锁保护；func 当中可能请求锁，导致死锁</span>
      <span class="token keyword">auto</span> func <span class="token operator">=</span> executable_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      executable_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">public</span><span class="token operator">:</span>

  <span class="token function">LooperExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    is_active<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    work_thread <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>LooperExecutor<span class="token double-colon punctuation">::</span>run_loop<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">LooperExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待线程执行完，防止出现意外情况</span>
    <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock <span class="token function">lock</span><span class="token punctuation">(</span>queue_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_active<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      executable_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 通知队列，主要用于队列之前为空时调用 wait 等待的情况</span>
      <span class="token comment">// 通知不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span>
      queue_condition<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">bool</span> wait_for_complete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改后立即生效，在 run_loop 当中就能尽早（加锁前）就检测到 is_active 的变化</span>
    is_active<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wait_for_complete<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
      std<span class="token double-colon punctuation">::</span>unique_lock <span class="token function">lock</span><span class="token punctuation">(</span>queue_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 清空任务队列</span>
      <span class="token keyword">decltype</span><span class="token punctuation">(</span>executable_queue<span class="token punctuation">)</span> empty_queue<span class="token punctuation">;</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>executable_queue<span class="token punctuation">,</span> empty_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通知 wait 函数，避免 Looper 线程不退出</span>
    <span class="token comment">// 不需要加锁，否则锁会交给 wait 方导致当前线程阻塞</span>
    queue_condition<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>work_thread<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      work_thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>各位读者可以参考代码注释来理解其中的逻辑。简单来说就是：</p><ol><li>当队列为空时，Looper 的线程通过 <code>wait</code> 来实现阻塞等待。</li><li>有新任务加入时，通过 <code>notify_one</code> 来通知 <code>run_loop</code> 继续执行。</li></ol><h3 id="sharedlooperexecutor" tabindex="-1"><a class="header-anchor" href="#sharedlooperexecutor" aria-hidden="true">#</a> SharedLooperExecutor</h3><p>这个其实就是 <code>LooperExecutor</code> 的一个马甲，它的作用就是让各个协程共享一个 <code>LooperExecutor</code> 实例。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">SharedLooperExecutor</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractExecutor</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>func<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> LooperExecutor sharedLooperExecutor<span class="token punctuation">;</span>
    sharedLooperExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小试牛刀" tabindex="-1"><a class="header-anchor" href="#小试牛刀" aria-hidden="true">#</a> 小试牛刀</h2><p>这次我们基于上一篇文章当中的 demo 加入调度器的支持：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 使用了 Async 调度器</span>
<span class="token comment">// 这意味着每个恢复的位置都会通过 std::async 上执行</span>
Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> AsyncExecutor<span class="token operator">&gt;</span> <span class="token function">simple_task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;task 2 start ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono_literals<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;task 2 returns after 1s.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">co_return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用了 NewThread 调度器</span>
<span class="token comment">// 这意味着每个恢复的位置都会新建一个线程来执行</span>
Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> NewThreadExecutor<span class="token operator">&gt;</span> <span class="token function">simple_task3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;in task 3 start ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono_literals<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">2</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;task 3 returns after 2s.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">co_return</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用了 Looper 调度器</span>
<span class="token comment">// 这意味着每个恢复的位置都会在同一个线程上执行</span>
Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> LooperExecutor<span class="token operator">&gt;</span> <span class="token function">simple_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;task start ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">simple_task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;returns from task2: &quot;</span><span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> result3 <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">simple_task3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;returns from task3: &quot;</span><span class="token punctuation">,</span> result3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">co_return</span> <span class="token number">1</span> <span class="token operator">+</span> result2 <span class="token operator">+</span> result3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> simpleTask <span class="token operator">=</span> <span class="token function">simple_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  simpleTask<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;simple task end: &quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catching</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;error occurred&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> i <span class="token operator">=</span> simpleTask<span class="token punctuation">.</span><span class="token function">get_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;simple task end from get: &quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;error: &quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的代码跟上次不能说完全没有修改吧，那也是几乎没有修改，除了加了调度器的类型作为 <code>Task</code> 的模板参数。运行结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>11:46:03.305 [Thread-32620] (main.cpp:40) simple_task: task start ...
11:46:03.307 [Thread-33524] (main.cpp:24) simple_task2: task 2 start ...
11:46:04.310 [Thread-33524] (main.cpp:27) simple_task2: task 2 returns after 1s.
11:46:04.312 [Thread-32620] (main.cpp:42) simple_task: returns from task2:  2
11:46:04.313 [Thread-42232] (main.cpp:32) simple_task3: in task 3 start ...
11:46:06.327 [Thread-42232] (main.cpp:35) simple_task3: task 3 returns after 2s.
11:46:06.329 [Thread-32620] (main.cpp:44) simple_task: returns from task3:  3
11:46:06.329 [Thread-32620] (main.cpp:51) operator (): simple task end:  6
11:46:06.330 [Thread-30760] (main.cpp:57) main: simple task end from get:  6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请大家仔细观察，所有 <code>simple_task</code> 函数的日志输出都在 id 为 32620 的线程上，这实际上就是我们的 Looper 线程。当然，由于 <code>simple_task2</code> 和 <code>simple_task3</code> 当中没有挂起点，因此它们只会在 <code>initial_suspend</code> 时调度一次。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文我们终于给 <code>Task</code> 添加了调度器的支持。如此一来，我们就可以把 <code>Task</code> 绑定到合适的线程调度器上，来应对更加复杂的业务场景了。</p><p>读者也可以发挥自己的想象力，按照类似的方式定义出更加有用或者有趣的调度器。当然，本文给出的调度器没有做调度优化，有兴趣的读者也可以自己尝试</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p>`,60),v=n("li",null,"GitHub：https://github.com/bennyhuo",-1),m=n("li",null,"博客：https://www.bennyhuo.com",-1),b={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},w=n("strong",null,"霍丙乾 bennyhuo",-1),h=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function y(f,_){const p=t("BiliBili"),e=t("ExternalLinkIcon");return c(),l("div",null,[k,r,a(p,{bvid:"BV1TW4y1k7gp"}),d,n("ul",null,[v,m,n("li",null,[s("bilibili："),n("a",b,[w,a(e)])]),h])])}const g=o(i,[["render",y],["__file","05-dispatcher.html.vue"]]);export{g as default};
