import{_ as e,X as t,Y as o,Z as n,a0 as s,$ as p,a1 as c,D as l}from"./framework-98842e7a.js";const i={},u=c(`<h1 id="_1-java-也支持类型推导了" tabindex="-1"><a class="header-anchor" href="#_1-java-也支持类型推导了" aria-hidden="true">#</a> 1. Java 也支持类型推导了？</h1><p>类型推导是现代编程语言必备的能力，我们现在很少能够看到不支持类型推导的主流编程语言了。当然，C 语言是个例外。</p><p>类型推导就是编译器根据上下文信息对变量的类型进行推算的能力，最典型的例子莫过于 C++ 当中的这个场景了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> values<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator i <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，for 循环中的 i 的类型非常长，写起来繁琐之外，还很难写对这一度让 C++ 的开发者极度难受。不过，从 C++ 11 开始，类型推导的引入让事情变得简单了起来：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>i 的类型使用 <code>auto</code> 关键字替代，这样编译器就会根据 i 的初始化表达式 <code>values.begin()</code> 的类型推断出来。</p><p>现代编程语言基本上都在类型推导上做足了功夫，我们甚至可以认为一门不具备编译时类型推导的语言是不够现代化的。</p><p>下面是 Kotlin 当中的类型推导：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 完整的变量定义</span>
<span class="token keyword">val</span> s<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello World&quot;</span></span>

<span class="token comment">// 省略类型</span>
<span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello World&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量 <code>s</code> 的类型可以通过初始化的表达式推断出来，因此可以省略。绝大多数编程语言在对变量的类型进行推断时，都只对变量定义时的初始化表达式做了分析。</p><p>当然也有例外。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> s<span class="token punctuation">;</span>
    
s <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Rust 允许先把变量定义出来，在后面根据对该变量的使用情况进行变量类型的推导。示例代码中变量 <code>s</code> 在定义时并没有声明类型，也没有进行初始化，Rust 编译器通过分析后面对 <code>s</code> 的赋值，推断出 <code>s</code> 的类型是 <code>&amp;str</code>。这在 Kotlin 当中是不行的。</p><p>Rust 编译器通过上下文推断类型的能力在下面的例子当中用处更大。</p><p>我们先给出 Kotlin 版本的写法：</p><div class="language-Kotlin line-numbers-mode" data-ext="Kotlin"><pre class="language-Kotlin"><code>val multiply2 = { i: Int -&gt; i * 2 }
multiply2(10)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段 Kotlin 代码中，Lambda 表达式 <code>multiply2</code> 的参数 <code>i</code> 的类型必须显式地写出来，不然编译器就无法推断出 <code>multiply2</code> 的类型了。</p><p>但等价的代码在 Rust 当中是这样的：</p><div class="language-Rust line-numbers-mode" data-ext="Rust"><pre class="language-Rust"><code>let multiply2 = |i| i * 2;
multiply2(10);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>|i|</code> 是 Rust 的 Lambda 表达式（或者闭包）的参数列表，我们发现 <code>i</code> 的类型并不需要明确地写出来，编译器通过分析后面的实参 <code>10</code> 即可推断出 <code>i</code> 的类型为 <code>i32</code> 了。</p><p>这个例子还可以继续延伸。不管是 Kotlin 还是 Rust，<code>multiply2</code> 都是一个确定的类型，也就是说在上述代码之后追加一句 <code>multiply2(30.0)</code>，编译器就会抱怨说 <code>30.0</code> 是 <code>Double</code>（Kotlin）/ <code>f64</code>（Rust） 类型 ，而 <code>multiply2</code> 需要的是 <code>Int</code>（Kotlin）/<code>i32</code>（Rust）类型。不过，事情总有例外。</p><p>下面是使用 C++ 编写的等价代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> multiply2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">multiply2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">multiply2</span><span class="token punctuation">(</span><span class="token number">30.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>multiply2</code> 的参数 <code>i</code> 的类型是 <code>auto</code>，它自身的类型也是 <code>auto</code>，这意味着它们的类型需要编译器来推导。接下来我们分别把 <code>10</code> 和 <code>30.0</code> 传给 <code>multiply2</code>，然后我们就会发现，这都是合法的。这表明 <code>multiply2</code> 针对不同的类型会有不同的实现。对于 C++ 而言，<code>auto</code> 不仅仅是用于类型推导的关键字，很多时候我们把它当做模板的一种特殊形式来看待，似乎更容易理解。</p><p>说了这么多，那 Java 的类型推导是哪一种呢？</p><p>答案是：都不如。Java 从 Java 10 开始新增了 <code>var</code> 关键字来简化变量定义时的类型，仅此而已。</p><p>例如：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>var list = new ArrayList&lt;String&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的 <code>var</code> 相当于 <code>ArrayList&lt;String&gt;</code>。</p><p>那么，我们能不能用 <code>var</code> 来定义 Lambda 表达式呢？答案是，不能。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>var multiply2 = (int i) -&gt; i * 2;
^^^
---------------------------------------------------------------------
Error: Cannot infer type: lambda expression requires an explicit target type
---------------------------------------------------------------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们在 Java 中试图使用 <code>var</code> 来定义一个变量，并使用 Lambda 表达式来初始化，就会得到上面的错误。当然，这个错误并不是 <code>var</code> 的问题，而是 Java 对函数类型的支持问题。这个话题我们将在后面的文章中详细探讨，这里就不再展开说明了。</p><p>需要说明的是，Java 的 var 只能用于局部变量的定义，不能用于类成员的定义，这一点倒是与 C++ 的 auto 有一些相似了。</p><p>通过与其他编程语言的对比我们不难发现，Java 在类型推断上仍然处于萌芽状态，后面的路还很长。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>`,37),d=n("li",null,"GitHub：https://github.com/bennyhuo",-1),r=n("li",null,"博客：https://www.bennyhuo.com",-1),v={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},k=n("strong",null,"霍丙乾 bennyhuo",-1),m=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function b(g,h){const a=l("ExternalLinkIcon");return t(),o("div",null,[u,n("ul",null,[d,r,n("li",null,[s("bilibili："),n("a",v,[k,p(a)])]),m])])}const _=e(i,[["render",b],["__file","01-var.html.vue"]]);export{_ as default};
