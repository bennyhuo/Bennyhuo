import{_ as o,X as p,Y as c,Z as n,a0 as s,$ as t,a1 as e,D as i}from"./framework-98842e7a.js";const u={},l=e(`<h1 id="_9-一个简单的示例" tabindex="-1"><a class="header-anchor" href="#_9-一个简单的示例" aria-hidden="true">#</a> 9. 一个简单的示例</h1><blockquote><p>截止目前，我们一直专注于构建基于协程 API 的框架支持，这次我们用这些框架来写个简单的示例，并以此来结束整个系列的内容。</p></blockquote><h3 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h3><p>在本文当中，我将使用前文实现好的 <code>Task</code> 来发起一个简单的网络请求。</p><p>我会借助一些已有的框架来完成这次的目标：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cpp-httplib/0.10.4
openssl/3.0.2
nlohmann_json/3.10.5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),d={href:"https://www.bilibili.com/video/BV1wL411u74B/",target:"_blank",rel:"noopener noreferrer"},r=e(`<h3 id="示例实现" tabindex="-1"><a class="header-anchor" href="#示例实现" aria-hidden="true">#</a> 示例实现</h3><p>首先我们给出发起网络请求的核心代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 用协程包装网络请求，请求的处理调度到 std::async 上</span>
Task<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> AsyncExecutor<span class="token operator">&gt;</span> <span class="token function">http_get</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string host<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  httplib<span class="token double-colon punctuation">::</span>Client <span class="token function">cli</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 阻塞地发起网络请求</span>
  <span class="token keyword">auto</span> res <span class="token operator">=</span> cli<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 返回响应内容，类型为 std::string</span>
    <span class="token keyword">co_return</span> res<span class="token operator">-&gt;</span>body<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_return</span> httplib<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 httplib 来完成网络请求的处理非常简单直接，我们只需要把 url 传入即可。通常我们的网络请求都会在 io 线程当中发起，因此我们将其调度到 <code>AsyncExecutor</code> 上。</p><p>接下来，我们再定义一个协程来调用 <code>http_get</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Task<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">,</span> LooperExecutor<span class="token operator">&gt;</span> <span class="token function">test_http</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;send request...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Looper 线程上执行</span>

    <span class="token comment">// 发起网络请求，切换线程，当前协程挂起，Looper 线程被释放（此时 Looper 线程可以去调度其他任务）</span>
    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">http_get</span><span class="token punctuation">(</span><span class="token string">&quot;https://api.github.com&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/users/bennyhuo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 请求返回，当前协程接着在 Looper 线程上调度执行</span>
    <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;done.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 业务逻辑处理，解析 json</span>
    <span class="token keyword">auto</span> json <span class="token operator">=</span> nlohmann<span class="token double-colon punctuation">::</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 打印 json 内容</span>
    <span class="token function">debug</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 假装这是其他业务处理</span>
    <span class="token function">debug</span><span class="token punctuation">(</span>json<span class="token punctuation">[</span><span class="token string">&quot;login&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> json<span class="token punctuation">[</span><span class="token string">&quot;url&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">debug</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序运行结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>22:10:54.046 [Thread-08056] (main.cpp:27) test_http: send request...
22:10:54.953 [Thread-08056] (main.cpp:29) test_http: done.
22:10:54.953 [Thread-08056] (main.cpp:31) test_http: {
  &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6336960?v=4&quot;,
  &quot;bio&quot;: &quot;Google Developer Expert @Kotlin&quot;,
  &quot;blog&quot;: &quot;https://www.bennyhuo.com&quot;,
  ...  中间内容很多，省略掉 ...
  &quot;updated_at&quot;: &quot;2022-03-23T13:51:26Z&quot;,
  &quot;url&quot;: &quot;https://api.github.com/users/bennyhuo&quot;
}
22:10:54.953 [Thread-08056] (main.cpp:32) test_http: &quot;bennyhuo&quot;
22:10:54.954 [Thread-08056] (main.cpp:33) test_http: &quot;https://api.github.com/users/bennyhuo&quot;
22:10:54.954 [Thread-08056] (main.cpp:34) test_http: &quot;Google Developer Expert @Kotlin&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例当中，我们没有使用协程来解决阻塞的问题，而是将一个异步的请求封装成同步的代码。<code>test_http</code> 当中的代码全程在 Looper 线程当中执行，尽管中间穿插了一个异步网络请求，但这看上去丝毫没有影响程序的连贯性和简洁性。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文的内容相对轻松，因为我们终于停止了基于协程的基础 API 的探索。</p><p>实际上，如果你发现你用到的某些 API 提供了异步回调，你完全可以使用 <code>Awaiter</code> 对其提供 <code>co_await</code> 的支持。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p>`,14),k=n("li",null,"GitHub：https://github.com/bennyhuo",-1),v=n("li",null,"博客：https://www.bennyhuo.com",-1),b={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},m=n("strong",null,"霍丙乾 bennyhuo",-1),h=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function g(_,q){const a=i("ExternalLinkIcon");return p(),c("div",null,[l,n("p",null,[s("这些框架可以通过 "),n("a",d,[s("conan"),t(a)]),s(" 很轻松的完成安装。")]),r,n("ul",null,[k,v,n("li",null,[s("bilibili："),n("a",b,[m,t(a)])]),h])])}const x=o(u,[["render",g],["__file","09-http.html.vue"]]);export{x as default};
