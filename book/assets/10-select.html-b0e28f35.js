import{_ as e,X as t,Y as o,Z as n,a0 as s,$ as p,a1 as c,D as l}from"./framework-98842e7a.js";const i={},u=c(`<h1 id="_10-select-篇" tabindex="-1"><a class="header-anchor" href="#_10-select-篇" aria-hidden="true">#</a> 10. Select 篇</h1><blockquote><p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。</p></blockquote><h2 id="复用多个-await" tabindex="-1"><a class="header-anchor" href="#复用多个-await" aria-hidden="true">#</a> 复用多个 await</h2><p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">getUserFromApi</span><span class="token punctuation">(</span>login<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span><span class="token punctuation">{</span>
    gitHubServiceApi<span class="token punctuation">.</span><span class="token function">getUserSuspend</span><span class="token punctuation">(</span>login<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">getUserFromLocal</span><span class="token punctuation">(</span>login<span class="token operator">:</span>String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">File</span><span class="token punctuation">(</span>localDir<span class="token punctuation">,</span> login<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">readText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> User<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p><p>接下来我们用 <code>select</code> 来解决这个问题：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> localDeferred <span class="token operator">=</span> <span class="token function">getUserFromLocal</span><span class="token punctuation">(</span>login<span class="token punctuation">)</span>
    <span class="token keyword">val</span> remoteDeferred <span class="token operator">=</span> <span class="token function">getUserFromApi</span><span class="token punctuation">(</span>login<span class="token punctuation">)</span>

    <span class="token keyword">val</span> userResponse <span class="token operator">=</span> select<span class="token operator">&lt;</span>Response<span class="token operator">&lt;</span>User<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        localDeferred<span class="token punctuation">.</span><span class="token function">onAwait</span> <span class="token punctuation">{</span> <span class="token function">Response</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        remoteDeferred<span class="token punctuation">.</span><span class="token function">onAwait</span> <span class="token punctuation">{</span> <span class="token function">Response</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p><p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    userResponse<span class="token punctuation">.</span>value<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    userResponse<span class="token punctuation">.</span>isLocal<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span> it <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> userFromApi <span class="token operator">=</span> remoteDeferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">cacheUser</span><span class="token punctuation">(</span>login<span class="token punctuation">,</span> userFromApi<span class="token punctuation">)</span>
        <span class="token function">log</span><span class="token punctuation">(</span>userFromApi<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复用多个-channel" tabindex="-1"><a class="header-anchor" href="#复用多个-channel" aria-hidden="true">#</a> 复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> channels <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

select<span class="token operator">&lt;</span>Int<span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    channels<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> channel <span class="token operator">-&gt;</span>
        channel<span class="token punctuation">.</span><span class="token function">onReceive</span> <span class="token punctuation">{</span> it <span class="token punctuation">}</span>
        <span class="token comment">// OR</span>
        channel<span class="token punctuation">.</span><span class="token function">onReceiveOrNull</span> <span class="token punctuation">{</span> it <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p><h2 id="selectclause" tabindex="-1"><a class="header-anchor" href="#selectclause" aria-hidden="true">#</a> SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p><ul><li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>select<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    job<span class="token punctuation">.</span><span class="token function">onJoin</span> <span class="token punctuation">{</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Join resumed!&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p></li><li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> element <span class="token operator">-&gt;</span>
    select<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        channels<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> channel <span class="token operator">-&gt;</span>
            channel<span class="token punctuation">.</span><span class="token function">onSend</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span> sentChannel <span class="token operator">-&gt;</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;sent on </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">sentChannel</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p></li></ul><p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p><p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；前腾讯高级工程师，现就职于猿辅导</p>`,24),d=n("li",null,"GitHub：https://github.com/bennyhuo",-1),r=n("li",null,"博客：https://www.bennyhuo.com",-1),k={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},v=n("strong",null,"霍丙乾 bennyhuo",-1),m=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function h(b,g){const a=l("ExternalLinkIcon");return t(),o("div",null,[u,n("ul",null,[d,r,n("li",null,[s("bilibili："),n("a",k,[v,p(a)])]),m])])}const _=e(i,[["render",h],["__file","10-select.html.vue"]]);export{_ as default};
