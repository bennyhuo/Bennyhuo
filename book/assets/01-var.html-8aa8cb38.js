import{_ as p,X as t,Y as c,Z as a,a0 as s,$ as e,a1 as o,D as l}from"./framework-98842e7a.js";const r={},i=o(`<h1 id="_1-java-也支持类型推断了" tabindex="-1"><a class="header-anchor" href="#_1-java-也支持类型推断了" aria-hidden="true">#</a> 1. Java 也支持类型推断了？</h1><p>类型推断是现代编程语言必备的能力，我们现在很少能够看到不支持类型推断的主流编程语言了。当然，C 语言是个例外。</p><p>类型推断就是编译器根据上下文信息对类型进行推算的能力。类型推断是一个极其复杂的话题，从工程应用的角度而言，我们不用过多关注其背后的数学原理。为了方便讨论，我们将类型的推断分为变量类型推断和泛型类型推断。</p><h2 id="变量类型推断" tabindex="-1"><a class="header-anchor" href="#变量类型推断" aria-hidden="true">#</a> 变量类型推断</h2><p>变量的类型推断就是在变量声明时省略类型，编译器通过变量的初始化来推断其类型。</p><h3 id="c-的-auto" tabindex="-1"><a class="header-anchor" href="#c-的-auto" aria-hidden="true">#</a> C++ 的 auto</h3><p>变量类型推断最典型的例子莫过于 C++ 当中的这个场景了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> values<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator i <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，for 循环中的 i 的类型非常长，写起来繁琐之外，还很难写对这一度让 C++ 的开发者极度难受。不过，从 C++ 11 开始，类型推断的引入让事情变得简单了起来：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>i 的类型使用 <code>auto</code> 关键字替代，这样编译器就会根据 i 的初始化表达式 <code>values.begin()</code> 的类型推断出来。</p><h3 id="java-的-var" tabindex="-1"><a class="header-anchor" href="#java-的-var" aria-hidden="true">#</a> Java 的 var</h3><p>Java 从 Java 10 开始新增了 <code>var</code> 关键字来简化变量定义时的类型。</p><p>例如：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>var list = new ArrayList&lt;String&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的 <code>var</code> 相当于 <code>ArrayList&lt;String&gt;</code>。</p><p><code>var</code> 只能用于局部变量的定义，不能用于类成员的定义，这一点与 C++ 的 <code>auto</code> 非常相似。</p>`,17),d=a("strong",null,"说明",-1),u=a("code",null,"var",-1),k={href:"https://projectlombok.org/",target:"_blank",rel:"noopener noreferrer"},v=a("code",null,"var",-1),m={href:"https://projectlombok.org/features/var",target:"_blank",rel:"noopener noreferrer"},g=o(`<h3 id="类型后置" tabindex="-1"><a class="header-anchor" href="#类型后置" aria-hidden="true">#</a> 类型后置</h3><p>C++ 和 Java 的变量声明中类型都在变量名前面，通常又被称为类型前置的形式。这类语言的特点是在语言诞生之初并没有类型推断的语法设计。</p><p>随着开发者对类型推断的需求的日益增长，业界编程语言设计的优秀实践的不断积累，越来越多的新语言选择了类型后置的形式。</p><p>下面是 Kotlin 的变量定义语法，类型后置的形式使得类型推断变得非常自然：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 完整的变量定义</span>
<span class="token keyword">val</span> s<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello World&quot;</span></span>

<span class="token comment">// 省略类型</span>
<span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello World&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量 <code>s</code> 的类型可以通过初始化的表达式推断出来，因此可以省略。常见的采用类型后置的语法设计的语言还包括 Scala、Swift、TypeScript、Rust 等等。</p><h3 id="全局类型推断" tabindex="-1"><a class="header-anchor" href="#全局类型推断" aria-hidden="true">#</a> 全局类型推断</h3><p>绝大多数编程语言在对变量的类型进行推断时，都只对变量定义时的初始化表达式做了分析，Rust 就是个例外。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> s<span class="token punctuation">;</span>
    
s <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Rust 允许先把变量定义出来，在后面根据对该变量的使用情况进行变量类型的推断。示例代码中变量 <code>s</code> 在定义时并没有声明类型，也没有进行初始化，Rust 编译器通过分析后面对 <code>s</code> 的赋值，推断出 <code>s</code> 的类型是 <code>&amp;str</code>。这在 Kotlin 当中是不行的。</p><p>Rust 编译器通过上下文推断类型的能力在下面的例子当中用处更大。</p><p>作为对比，我们先给出 Kotlin 版本的写法：</p><div class="language-Kotlin line-numbers-mode" data-ext="Kotlin"><pre class="language-Kotlin"><code>val multiply2 = { i: Int -&gt; i * 2 }
multiply2(10)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段 Kotlin 代码中，Lambda 表达式 <code>multiply2</code> 的参数 <code>i</code> 的类型必须显式地写出来，不然编译器就无法推断出 <code>multiply2</code> 的类型了。</p><p>接下来我们看一下等价的 Rust 代码：</p><div class="language-Rust line-numbers-mode" data-ext="Rust"><pre class="language-Rust"><code>let multiply2 = |i| i * 2;
multiply2(10);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>|i|</code> 是 Rust 的 Lambda 表达式（或者闭包）的参数列表，我们发现 <code>i</code> 的类型并不需要明确地写出来，编译器通过分析后面的实参 <code>10</code> 即可推断出 <code>i</code> 的类型为 <code>i32</code> 了。</p><h3 id="模板化的类型推断" tabindex="-1"><a class="header-anchor" href="#模板化的类型推断" aria-hidden="true">#</a> 模板化的类型推断</h3><p><code>multiply2</code> 的例子还可以继续延伸。不管是 Kotlin 还是 Rust，<code>multiply2</code> 都是一个确定的类型，也就是说在上述代码之后追加一句 <code>multiply2(30.0)</code>，编译器就会抱怨说 <code>30.0</code> 是 <code>Double</code>（Kotlin）/ <code>f64</code>（Rust） 类型 ，而 <code>multiply2</code> 需要的是 <code>Int</code>（Kotlin）/<code>i32</code>（Rust）类型。不过，事情总有例外。</p><p>下面是使用 C++ 编写的等价代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> multiply2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">multiply2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">multiply2</span><span class="token punctuation">(</span><span class="token number">30.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>multiply2</code> 的参数 <code>i</code> 的类型是 <code>auto</code>，它自身的类型也是 <code>auto</code>，这意味着它们的类型需要编译器来推断。接下来我们分别把 <code>10</code> 和 <code>30.0</code> 传给 <code>multiply2</code>，然后我们就会发现，这都是合法的。这表明 <code>multiply2</code> 针对不同的类型会有不同的实现。对于 C++ 而言，<code>auto</code> 不仅仅是用于类型推断的关键字，很多时候我们把它当做模板的一种特殊形式来看待，似乎更容易理解。</p><h3 id="java-中的-lambda-表达式的类型推断" tabindex="-1"><a class="header-anchor" href="#java-中的-lambda-表达式的类型推断" aria-hidden="true">#</a> Java 中的 Lambda 表达式的类型推断</h3><p>既然提到了 Lambda 表达式的类型推断，那么我们能不能用 <code>var</code> 来定义 Lambda 表达式呢？答案当然是，不能。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>var multiply2 = (int i) -&gt; i * 2;
^^^
---------------------------------------------------------------------
Error: Cannot infer type: lambda expression requires an explicit target type
---------------------------------------------------------------------
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们在 Java 中试图使用 <code>var</code> 来定义一个变量，并使用 Lambda 表达式来初始化，就会得到上面的错误。不过，这个错误并不是 <code>var</code> 的问题，而是 Java 对函数类型的支持问题。这个话题我们将在后面的文章中详细探讨，这里就不再展开说明了。</p><h3 id="分支表达式的类型推断" tabindex="-1"><a class="header-anchor" href="#分支表达式的类型推断" aria-hidden="true">#</a> 分支表达式的类型推断</h3><p>分支表达式在现代编程语言中非常常见。C 语言甚至就已经有了分支表达式：</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>int a = ...;
int b = ...;
int c = a &gt; b ? a : b;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没错，<code>?:</code> 可能是最古老的分支表达式之一。</p><p>Java 当中除了 <code>?:</code> 表达式以外，还从 Java 12 开始支持了 Switch 表达式（Java 14 正式支持） ，因此 Java 中的表达式类型推断也是值得探讨的内容。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>var x = &quot;...&quot;;
var y = switch (x) {
    case &quot;A&quot; -&gt; 1;
    case &quot;B&quot; -&gt; 2.0;
    case &quot;C&quot; -&gt; &quot;Hello&quot;;
    default -&gt; new ArrayList&lt;String&gt;();
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个 switch 表达式中，四个分支表达式的值类型分别为 <code>int</code>(<code>Integer</code>)、<code>double</code>(<code>Double</code>)、<code>String</code>、<code>ArrayList&lt;String&gt;</code>。这意味着整体表达式的返回值 <code>y</code> 的类型只能是其中的一个，从数学的角度来讲，<code>y</code> 的类型为这四种类型的交集，Java 的类型系统中也确实存在交集类型的概念，即：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> <span class="token operator">&amp;</span> <span class="token class-name">Double</span> <span class="token operator">&amp;</span> <span class="token class-name">String</span> <span class="token operator">&amp;</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>交集类型的计算结果其实就是这些类型的公共父类，因此 <code>y</code> 在编译时的类型为 <code>Serializable</code>。</p><p>如果没有公共父类呢？这在 Java 当中是不可能的，因为所有的类型都至少有一个公共父类是 <code>Object</code>。</p><p>顺便提一句，Kotlin 的推断方法也是类似的。作为对比，我们给出 Rust 的代码：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">match</span> x <span class="token punctuation">{</span>
    <span class="token string">&quot;A&quot;</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">&quot;B&quot;</span> <span class="token operator">=&gt;</span> <span class="token number">2.0</span><span class="token punctuation">,</span>
           <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span>
           <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
           \`<span class="token keyword">match</span>\` arms have incompatible types <span class="token punctuation">[</span><span class="token constant">E0308</span><span class="token punctuation">]</span>
           expected integer<span class="token punctuation">,</span> found floating<span class="token operator">-</span>point number
           <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
    <span class="token string">&quot;C&quot;</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Rust 编译器在遇到各个分支的类型不兼容的情况时，会直接报错。实际上，C++ 的行为也是类似的。</p><p>为什么会有这样的差别呢？</p><p>我稍微做一下猜测，供大家参考。Java 和 Kotlin 的对象都是分配在堆内存上的，栈内存上只需保留一个引用，而这个引用的类型不管是什么，占用的内存大小都是固定的，因此在做分支表达式的类型推断时可以尽可能向开发者友好的方向设计。而 C++ 和 Rust 的编译器需要在编译时确定 <code>y</code> 的类型，以便于给他在栈内存上分配内存，因此遇到不兼容的类型时就只好拒绝编译了。</p><h2 id="泛型类型推断" tabindex="-1"><a class="header-anchor" href="#泛型类型推断" aria-hidden="true">#</a> 泛型类型推断</h2><p>除了对变量的类型进行推断以外，还有对泛型类型的推断。</p><h3 id="变量初始化表达式的泛型类型参数推断" tabindex="-1"><a class="header-anchor" href="#变量初始化表达式的泛型类型参数推断" aria-hidden="true">#</a> 变量初始化表达式的泛型类型参数推断</h3><p>我们还是以 <code>ArrayList</code> 为例，在 Java 7 之前的版本，我们需要完整的将类型写出来：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从 Java 7 开始，编译器稍微为我们做一点简化，允许我们把初始化表达式中的泛型参数省略掉了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>理由也很简单，变量的类型已经明确，后面的泛型参数 <code>String</code> 显然是冗余的。</p><p>不得不说，这一点 Java 做得比 C# 似乎更好一些，在 C# 中定义一个类似的 <code>List</code> 时必须完整的写出泛型参数。如果省略泛型参数，那么编译器就会报告如下错误：</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">List<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token operator">^</span><span class="token operator">^</span>
                            <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
                            Type argument <span class="token keyword">is</span> <span class="token class-name">missing</span>
                            <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，C# 的设计者可能觉得这里使用 <code>var</code> 会更好（就像 Java 10 之后那样）。</p><h3 id="方法泛型类型参数的推断" tabindex="-1"><a class="header-anchor" href="#方法泛型类型参数的推断" aria-hidden="true">#</a> 方法泛型类型参数的推断</h3><p>定义在方法中的泛型参数也支持类型推断，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>identity</code> 在调用时，泛型参数 <code>T</code> 可以通过函数参数 <code>t</code> 推断出来，因此无须显式写出：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个特性还有一个更为常见的使用场景：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token class-name">String</span> json<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> cls<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到 <code>Class</code> 的泛型参数是 <code>fromJson</code> 的泛型参数 <code>T</code>，因此可以通过 <code>cls</code> 的实参类型来推断 <code>T</code> 的类型。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你可能会想，竟然有了泛型参数 <code>T</code>，我们是不是可以直接使用 <code>T.class</code> 而不用向 <code>fromJson</code> 中传入 <code>Class&lt;T&gt;</code> 了呢？当然不能，这是因为 Java 的泛型会在编译时擦除，也就是说 <code>T</code> 在运行时并不存在。</p><p>像绝大多数编程语言一样，Java 也可以通过方法的返回值类型来推断泛型参数，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用处</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用时，如果返回值类型已经明确，则无须显式指定泛型参数。不过，C# 却不支持通过返回值类型来推断泛型参数，例如：</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">static</span> T <span class="token generic-method"><span class="token function">get</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用处</span>
<span class="token class-name"><span class="token keyword">string</span></span> name <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span>
              <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
              The type arguments <span class="token keyword">for</span> method &#39;T <span class="token generic-method"><span class="token function">get</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span>&#39; 
              cannot be inferred <span class="token keyword">from</span> the usage<span class="token punctuation">.</span> 
              Try specifying the type arguments explicitly<span class="token punctuation">.</span>
              <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文从变量类型和泛型参数类型的推断两方面对 Java 的相关特性进行了介绍。为了方便读者对类型推断有更全面的认识，我们也列举了其他编程语言的相关特性作为参照。</p><p>综合来看，Java 在类型推断方面做得中规中矩，虽然没有像常见的现代编程语言那样能够做到极致，但也能够应对绝大多数的场景了。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p>`,71),b=a("li",null,"GitHub：https://github.com/bennyhuo",-1),h=a("li",null,"博客：https://www.bennyhuo.com",-1),y={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},f=a("strong",null,"霍丙乾 bennyhuo",-1),x=a("li",null,[s("微信公众号："),a("strong",null,"霍丙乾 bennyhuo")],-1);function w(_,J){const n=l("ExternalLinkIcon");return t(),c("div",null,[i,a("blockquote",null,[a("p",null,[d,s(" 在 Java 正式支持 "),u,s(" 关键字之前，著名的元编程框架 "),a("a",k,[s("Lombok"),e(n)]),s(" 就通过编译时修改 Java 语法树为 Java 添加了 "),v,s(" 关键字的支持，有兴趣的读者可以参考 Lombok 的官方文档："),a("a",m,[s("https://projectlombok.org/features/var"),e(n)]),s("。")])]),g,a("ul",null,[b,h,a("li",null,[s("bilibili："),a("a",y,[f,e(n)])]),x])])}const j=p(r,[["render",w],["__file","01-var.html.vue"]]);export{j as default};
