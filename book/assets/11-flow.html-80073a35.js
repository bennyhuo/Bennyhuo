import{_ as p,X as o,Y as c,Z as n,a0 as s,$ as t,a1 as e,D as l}from"./framework-98842e7a.js";const i={},u=e(`<h1 id="_11-flow-篇" tabindex="-1"><a class="header-anchor" href="#_11-flow-篇" aria-hidden="true">#</a> 11. Flow 篇</h1><blockquote><p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p></blockquote><p>随着 RxJava 的流行，响应式编程模型逐步深入人心。<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物。</p><p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p><h2 id="认识-flow" tabindex="-1"><a class="header-anchor" href="#认识-flow" aria-hidden="true">#</a> 认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p><p><strong>代码清单1： 序列生成器</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> ints <span class="token operator">=</span> sequence <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">yield</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p><p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> ints <span class="token operator">=</span> sequence <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">yield</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// ERROR!</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p><p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p><p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p><p><strong>代码清单3：创建 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> intFlow <span class="token operator">=</span> flow <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> 
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p><p>Flow 也可以设定它运行时所使用的调度器：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>intFlow<span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p><p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p><p><strong>代码清单4： 消费 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>myDispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  intFlow<span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">1</span>
<span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">2</span>
<span class="token punctuation">[</span>MyThread<span class="token punctuation">]</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对比-rxjava-的线程切换" tabindex="-1"><a class="header-anchor" href="#对比-rxjava-的线程切换" aria-hidden="true">#</a> 对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p><p><strong>代码清单5：RxJava 的调度器切换</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Observable<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> e <span class="token operator">-&gt;</span>
    it<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  it<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>myExecutor<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">subscribe</span> <span class="token punctuation">{</span>
  <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p><p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p><p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p><h2 id="冷数据流" tabindex="-1"><a class="header-anchor" href="#冷数据流" aria-hidden="true">#</a> 冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p><p><strong>代码清单6：Flow 可以被重复消费</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p><p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p><p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p><blockquote><p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p></blockquote><h2 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p><p><strong>代码清单7：捕获 Flow 的异常</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p><p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p><p><strong>代码清单8：订阅流的完成</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onCompletion</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable<span class="token operator">?</span> <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;finally.&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p><p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p><p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span> 
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>t<span class="token operator">:</span> Throwable<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;finally.&quot;</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p><p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p><p><strong>代码清单10：RxJava 从异常中恢复</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> observable <span class="token operator">=</span> Observable<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onErrorReturn</span> <span class="token punctuation">{</span>
  <span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
  <span class="token number">10</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>捕获异常后，返回 10 作为下一个值。</p><p>我们在 Flow 当中也可以模拟这样的操作：</p><p><strong>代码清单11：Flow 从异常中恢复</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">throw</span> <span class="token function">ArithmeticException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Div 0&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{</span> t<span class="token operator">:</span> Throwable <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;caught error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">t</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p>`,61),d=n("strong",null,"说明",-1),r={href:"https://github.com/Kotlin/kotlinx.coroutines/pull/1732",target:"_blank",rel:"noopener noreferrer"},k=e(`<h2 id="末端操作符" tabindex="-1"><a class="header-anchor" href="#末端操作符" aria-hidden="true">#</a> 末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p><ol><li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li><li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li></ol><p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p><h2 id="分离-flow-的消费和触发" tabindex="-1"><a class="header-anchor" href="#分离-flow-的消费和触发" aria-hidden="true">#</a> 分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p><p><strong>代码清单12：分离 Flow 的消费和触发</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> flow<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
      <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p><p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">createFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">launchIn</span><span class="token punctuation">(</span>GlobalScope<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p><h2 id="flow-的取消" tabindex="-1"><a class="header-anchor" href="#flow-的取消" aria-hidden="true">#</a> Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p><p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p><p><strong>代码清单14：Flow 的取消</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> job <span class="token operator">=</span> GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
  <span class="token keyword">val</span> intFlow <span class="token operator">=</span> flow <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
      <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  intFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2500</span><span class="token punctuation">)</span>
job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token number">1</span>
▶ 1000ms later
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p><h2 id="其他-flow-的创建方式" tabindex="-1"><a class="header-anchor" href="#其他-flow-的创建方式" aria-hidden="true">#</a> 其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow { ... }</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p><p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span> <span class="token comment">// BAD!!</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>channelFlow <span class="token punctuation">{</span>
  <span class="token function">send</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，我们也可以通过集合框架来创建 Flow：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="flow-的背压" tabindex="-1"><a class="header-anchor" href="#flow-的背压" aria-hidden="true">#</a> Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p><p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p><p><strong>代码清单16：为 Flow 添加缓冲</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p><p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p><p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p><p><strong>代码清单17：使用 conflate 解决背压问题</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">conflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> value <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Collecting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> 
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string"> collected&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Collecting <span class="token number">1</span>
<span class="token number">1</span> collected
Collecting <span class="token number">99</span>
<span class="token number">99</span> collected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><p>还是前面的例子，我们稍作修改：</p><p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collectLatest</span> <span class="token punctuation">{</span> value <span class="token operator">-&gt;</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Collecting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string"> collected&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Collecting 0
Collecting 1
...
Collecting 97
Collecting 98
Collecting 99
▶ 100ms later
99 collected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p><p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p><h2 id="flow-的变换" tabindex="-1"><a class="header-anchor" href="#flow-的变换" aria-hidden="true">#</a> Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p><p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p><p><strong>代码清单19：Flow 的元素变换</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> 
  it <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以映射成其他 Flow：</p><p><strong>代码清单20：Flow 的嵌套</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
  flow <span class="token punctuation">{</span> <span class="token function">List</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p><p><strong>代码清单21：拼接 Flow</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>flow <span class="token punctuation">{</span>
  <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
  flow <span class="token punctuation">{</span> <span class="token function">List</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">flattenConcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p><h2 id="使用-flow-实现多路复用" tabindex="-1"><a class="header-anchor" href="#使用-flow-实现多路复用" aria-hidden="true">#</a> 使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p>`,62),v={href:"https://www.bennyhuo.com/2020/02/03/coroutine-select/",target:"_blank",rel:"noopener noreferrer"},m=e(`<p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>coroutineScope <span class="token punctuation">{</span>
  <span class="token keyword">val</span> login <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;...&quot;</span></span>
  <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token operator">::</span>getUserFromApi<span class="token punctuation">,</span> <span class="token operator">::</span>getUserFromLocal<span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ①
    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> function <span class="token operator">-&gt;</span>
      function<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>login<span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ②
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> deferred <span class="token operator">-&gt;</span>
      flow <span class="token punctuation">{</span> <span class="token function">emit</span><span class="token punctuation">(</span>deferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">..</span><span class="token punctuation">.</span> ③
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">..</span><span class="token punctuation">.</span> ④
    <span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{</span> user <span class="token operator">-&gt;</span>
      <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">user</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">launchIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png" alt=""></p><p><strong>图1：使用 merge 合并 Flow</strong></p>`,5),b={href:"https://www.bennyhuo.com/2020/02/03/coroutine-select/",target:"_blank",rel:"noopener noreferrer"},g=e(`<p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> channels <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> channels<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span>
    it<span class="token punctuation">.</span><span class="token function">consumeAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p>`,7),f=n("li",null,"GitHub：https://github.com/bennyhuo",-1),h=n("li",null,"博客：https://www.bennyhuo.com",-1),w={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},F=n("strong",null,"霍丙乾 bennyhuo",-1),x=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function y(_,q){const a=l("ExternalLinkIcon");return o(),c("div",null,[u,n("blockquote",null,[n("p",null,[d,s(" onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue："),n("a",r,[s("Breaking change: Experimental Flow.onCompletion contract for cause #1732"),t(a)]),s("。")])]),k,n("p",null,[s("上一篇文章"),n("a",v,[s("破解 Kotlin 协程(10) - Select 篇"),t(a)]),s("中对 await 的复用我们可以用 Flow 实现如下：")]),m,n("p",null,[s("同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照"),n("a",b,[s("破解 Kotlin 协程(10) - Select 篇"),t(a)]),s("，我们给出 Flow 的实现版本：")]),g,n("ul",null,[f,h,n("li",null,[s("bilibili："),n("a",w,[F,t(a)])]),x])])}const O=p(i,[["render",y],["__file","11-flow.html.vue"]]);export{O as default};
