import{_ as o,X as c,Y as l,$ as a,Z as n,a0 as s,a1 as i,D as e}from"./framework-98842e7a.js";const u={},d=n("h1",{id:"_1-c-协程概览",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-c-协程概览","aria-hidden":"true"},"#"),s(" 1. C++ 协程概览")],-1),r=n("blockquote",null,[n("p",null,"C++ 20 当中正式对协程做出了初步的支持，尽管这些 API 并不是很友好。")],-1),k=i(`<h2 id="什么是协程" tabindex="-1"><a class="header-anchor" href="#什么是协程" aria-hidden="true">#</a> 什么是协程</h2><p>协程就是一段可以<strong>挂起（suspend）<strong>和</strong>恢复（resume）<strong>的程序，一般而言，就是一个支持</strong>挂起</strong>和<strong>恢复</strong>的函数。</p><p>这么说比较抽象，我们下面看一个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Fun 是一个非常普通的函数，大家对它的直观印象是什么呢？</p><ul><li>它有四行代码</li><li>这四行代码一行一行依次执行</li><li>这四行代码连续执行</li></ul><p>作为一个合格的程序员，我们的眼睛就是编译器，我们的脑子就是运行时。相信大家在看完这个函数的定义之后脑子里面已经不自主的把它运行过了：这个函数一旦开始，就无法暂停。</p><p>如果一个函数能够暂停，那它就可以被认为是我们开头提到的协程。所以<strong>挂起</strong>你就可以理解成暂停，<strong>恢复</strong>你就理解成从暂停的地方继续执行。</p><p>下面我们给出一段 C++ 协程的不完整的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Result 的定义我们后面再谈论，大家只需要知道 Result 是按照协程的规则定义的类型，在 C++ 当中，一个函数的返回值类型如果是符合协程的规则的类型，那么这个函数就是一个协程。</p><p>请大家留意一下这个函数体当中的 <code>co_await std::suspend_always{};</code>，其中 <code>co_await</code> 是个关键字，它的出现，通常来说就会使得当前函数（协程）的执行被挂起。也就是说我们在控制台看到输出 1 以后，很可能过了很久才看到 2，这个“很久”也一般不是因为当前执行的线程被阻塞了，而是当前函数（协程）执行的位置被存起来，在将来某个时间点又读取出来继续执行的。</p><h2 id="协程的状态" tabindex="-1"><a class="header-anchor" href="#协程的状态" aria-hidden="true">#</a> 协程的状态</h2><p>很多读者在初次接触到协程这个概念的时候，总是会想得太过于复杂，以至于觉得<strong>挂起</strong>和<strong>恢复</strong>充满了神秘色彩而无法理解。这确实大可不必，你只要能理解听歌的时候可以暂停继续，能理解下载的时候可以断点续传，那你就必然可以理解协程的<strong>挂起</strong>和<strong>恢复</strong>。</p><p>那么问题来了，在我们现有的语言特性框架下，如何实现所谓的<strong>挂起</strong>和<strong>恢复</strong>呢？</p><p>我们以音频文件的播放为例，我们将其与协程的执行做对比，例如整个音频文件对比协程的函数体（即<strong>协程体</strong>），完整的对比见下表：</p><table><thead><tr><th>音频</th><th>协程</th></tr></thead><tbody><tr><td>音频文件</td><td>协程体</td></tr><tr><td>音频播放</td><td>协程执行</td></tr><tr><td>播放暂停</td><td>执行挂起</td></tr><tr><td>播放恢复</td><td>执行恢复</td></tr><tr><td>播放异常</td><td>执行异常</td></tr><tr><td>播放完成</td><td>协程返回</td></tr></tbody></table><p>音频暂停的时候需要记录音频暂停的位置，同时之前正在播放的音频也不会销毁（即便销毁重建，也要能够完全恢复原样）。</p><p>类似地，协程挂起时，我们需要记录函数执行的位置，C++ 协程会在开始执行时的第一步就使用 <code>operator new</code> 来开辟一块内存来存放这些信息，这块内存或者说这个对象又被称为<strong>协程的状态（coroutine state）</strong>。</p><p>协程的状态不仅会被用于存放挂起时的位置（后称为<strong>挂起点</strong>），也会在协程开始执行时存入协程体的参数值。例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token keyword">int</span> start_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> start_value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> start_value <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>start_value</code> 就会被存入协程的状态当中。</p><p>需要注意的是，如果参数是值类型，他们的值或被移动或被复制（取决于类型自身的复制构造和移动构造的定义）到协程的状态当中；如果是引用、指针类型，那么存入协程的状态的值将会是引用或指针本身，而不是其指向的对象，这时候需要开发者自行保证协程在挂起后续恢复执行时参数引用或者指针指向的对象仍然存活。</p><p>与创建相对应，在协程执行完成或者被外部主动销毁之后，协程的状态也随之被销毁释放。</p><p>看到这里，大家也不必紧张，协程的状态的创建和销毁都是编译器帮我们处理好的，不需要我们显式的处理。</p><h2 id="协程的挂起" tabindex="-1"><a class="header-anchor" href="#协程的挂起" aria-hidden="true">#</a> 协程的挂起</h2><p>协程的挂起是协程的灵魂。C++ 通过 <code>co_await</code> 表达式来处理协程的挂起，表达式的操作对象则为<strong>等待体（awaiter）</strong>。</p><p>等待体需要实现三个函数，这三个函数在挂起和恢复时分别调用。</p><h3 id="await-ready" tabindex="-1"><a class="header-anchor" href="#await-ready" aria-hidden="true">#</a> await_ready</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>await_ready 返回 bool 类型，如果返回 true，则表示已经就绪，无需挂起；否则表示需要挂起。</p><p>标准库当中提供了两个非常简单直接的等待体，<code>struct suspend_always</code> 表示总是挂起，<code>struct suspend_never</code> 表示总是不挂起。不难想到，这二者的功能主要就是依赖 await_ready 函数的返回值：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">suspend_never</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 true，总是不挂起</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">suspend_always</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 返回 false，总是挂起</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="await-suspend" tabindex="-1"><a class="header-anchor" href="#await-suspend" aria-hidden="true">#</a> await_suspend</h3><p>await_ready 返回 false 时，协程就挂起了。这时候协程的局部变量和挂起点都会被存入协程的状态当中，await_suspend 被调用到。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> coroutine_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数 coroutine_handle 用来表示当前协程，我们可以在稍后合适的时机通过调用 resume 来恢复执行当前协程：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>coroutine_handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意到 await_suspend 函数的返回值类型我们没有明确给出，因为它有以下几种选项：</p><ul><li>返回 void 类型或者返回 true，表示当前协程挂起之后将执行权还给当初调用或者恢复当前协程的函数。</li><li>返回 false，则恢复执行当前协程。注意此时不同于 await_ready 返回 true 的情形，此时协程已经挂起，await_suspend 返回 false 相当于挂起又立即恢复。</li><li>返回其他协程的 coroutine_handle 对象，这时候返回的 coroutine_handle 对应的协程被恢复执行。</li><li>抛出异常，此时当前协程恢复执行，并在当前协程当中抛出异常。</li></ul><p>可见，await_suspend 支持的情况非常多，也相对复杂。实际上这也是 C++ 协程当中最为核心的函数之一了。</p><h3 id="await-resume" tabindex="-1"><a class="header-anchor" href="#await-resume" aria-hidden="true">#</a> await_resume</h3><p>协程恢复执行之后，等待体的 await_resume 函数被调用。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同样地，await_resume 的返回值类型也是不限定的，返回值将作为 <code>co_await</code> 表达式的返回值。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h3><p>了解了以上内容以后，我们可以自己定义一个非常简单的等待体：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Awaiter</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>

  <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 协程挂起</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> coroutine_handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 切换线程</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono_literals<span class="token punctuation">;</span>
      <span class="token comment">// sleep 1s</span>
      std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token comment">// 恢复协程</span>
      coroutine_handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// value 将作为 co_await 表达式的值</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">co_await</span> Awaiter<span class="token punctuation">{</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 1 秒之后再执行</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序运行结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1
1000
2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 &quot;1000&quot; 在 &quot;1&quot; 输出 1 秒之后输出。</p><blockquote><p><strong>说明</strong>：co_await 后面的对象也可以不是等待体，这类情况需要定义其他的函数和运算符来转换成等待体。这个我们后面再讨论。</p></blockquote><h2 id="协程的返回值类型" tabindex="-1"><a class="header-anchor" href="#协程的返回值类型" aria-hidden="true">#</a> 协程的返回值类型</h2><p>我们前面提到，区别一个函数是不是协程，是通过它的返回值类型来判断的。如果它的返回值类型满足协程的规则，那这个函数就会<strong>被编译成</strong>协程。</p><p>那么，这个<strong>协程的规则</strong>是什么呢？规则就是返回值类型能够实例化下面的模板类型 <code>_Coroutine_traits</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ret</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">_Coroutine_traits</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ret</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">_Coroutine_traits</span><span class="token operator">&lt;</span>_Ret<span class="token punctuation">,</span> void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Ret</span><span class="token double-colon punctuation">::</span>promise_type<span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> promise_type <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">_Ret</span><span class="token double-colon punctuation">::</span>promise_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ret</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">coroutine_traits</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">_Coroutine_traits</span><span class="token operator">&lt;</span><span class="token class-name">_Ret</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是返回值类型 <code>_Ret</code> 能够找到一个类型 <code>_Ret::promise_type</code> 与之相匹配。这个 <code>promise_type</code> 既可以是直接定义在 <code>_Ret</code> 当中的类型，也可以通过 <code>using</code> 指向已经存在的其他外部类型。</p><p>此时，我们就可以给出 <code>Result</code> 的部分实现了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="协程返回值对象的构建" tabindex="-1"><a class="header-anchor" href="#协程返回值对象的构建" aria-hidden="true">#</a> 协程返回值对象的构建</h2><p>我们再看一下协程的示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token keyword">int</span> start_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> start_value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> start_value <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时你已经了解 C++ 当中如何界定一个协程。不过你可能会产生一个新的问题，返回值是从哪儿来的？协程体当中并没有给出 Result 对象创建的代码。</p><p>实际上，Result 对象的创建是由 promise_type 负责的，我们需要定义一个 <code>get_return_object</code> 函数来处理对 Result 对象的创建：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>

    Result <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 创建 Result 对象</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不同于一般的函数，协程的返回值并不是在返回之前才创建，而是在协程的状态创建出来之后马上就创建的。也就是说，协程的状态被创建出来之后，会立即构造 <code>promise_type</code> 对象，进而调用 <code>get_return_object</code> 来创建返回值对象。</p><p><code>promise_type</code> 类型的构造函数参数列表如果与协程的参数列表一致，那么构造 <code>promise_type</code> 时就会调用这个构造函数。否则，就通过默认无参构造函数来构造 <code>promise_type</code>。</p><h2 id="协程体的执行" tabindex="-1"><a class="header-anchor" href="#协程体的执行" aria-hidden="true">#</a> 协程体的执行</h2><p>在协程的返回值被创建之后，协程体就要被执行了。</p><h3 id="initial-suspend" tabindex="-1"><a class="header-anchor" href="#initial-suspend" aria-hidden="true">#</a> initial_suspend</h3><p>为了方便灵活扩展，协程体执行的第一步是调用 <code>co_await promise.initial_suspend()</code>，<code>initial_suspend</code> 的返回值就是一个等待对象（awaiter），如果返回值满足挂起的条件，则协程体在最一开始就立即挂起。这个点实际上非常重要，我们可以通过控制 initial_suspend 返回的等待体来实现协程的执行调度。有关调度的内容我们后面会专门探讨。</p><h3 id="协程体的执行-1" tabindex="-1"><a class="header-anchor" href="#协程体的执行-1" aria-hidden="true">#</a> 协程体的执行</h3><p>接下来执行协程体。</p><p>协程体当中会存在 co_await、co_yield、co_return 三种协程特有的调用，其中</p><ul><li>co_await 我们前面已经介绍过，用来将协程挂起。</li><li>co_yield 则是 co_await 的一个马甲，用于传值给协程的调用者或恢复者或被恢复者，我们后面会专门用一篇文章给出例子介绍它的用法。</li><li>co_return 则用来返回一个值或者从协程体返回。</li></ul><h4 id="协程体的返回值" tabindex="-1"><a class="header-anchor" href="#协程体的返回值" aria-hidden="true">#</a> 协程体的返回值</h4><p>对于返回一个值的情况，需要在 promise_type 当中定义一个函数</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token function">return_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">return_value</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，我们的 Coroutine 函数就需要使用 co_return 来返回一个整数了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">co_return</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1000 会作为参数传入，即 return_value 函数的参数 value 的值为 1000。</p><p>这时候读者可能会疑惑，这个值好像没什么用啊？大家别急，这个值可以存到 promise_type 对象当中，外部的调用者可以获取到。</p><h4 id="协程体返回-void" tabindex="-1"><a class="header-anchor" href="#协程体返回-void" aria-hidden="true">#</a> 协程体返回 void</h4><p>除了返回值的情况以外，C++ 协程当然也支持返回 void。只不过 promise_type 要定义的函数就不再是 return_value 了，而是 return_void 了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时，协程内部就可以通过 co_return 来退出协程体了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Result <span class="token function">Coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">co_return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="协程体抛出异常" tabindex="-1"><a class="header-anchor" href="#协程体抛出异常" aria-hidden="true">#</a> 协程体抛出异常</h4><p>协程体除了正常返回以外，也可以抛出异常。异常实际上也是一种结果的类型，因此处理方式也与返回结果相似。我们只需要在 promise_type 当中定义一个函数，在异常抛出时这个函数就会被调用到：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      exception_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前异常</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="final-suspend" tabindex="-1"><a class="header-anchor" href="#final-suspend" aria-hidden="true">#</a> final_suspend</h3><p>当协程执行完成或者抛出异常之后会先清理局部变量，接着调用 final_suspend 来方便开发者自行处理其他资源的销毁逻辑。final_suspend 也可以返回一个等待体使得当前协程挂起，但之后当前协程应当通过 coroutine_handle 的 destroy 函数来直接销毁，而不是 resume。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文我们介绍了一些 C++ 协程的各种概念和约定，看似介绍了非常多的内容，但因为示例较少又感觉什么都没介绍。大家不要着急，C++ 协程的概念基本上就这么多，剩下的文章我们都将基于一个或多个具体的场景展开来介绍如何运用 C++ 协程来解决问题。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p><strong>霍丙乾 bennyhuo</strong>，Google 开发者专家（Kotlin 方向）；<strong>《深入理解 Kotlin 协程》</strong> 作者（机械工业出版社，2020.6）；<strong>《深入实践 Kotlin 元编程》</strong> 作者（机械工业出版社，2023.8）；移动客户端工程师，先后就职于腾讯地图、猿辅导、腾讯视频。</p>`,99),v=n("li",null,"GitHub：https://github.com/bennyhuo",-1),m=n("li",null,"博客：https://www.bennyhuo.com",-1),b={href:"https://space.bilibili.com/28615855",target:"_blank",rel:"noopener noreferrer"},h=n("strong",null,"霍丙乾 bennyhuo",-1),_=n("li",null,[s("微信公众号："),n("strong",null,"霍丙乾 bennyhuo")],-1);function g(w,y){const t=e("BiliBili"),p=e("ExternalLinkIcon");return c(),l("div",null,[d,r,a(t,{bvid:"BV1vv4y1A7fX"}),k,n("ul",null,[v,m,n("li",null,[s("bilibili："),n("a",b,[h,a(p)])]),_])])}const x=o(u,[["render",g],["__file","01-intro.html.vue"]]);export{x as default};
