{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/browserconfig.xml","path":"images/browserconfig.xml","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/safari-pinned-tab.svg","path":"images/safari-pinned-tab.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/md5.min.js","path":"js/src/md5.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/busuanzi/busuanzi.pure.mini.js","path":"lib/busuanzi/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/assets/avatar.jpg","path":"assets/avatar.jpg","modified":0,"renderable":0},{"_id":"source/testdata/三国演义.txt","path":"testdata/三国演义.txt","modified":0,"renderable":0},{"_id":"source/testdata/水浒传.txt","path":"testdata/水浒传.txt","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"4c444ec54483d1133f4921a38568b4747f549154","modified":1619445380240},{"_id":"source/robots.txt","hash":"49da63d3b2d251fa06ba6f3f2d789d6766409b47","modified":1619445380240},{"_id":"source/.upload/.history.json","hash":"faaece6cc0ea2e8709f99b905fcf44369cfe1b7c","modified":1619445380240},{"_id":"source/_posts/2018-JetBrains-Day.md","hash":"0924a0400250ab64abf8826750cf9f03cbcb54f1","modified":1619445380240},{"_id":"source/_posts/2019_new_year.md","hash":"db47d20e870154e73fe782a6e5df7b40484531b5","modified":1619445380240},{"_id":"source/_posts/Add-extensions-to-build-scripts copy.md","hash":"dad0737e88dae3454aaf1d8b0d04733e057f7b1d","modified":1620583863260},{"_id":"source/_posts/Add-extensions-to-build-scripts.md","hash":"f537658ebc69eb17f7a3ef87c87336140aec9fce","modified":1620584087030},{"_id":"source/_posts/ReleasableVar.md","hash":"f88079f8c5d28256f867e37654283e79e1746708","modified":1619445380240},{"_id":"source/_posts/android-studio-shortcuts.md","hash":"d927f74c90d56d9566c29fb9a95e9b58286cd62b","modified":1622763200395},{"_id":"source/_posts/apt-tutorials.md","hash":"9a5e3cd005637cbf3d0a238863c893ab8bef0356","modified":1619445380240},{"_id":"source/_posts/basic-coroutines.md","hash":"9512c44dd174359347b3ef9964d1fe558e53f5b6","modified":1619445380240},{"_id":"source/_posts/c-println.md","hash":"dfdc41de56033c128850863ae7468e46d44495ae","modified":1620584087030},{"_id":"source/_posts/coroutine-android.md","hash":"328b55c7ccfe84f404f7320a5ae525aa5ef8fd51","modified":1620584087030},{"_id":"source/_posts/coroutine-cancellation.md","hash":"aa689949d8ba554abf9bdf18e62e5cd40d7cb5e1","modified":1619445380240},{"_id":"source/_posts/coroutine-channel.md","hash":"0806ffa9e2b03f3f6996ac85f92ea115aeeb33cf","modified":1619445380240},{"_id":"source/_posts/coroutine-dispatchers.md","hash":"ac0db41c73bf49081f7133562aea744bfbc5dcde","modified":1619445380240},{"_id":"source/_posts/coroutine-exceptions.md","hash":"85713b2fbfaff3075f8ab20d8f99d9c91c693804","modified":1619445380240},{"_id":"source/_posts/coroutine-flow.md","hash":"5b083261f231d0f857687e4496355bc561358188","modified":1620584087030},{"_id":"source/_posts/coroutine-implementations.md","hash":"a6d96bc80646d2ad663d91ad3201b5150898afd9","modified":1619445380240},{"_id":"source/_posts/coroutine-select.md","hash":"4cb705ff46a6323b9d7b765b13ad1c5f9014d7c5","modified":1620584087030},{"_id":"source/_posts/coroutine-sequence.md","hash":"40a6f021abeabda9bc0fb7e8eaa40d124ad0401f","modified":1619445380240},{"_id":"source/_posts/coroutine-suspend.md","hash":"75934576dea1f9f1467c6d0785ebff2c272d07b0","modified":1619445380240},{"_id":"source/_posts/coroutine-why-so-called-lightweight-thread.md","hash":"16daa3ced724b64c7761bd625ad19ad717b92632","modified":1619445380240},{"_id":"source/_posts/coroutines-start-mode.md","hash":"d9871063ee80dbb13f79d5ed597c34eade6832ee","modified":1619445380240},{"_id":"source/_posts/deepcopy.md","hash":"da6c104ae1954ea764b2dac550d5bb7e95d8834b","modified":1619445380240},{"_id":"source/_posts/deprecated-kotlin-android-extensions.md","hash":"3b0f147607cef3aefdd718c46f59785739986427","modified":1620584087030},{"_id":"source/_posts/google-preferred-kotlin.md","hash":"e6d1a50cf5e737a0d2b48670eaa96f0030505565","modified":1619445380240},{"_id":"source/_posts/gradle-migrate-to-kts.md","hash":"b1495ff37469736713644ca10b4643be3ffba429","modified":1620584087030},{"_id":"source/_posts/gradle-task-syntax.md","hash":"0100798d780fa6cd851e64ce6f5370c5cb559c99","modified":1620584087030},{"_id":"source/_posts/how-to-read-the-book-of-coroutines.md","hash":"2398e8021f3c0b9e3e3afc5c192683cc044e94a0","modified":1620584087030},{"_id":"source/_posts/kotlin-1.4-preview.md","hash":"365e8afb8ea508bf29b1924ddf6687a7d4b8510c","modified":1620584087030},{"_id":"source/_posts/kotlin-2019-whats-new.md","hash":"0d6f53fb09fcdbac9b708e2b7af0a275c3cd52f0","modified":1619445380240},{"_id":"source/_posts/kotlin-community-cn.md","hash":"97603cfee54486eb1c5ddef41d30a393c6789ef5","modified":1619445380240},{"_id":"source/_posts/kotlin-forum-mobile.md","hash":"9c4fc7364e029f62b25f90a6372067275d9d57b5","modified":1619445380240},{"_id":"source/_posts/kotlin-inline-class-improvements.md","hash":"72e999dbb8536834e4cc184822bd51c6324d8c4d","modified":1620584087030},{"_id":"source/_posts/kotlin-intersect-type.md","hash":"44150f6068a1c6f8d6d6d97f280ffd55e24edf33","modified":1620584087030},{"_id":"source/_posts/kotlin-map-default.md","hash":"27110a72313c027027a9ee1bc9933e62eade24cb","modified":1620584087030},{"_id":"source/_posts/kotlin-native-android-mpp.md","hash":"b3b3012728e17a5eb204be9babe9cdb54a283578","modified":1620584087030},{"_id":"source/_posts/kotlin-native-introduction.md","hash":"f060c4f57f39ae4533a9ad651ce369d7c9f42e1e","modified":1620584087030},{"_id":"source/_posts/kotlin-native-jni-dynamic.md","hash":"75b5743c8719d31791dc571ae155e093933096af","modified":1619445380240},{"_id":"source/_posts/kotlin-news-202002.md","hash":"113a675f26a7d9f5394c0cb18950dd57fcaf0084","modified":1620584087030},{"_id":"source/_posts/kotlin-news-202010.md","hash":"af62cb8603f967e066a1261053a495f09914e3d7","modified":1620584087030},{"_id":"source/_posts/kotlin-nodejs.md","hash":"81d731cf4791036478e740ab6a806d8a9176c83b","modified":1619445380240},{"_id":"source/_posts/kotlin-sealed-interface.md","hash":"f9d785c9a6cc5b88ae3243e98d2aee9117ab582c","modified":1620584087030},{"_id":"source/_posts/kotlin_native_jni.md","hash":"bd104eea1e1719c5eace143a39dd040ce4613505","modified":1619445380240},{"_id":"source/_posts/kotlin-swift-property-delegate.md","hash":"f3150f899992a2c2a49da97db673470e038777ca","modified":1620584087030},{"_id":"source/_posts/kotlin_AutoDispose.md","hash":"dfcc46e5d670325193139ecc6f839e7484ede8c0","modified":1619445380240},{"_id":"source/_posts/lazy-evaluation.md","hash":"6a7a3edf6f42d85f4f87faede9c694868bbc8638","modified":1620584087030},{"_id":"source/_posts/nan-equals.md","hash":"e968b2790cfb61009a44598f830fa90dc1c0b046","modified":1619445380240},{"_id":"source/_posts/this-type.md","hash":"1720ecffde0edbd2fa45df590dc5acd3d7ecff23","modified":1619445380240},{"_id":"source/_posts/understanding-kotlin-coroutines.md","hash":"04776e6635636184b94da03af9d4804847c3d68a","modified":1620584087030},{"_id":"source/about/index.md","hash":"0f45f7d6ad28339345940386f8776399ac329825","modified":1619856332940},{"_id":"source/assets/avatar.jpg","hash":"fe03d2499b5353bf4feeae281513c92668f8a5b7","modified":1619445380240},{"_id":"source/project/index.md","hash":"cb7c4622d509efc40879d73ad622054152769ad8","modified":1619445380240},{"_id":"source/project/kotlin-coroutines.md","hash":"bd5f359f36c8b2ba4b3877e890a2f8f0b8044602","modified":1627515520200},{"_id":"source/tags/index.md","hash":"4da30932a874d705d3c9b407e41581ba282e5d84","modified":1619445380240},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619445380260},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1619445380250},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1619445380250},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1619445380250},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1619445380250},{"_id":"themes/next/.gitignore","hash":"afba2eb24a0cdf7946ce85502d6b012c16fd2533","modified":1619445380250},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1619445380250},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1619445380250},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1619445380250},{"_id":"themes/next/README.md","hash":"140f4ece6670327a7d33b293947d958de80b44da","modified":1619445380250},{"_id":"themes/next/_config.yml","hash":"0561689a325cf93247cc5cbc1371bf15f3fdcee9","modified":1619857098920},{"_id":"themes/next/bower.json","hash":"23379fec9b4f70bc2611433ac3770445a8ca18d9","modified":1619445380250},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1619445380250},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1619445380260},{"_id":"themes/next/package.json","hash":"42186cf60771f5547b3a68cf3865f102011930d0","modified":1619445380260},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1619445380250},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1619445380250},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1619445380250},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1619445380250},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1619445380250},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1619445380250},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1619445380260},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1619445380260},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1619445380260},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1619445380260},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1619445380260},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1619445380260},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1619445380260},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1619445380260},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1619445380260},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1619445380260},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1619445380260},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1619445380260},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1619445380260},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1619445380260},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1619445380260},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1619445380260},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1619445380260},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1619445380260},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1619445380260},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1619445380260},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1619445380260},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1619445380260},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1619445380260},{"_id":"themes/next/languages/zh-CN.yml","hash":"aa84e190eb7cf1c0d13bfea703d791d1a09c3de3","modified":1619445380260},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1619445380260},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1619445380260},{"_id":"themes/next/layout/_layout.swig","hash":"1b59036ccb2ad571503b94587f458fad46775642","modified":1619445380260},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1619445380260},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1619445380260},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1619445380260},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1619445380260},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1619445380260},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1619445380260},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1619445380260},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1619445380260},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1619445380260},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1619445380260},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1619445380260},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1619445380260},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1619445380260},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1619445380260},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1619445380260},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1619445380260},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1619445380260},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1619445380260},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1619445380260},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1619445380260},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1619445380260},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1619445380260},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1619445380260},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1619445380260},{"_id":"themes/next/layout/_macro/post.swig","hash":"27922af64ecb9db9a28bcf1c98fb68b26bf0b67a","modified":1619445380260},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1619445380260},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1619445380260},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1619445380260},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1619445380260},{"_id":"themes/next/layout/_partials/comments.swig","hash":"d24fc544cb9181ce9ad974852bc0cdedc1436fec","modified":1619445380260},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a701c5fa227d8312eac43d7fc05851dc929cbccb","modified":1619445380260},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1619445380260},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9fd07541f1f10bbf897819b48465241c4c89a18c","modified":1619445380260},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1619445380260},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1619445380260},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1619445380260},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1619445380260},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1619445380260},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1619445380260},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1619445380260},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1619445380260},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1619445380260},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1619445380260},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1619445380260},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1619445380260},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1619445380260},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1619445380260},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1619445380260},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1619445380260},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1619445380260},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1619445380260},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1619445380260},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1619445380260},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1619445380260},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1619445380260},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1619445380260},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1619445380260},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1619445380260},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"79d8e7ba31017bb86b21e8391434a6caa4f9dfd0","modified":1619445380260},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1619445380260},{"_id":"themes/next/source/images/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1619445380260},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1619445380260},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1619445380260},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1619445380260},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1619445380260},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1619445380260},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1619445380260},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1619445380260},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1619445380260},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"25fc74d98b0c36a9d7a6998118b1e8cb838c4195","modified":1619445380260},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1619445380260},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"d59e67ade7e3e4788d2e0ea89bc59a6fb1733487","modified":1619445380260},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1619445380260},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1619445380260},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1619445380260},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1619445380260},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1619445380260},{"_id":"themes/next/source/images/safari-pinned-tab.svg","hash":"d8c0f648e3121e9754214fa534fba84a8cb140d4","modified":1619445380260},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1619445380260},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1619445380260},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1619445380260},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1619445380260},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1619445380260},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"cb2e31b0aeeb45b3dfbfd087e19c0c4dc1ba8628","modified":1619445380260},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1619445380260},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1619445380260},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1619445380260},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1619445380260},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1619445380260},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1619445380260},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1619445380260},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1619445380260},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1619445380260},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1619445380260},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1619445380260},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1619445380260},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1619445380260},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1619445380260},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"379d4f68abc4fb05f7e82a1dd1dd54a0866043b3","modified":1619856230140},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"9809d63a4234c5f268ff0b489579149b849728fc","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1619445380260},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1619445380260},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1619445380260},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1619445380260},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1619445380260},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1619445380260},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1619445380260},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1619445380260},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1619445380260},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"6c74dd1ee95cba0a5e6ae42a00bb4ff4ca289660","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1619445380260},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1619445380260},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1619445380260},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1619445380260},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1619445380260},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1619445380260},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1619445380260},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1619445380260},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1619445380260},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1619445380260},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1619445380260},{"_id":"themes/next/source/js/src/md5.min.js","hash":"5cd5c4695627f4a02874915eddee964e5c847e6f","modified":1619445380260},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1619445380260},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1619445380260},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1619445380260},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1619445380260},{"_id":"themes/next/source/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1619445380260},{"_id":"themes/next/source/lib/busuanzi/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1619445380260},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1619445380260},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1619445380260},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1619445380260},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1619445380260},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1619445380260},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1619445380260},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1619445380260},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1619445380260},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1619445380260},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1619445380260},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"85e048a5829cdd0235c97e594765ec325076775b","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1619445380260},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1619445380260},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1619445380260},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1619445380260},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1619445380260},{"_id":"source/testdata/三国演义.txt","hash":"6688c063af3b2e8a0a911eaad78b6b1e815e3ac6","modified":1619445380250},{"_id":"source/testdata/水浒传.txt","hash":"7fade629dd08dbbe6061f6ac527c9cf743ba0e25","modified":1619445380250},{"_id":"public/images/algolia_logo.svg","hash":"a12a713f9d8eb0db28ffbf0eac28aed99873ca44","modified":1620584215279},{"_id":"public/images/apple-touch-icon-next.png","hash":"b972160c147e9bec3a0f7432e6e80dfa92581b0b","modified":1620584215279},{"_id":"public/images/apple-touch-icon.png","hash":"6f8a1ccf204dd7b31110f1909b1c453c578b7982","modified":1620584215279},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1620584215279},{"_id":"public/images/cc-by-nc-nd.svg","hash":"52fbdaddcb35bfbc996942f2ef1f0785346c04b8","modified":1620584215279},{"_id":"public/images/cc-by-nc-sa.svg","hash":"7470717cdf9fccbe012477d6abcac3b72c69d1f6","modified":1620584215279},{"_id":"public/images/cc-by-nc.svg","hash":"75262099541b67d440f6330bc51f8d6061520871","modified":1620584215279},{"_id":"public/images/cc-by-nd.svg","hash":"f980b687bd05415bbaa0f7276fc304c86302e36e","modified":1620584215279},{"_id":"public/images/cc-by-sa.svg","hash":"237abcff008ee00c67b6b3858d327804b8f4ca78","modified":1620584215279},{"_id":"public/images/cc-by.svg","hash":"359ca2c46a8a6740640502cac3bd26bde3f3554d","modified":1620584215279},{"_id":"public/images/cc-zero.svg","hash":"3ccde47c9aff8218973d2a195deb08ecba2175ca","modified":1620584215279},{"_id":"public/images/favicon-16x16-next.png","hash":"5ee510e58b7b9e062a22da28ce1eb35a2f381021","modified":1620584215279},{"_id":"public/images/favicon-16x16.png","hash":"49bb0e3f991b5d2a5a95fb70ba867933b822769e","modified":1620584215279},{"_id":"public/images/favicon-32x32-next.png","hash":"f88e49404e4c2a326e51ae65ea5b2375b5d5fde8","modified":1620584215279},{"_id":"public/images/favicon-32x32.png","hash":"19bdeac41bd0bf73d8eb5fc8f3a4518226456f4e","modified":1620584215279},{"_id":"public/images/logo.svg","hash":"341e56181f7fb241cf223acc75a46af1112555ea","modified":1620584215279},{"_id":"public/images/quote-l.svg","hash":"998becfabb95374376eca720f86b00c8f254533e","modified":1620584215279},{"_id":"public/images/quote-r.svg","hash":"75f3c20e3a9fdf866ed7af1f59a7db8e6b8138f9","modified":1620584215279},{"_id":"public/images/safari-pinned-tab.svg","hash":"cb2b6e60ae1e2f1e355714a7c4115b83c6a3f3d7","modified":1620584215279},{"_id":"public/images/searchicon.png","hash":"00eed611c73d736ddea861a92d8c91d44aefef5c","modified":1620584215279},{"_id":"public/assets/avatar.jpg","hash":"79f64e36ee0b6af7932cb135782a2897fdc645cc","modified":1620584215279},{"_id":"public/baidusitemap.xml","hash":"1c5ea1be8f90b91f57c808efbbfe7ed29894ffed","modified":1622763201206},{"_id":"public/atom.xml","hash":"5da63ae9487ee9e9eaca8f42efefc0e8f1d60f2a","modified":1622763289621},{"_id":"public/sitemap.xml","hash":"4c7408e16fdb1c00a660e225852f37db2bfdecc5","modified":1627515530159},{"_id":"public/project/index.html","hash":"6107ba61e907224c8cc01b7b65afdf4b21260610","modified":1622763201206},{"_id":"public/tags/index.html","hash":"88244c3090b1c2ed69c2c89fa55b619a15569fa1","modified":1622763201206},{"_id":"public/archives/index.html","hash":"0d17758a56369998c15739124587a1c23a7b0bf1","modified":1622763201206},{"_id":"public/archives/page/2/index.html","hash":"96e014176d0b978f198bf43c7f364b7ef1b01174","modified":1622763201206},{"_id":"public/archives/page/3/index.html","hash":"c17d51be89acc548e0aaec68b866016955a1deff","modified":1622763201206},{"_id":"public/archives/page/4/index.html","hash":"efd524a1fb7c8538340a746ea9cb7ff51aabfaa4","modified":1622763201206},{"_id":"public/archives/page/5/index.html","hash":"53ae6303b49ab6dd9ac32014d6f500c57fd256d4","modified":1622763201206},{"_id":"public/archives/2018/index.html","hash":"e6b96681a1119da32e8c0854df0b436395696084","modified":1622763201206},{"_id":"public/archives/2018/10/index.html","hash":"28a9cc2652c2f4ccb900d4254fdef9a43a1f0cb8","modified":1622763201206},{"_id":"public/archives/2018/11/index.html","hash":"e80efc64099359f7e267d5abc2299432e2cf049a","modified":1622763201206},{"_id":"public/archives/2018/12/index.html","hash":"57e560dbef57efd6b36eb3bfc7d645d6cfd50279","modified":1622763201206},{"_id":"public/archives/2019/index.html","hash":"b1472734cceb4557abf10f95dbe8fd4d3dfa0e72","modified":1622763201206},{"_id":"public/archives/2019/page/2/index.html","hash":"bd84baea42bdee0972ed5437eeccdc7aaa00b0e4","modified":1622763201206},{"_id":"public/archives/2019/01/index.html","hash":"3ce7382b8bb25c196eb93d2804e810e809674c92","modified":1622763201206},{"_id":"public/archives/2019/02/index.html","hash":"fe07081ccd73c9b50cab3f4648831871c50abc1c","modified":1622763201206},{"_id":"public/archives/2019/03/index.html","hash":"8f71bdc0b44c260a145bb2111d571b3c87106cab","modified":1622763201206},{"_id":"public/archives/2019/04/index.html","hash":"0c74cdd1b86b3a17d81723845270c9d8847da6a7","modified":1622763201206},{"_id":"public/archives/2019/05/index.html","hash":"be5c20816d86cd19e0d055297a0133648170fd08","modified":1622763201206},{"_id":"public/archives/2019/09/index.html","hash":"4d13f5d778155da950f71e02ca535d92d9d76200","modified":1622763201206},{"_id":"public/archives/2019/10/index.html","hash":"cddc79ceac661ce84c20f0ba7ee4d02d13a0fbad","modified":1622763201206},{"_id":"public/archives/2019/12/index.html","hash":"db97ecd670aa5d8a1f6834511ae196d36e85cc46","modified":1622763201206},{"_id":"public/archives/2020/index.html","hash":"ba59715140785fee577cd69c12dc41186b471a23","modified":1622763201206},{"_id":"public/archives/2020/page/2/index.html","hash":"117fc07f42865f97f28d88327a1b11d5fa6ce50d","modified":1622763201206},{"_id":"public/archives/2020/02/index.html","hash":"27fd85839a77791f43dd8bf57c028c3b2af7a5dc","modified":1622763201206},{"_id":"public/archives/2020/03/index.html","hash":"dd1b11943e6b7b236ff0659871caed04e392e51c","modified":1622763201206},{"_id":"public/archives/2020/04/index.html","hash":"91d1e7d7f659702243e56545f6bd251d34ee7485","modified":1622763201206},{"_id":"public/archives/2020/05/index.html","hash":"5013cb11df2c3d13dee419aa0f1ffe911ac51326","modified":1622763201206},{"_id":"public/archives/2020/06/index.html","hash":"b246b76ae2396ecde5c9560677e3d7622be92bf6","modified":1622763201206},{"_id":"public/archives/2020/07/index.html","hash":"da1c668b874443b7b582eb1be8bec26d20fb5438","modified":1622763201206},{"_id":"public/archives/2020/10/index.html","hash":"4836d2cbf9cd0e75af4ffd5a2230bc0673f90562","modified":1622763201206},{"_id":"public/archives/2020/11/index.html","hash":"af6f023826d1313f7b41aaeb222c7c8e79617f90","modified":1622763201206},{"_id":"public/archives/2021/index.html","hash":"800ac81d0b9bb90881328c9895710f9d3f1440a7","modified":1622763201206},{"_id":"public/archives/2021/01/index.html","hash":"5393ce8d22f086bfa3dad3830b8bb73ef5a8a6e4","modified":1622763201206},{"_id":"public/archives/2021/04/index.html","hash":"063923495ca0f09d98233abddd43f378829a1070","modified":1622763201206},{"_id":"public/archives/2021/05/index.html","hash":"b06e0d42859ea5569cec97e589b6197d6cfe98ce","modified":1622763201206},{"_id":"public/tags/jetbrains/index.html","hash":"2e7f2d101b320947dfece9b819684e951918d502","modified":1622763201206},{"_id":"public/tags/news/index.html","hash":"79bce1a9428fbdea8c9546df6dea2944f0d307d2","modified":1622763201206},{"_id":"public/tags/newyear/index.html","hash":"82b3ee6e6a5cb8e89086682952b68cf11061fd5e","modified":1622763201206},{"_id":"public/tags/kotlin/index.html","hash":"60082ad97992449e81a8d8ea544658eda7c2ba05","modified":1622763201206},{"_id":"public/tags/kotlin/page/2/index.html","hash":"c052edeb311a9f9de989df32529db0b9c6c711e8","modified":1622763201206},{"_id":"public/tags/kotlin/page/3/index.html","hash":"5e4e2b693088ded5ce0baf1effd495515f00df72","modified":1622763201206},{"_id":"public/tags/java/index.html","hash":"527359e82b5e7adea0abe4c865a4123913fb153a","modified":1622763201206},{"_id":"public/tags/gradle/index.html","hash":"eeca369ed91907d6855a429b9162d06f6e9b39d7","modified":1622763201206},{"_id":"public/tags/groovy/index.html","hash":"91c7a9e1f5809b519b452275880aca46a9f47496","modified":1622763201206},{"_id":"public/tags/kts/index.html","hash":"dd372a16e2af1a4f159031c549c632c9380bd86b","modified":1622763201206},{"_id":"public/tags/propertydelegate/index.html","hash":"0dd9ee7d5470155a7a80091a68b11a89ba50a376","modified":1622763201206},{"_id":"public/tags/android-studio/index.html","hash":"5b0a787da81a0f409b4bda9f8a84bb0f3ee09743","modified":1622763201206},{"_id":"public/tags/技巧/index.html","hash":"5812a314cdd1206621315f5499edfb8919907562","modified":1622763201206},{"_id":"public/tags/快捷键/index.html","hash":"06df5a60edd37a900d60e7541351d59961c38c00","modified":1622763201206},{"_id":"public/tags/apt/index.html","hash":"756aea38a87732d7a634b9a4ef810ff320bad269","modified":1622763201206},{"_id":"public/tags/coroutine/index.html","hash":"a35cc2fd0dd9dbf7c0393cdb0ee2444ed9959d0f","modified":1622763201206},{"_id":"public/tags/coroutine/page/2/index.html","hash":"f2eb37f72447d55b650537dc4a8e17edf52afd97","modified":1622763201206},{"_id":"public/tags/c/index.html","hash":"6bd81e4a68bbd015d39dbd0db255cd66bd3b9b1b","modified":1622763201206},{"_id":"public/tags/macro/index.html","hash":"e6cdb659e235531c51f10066adc2085155fc7e51","modified":1622763201206},{"_id":"public/tags/android/index.html","hash":"35539fb961f6e103c1028b3e99b3666f903551ad","modified":1622763201206},{"_id":"public/tags/flow/index.html","hash":"c6cab5b098c0210f2a2b8ebccf0ee653a087c428","modified":1622763201206},{"_id":"public/tags/rxjava/index.html","hash":"c7e5a2264b36c9127a9251bf7383d21fcad26b7d","modified":1622763201206},{"_id":"public/tags/coroutines/index.html","hash":"5909bf3b61b0e11abf37801467b17b0a7cdc3865","modified":1622763201206},{"_id":"public/tags/select/index.html","hash":"6721f6139257530f922fd9b1d7b0119276c919c6","modified":1622763201206},{"_id":"public/tags/dataclass/index.html","hash":"d7cb6d610616f2f62154492f1a53f221fd865459","modified":1622763201206},{"_id":"public/tags/协程/index.html","hash":"41fb9afd5b25824afcbe78e00139344b3cb18d9d","modified":1622763201206},{"_id":"public/tags/release/index.html","hash":"7d13dfc72beb865d10b6b859e93bb0690c3368f9","modified":1622763201206},{"_id":"public/tags/website/index.html","hash":"c11183c00f82959ced9342da8504a1d533870c61","modified":1622763201206},{"_id":"public/tags/inline-class/index.html","hash":"3cafbb57347b0bbcfae70da6d32be59624616236","modified":1622763201206},{"_id":"public/tags/type/index.html","hash":"e07357c517a5da409e1e603c907b35abadccc14d","modified":1622763201206},{"_id":"public/tags/map/index.html","hash":"8d248294b3d4ed496aeb8b345bd4d97fb5b9c5a4","modified":1622763201206},{"_id":"public/tags/kotlin-native/index.html","hash":"55a3ce3a27a678546cfc8beae078df2e520db951","modified":1622763201206},{"_id":"public/tags/mpp/index.html","hash":"5348f235309d9d6979eed2eac06ae01384b0b0cc","modified":1622763201206},{"_id":"public/tags/native/index.html","hash":"ac220b586854f454b83680c48a874861cef003ce","modified":1622763201206},{"_id":"public/tags/kotlni-js/index.html","hash":"4d83962c4de1dc7a66ce9bea41c5eae08993c4b5","modified":1622763201206},{"_id":"public/tags/sealed-interface/index.html","hash":"a20ebdbf6101d6fbb582f5a8762bdae70a28694f","modified":1622763201206},{"_id":"public/tags/swift/index.html","hash":"59709aec860af6682f5a0e55a389602ea3c8ba8d","modified":1622763201206},{"_id":"public/tags/property/index.html","hash":"0283ad3bca6b75f2cac4b2cba95b90bcfe8ce346","modified":1622763201206},{"_id":"public/tags/scala/index.html","hash":"c71f3e44b98a9056008e643d81f545794acc074b","modified":1622763201206},{"_id":"public/tags/lazy/index.html","hash":"697b30579ed0b8517889396d711c690ec53bae5a","modified":1622763201206},{"_id":"public/tags/selftype/index.html","hash":"e3597562dd479be20e489bff7830a2823f220498","modified":1622763201206},{"_id":"public/about/index.html","hash":"8427f97eaa8d3a3f695cd92c94b11b2950bba1c4","modified":1622763201206},{"_id":"public/project/kotlin-coroutines.html","hash":"0be8c23814faf925bb578fe0e478433a12d7629f","modified":1627515530159},{"_id":"public/2021/05/10/Add-extensions-to-build-scripts copy/index.html","hash":"cc48d67a3ce967c9be45fa5239f61ac007a24dd5","modified":1620584215279},{"_id":"public/2021/05/10/android-studio-shortcuts/index.html","hash":"442c23feb14dc8c15c6f3bbcbfad78201a4d52d4","modified":1622763201206},{"_id":"public/2021/04/18/Add-extensions-to-build-scripts/index.html","hash":"88afae998beeef2308fc1a4081b57b0d500ac896","modified":1622763201206},{"_id":"public/2021/04/18/gradle-migrate-to-kts/index.html","hash":"1686c7cdf36f6f0206c772a6da6c33d56a91f2a9","modified":1622763201206},{"_id":"public/2021/04/12/gradle-task-syntax/index.html","hash":"48e37f290e969496577d6d1384f3bda9c96d6a9b","modified":1622763201206},{"_id":"public/2021/01/31/how-to-read-the-book-of-coroutines/index.html","hash":"38c749df8c58755976998ccb36664692ce2bd54c","modified":1622763201206},{"_id":"public/2021/01/23/kotlin-sealed-interface/index.html","hash":"67567fef8f06abe0c6ca7bee1ae2af6aeddf6134","modified":1622763201206},{"_id":"public/2021/01/18/kotlin-inline-class-improvements/index.html","hash":"d0c8224bf1bf5aad667e54ab223aa6bf41b17c74","modified":1622763201206},{"_id":"public/2020/11/07/deprecated-kotlin-android-extensions/index.html","hash":"a1e700dd05e32e80e8976dad1eed99ede5803475","modified":1622763201206},{"_id":"public/2020/10/19/kotlin-news-202010/index.html","hash":"2d943fd59008eb7cb23b4d8b951d9c90d6672143","modified":1622763201206},{"_id":"public/2020/07/15/kotlin-native-introduction/index.html","hash":"0bcd5d35509cd93babf368eea323ad5c7c648248","modified":1622763201206},{"_id":"public/2020/06/23/understanding-kotlin-coroutines/index.html","hash":"9761b5c0c87805a3b6b8421baec79f6c992b9d0e","modified":1622763201206},{"_id":"public/2020/06/14/c-println/index.html","hash":"fe4e27b339bde30ac6f72efceefafc96c8564b90","modified":1622763201206},{"_id":"public/2020/06/09/kotlin-map-default/index.html","hash":"863e9ea986c486ee373caddf9cf44995f825f9c6","modified":1622763201206},{"_id":"public/2020/05/23/lazy-evaluation/index.html","hash":"86d65a36725617f582176d9f30c536cf8bf09f16","modified":1622763201206},{"_id":"public/2020/05/08/kotlin-swift-property-delegate/index.html","hash":"79da893d802f9009bf9d62d6b6933b503c89d32f","modified":1622763201206},{"_id":"public/2020/04/19/kotlin-native-android-mpp/index.html","hash":"4d5b3b767916ecb54b29cf9ae66e45747384314e","modified":1622763201206},{"_id":"public/2020/04/06/kotlin-intersect-type/index.html","hash":"cd77aa8ff6e35c14d9433c4b590687994c029428","modified":1622763201206},{"_id":"public/2020/03/26/kotlin-1.4-preview/index.html","hash":"b790fbb0fc24ab5d60748e9c4865e8f76a0aa222","modified":1622763201206},{"_id":"public/2020/03/14/coroutine-flow/index.html","hash":"e2404c1b51f37969a03632b3a5c443a40d335353","modified":1622763201206},{"_id":"public/2020/02/13/kotlin-news-202002/index.html","hash":"4d29ef72ab35039868f87a3e88cefafb1e3ea437","modified":1622763201206},{"_id":"public/2020/02/03/coroutine-select/index.html","hash":"8e86cd53194b52aadd4c006551204b67929b16eb","modified":1622763201206},{"_id":"public/2019/12/23/kotlin-2019-whats-new/index.html","hash":"e47fccfe8f7bd15f608da8a843c6d8c6ae0bfbdf","modified":1622763201206},{"_id":"public/2019/12/01/coroutine-implementations/index.html","hash":"d7d0904dd804d44c9fde1c150fdb7999d5d810df","modified":1622763201206},{"_id":"public/2019/10/22/kotlin-forum-mobile/index.html","hash":"b2595357ec3a6fa192701d8586ab443fc85b3aeb","modified":1622763201206},{"_id":"public/2019/10/19/coroutine-why-so-called-lightweight-thread/index.html","hash":"9fd92b5ab985fbc7e831051f33fcee641aa9c517","modified":1622763201206},{"_id":"public/2019/09/16/coroutine-channel/index.html","hash":"faf32934903db9b6e0fd6409f8b62ed8283b49f8","modified":1622763201206},{"_id":"public/2019/05/27/coroutine-android/index.html","hash":"d0916d90f52d1fe8cee2762ba75e1f1622a71b15","modified":1622763201206},{"_id":"public/2019/05/26/coroutine-sequence/index.html","hash":"6b91e7104ff2923c74c43b0a15cfbb01ca1f2a65","modified":1622763201206},{"_id":"public/2019/05/10/google-preferred-kotlin/index.html","hash":"e4312c84275066330ba32ccd39da2914c8df5490","modified":1622763201206},{"_id":"public/2019/05/07/coroutine-suspend/index.html","hash":"45f1b7bb742811e470221dc0e4add63eaa49e14a","modified":1622763201206},{"_id":"public/2019/04/30/coroutine-cancellation/index.html","hash":"b0ee360aa8c8c3c9ba46b1055456c97d06b68175","modified":1622763201206},{"_id":"public/2019/04/23/coroutine-exceptions/index.html","hash":"a5b2334a24653799732ce7dddfb19d9725fa84d8","modified":1622763201206},{"_id":"public/2019/04/11/coroutine-dispatchers/index.html","hash":"1c48bda97fc9c85592948221151c28195135ac65","modified":1622763201206},{"_id":"public/2019/04/08/coroutines-start-mode/index.html","hash":"ae4a103d05458823228af50ddebe6ff6c3344185","modified":1622763201206},{"_id":"public/2019/04/01/basic-coroutines/index.html","hash":"8430e28ab83500d5f8e74ed142d1c202f16bc989","modified":1622763201206},{"_id":"public/2019/03/23/nan-equals/index.html","hash":"ff3cfabddd9108a523a9a13ca98dbc66bb896b38","modified":1622763201206},{"_id":"public/2019/03/11/kotlin-nodejs/index.html","hash":"a4127603082278509682a7e216645edb713ca985","modified":1622763201206},{"_id":"public/2019/02/18/this-type/index.html","hash":"7d5221274876dad8ae6bebb2702d3c473ddc1ddd","modified":1622763201206},{"_id":"public/2019/02/05/2019_new_year/index.html","hash":"09138e4275f46140156d86e072791b1fe2480294","modified":1622763201206},{"_id":"public/2019/01/07/kotlin_AutoDispose/index.html","hash":"01504af532698f3474020086a67a8b32d0c878c0","modified":1622763201206},{"_id":"public/2018/12/31/kotlin-native-jni-dynamic/index.html","hash":"37a8d9a5ab39d948301ff990a52919412606de03","modified":1622763201206},{"_id":"public/2018/12/17/kotlin_native_jni/index.html","hash":"8df76f299741afbea98b12061ed2c7acddae5213","modified":1622763201206},{"_id":"public/2018/12/02/deepcopy/index.html","hash":"bf6deb88283256ea41d97dd552ce2b08858e4849","modified":1622763201206},{"_id":"public/2018/11/26/ReleasableVar/index.html","hash":"665932c16d3dad66054aa49937e7c79e029beae4","modified":1622763201206},{"_id":"public/2018/11/18/2018-JetBrains-Day/index.html","hash":"1d40e8ae7210de7d165298e0f510b9e571bc3d2e","modified":1622763201206},{"_id":"public/2018/10/03/apt-tutorials/index.html","hash":"ef292da13c5b5d6c9a9323d4a478c112a8bc7aa7","modified":1622763201206},{"_id":"public/2018/10/02/kotlin-community-cn/index.html","hash":"c30fbc3cad89971ab4fad5893ce88ee81c5fc88d","modified":1622763201206},{"_id":"public/index.html","hash":"812e6acb119ca06b739396d2010cb9bac22cefd4","modified":1622763289621},{"_id":"public/page/2/index.html","hash":"f39f13c3a9a79083c432f4ed636dce1df1d98422","modified":1622763201206},{"_id":"public/page/3/index.html","hash":"29cda93953dc13ef95d825250412209135962e81","modified":1622763201206},{"_id":"public/page/4/index.html","hash":"ba67f36a6923909a7aa15a193d3818c512e48840","modified":1622763201206},{"_id":"public/page/5/index.html","hash":"8d94b0c30cb69098dbbb047ac0edcc305a40e150","modified":1622763201206},{"_id":"public/images/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1620584215279},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1620584215279},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1620584215279},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1620584215279},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1620584215279},{"_id":"public/CNAME","hash":"4c444ec54483d1133f4921a38568b4747f549154","modified":1620584215279},{"_id":"public/robots.txt","hash":"49da63d3b2d251fa06ba6f3f2d789d6766409b47","modified":1620584215279},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1620584215279},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1620584215279},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1620584215279},{"_id":"public/js/src/affix.js","hash":"9a8af487c71f3eaf4af41fa1dc4e73824b874e03","modified":1620584215279},{"_id":"public/js/src/algolia-search.js","hash":"cc68d6c8b5d7f281775deebd24c9a03d61c29827","modified":1620584215279},{"_id":"public/js/src/bootstrap.js","hash":"6872ae2c88ae21a28a714f40ea1a5ced91118e04","modified":1620584215279},{"_id":"public/js/src/exturl.js","hash":"7b2225e68ea4790522cf8662e6a374bdc53d13fe","modified":1620584215279},{"_id":"public/js/src/js.cookie.js","hash":"6a6c9f67a625fa8df87f1a636441ff2816d436c0","modified":1620584215279},{"_id":"public/js/src/md5.min.js","hash":"5cd5c4695627f4a02874915eddee964e5c847e6f","modified":1620584215279},{"_id":"public/js/src/motion.js","hash":"c1c43a4eb33cb46eb586eda0a9687d6d6e38b3a0","modified":1620584215279},{"_id":"public/js/src/post-details.js","hash":"c65e123bf33481571b2ca7748de87a70fa1af23e","modified":1620584215279},{"_id":"public/js/src/scroll-cookie.js","hash":"4ce8bf3b3abea9d6033a199b845ecc5f8d8b38bf","modified":1620584215279},{"_id":"public/js/src/scrollspy.js","hash":"ce453c3d4bebe99da794122ddcb45d038f5a029e","modified":1620584215279},{"_id":"public/js/src/utils.js","hash":"d286bbf29877c7de0a742650e9d517a0244483bd","modified":1620584215279},{"_id":"public/lib/busuanzi/busuanzi.pure.mini.js","hash":"57a6b2bda267fcf54c1372658bc6cdeba22c5543","modified":1620584215279},{"_id":"public/lib/velocity/velocity.ui.js","hash":"034504ba8eaed985a73e77e750620d7e6c6f0a0b","modified":1620584215279},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1620584215279},{"_id":"public/js/src/schemes/pisces.js","hash":"a87997525c58ce213b20728d1b4fc8cbb282c6d8","modified":1620584215279},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1620584215279},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"e651b44d066cc4f7fc8582c90bef00257ce58370","modified":1620584215279},{"_id":"public/css/main.css","hash":"5f7ad0230ae17aa31fc0cec9f1635cd8ac5023c7","modified":1620584215279},{"_id":"public/lib/jquery/index.js","hash":"a1bca9aec3865b8f44a3ede3fc9a9a11a1ab0481","modified":1620584215279},{"_id":"public/lib/velocity/velocity.js","hash":"0cdfbcb850b61a01f54ba494b929736296b16314","modified":1620584215279},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1620584215279},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1620584215279},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"785cb4beecaad98329fff0a54f9a5536cda200ab","modified":1620584215279},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1620584215279},{"_id":"public/testdata/三国演义.txt","hash":"6688c063af3b2e8a0a911eaad78b6b1e815e3ac6","modified":1620584215279},{"_id":"public/testdata/水浒传.txt","hash":"7fade629dd08dbbe6061f6ac527c9cf743ba0e25","modified":1620584215279},{"_id":"source/_posts/sam-meets-package-visibility.md","hash":"67a6ef3f8bc456f9a08662f26cf0713d3fcce42e","modified":1622763289265},{"_id":"public/archives/2021/06/index.html","hash":"340784ebfe83644b90135ce76d0799734c0760f4","modified":1622763201206},{"_id":"public/tags/sam/index.html","hash":"faee6d3be7a1d729f4eaca18ada163cffe9c9d40","modified":1622763201206},{"_id":"public/2021/06/04/sam-meets-package-visibility/index.html","hash":"f22d3ff0963445069f48ed2e3ec68c5e44d77d6d","modified":1622763289621}],"Category":[],"Data":[],"Page":[{"title":"关于 Bennyhuo","date":"2018-10-03T12:10:50.000Z","_content":"\n# 基本信息\n\n* 前腾讯客户端高级工程师，团队负责人\n* Kotlin 布道师/社区组织者\n* **微信公众号：Kotlin**：2016年10月至今，专注于 Kotlin 技术布道\n* **bilibili：[bennyhuo 不是算命的](https://space.bilibili.com/28615855)**\n* **知乎：[bennyhuo](https://www.zhihu.com/people/bennyhuo)**\n\n# 技术书籍\n\n* 2020.06 **[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)**\n\n# 教学视频\n\n* 2020.11 慕课网: **[C 语言系统精讲](https://coding.imooc.com/class/463.html)**\n* 2019.11 慕课网: **[新版 Kotlin 入门到精通](https://coding.imooc.com/class/398.html)**\n* 2019.04 慕课网: **[破解 Retrofit](https://www.imooc.com/learn/1128)**\n* 2019.02 慕课网: **[破解Android高级面试](https://coding.imooc.com/class/317.html)**\n* 2018.10 哔哩哔哩: **[注解处理器教程](https://www.bilibili.com/video/BV1RW411m7Hk/)**\n* 2018.06 慕课网: **[基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计](https://coding.imooc.com/class/232.html)**\n* 2017.06 慕课网: **[Kotlin 系统入门到进阶](http://coding.imooc.com/class/108.html)**\n* 2016.10 **[Kotlin 入门到放弃](https://github.com/enbandari/Kotlin-Tutorials)**\n\n# 大会分享\n\n* 2020.11 2020 全球移动开发者峰会 & GDG Kotlin Day: **[Kotlin多平台在移动端应用与展望](https://live.csdn.net/room/zxff716/Dl55vGUZ)**\n* 2020.05 2020 GDG Android 11 Meetup: **[Kotlin 协程那些事儿](https://www.bilibili.com/video/BV1MV411z7pM)**\n* 2018.11 2018 JetBrains 北京开发者大会: **[如何优雅的使用 Data Class](https://v.qq.com/x/page/n08227okqh9.html)**\n* 2017.11 2017 Android 技术大会: **[效率的抉择 - 将 Kotlin 投入 Android 应用开发当中 ](http://play.itdks.com/watch/3740769?player=)**\n\n# 相关网站\n\n* **个人主页**：https://www.bennyhuo.com\n* **GitHub**：https://github.com/bennyhuo\n* **[Kotlin 中文官网](https://www.kotlincn.net)**: 同步翻译官网，为国内开发者提供最权威的参考资料\n* **[Kotlin 中文博客](https://www.kotliner.cn)**: 同步翻译博客，为国内开发者提供最新的 Kotlin 官方动态\n* **[Kotlin 中文论坛](https://discuss.kotliner.cn)**: 提供讨论的平台，方便 Kotlin 爱好者交流\n\n","source":"about/index.md","raw":"---\ntitle: 关于 Bennyhuo\ndate: 2018-10-03 20:10:50\n---\n\n# 基本信息\n\n* 前腾讯客户端高级工程师，团队负责人\n* Kotlin 布道师/社区组织者\n* **微信公众号：Kotlin**：2016年10月至今，专注于 Kotlin 技术布道\n* **bilibili：[bennyhuo 不是算命的](https://space.bilibili.com/28615855)**\n* **知乎：[bennyhuo](https://www.zhihu.com/people/bennyhuo)**\n\n# 技术书籍\n\n* 2020.06 **[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)**\n\n# 教学视频\n\n* 2020.11 慕课网: **[C 语言系统精讲](https://coding.imooc.com/class/463.html)**\n* 2019.11 慕课网: **[新版 Kotlin 入门到精通](https://coding.imooc.com/class/398.html)**\n* 2019.04 慕课网: **[破解 Retrofit](https://www.imooc.com/learn/1128)**\n* 2019.02 慕课网: **[破解Android高级面试](https://coding.imooc.com/class/317.html)**\n* 2018.10 哔哩哔哩: **[注解处理器教程](https://www.bilibili.com/video/BV1RW411m7Hk/)**\n* 2018.06 慕课网: **[基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计](https://coding.imooc.com/class/232.html)**\n* 2017.06 慕课网: **[Kotlin 系统入门到进阶](http://coding.imooc.com/class/108.html)**\n* 2016.10 **[Kotlin 入门到放弃](https://github.com/enbandari/Kotlin-Tutorials)**\n\n# 大会分享\n\n* 2020.11 2020 全球移动开发者峰会 & GDG Kotlin Day: **[Kotlin多平台在移动端应用与展望](https://live.csdn.net/room/zxff716/Dl55vGUZ)**\n* 2020.05 2020 GDG Android 11 Meetup: **[Kotlin 协程那些事儿](https://www.bilibili.com/video/BV1MV411z7pM)**\n* 2018.11 2018 JetBrains 北京开发者大会: **[如何优雅的使用 Data Class](https://v.qq.com/x/page/n08227okqh9.html)**\n* 2017.11 2017 Android 技术大会: **[效率的抉择 - 将 Kotlin 投入 Android 应用开发当中 ](http://play.itdks.com/watch/3740769?player=)**\n\n# 相关网站\n\n* **个人主页**：https://www.bennyhuo.com\n* **GitHub**：https://github.com/bennyhuo\n* **[Kotlin 中文官网](https://www.kotlincn.net)**: 同步翻译官网，为国内开发者提供最权威的参考资料\n* **[Kotlin 中文博客](https://www.kotliner.cn)**: 同步翻译博客，为国内开发者提供最新的 Kotlin 官方动态\n* **[Kotlin 中文论坛](https://discuss.kotliner.cn)**: 提供讨论的平台，方便 Kotlin 爱好者交流\n\n","updated":"2021-05-01T08:05:32.940Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckohi002p0000lduz7dqn7gwb","content":"<h1 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h1><ul>\n<li>前腾讯客户端高级工程师，团队负责人</li>\n<li>Kotlin 布道师/社区组织者</li>\n<li><strong>微信公众号：Kotlin</strong>：2016年10月至今，专注于 Kotlin 技术布道</li>\n<li><strong>bilibili：<a href=\"https://space.bilibili.com/28615855\">bennyhuo 不是算命的</a></strong></li>\n<li><strong>知乎：<a href=\"https://www.zhihu.com/people/bennyhuo\">bennyhuo</a></strong></li>\n</ul>\n<h1 id=\"技术书籍\"><a href=\"#技术书籍\" class=\"headerlink\" title=\"技术书籍\"></a>技术书籍</h1><ul>\n<li>2020.06 <strong><a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a></strong></li>\n</ul>\n<h1 id=\"教学视频\"><a href=\"#教学视频\" class=\"headerlink\" title=\"教学视频\"></a>教学视频</h1><ul>\n<li>2020.11 慕课网: <strong><a href=\"https://coding.imooc.com/class/463.html\">C 语言系统精讲</a></strong></li>\n<li>2019.11 慕课网: <strong><a href=\"https://coding.imooc.com/class/398.html\">新版 Kotlin 入门到精通</a></strong></li>\n<li>2019.04 慕课网: <strong><a href=\"https://www.imooc.com/learn/1128\">破解 Retrofit</a></strong></li>\n<li>2019.02 慕课网: <strong><a href=\"https://coding.imooc.com/class/317.html\">破解Android高级面试</a></strong></li>\n<li>2018.10 哔哩哔哩: <strong><a href=\"https://www.bilibili.com/video/BV1RW411m7Hk/\">注解处理器教程</a></strong></li>\n<li>2018.06 慕课网: <strong><a href=\"https://coding.imooc.com/class/232.html\">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a></strong></li>\n<li>2017.06 慕课网: <strong><a href=\"http://coding.imooc.com/class/108.html\">Kotlin 系统入门到进阶</a></strong></li>\n<li>2016.10 <strong><a href=\"https://github.com/enbandari/Kotlin-Tutorials\">Kotlin 入门到放弃</a></strong></li>\n</ul>\n<h1 id=\"大会分享\"><a href=\"#大会分享\" class=\"headerlink\" title=\"大会分享\"></a>大会分享</h1><ul>\n<li>2020.11 2020 全球移动开发者峰会 &amp; GDG Kotlin Day: <strong><a href=\"https://live.csdn.net/room/zxff716/Dl55vGUZ\">Kotlin多平台在移动端应用与展望</a></strong></li>\n<li>2020.05 2020 GDG Android 11 Meetup: <strong><a href=\"https://www.bilibili.com/video/BV1MV411z7pM\">Kotlin 协程那些事儿</a></strong></li>\n<li>2018.11 2018 JetBrains 北京开发者大会: <strong><a href=\"https://v.qq.com/x/page/n08227okqh9.html\">如何优雅的使用 Data Class</a></strong></li>\n<li>2017.11 2017 Android 技术大会: <strong><a href=\"http://play.itdks.com/watch/3740769?player=\">效率的抉择 - 将 Kotlin 投入 Android 应用开发当中 </a></strong></li>\n</ul>\n<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><ul>\n<li><strong>个人主页</strong>：<a href=\"https://www.bennyhuo.com/\">https://www.bennyhuo.com</a></li>\n<li><strong>GitHub</strong>：<a href=\"https://github.com/bennyhuo\">https://github.com/bennyhuo</a></li>\n<li><strong><a href=\"https://www.kotlincn.net/\">Kotlin 中文官网</a></strong>: 同步翻译官网，为国内开发者提供最权威的参考资料</li>\n<li><strong><a href=\"https://www.kotliner.cn/\">Kotlin 中文博客</a></strong>: 同步翻译博客，为国内开发者提供最新的 Kotlin 官方动态</li>\n<li><strong><a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a></strong>: 提供讨论的平台，方便 Kotlin 爱好者交流</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h1><ul>\n<li>前腾讯客户端高级工程师，团队负责人</li>\n<li>Kotlin 布道师/社区组织者</li>\n<li><strong>微信公众号：Kotlin</strong>：2016年10月至今，专注于 Kotlin 技术布道</li>\n<li><strong>bilibili：<a href=\"https://space.bilibili.com/28615855\">bennyhuo 不是算命的</a></strong></li>\n<li><strong>知乎：<a href=\"https://www.zhihu.com/people/bennyhuo\">bennyhuo</a></strong></li>\n</ul>\n<h1 id=\"技术书籍\"><a href=\"#技术书籍\" class=\"headerlink\" title=\"技术书籍\"></a>技术书籍</h1><ul>\n<li>2020.06 <strong><a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a></strong></li>\n</ul>\n<h1 id=\"教学视频\"><a href=\"#教学视频\" class=\"headerlink\" title=\"教学视频\"></a>教学视频</h1><ul>\n<li>2020.11 慕课网: <strong><a href=\"https://coding.imooc.com/class/463.html\">C 语言系统精讲</a></strong></li>\n<li>2019.11 慕课网: <strong><a href=\"https://coding.imooc.com/class/398.html\">新版 Kotlin 入门到精通</a></strong></li>\n<li>2019.04 慕课网: <strong><a href=\"https://www.imooc.com/learn/1128\">破解 Retrofit</a></strong></li>\n<li>2019.02 慕课网: <strong><a href=\"https://coding.imooc.com/class/317.html\">破解Android高级面试</a></strong></li>\n<li>2018.10 哔哩哔哩: <strong><a href=\"https://www.bilibili.com/video/BV1RW411m7Hk/\">注解处理器教程</a></strong></li>\n<li>2018.06 慕课网: <strong><a href=\"https://coding.imooc.com/class/232.html\">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a></strong></li>\n<li>2017.06 慕课网: <strong><a href=\"http://coding.imooc.com/class/108.html\">Kotlin 系统入门到进阶</a></strong></li>\n<li>2016.10 <strong><a href=\"https://github.com/enbandari/Kotlin-Tutorials\">Kotlin 入门到放弃</a></strong></li>\n</ul>\n<h1 id=\"大会分享\"><a href=\"#大会分享\" class=\"headerlink\" title=\"大会分享\"></a>大会分享</h1><ul>\n<li>2020.11 2020 全球移动开发者峰会 &amp; GDG Kotlin Day: <strong><a href=\"https://live.csdn.net/room/zxff716/Dl55vGUZ\">Kotlin多平台在移动端应用与展望</a></strong></li>\n<li>2020.05 2020 GDG Android 11 Meetup: <strong><a href=\"https://www.bilibili.com/video/BV1MV411z7pM\">Kotlin 协程那些事儿</a></strong></li>\n<li>2018.11 2018 JetBrains 北京开发者大会: <strong><a href=\"https://v.qq.com/x/page/n08227okqh9.html\">如何优雅的使用 Data Class</a></strong></li>\n<li>2017.11 2017 Android 技术大会: <strong><a href=\"http://play.itdks.com/watch/3740769?player=\">效率的抉择 - 将 Kotlin 投入 Android 应用开发当中 </a></strong></li>\n</ul>\n<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><ul>\n<li><strong>个人主页</strong>：<a href=\"https://www.bennyhuo.com/\">https://www.bennyhuo.com</a></li>\n<li><strong>GitHub</strong>：<a href=\"https://github.com/bennyhuo\">https://github.com/bennyhuo</a></li>\n<li><strong><a href=\"https://www.kotlincn.net/\">Kotlin 中文官网</a></strong>: 同步翻译官网，为国内开发者提供最权威的参考资料</li>\n<li><strong><a href=\"https://www.kotliner.cn/\">Kotlin 中文博客</a></strong>: 同步翻译博客，为国内开发者提供最新的 Kotlin 官方动态</li>\n<li><strong><a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a></strong>: 提供讨论的平台，方便 Kotlin 爱好者交流</li>\n</ul>\n"},{"title":"项目清单","date":"2020-02-26T01:01:40.000Z","type":"project","comments":0,"_content":"# 项目清单\n\n* [深入理解 Kotlin 协程](kotlin-coroutines.html)","source":"project/index.md","raw":"---\ntitle: 项目清单\ndate: 2020-02-26 09:01:40\ntype: \"project\"\ncomments: false\n---\n# 项目清单\n\n* [深入理解 Kotlin 协程](kotlin-coroutines.html)","updated":"2021-04-26T13:56:20.240Z","path":"project/index.html","layout":"page","_id":"ckohi002s0002lduzhut6eyq2","content":"<h1 id=\"项目清单\"><a href=\"#项目清单\" class=\"headerlink\" title=\"项目清单\"></a>项目清单</h1><ul>\n<li><a href=\"kotlin-coroutines.html\">深入理解 Kotlin 协程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"项目清单\"><a href=\"#项目清单\" class=\"headerlink\" title=\"项目清单\"></a>项目清单</h1><ul>\n<li><a href=\"kotlin-coroutines.html\">深入理解 Kotlin 协程</a></li>\n</ul>\n"},{"title":"深入理解 Kotlin 协程","_content":"\n## 本书内容\n\n这是一部从工作机制、实现原理、应用场景、使用方法、实践技巧、标准库、框架、应用案例等多个维度全面讲解Kotlin协程的专著，它同时提供了多语言视角，亦可通过本书了解其他语言的协程。\n\n全书共9章：\n\n第1章从协程的核心应用场景——异步程序设计的思路和关键问题切入，引出Kotlin协程的概念；\n\n第2章首先介绍了协程的概念、分类，然后讲解了Python、Lua、Go等不同语言的协程实现和对比；\n\n第3~4章以 Kotlin 标准库的协程 API 为核心，讲解了简单协程的使用方法和运行机制，以及通过简单协程设计和实现复合协程的思路和方法；\n\n第5~6章以Kotlin的官方协程框架为模板，通过逐步实现其中的核心功能，分析了其中的实现细节和复合协程的运行机制，并对框架的使用做了深入探讨；\n\n第7~8章讲解了协程在Android应用开发和Web服务开发中的应用场景、面临的挑战，以及解决各种常见问题的方法和思路；\n\n第9章探讨了JavaScript 和 Native等非JVM平台对协程的支持情况，以及协程在这些平台上的应用。\n\n## 反馈方式\n\n感谢大家的关注和支持，如果在阅读过程中遇到问题，欢迎大家选择以下方式与我联系并提供尽可能详细的信息，以便于你的问题能够得到快速的解答：\n\n* 在本页面下方直接发布评论\n* 发送邮件至 [bennyhuo@kotliner.cn](mailto:bennyhuo@kotliner.cn)\n* 在 [Kotlin 中文论坛](https://discuss.kotliner.cn/) 发布问题\n\n另外，为了方便大家交流，创建读者 QQ 群：612797230，欢迎大家加入~\n\n## 随书源码\n\n本书**源码地址**：[《深入理解 Kotlin 协程》源码](https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources)\n\n## 购买途径\n\n* 京东自营：[深入理解Kotlin协程](https://item.jd.com/12898592.html)\n* 当当自营：[深入理解Kotlin协程](http://product.dangdang.com/28973005.html)\n\n## 本书批注\n\n为便于读者理解，针对大家提出疑问的部分附加说明如下：\n\n页码 | 原文 | 说明 \n---------|----------|--------- \n153 | 还可以通过 onEach 来做到这一点 ... collect 函数可以放到其他任意位置调用 | collect 函数有一个重载版本可以同时消费 flow，如果用 onEach 消费 flow，则可以在任意位置调用 collect 的无参版本直接激活 flow 而无需考虑消费的问题。 \n\n## 本书勘误\n\n以下为本书勘误，感谢各位读者的支持！\n\n页码 | 发现版本 | 原内容 | 修改为 | 致谢 \n---------| ---------|----------|--------- | ------\n 38 | 2020.6 | 在代码清单 3-<font color=\"red\">8</font> 的①处 | 在代码清单 3-**7** 的①处 | 论坛 ID： [jkwar](https://discuss.kotliner.cn/u/jkwar/summary)\n 45 | 2020.10 | 都会异步挂起（见代码清单 3-<font color=\"red\">8</font> ） | 都会异步挂起（见代码清单 3-**7** ） | [silladus](mailto:silladus@163.com)\n 85 | 2020.6 | block.startCoroutine(completion<font color=\"red\">, completion</font>) | block.startCoroutine(completion) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n 91 | 2020.6 | block.startCoroutine(completion<font color=\"red\">, completion</font>) | block.startCoroutine(completion) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n105 | 2020.6 | <font color=\"red\">resumeWith Exception</font> | resumeWithException | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n106 | 2020.6 | 在引入取消响应的概念之前，所有的挂起函数都不支持<font color=\"red\">挂起</font> | 在引入取消响应的概念之前，所有的挂起函数都不支持**取消** | 论坛 ID： [zaze8736](https://discuss.kotliner.cn/u/zaze8736/summary)\n124 | 2020.6 | Kotlin 协程的官方框架 <font color=\"red\">kotlin.coroutines</font> 是一套独立于标准库之外的... | Kotlin 协程的官方框架 kotlin**x**.coroutines 是一套独立于标准库之外的... | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n142 | 2020.6 | val broadcastChannel = <font color=\"red\">b</font>roadCastChannel<Int>(5) | val broadcastChannel = **B**roadCastChannel<Int>(5) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n148 | 2020.10 | 当然这个过程稍<font color=\"red\">些</font>复杂 | 当然这个过程稍显复杂 | huml\n161 | 2020.10 | 那么 onJoin 就是 SelectClause<font color=\"red\">N</font>类型 | 那么 onJoin 就是 SelectClause0 类型 | huml\n205 | 2020.6 | 包括浏览器上的 window<font color=\"red\">s</font> 和 document | 包括浏览器上的 **window** 和 document | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n209 | 2020.6 | window<font color=\"red\">s</font>.asCoroutineDispatcher | **window**.asCoroutineDispatcher | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n\n> **说明：**\n>  1. 2020.6 版本的问题已经在 2020.10 版修正。\n>  2. 2020.10 版本的问题计划在 2021.7 版修正。","source":"project/kotlin-coroutines.md","raw":"---\ntitle: 深入理解 Kotlin 协程\n---\n\n## 本书内容\n\n这是一部从工作机制、实现原理、应用场景、使用方法、实践技巧、标准库、框架、应用案例等多个维度全面讲解Kotlin协程的专著，它同时提供了多语言视角，亦可通过本书了解其他语言的协程。\n\n全书共9章：\n\n第1章从协程的核心应用场景——异步程序设计的思路和关键问题切入，引出Kotlin协程的概念；\n\n第2章首先介绍了协程的概念、分类，然后讲解了Python、Lua、Go等不同语言的协程实现和对比；\n\n第3~4章以 Kotlin 标准库的协程 API 为核心，讲解了简单协程的使用方法和运行机制，以及通过简单协程设计和实现复合协程的思路和方法；\n\n第5~6章以Kotlin的官方协程框架为模板，通过逐步实现其中的核心功能，分析了其中的实现细节和复合协程的运行机制，并对框架的使用做了深入探讨；\n\n第7~8章讲解了协程在Android应用开发和Web服务开发中的应用场景、面临的挑战，以及解决各种常见问题的方法和思路；\n\n第9章探讨了JavaScript 和 Native等非JVM平台对协程的支持情况，以及协程在这些平台上的应用。\n\n## 反馈方式\n\n感谢大家的关注和支持，如果在阅读过程中遇到问题，欢迎大家选择以下方式与我联系并提供尽可能详细的信息，以便于你的问题能够得到快速的解答：\n\n* 在本页面下方直接发布评论\n* 发送邮件至 [bennyhuo@kotliner.cn](mailto:bennyhuo@kotliner.cn)\n* 在 [Kotlin 中文论坛](https://discuss.kotliner.cn/) 发布问题\n\n另外，为了方便大家交流，创建读者 QQ 群：612797230，欢迎大家加入~\n\n## 随书源码\n\n本书**源码地址**：[《深入理解 Kotlin 协程》源码](https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources)\n\n## 购买途径\n\n* 京东自营：[深入理解Kotlin协程](https://item.jd.com/12898592.html)\n* 当当自营：[深入理解Kotlin协程](http://product.dangdang.com/28973005.html)\n\n## 本书批注\n\n为便于读者理解，针对大家提出疑问的部分附加说明如下：\n\n页码 | 原文 | 说明 \n---------|----------|--------- \n153 | 还可以通过 onEach 来做到这一点 ... collect 函数可以放到其他任意位置调用 | collect 函数有一个重载版本可以同时消费 flow，如果用 onEach 消费 flow，则可以在任意位置调用 collect 的无参版本直接激活 flow 而无需考虑消费的问题。 \n\n## 本书勘误\n\n以下为本书勘误，感谢各位读者的支持！\n\n页码 | 发现版本 | 原内容 | 修改为 | 致谢 \n---------| ---------|----------|--------- | ------\n 38 | 2020.6 | 在代码清单 3-<font color=\"red\">8</font> 的①处 | 在代码清单 3-**7** 的①处 | 论坛 ID： [jkwar](https://discuss.kotliner.cn/u/jkwar/summary)\n 45 | 2020.10 | 都会异步挂起（见代码清单 3-<font color=\"red\">8</font> ） | 都会异步挂起（见代码清单 3-**7** ） | [silladus](mailto:silladus@163.com)\n 85 | 2020.6 | block.startCoroutine(completion<font color=\"red\">, completion</font>) | block.startCoroutine(completion) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n 91 | 2020.6 | block.startCoroutine(completion<font color=\"red\">, completion</font>) | block.startCoroutine(completion) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n105 | 2020.6 | <font color=\"red\">resumeWith Exception</font> | resumeWithException | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n106 | 2020.6 | 在引入取消响应的概念之前，所有的挂起函数都不支持<font color=\"red\">挂起</font> | 在引入取消响应的概念之前，所有的挂起函数都不支持**取消** | 论坛 ID： [zaze8736](https://discuss.kotliner.cn/u/zaze8736/summary)\n124 | 2020.6 | Kotlin 协程的官方框架 <font color=\"red\">kotlin.coroutines</font> 是一套独立于标准库之外的... | Kotlin 协程的官方框架 kotlin**x**.coroutines 是一套独立于标准库之外的... | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n142 | 2020.6 | val broadcastChannel = <font color=\"red\">b</font>roadCastChannel<Int>(5) | val broadcastChannel = **B**roadCastChannel<Int>(5) | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n148 | 2020.10 | 当然这个过程稍<font color=\"red\">些</font>复杂 | 当然这个过程稍显复杂 | huml\n161 | 2020.10 | 那么 onJoin 就是 SelectClause<font color=\"red\">N</font>类型 | 那么 onJoin 就是 SelectClause0 类型 | huml\n205 | 2020.6 | 包括浏览器上的 window<font color=\"red\">s</font> 和 document | 包括浏览器上的 **window** 和 document | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n209 | 2020.6 | window<font color=\"red\">s</font>.asCoroutineDispatcher | **window**.asCoroutineDispatcher | 论坛 ID： [llt](https://discuss.kotliner.cn/u/llt/summary)\n\n> **说明：**\n>  1. 2020.6 版本的问题已经在 2020.10 版修正。\n>  2. 2020.10 版本的问题计划在 2021.7 版修正。","date":"2021-07-28T23:38:40.200Z","updated":"2021-07-28T23:38:40.200Z","path":"project/kotlin-coroutines.html","_id":"ckohi002v0005lduz1ky4fbpb","comments":1,"layout":"page","content":"<h2 id=\"本书内容\"><a href=\"#本书内容\" class=\"headerlink\" title=\"本书内容\"></a>本书内容</h2><p>这是一部从工作机制、实现原理、应用场景、使用方法、实践技巧、标准库、框架、应用案例等多个维度全面讲解Kotlin协程的专著，它同时提供了多语言视角，亦可通过本书了解其他语言的协程。</p>\n<p>全书共9章：</p>\n<p>第1章从协程的核心应用场景——异步程序设计的思路和关键问题切入，引出Kotlin协程的概念；</p>\n<p>第2章首先介绍了协程的概念、分类，然后讲解了Python、Lua、Go等不同语言的协程实现和对比；</p>\n<p>第3~4章以 Kotlin 标准库的协程 API 为核心，讲解了简单协程的使用方法和运行机制，以及通过简单协程设计和实现复合协程的思路和方法；</p>\n<p>第5~6章以Kotlin的官方协程框架为模板，通过逐步实现其中的核心功能，分析了其中的实现细节和复合协程的运行机制，并对框架的使用做了深入探讨；</p>\n<p>第7~8章讲解了协程在Android应用开发和Web服务开发中的应用场景、面临的挑战，以及解决各种常见问题的方法和思路；</p>\n<p>第9章探讨了JavaScript 和 Native等非JVM平台对协程的支持情况，以及协程在这些平台上的应用。</p>\n<h2 id=\"反馈方式\"><a href=\"#反馈方式\" class=\"headerlink\" title=\"反馈方式\"></a>反馈方式</h2><p>感谢大家的关注和支持，如果在阅读过程中遇到问题，欢迎大家选择以下方式与我联系并提供尽可能详细的信息，以便于你的问题能够得到快速的解答：</p>\n<ul>\n<li>在本页面下方直接发布评论</li>\n<li>发送邮件至 <a href=\"mailto:bennyhuo@kotliner.cn\">bennyhuo@kotliner.cn</a></li>\n<li>在 <a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a> 发布问题</li>\n</ul>\n<p>另外，为了方便大家交流，创建读者 QQ 群：612797230，欢迎大家加入~</p>\n<h2 id=\"随书源码\"><a href=\"#随书源码\" class=\"headerlink\" title=\"随书源码\"></a>随书源码</h2><p>本书<strong>源码地址</strong>：<a href=\"https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources\">《深入理解 Kotlin 协程》源码</a></p>\n<h2 id=\"购买途径\"><a href=\"#购买途径\" class=\"headerlink\" title=\"购买途径\"></a>购买途径</h2><ul>\n<li>京东自营：<a href=\"https://item.jd.com/12898592.html\">深入理解Kotlin协程</a></li>\n<li>当当自营：<a href=\"http://product.dangdang.com/28973005.html\">深入理解Kotlin协程</a></li>\n</ul>\n<h2 id=\"本书批注\"><a href=\"#本书批注\" class=\"headerlink\" title=\"本书批注\"></a>本书批注</h2><p>为便于读者理解，针对大家提出疑问的部分附加说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>页码</th>\n<th>原文</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>153</td>\n<td>还可以通过 onEach 来做到这一点 … collect 函数可以放到其他任意位置调用</td>\n<td>collect 函数有一个重载版本可以同时消费 flow，如果用 onEach 消费 flow，则可以在任意位置调用 collect 的无参版本直接激活 flow 而无需考虑消费的问题。</td>\n</tr>\n</tbody></table>\n<h2 id=\"本书勘误\"><a href=\"#本书勘误\" class=\"headerlink\" title=\"本书勘误\"></a>本书勘误</h2><p>以下为本书勘误，感谢各位读者的支持！</p>\n<table>\n<thead>\n<tr>\n<th>页码</th>\n<th>发现版本</th>\n<th>原内容</th>\n<th>修改为</th>\n<th>致谢</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>38</td>\n<td>2020.6</td>\n<td>在代码清单 3-<font color=\"red\">8</font> 的①处</td>\n<td>在代码清单 3-<strong>7</strong> 的①处</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/jkwar/summary\">jkwar</a></td>\n</tr>\n<tr>\n<td>45</td>\n<td>2020.10</td>\n<td>都会异步挂起（见代码清单 3-<font color=\"red\">8</font> ）</td>\n<td>都会异步挂起（见代码清单 3-<strong>7</strong> ）</td>\n<td><a href=\"mailto:silladus@163.com\">silladus</a></td>\n</tr>\n<tr>\n<td>85</td>\n<td>2020.6</td>\n<td>block.startCoroutine(completion<font color=\"red\">, completion</font>)</td>\n<td>block.startCoroutine(completion)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>91</td>\n<td>2020.6</td>\n<td>block.startCoroutine(completion<font color=\"red\">, completion</font>)</td>\n<td>block.startCoroutine(completion)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>105</td>\n<td>2020.6</td>\n<td><font color=\"red\">resumeWith Exception</font></td>\n<td>resumeWithException</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>106</td>\n<td>2020.6</td>\n<td>在引入取消响应的概念之前，所有的挂起函数都不支持<font color=\"red\">挂起</font></td>\n<td>在引入取消响应的概念之前，所有的挂起函数都不支持<strong>取消</strong></td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/zaze8736/summary\">zaze8736</a></td>\n</tr>\n<tr>\n<td>124</td>\n<td>2020.6</td>\n<td>Kotlin 协程的官方框架 <font color=\"red\">kotlin.coroutines</font> 是一套独立于标准库之外的…</td>\n<td>Kotlin 协程的官方框架 kotlin<strong>x</strong>.coroutines 是一套独立于标准库之外的…</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>142</td>\n<td>2020.6</td>\n<td>val broadcastChannel = <font color=\"red\">b</font>roadCastChannel<Int>(5)</td>\n<td>val broadcastChannel = <strong>B</strong>roadCastChannel<Int>(5)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>148</td>\n<td>2020.10</td>\n<td>当然这个过程稍<font color=\"red\">些</font>复杂</td>\n<td>当然这个过程稍显复杂</td>\n<td>huml</td>\n</tr>\n<tr>\n<td>161</td>\n<td>2020.10</td>\n<td>那么 onJoin 就是 SelectClause<font color=\"red\">N</font>类型</td>\n<td>那么 onJoin 就是 SelectClause0 类型</td>\n<td>huml</td>\n</tr>\n<tr>\n<td>205</td>\n<td>2020.6</td>\n<td>包括浏览器上的 window<font color=\"red\">s</font> 和 document</td>\n<td>包括浏览器上的 <strong>window</strong> 和 document</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>209</td>\n<td>2020.6</td>\n<td>window<font color=\"red\">s</font>.asCoroutineDispatcher</td>\n<td><strong>window</strong>.asCoroutineDispatcher</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>说明：</strong></p>\n<ol>\n<li>2020.6 版本的问题已经在 2020.10 版修正。</li>\n<li>2020.10 版本的问题计划在 2021.7 版修正。</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"本书内容\"><a href=\"#本书内容\" class=\"headerlink\" title=\"本书内容\"></a>本书内容</h2><p>这是一部从工作机制、实现原理、应用场景、使用方法、实践技巧、标准库、框架、应用案例等多个维度全面讲解Kotlin协程的专著，它同时提供了多语言视角，亦可通过本书了解其他语言的协程。</p>\n<p>全书共9章：</p>\n<p>第1章从协程的核心应用场景——异步程序设计的思路和关键问题切入，引出Kotlin协程的概念；</p>\n<p>第2章首先介绍了协程的概念、分类，然后讲解了Python、Lua、Go等不同语言的协程实现和对比；</p>\n<p>第3~4章以 Kotlin 标准库的协程 API 为核心，讲解了简单协程的使用方法和运行机制，以及通过简单协程设计和实现复合协程的思路和方法；</p>\n<p>第5~6章以Kotlin的官方协程框架为模板，通过逐步实现其中的核心功能，分析了其中的实现细节和复合协程的运行机制，并对框架的使用做了深入探讨；</p>\n<p>第7~8章讲解了协程在Android应用开发和Web服务开发中的应用场景、面临的挑战，以及解决各种常见问题的方法和思路；</p>\n<p>第9章探讨了JavaScript 和 Native等非JVM平台对协程的支持情况，以及协程在这些平台上的应用。</p>\n<h2 id=\"反馈方式\"><a href=\"#反馈方式\" class=\"headerlink\" title=\"反馈方式\"></a>反馈方式</h2><p>感谢大家的关注和支持，如果在阅读过程中遇到问题，欢迎大家选择以下方式与我联系并提供尽可能详细的信息，以便于你的问题能够得到快速的解答：</p>\n<ul>\n<li>在本页面下方直接发布评论</li>\n<li>发送邮件至 <a href=\"mailto:bennyhuo@kotliner.cn\">bennyhuo@kotliner.cn</a></li>\n<li>在 <a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a> 发布问题</li>\n</ul>\n<p>另外，为了方便大家交流，创建读者 QQ 群：612797230，欢迎大家加入~</p>\n<h2 id=\"随书源码\"><a href=\"#随书源码\" class=\"headerlink\" title=\"随书源码\"></a>随书源码</h2><p>本书<strong>源码地址</strong>：<a href=\"https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources\">《深入理解 Kotlin 协程》源码</a></p>\n<h2 id=\"购买途径\"><a href=\"#购买途径\" class=\"headerlink\" title=\"购买途径\"></a>购买途径</h2><ul>\n<li>京东自营：<a href=\"https://item.jd.com/12898592.html\">深入理解Kotlin协程</a></li>\n<li>当当自营：<a href=\"http://product.dangdang.com/28973005.html\">深入理解Kotlin协程</a></li>\n</ul>\n<h2 id=\"本书批注\"><a href=\"#本书批注\" class=\"headerlink\" title=\"本书批注\"></a>本书批注</h2><p>为便于读者理解，针对大家提出疑问的部分附加说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>页码</th>\n<th>原文</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>153</td>\n<td>还可以通过 onEach 来做到这一点 … collect 函数可以放到其他任意位置调用</td>\n<td>collect 函数有一个重载版本可以同时消费 flow，如果用 onEach 消费 flow，则可以在任意位置调用 collect 的无参版本直接激活 flow 而无需考虑消费的问题。</td>\n</tr>\n</tbody></table>\n<h2 id=\"本书勘误\"><a href=\"#本书勘误\" class=\"headerlink\" title=\"本书勘误\"></a>本书勘误</h2><p>以下为本书勘误，感谢各位读者的支持！</p>\n<table>\n<thead>\n<tr>\n<th>页码</th>\n<th>发现版本</th>\n<th>原内容</th>\n<th>修改为</th>\n<th>致谢</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>38</td>\n<td>2020.6</td>\n<td>在代码清单 3-<font color=\"red\">8</font> 的①处</td>\n<td>在代码清单 3-<strong>7</strong> 的①处</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/jkwar/summary\">jkwar</a></td>\n</tr>\n<tr>\n<td>45</td>\n<td>2020.10</td>\n<td>都会异步挂起（见代码清单 3-<font color=\"red\">8</font> ）</td>\n<td>都会异步挂起（见代码清单 3-<strong>7</strong> ）</td>\n<td><a href=\"mailto:silladus@163.com\">silladus</a></td>\n</tr>\n<tr>\n<td>85</td>\n<td>2020.6</td>\n<td>block.startCoroutine(completion<font color=\"red\">, completion</font>)</td>\n<td>block.startCoroutine(completion)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>91</td>\n<td>2020.6</td>\n<td>block.startCoroutine(completion<font color=\"red\">, completion</font>)</td>\n<td>block.startCoroutine(completion)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>105</td>\n<td>2020.6</td>\n<td><font color=\"red\">resumeWith Exception</font></td>\n<td>resumeWithException</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>106</td>\n<td>2020.6</td>\n<td>在引入取消响应的概念之前，所有的挂起函数都不支持<font color=\"red\">挂起</font></td>\n<td>在引入取消响应的概念之前，所有的挂起函数都不支持<strong>取消</strong></td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/zaze8736/summary\">zaze8736</a></td>\n</tr>\n<tr>\n<td>124</td>\n<td>2020.6</td>\n<td>Kotlin 协程的官方框架 <font color=\"red\">kotlin.coroutines</font> 是一套独立于标准库之外的…</td>\n<td>Kotlin 协程的官方框架 kotlin<strong>x</strong>.coroutines 是一套独立于标准库之外的…</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>142</td>\n<td>2020.6</td>\n<td>val broadcastChannel = <font color=\"red\">b</font>roadCastChannel<Int>(5)</td>\n<td>val broadcastChannel = <strong>B</strong>roadCastChannel<Int>(5)</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>148</td>\n<td>2020.10</td>\n<td>当然这个过程稍<font color=\"red\">些</font>复杂</td>\n<td>当然这个过程稍显复杂</td>\n<td>huml</td>\n</tr>\n<tr>\n<td>161</td>\n<td>2020.10</td>\n<td>那么 onJoin 就是 SelectClause<font color=\"red\">N</font>类型</td>\n<td>那么 onJoin 就是 SelectClause0 类型</td>\n<td>huml</td>\n</tr>\n<tr>\n<td>205</td>\n<td>2020.6</td>\n<td>包括浏览器上的 window<font color=\"red\">s</font> 和 document</td>\n<td>包括浏览器上的 <strong>window</strong> 和 document</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n<tr>\n<td>209</td>\n<td>2020.6</td>\n<td>window<font color=\"red\">s</font>.asCoroutineDispatcher</td>\n<td><strong>window</strong>.asCoroutineDispatcher</td>\n<td>论坛 ID： <a href=\"https://discuss.kotliner.cn/u/llt/summary\">llt</a></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>说明：</strong></p>\n<ol>\n<li>2020.6 版本的问题已经在 2020.10 版修正。</li>\n<li>2020.10 版本的问题计划在 2021.7 版修正。</li>\n</ol>\n</blockquote>\n"},{"title":"标签","date":"2020-02-26T01:01:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-02-26 09:01:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2021-04-26T13:56:20.240Z","path":"tags/index.html","layout":"page","_id":"ckohi002w0007lduz3r9hckk6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018 JetBrains 开发者大会见闻","date":"2018-11-17T16:00:00.000Z","_content":"\n> 难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。\n\n话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg)\n\n<!--more-->\n\n大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。\n\n开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）\n\nJetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg)\n\n\n印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg)\n\n还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。\n\n干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 bennyhuo@kotliner.cn）。\n\nHadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。\n\n中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg)\n\n\n因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||\n\n讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T\n\n整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。\n\nHadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg)\n\n还有一个是 Nyan 进度条的插件，很有趣：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg)\n\n来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：\n\n```kotlin\ninterface Api{\n    @GET(\"https://api.github.com/users/jetbrains\")\n    suspend fun getJetBrains(): GitUser\n}\n```\n\n当然，现在我们也可以用 `Deferred` 来接入：\n\n```kotlin\ninterface Api{\n    @GET(\"https://api.github.com/users/jetbrains\")\n    fun getJetBrains(): Deferred<GitUser>\n}\n```\n\n之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。\n\n听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)\n\n不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！\n\n下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg)\n\n\n\n这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~\n\n\nPS：茶歇的小饼干也很好吃啊！\n\n---\n\n下午第一场 \"如何优雅地使用数据类\" 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~\n\n链接：https://share.weiyun.com/5YMPoL4 密码：sz4vyw\n\n---\n\nKotlin 中文站：https://www.kotlincn.net\nKotlin 中文博客：https://www.kotliner.cn\nKotlin 中文论坛：https://discuss.kotliner.cn\nKtor 中文站：https://ktor.kotlincn.net\n\n---\n欢迎关注：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n\n","source":"_posts/2018-JetBrains-Day.md","raw":"---\ntitle: 2018 JetBrains 开发者大会见闻\ndate: 2018/11/18\ntags:\n  - JetBrains\n  - News\n---\n\n> 难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。\n\n话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg)\n\n<!--more-->\n\n大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。\n\n开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）\n\nJetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg)\n\n\n印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg)\n\n还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。\n\n干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 bennyhuo@kotliner.cn）。\n\nHadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。\n\n中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg)\n\n\n因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||\n\n讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T\n\n整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。\n\nHadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg)\n\n还有一个是 Nyan 进度条的插件，很有趣：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg)\n\n来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：\n\n```kotlin\ninterface Api{\n    @GET(\"https://api.github.com/users/jetbrains\")\n    suspend fun getJetBrains(): GitUser\n}\n```\n\n当然，现在我们也可以用 `Deferred` 来接入：\n\n```kotlin\ninterface Api{\n    @GET(\"https://api.github.com/users/jetbrains\")\n    fun getJetBrains(): Deferred<GitUser>\n}\n```\n\n之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。\n\n听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)\n\n不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！\n\n下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg)\n\n\n\n这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~\n\n\nPS：茶歇的小饼干也很好吃啊！\n\n---\n\n下午第一场 \"如何优雅地使用数据类\" 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~\n\n链接：https://share.weiyun.com/5YMPoL4 密码：sz4vyw\n\n---\n\nKotlin 中文站：https://www.kotlincn.net\nKotlin 中文博客：https://www.kotliner.cn\nKotlin 中文论坛：https://discuss.kotliner.cn\nKtor 中文站：https://ktor.kotlincn.net\n\n---\n欢迎关注：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n\n","slug":"2018-JetBrains-Day","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002q0001lduz5cxwam4m","content":"<blockquote>\n<p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p>\n</blockquote>\n<p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg\"></p>\n<span id=\"more\"></span>\n\n<p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p>\n<p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p>\n<p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg\"></p>\n<p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg\"></p>\n<p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p>\n<p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href=\"mailto:&#x62;&#101;&#110;&#110;&#x79;&#104;&#117;&#111;&#x40;&#x6b;&#111;&#116;&#x6c;&#105;&#110;&#x65;&#x72;&#46;&#99;&#110;\">&#x62;&#101;&#110;&#110;&#x79;&#104;&#117;&#111;&#x40;&#x6b;&#111;&#116;&#x6c;&#105;&#110;&#x65;&#x72;&#46;&#99;&#110;</a>）。</p>\n<p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p>\n<p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg\"></p>\n<p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p>\n<p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p>\n<p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p>\n<p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg\"></p>\n<p>还有一个是 Nyan 进度条的插件，很有趣：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg\"></p>\n<p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getJetBrains</span><span class=\"params\">()</span></span>: GitUser</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getJetBrains</span><span class=\"params\">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p>\n<p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p>\n<p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p>\n<p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg\"></p>\n<p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p>\n<p>PS：茶歇的小饼干也很好吃啊！</p>\n<hr>\n<p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p>\n<p>链接：<a href=\"https://share.weiyun.com/5YMPoL4\">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p>\n<hr>\n<p>Kotlin 中文站：<a href=\"https://www.kotlincn.net/\">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href=\"https://www.kotliner.cn/\">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href=\"https://discuss.kotliner.cn/\">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href=\"https://ktor.kotlincn.net/\">https://ktor.kotlincn.net</a></p>\n<hr>\n<p>欢迎关注：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>难得取了这么正经的一个题目，根本不是我的风格啊︿(￣︶￣)︿。</p>\n</blockquote>\n<p>话说昨天去参加了一下 JetBrains 的开发者大会，因为我把钱都充点券买皮肤了，买不起门票(￣.￣)，所以就选择在下午分会场做了一个 Kotlin 的分享来混入其中 (～￣▽￣)～</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363650953.jpg\"></p>","more":"<p>大会从 7点半开始调试设备，我 8点半左右到达，进去接了一下设备看着没啥大毛病，就跟中文站的贾哥去休息室摆龙门阵去了。当时也遇到了 Hadi ， 他因为当天要分享好几场，在紧张的调试 PPT 效果当中，JetBrains 布道师一哥那可不是玩的，整个一天下来，基本上最让人期待的就是他的分享了。</p>\n<p>开始之前 Lenyo 过来跟我和贾哥说你们对 Kotlin 新特性有什么想问的吗？我说有啊，萌雀雀一直都比较关心 Kotlin 接口的 SAM 的事儿。结果在 Hadi 介绍完 Kotlin 新特性的时候提问，我真的问了，折腾了半天他终于明白了我的意思ヽ(；´Д｀)ﾉ，一句“介个不在我们的规划当中”，瞬间把萌雀雀击伤，并当即表示要卸载 Kotlin（假惺惺，有本事你卸载 IntelliJ 啊(╬￣皿￣)=○）</p>\n<p>JetBrains 公司是一家有趣的公司，开场来自 JetBrains 的大佬们先后从不同的角度分享了这家公司的发展历程，管理文化。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363333557.jpg\"></p>\n<p>印象比较深的是 Hadi 提到的，”如果你睁开眼，感觉脑子不在线，那就不要来工作了“，”如果定了 KPI，那么所有的努力都只是为了 KPI“，这确实是一件很难把握的事儿，毕竟如果不加任何限制，可能确实会让人放任自流，不过换个角度来看看，如果招来的程序员还需要管，那么说明这些程序员之所以成为程序员，估计就是看到码农赚钱多吧；他还提到他们是没有上班时间的概念的，这个嘛，我们也没有的，国内互联网公司的弹性工作时间也许出发点是好的，但结果却往往成了加班演给老板看。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363496793.jpg\"></p>\n<p>还有就是关于 Leadership，其中提到一点就是 Delegate，带人其实没有那么轻松吧，团队做出成果自然有你的一份努力，而这一份努力需要花在对团队成员的了解，任务的合理安排，提供必要的帮助和指导上面，这里面 Hadi 有一句话让我特别受益，你安排了任务给其他人，在产出摆在面前的时候千万不要想着你自己完成了之后会比他完成的好 —— 这不公平，你应该考虑提供必要的指导和支持，一方面让事情开展的更加顺利，另一方面也让大家得到成长。</p>\n<p>干程序员这一行，还是需要点儿热爱的。最近大家都说移动客户端没落了，其实不然，大家对待这个领域的态度只是趋于理性和客观了，仍然有公司在招人，比如我们团队 Android 客户端校招就没有招够= =、（有兴趣可以发简历到 <a href=\"mailto:&#x62;&#101;&#110;&#110;&#x79;&#104;&#117;&#111;&#x40;&#x6b;&#111;&#116;&#x6c;&#105;&#110;&#x65;&#x72;&#46;&#99;&#110;\">&#x62;&#101;&#110;&#110;&#x79;&#104;&#117;&#111;&#x40;&#x6b;&#111;&#116;&#x6c;&#105;&#110;&#x65;&#x72;&#46;&#99;&#110;</a>）。</p>\n<p>Hadi 在上午接着介绍了 Kotlin 1.3 的新特性，这当中涉及了包括我们公众号前不久提到的 NewInference 和 SAMForKotlinFuction，以及注解支持内部成员，协程转正，无符号类型等等这些大家已经熟知的内容，我就不细说啦。</p>\n<p>中午吃饭，伙食还不错，想了想（那个我买不起Σ（ﾟдﾟlll）的）票价，其实也很划算了，65块钱这顿饭就吃回来了(๑•̀ㅂ•́)و✧。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363200631.jpg\"></p>\n<p>因为下午第一场就要分享，中午吃饭的时候时间比较紧张，怕影响效果没敢多吃，我就吃了一个餐包，三块这个，两块那个，火腿若干，羊肉数块。。。好吧，吃得一点儿也不少，以至于我上台开始讲的时候满脑子都是肉。。⊙﹏⊙|||</p>\n<p>讲之前 PPT 提前10分钟就开始播放了，我刚讲了个开头低头一看时间赫然写着 24:31，心中暗道：尼玛，时间都去哪儿了，我这还没进入状态呢。。。于是加快语速开始狂喷。。。小伙伴们一定在下面不明就里，当我眼看着时间逼近 40 分钟的时候，我果断开大，我靠早知道不做这么多页ppt 了（o´ﾟ□ﾟ`o），终于 43 分钟的时候ppt就剩最后几页，长舒 一口气，结果下来被告知当时其实才 34 分钟。。no！你们没看出来我讲完马上抱着电脑就要跑吗，我还以为超时了。。T^T</p>\n<p>整个活动的时间是非常紧凑的，演讲中间没有时间间隔，节奏不能乱，所以后来贾哥分享完 Ktor 倒是真的超时了，Lenyo 一看时间不够，果断上去提示大家有问题可以线下讨论。</p>\n<p>Hadi 下午的演讲主要是讲 Kotlin 可以在多平台上运行，其实我个人对 Hadi 的几个插件都是非常感兴趣，一个是快捷键提示，这个不同于 Key Promoter，后者在你没有使用快捷键的时候提示你快捷键是什么，前者则是在你用了快捷键的时候告诉观众这是什么快捷键，以及其他平台上对应的是什么：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425363067963.jpg\"></p>\n<p>还有一个是 Nyan 进度条的插件，很有趣：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362917548.jpg\"></p>\n<p>来自 Google 的钟辉老师也给我们介绍了协程在 Android 当中的使用，Retrofit 即将支持 suspend 函数，这一点我感觉还是很让人开心的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getJetBrains</span><span class=\"params\">()</span></span>: GitUser</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，现在我们也可以用 <code>Deferred</code> 来接入：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;https://api.github.com/users/jetbrains&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getJetBrains</span><span class=\"params\">()</span></span>: Deferred&lt;GitUser&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后来自蚂蚁的木磊老师分享的内容与 Kotlin 没有太大关系，我就不说啦。</p>\n<p>听完这个分享之后因为我晚上还有其他事情就提前撤了，但听说 Hadi 的第四个分享刷新了很多人对 IntelliJ 的认识：我难道从来没有真正会用过 IntelliJ ！天呐，我错过了几个亿！(ಥ_ಥ)</p>\n<p>不过不要担心啦，已经跟 JetBrains 的工作人员确认过啦，大会的 PPT 以及视频资料都会在后面统一放出来，届时咱们的公众号也会第一时间跟进，所以错过的小伙伴也不用担心！</p>\n<p>下午茶歇的时候，也与群里的小伙伴们一起合影，后来才知道还有其他小伙伴也在现场，所以下回咱们大群应该走一波节奏搞搞气氛~</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/15425362577824.jpg\"></p>\n<p>这次活动也还遇到了去年在 DroidConf 遇到的小伙伴，凑巧的是那一天正好是 17年的 11月 17日，时隔恰好一年，想来也是有趣，很幸运能结识这么多朋友~</p>\n<p>PS：茶歇的小饼干也很好吃啊！</p>\n<hr>\n<p>下午第一场 “如何优雅地使用数据类” 的 PPT 可以先分享给大家，有问题欢迎到论坛讨论~</p>\n<p>链接：<a href=\"https://share.weiyun.com/5YMPoL4\">https://share.weiyun.com/5YMPoL4</a> 密码：sz4vyw</p>\n<hr>\n<p>Kotlin 中文站：<a href=\"https://www.kotlincn.net/\">https://www.kotlincn.net</a><br>Kotlin 中文博客：<a href=\"https://www.kotliner.cn/\">https://www.kotliner.cn</a><br>Kotlin 中文论坛：<a href=\"https://discuss.kotliner.cn/\">https://discuss.kotliner.cn</a><br>Ktor 中文站：<a href=\"https://ktor.kotlincn.net/\">https://ktor.kotlincn.net</a></p>\n<hr>\n<p>欢迎关注：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题","date":"2019-02-04T16:00:00.000Z","_content":"\n\n### 0. 新年立个 Flag\n\n首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。\n\n每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。\n\n我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。\n\n<!--more-->\n\n一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。\n\n下面我们说我们今天的正题：\n\n### 1. Kotlin 不能完全兼容 Java 吗？\n\n有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：\n\n---\n\n**原帖开始**\n\nKotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，\n但是在实际使用上\n\n```java\npublic class ApiException extends Exception {\n    public int code;\n    public String message;\n    public String mmm;\n    \n    public ApiException(Throwable throwable, int code) {\n        super(throwable);\n        this.code = code;\n    }\n}\n```\n\n上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个 \n\n```java\npublic String getMessage() {\n    return detailMessage;\n}\n```\n\n在kotlin中调用\n\n```kotlin\nvar exception = ApiException(Throwable(),1)\nexception.code //正常\nexception.message //编译报错\n```\n\n错误信息如下：\n\n>Overload resolution ambiguity. All these functions match. public final var message\n\njava中调用\n\n```java\nnew ApiException(Throwable(),1).message 完全正常\n```\n\njava 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。\n\n**原帖结束**\n\n---\n\n\n\n看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。\n\n题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？\n\n当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）\n\n好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：\n\n先用 Java 包装一下：\n\n```java\nclass ExtApiException {\n    public static String getMessage(ApiException a){\n        return a.message;\n    }\n}\n```\n\n然后再在 Kotlin 里面这样调：\n\n```kotlin\nval a = ApiException()\nval t = (a as Throwable).message\nval r = ExtApiException.getMessage(a)\n\nfun ApiException.realMessage() = ExtApiException.getMessage(this)\nval i = a.realMessage()\n```\n\n这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。\n\n### 2. 为什么 message 会和 getMessage 纠缠不清？\n\n这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：\n\n```kotlin\npublic open class Throwable public constructor(message: kotlin.String?, cause: kotlin.Throwable?) {\n    ...\n    public open val message: kotlin.String? \n}\n```\n\n这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。\n\n### 3. 真的没有办法通过 Kotlin 实现访问吗？\n\nKotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。\n\n```kotlin\nval exception = ApiException(Throwable(\"ThrowableMessage\"),1)\nprintln((exception as java.lang.Throwable).getMessage())\n```\n\n不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：\n\n```kotlin\nfun <R, T> property1(property: KProperty1<R, T>) = property\nfun <R, T> mutableProperty1(property: KMutableProperty1<R, T>) = property\n\nval ApiException.throwableMessage: String?\n        get() = property1(Throwable::message).get(this)\n\nvar ApiException.apiMessage\n    get() = mutableProperty1<ApiException, String>(ApiException::message).get(this)\n    set(value) {\n        mutableProperty1<ApiException, String>(ApiException::message).set(this, value)\n    }\n```\n\n这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。\n\n当然我们也可以通过是否可空来区分，例如：\n\n```kotlin\nval ApiException.apiMessage2: String\n    get() = property1<ApiException, String>(ApiException::message).get(this)\n```\n我们如果给 property1 的第二个泛型参数传入 `String` 而不是 `String?` 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。\n\n这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：\n\n```java\nfinal class HelloKt$apiMessage$2 extends MutablePropertyReference1 {\n   public static final KMutableProperty1 INSTANCE = new HelloKt$apiMessage$2();\n\n   public String getName() {\n      return \"message\";\n   }\n\n   public String getSignature() {\n      return \"getMessage()Ljava/lang/String;\";\n   }\n\n   public KDeclarationContainer getOwner() {\n      return Reflection.getOrCreateKotlinClass(ApiException.class);\n   }\n\n   @Nullable\n   public Object get(@Nullable Object receiver) {\n      return ((ApiException)receiver).message;\n   }\n\n   public void set(@Nullable Object receiver, @Nullable Object value) {\n      ((ApiException)receiver).message = (String)value;\n   }\n}\n```\n\n我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。\n\n### 4. 小结\n\n这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。\n\n当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。\n\n\n","source":"_posts/2019_new_year.md","raw":"---\ntitle: 新年 Flag 以及论坛的一个所谓“Kotlin 不完全兼容 Java”的问题\ndate: 2019/02/05\ntags:\n  - NewYear\n  - Kotlin\n  - Java\n---\n\n\n### 0. 新年立个 Flag\n\n首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。\n\n每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。\n\n我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。\n\n<!--more-->\n\n一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。\n\n下面我们说我们今天的正题：\n\n### 1. Kotlin 不能完全兼容 Java 吗？\n\n有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：\n\n---\n\n**原帖开始**\n\nKotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，\n但是在实际使用上\n\n```java\npublic class ApiException extends Exception {\n    public int code;\n    public String message;\n    public String mmm;\n    \n    public ApiException(Throwable throwable, int code) {\n        super(throwable);\n        this.code = code;\n    }\n}\n```\n\n上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个 \n\n```java\npublic String getMessage() {\n    return detailMessage;\n}\n```\n\n在kotlin中调用\n\n```kotlin\nvar exception = ApiException(Throwable(),1)\nexception.code //正常\nexception.message //编译报错\n```\n\n错误信息如下：\n\n>Overload resolution ambiguity. All these functions match. public final var message\n\njava中调用\n\n```java\nnew ApiException(Throwable(),1).message 完全正常\n```\n\njava 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。\n\n**原帖结束**\n\n---\n\n\n\n看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。\n\n题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？\n\n当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）\n\n好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：\n\n先用 Java 包装一下：\n\n```java\nclass ExtApiException {\n    public static String getMessage(ApiException a){\n        return a.message;\n    }\n}\n```\n\n然后再在 Kotlin 里面这样调：\n\n```kotlin\nval a = ApiException()\nval t = (a as Throwable).message\nval r = ExtApiException.getMessage(a)\n\nfun ApiException.realMessage() = ExtApiException.getMessage(this)\nval i = a.realMessage()\n```\n\n这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。\n\n### 2. 为什么 message 会和 getMessage 纠缠不清？\n\n这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：\n\n```kotlin\npublic open class Throwable public constructor(message: kotlin.String?, cause: kotlin.Throwable?) {\n    ...\n    public open val message: kotlin.String? \n}\n```\n\n这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。\n\n### 3. 真的没有办法通过 Kotlin 实现访问吗？\n\nKotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。\n\n```kotlin\nval exception = ApiException(Throwable(\"ThrowableMessage\"),1)\nprintln((exception as java.lang.Throwable).getMessage())\n```\n\n不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：\n\n```kotlin\nfun <R, T> property1(property: KProperty1<R, T>) = property\nfun <R, T> mutableProperty1(property: KMutableProperty1<R, T>) = property\n\nval ApiException.throwableMessage: String?\n        get() = property1(Throwable::message).get(this)\n\nvar ApiException.apiMessage\n    get() = mutableProperty1<ApiException, String>(ApiException::message).get(this)\n    set(value) {\n        mutableProperty1<ApiException, String>(ApiException::message).set(this, value)\n    }\n```\n\n这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。\n\n当然我们也可以通过是否可空来区分，例如：\n\n```kotlin\nval ApiException.apiMessage2: String\n    get() = property1<ApiException, String>(ApiException::message).get(this)\n```\n我们如果给 property1 的第二个泛型参数传入 `String` 而不是 `String?` 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。\n\n这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：\n\n```java\nfinal class HelloKt$apiMessage$2 extends MutablePropertyReference1 {\n   public static final KMutableProperty1 INSTANCE = new HelloKt$apiMessage$2();\n\n   public String getName() {\n      return \"message\";\n   }\n\n   public String getSignature() {\n      return \"getMessage()Ljava/lang/String;\";\n   }\n\n   public KDeclarationContainer getOwner() {\n      return Reflection.getOrCreateKotlinClass(ApiException.class);\n   }\n\n   @Nullable\n   public Object get(@Nullable Object receiver) {\n      return ((ApiException)receiver).message;\n   }\n\n   public void set(@Nullable Object receiver, @Nullable Object value) {\n      ((ApiException)receiver).message = (String)value;\n   }\n}\n```\n\n我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。\n\n### 4. 小结\n\n这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。\n\n当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。\n\n\n","slug":"2019_new_year","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002t0003lduz1vj189rv","content":"<h3 id=\"0-新年立个-Flag\"><a href=\"#0-新年立个-Flag\" class=\"headerlink\" title=\"0. 新年立个 Flag\"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p>\n<p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p>\n<p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p>\n<span id=\"more\"></span>\n\n<p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p>\n<p>下面我们说我们今天的正题：</p>\n<h3 id=\"1-Kotlin-不能完全兼容-Java-吗？\"><a href=\"#1-Kotlin-不能完全兼容-Java-吗？\" class=\"headerlink\" title=\"1. Kotlin 不能完全兼容 Java 吗？\"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p>\n<hr>\n<p><strong>原帖开始</strong></p>\n<p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> code;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String mmm;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiException</span><span class=\"params\">(Throwable throwable, <span class=\"keyword\">int</span> code)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(throwable);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> detailMessage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在kotlin中调用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exception = ApiException(Throwable(),<span class=\"number\">1</span>)</span><br><span class=\"line\">exception.code <span class=\"comment\">//正常</span></span><br><span class=\"line\">exception.message <span class=\"comment\">//编译报错</span></span><br></pre></td></tr></table></figure>\n\n<p>错误信息如下：</p>\n<blockquote>\n<p>Overload resolution ambiguity. All these functions match. public final var message</p>\n</blockquote>\n<p>java中调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ApiException(Throwable(),<span class=\"number\">1</span>).message 完全正常</span><br></pre></td></tr></table></figure>\n\n<p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p>\n<p><strong>原帖结束</strong></p>\n<hr>\n<p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p>\n<p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p>\n<p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p>\n<p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p>\n<p>先用 Java 包装一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtApiException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(ApiException a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再在 Kotlin 里面这样调：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = ApiException()</span><br><span class=\"line\"><span class=\"keyword\">val</span> t = (a <span class=\"keyword\">as</span> Throwable).message</span><br><span class=\"line\"><span class=\"keyword\">val</span> r = ExtApiException.getMessage(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> ApiException.<span class=\"title\">realMessage</span><span class=\"params\">()</span></span> = ExtApiException.getMessage(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure>\n\n<p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p>\n<h3 id=\"2-为什么-message-会和-getMessage-纠缠不清？\"><a href=\"#2-为什么-message-会和-getMessage-纠缠不清？\" class=\"headerlink\" title=\"2. 为什么 message 会和 getMessage 纠缠不清？\"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Throwable</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">val</span> message: kotlin.String? </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p>\n<h3 id=\"3-真的没有办法通过-Kotlin-实现访问吗？\"><a href=\"#3-真的没有办法通过-Kotlin-实现访问吗？\" class=\"headerlink\" title=\"3. 真的没有办法通过 Kotlin 实现访问吗？\"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> exception = ApiException(Throwable(<span class=\"string\">&quot;ThrowableMessage&quot;</span>),<span class=\"number\">1</span>)</span><br><span class=\"line\">println((exception <span class=\"keyword\">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure>\n\n<p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R, T&gt;</span> <span class=\"title\">property1</span><span class=\"params\">(property: <span class=\"type\">KProperty1</span>&lt;<span class=\"type\">R</span>, T&gt;)</span></span> = property</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R, T&gt;</span> <span class=\"title\">mutableProperty1</span><span class=\"params\">(property: <span class=\"type\">KMutableProperty1</span>&lt;<span class=\"type\">R</span>, T&gt;)</span></span> = property</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> ApiException.throwableMessage: String?</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = property1(Throwable::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ApiException.apiMessage</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value) &#123;</span><br><span class=\"line\">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">set</span>(<span class=\"keyword\">this</span>, value)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p>\n<p>当然我们也可以通过是否可空来区分，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ApiException.apiMessage2: String</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p>\n<p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloKt</span>$<span class=\"title\">apiMessage</span>$2 <span class=\"keyword\">extends</span> <span class=\"title\">MutablePropertyReference1</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> KMutableProperty1 INSTANCE = <span class=\"keyword\">new</span> HelloKt$apiMessage$<span class=\"number\">2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;message&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSignature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;getMessage()Ljava/lang/String;&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> KDeclarationContainer <span class=\"title\">getOwner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Reflection.getOrCreateKotlinClass(ApiException.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object receiver)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ((ApiException)receiver).message;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object receiver, <span class=\"meta\">@Nullable</span> Object value)</span> </span>&#123;</span><br><span class=\"line\">      ((ApiException)receiver).message = (String)value;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p>\n<p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0-新年立个-Flag\"><a href=\"#0-新年立个-Flag\" class=\"headerlink\" title=\"0. 新年立个 Flag\"></a>0. 新年立个 Flag</h3><p>首先祝各位小伙伴在新的中国年里找到属于自己的奋斗方向，凝聚自己的奋斗方法，实现自己的奋斗目标。</p>\n<p>每年春节 0 点之后都喜欢随便做点儿自己喜欢的事情。曾经有一年就是在这个时间憋出了一篇晦涩难懂的协程的文章，所以今年需要在 Kotlin 协程上多写点儿文章，也许也可以写点儿 lib，总之公众号在这一年的发力点，协程算一个，应该也不会局限于 Java 虚拟机。</p>\n<p>我前一阵子写过几次用 Kotlin Native 作为 JNI 的底层实现的文章。Kotlin Native 尽管可能还不是很完美，但就像它的负责人说的，后面的版本就需要来偿还技术债了，毕竟它从诞生开始就面临了类似于我们国内任何一款互联网产品一样的境遇，它如果不够快，也许就赶不上这波节奏了。可能各方面体验还没有那么好，但它的全貌已经完全呈现在我们面前，所以我们要做的就是帮助它，把生态建立起来。所以今年公众号也会把 Kotlin Native 作为一个重点，也许年底我能鼓捣出一个让 KN 写 JNI 变得很方便的 wrapper 呢，希望我时间会比较充裕吧。</p>","more":"<p>一月份实在太忙了，在公司忙，回家还忙，在群里开玩笑说公众号都要长草了，这让我十分痛心。这种状态大约会持续到 2月底，3月份我一定会回归。</p>\n<p>下面我们说我们今天的正题：</p>\n<h3 id=\"1-Kotlin-不能完全兼容-Java-吗？\"><a href=\"#1-Kotlin-不能完全兼容-Java-吗？\" class=\"headerlink\" title=\"1. Kotlin 不能完全兼容 Java 吗？\"></a>1. Kotlin 不能完全兼容 Java 吗？</h3><p>有位大概是被队友坑了的小伙伴，在论坛发帖求助，原帖内容如下：</p>\n<hr>\n<p><strong>原帖开始</strong></p>\n<p>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码 文档上这样说，<br>但是在实际使用上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> code;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String mmm;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiException</span><span class=\"params\">(Throwable throwable, <span class=\"keyword\">int</span> code)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(throwable);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的ApiException 继承自 Exception ，Exception 继承Throwable ，Throwable 是有个 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> detailMessage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在kotlin中调用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exception = ApiException(Throwable(),<span class=\"number\">1</span>)</span><br><span class=\"line\">exception.code <span class=\"comment\">//正常</span></span><br><span class=\"line\">exception.message <span class=\"comment\">//编译报错</span></span><br></pre></td></tr></table></figure>\n\n<p>错误信息如下：</p>\n<blockquote>\n<p>Overload resolution ambiguity. All these functions match. public final var message</p>\n</blockquote>\n<p>java中调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ApiException(Throwable(),<span class=\"number\">1</span>).message 完全正常</span><br></pre></td></tr></table></figure>\n\n<p>java 代码已经打包成jar，显示 kotlin 中是无法完全调用已经 实现好的java 代码？是否有解决方法，特别是对用打包好的不能改的java代码，无法调用是致命的。</p>\n<p><strong>原帖结束</strong></p>\n<hr>\n<p>看到这个问题，突然觉得以前大家写 Java 代码，得是有多乱，人家明明就已经有了 message，你再继承，再搞出一个来，到底是为什么呢。。。</p>\n<p>题主说有可能是第三方 SDK 这样，没有办法修改源码，怎么办？</p>\n<p>当然是去找到 SDK 的开发者当面 diss 啊。然后弃之不用 ：）</p>\n<p>好啦，对于代码的坏味道，我们要犀利的抨击，不过解决办法还是可以提供一下的，例如帖子里面有个小伙伴说：</p>\n<p>先用 Java 包装一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtApiException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(ApiException a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再在 Kotlin 里面这样调：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> a = ApiException()</span><br><span class=\"line\"><span class=\"keyword\">val</span> t = (a <span class=\"keyword\">as</span> Throwable).message</span><br><span class=\"line\"><span class=\"keyword\">val</span> r = ExtApiException.getMessage(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> ApiException.<span class=\"title\">realMessage</span><span class=\"params\">()</span></span> = ExtApiException.getMessage(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> i = a.realMessage()</span><br></pre></td></tr></table></figure>\n\n<p>这个小伙伴的思路就很不错，为什么一定要用 Kotlin 兼容这样的代码呢，让 Java 自己收拾自己的烂摊子呗。</p>\n<h3 id=\"2-为什么-message-会和-getMessage-纠缠不清？\"><a href=\"#2-为什么-message-会和-getMessage-纠缠不清？\" class=\"headerlink\" title=\"2. 为什么 message 会和 getMessage 纠缠不清？\"></a>2. 为什么 message 会和 getMessage 纠缠不清？</h3><p>这个问题的根本原因在于 Kotlin 自己定义了一套 Throwable，换句话说 ApiException 在 Kotlin 看来，是继承自 kotlin.Throwable 的，它当中没有 getMessage 方法，对应的是 message 这个成员：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Throwable</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>(message: kotlin.String?, cause: kotlin.Throwable?) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">val</span> message: kotlin.String? </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个与绝大多数合成属性的情况还不一样，如果是合成的属性，通常我们也可以直接访问对应的 get/set 方法。实际上我们自己定义的类如果不继承存在 Kotlin 到 Java 映射关系的类型，几乎不会遇到类似的问题。</p>\n<h3 id=\"3-真的没有办法通过-Kotlin-实现访问吗？\"><a href=\"#3-真的没有办法通过-Kotlin-实现访问吗？\" class=\"headerlink\" title=\"3. 真的没有办法通过 Kotlin 实现访问吗？\"></a>3. 真的没有办法通过 Kotlin 实现访问吗？</h3><p>Kotlin 在编译到 JVM 上时，会把 Throwable 映射成 java.lang.Throwable，所以我们可以尝试把 ApiException 强转成 java.lang.Throwable，这样你就可以调用 getMessage 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> exception = ApiException(Throwable(<span class=\"string\">&quot;ThrowableMessage&quot;</span>),<span class=\"number\">1</span>)</span><br><span class=\"line\">println((exception <span class=\"keyword\">as</span> java.lang.Throwable).getMessage())</span><br></pre></td></tr></table></figure>\n\n<p>不过这时候我们仍然无法调用到 ApiException 的 message 成员（尽管这个设计很蠢。。。），不过没有关系，因为 ApiException 的 message 与kotlin.Throwable 的 message 类型不同，区别在于一个是 var 另一个是 val，以及一个是平台类型 String! 另一个是 String?，通过这两个区别，我们都可以用一些手段让编译器自动帮我们选择合适的成员，具体做法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R, T&gt;</span> <span class=\"title\">property1</span><span class=\"params\">(property: <span class=\"type\">KProperty1</span>&lt;<span class=\"type\">R</span>, T&gt;)</span></span> = property</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R, T&gt;</span> <span class=\"title\">mutableProperty1</span><span class=\"params\">(property: <span class=\"type\">KMutableProperty1</span>&lt;<span class=\"type\">R</span>, T&gt;)</span></span> = property</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> ApiException.throwableMessage: String?</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = property1(Throwable::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ApiException.apiMessage</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value) &#123;</span><br><span class=\"line\">        mutableProperty1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">set</span>(<span class=\"keyword\">this</span>, value)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们可以通过这两个成员是否可变来让编译器自动选择对应到相应的 property 当中。</p>\n<p>当然我们也可以通过是否可空来区分，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ApiException.apiMessage2: String</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = property1&lt;ApiException, String&gt;(ApiException::message).<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>我们如果给 property1 的第二个泛型参数传入 <code>String</code> 而不是 <code>String?</code> 那么结果就是调用 ApiException 当中定义的 message，否则调用 Throwable 当中的 message。</p>\n<p>这个访问的过程实际上也没有什么额外的开销，尽管看上去似乎用了反射，但根本不需要引入反射包，实际上也不会通过反射进行访问。以 apiMessage 为例，反编译的结果是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloKt</span>$<span class=\"title\">apiMessage</span>$2 <span class=\"keyword\">extends</span> <span class=\"title\">MutablePropertyReference1</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> KMutableProperty1 INSTANCE = <span class=\"keyword\">new</span> HelloKt$apiMessage$<span class=\"number\">2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;message&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSignature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;getMessage()Ljava/lang/String;&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> KDeclarationContainer <span class=\"title\">getOwner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Reflection.getOrCreateKotlinClass(ApiException.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object receiver)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ((ApiException)receiver).message;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Object receiver, <span class=\"meta\">@Nullable</span> Object value)</span> </span>&#123;</span><br><span class=\"line\">      ((ApiException)receiver).message = (String)value;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到它的 get 和 set 都是直接对相应的字段做处理，因此不会有任何开销。</p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h3><p>这种情况，ApiException 不是 Kotlin 友好的类型，对于这样的类型，或者说类似的 Java 质量并不怎么好的代码，以及典型的 raw 类型的代码，建议用 Java 去访问，或者进行适当包装再交给 Kotlin 去调用。</p>\n<p>当然，我最建议的是，如果有同事写了这样愚蠢的代码让你调用，离他远点儿，免得被带坏 ：）逃。。。</p>","popularPost_tmp_postPath":true},{"title":"如何为 Gradle 的 KTS 脚本添加扩展？","keywords":"Gradle Groovy Kotlin KTS","date":"2021-04-17T16:00:00.000Z","description":null,"_content":"\n> 本质上还是要搞清楚 KTS 是怎么运行的 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1BU4y1b7Wk&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n要知道在 Groovy 当中想要做到这一点并不难，毕竟作为一门动态类型的语言，只要运行时能够访问到即可，反正又不需要 IDE 代码提示。但在 Kotlin 这里情况就显得有点儿麻烦了，因为我们添加的扩展要在编译的时候就能够让编译器访问到。\n\n## 1. Kotlin DSL 的 Gradle 脚本是怎么运行的？\n\n为了搞清楚怎么添加扩展，我们同样需要搞清楚采用 Kotlin DSL 的 Gradle 脚本是怎么运行的。但受限于篇幅，我就不带着大家一步一步去看源码了，大家有兴趣可以在 Gradle 源码当中找到 org.gradle.kotlin.dsl 包，其中就是有关 Kotlin DSL 的支持的实现。\n\n![Gradle Kotlin DSL 的源码路径](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png)\n\n有了前面“[你的 Gradle 脚本是怎么运行起来的？](http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=793373419&lang=zh_CN#rd)”这个视频的基础，相信大家已经了解了 Gradle 脚本运行时的两个阶段：\n\n* classpath 阶段\n* body 阶段\n\n其实 Kotlin DSL 也是如此，只不过运行的时候具体的形式稍微有些差异。\n\nKotlin DSL 版本的脚本被称为 \"Program\"，它在 Gradle 的实现当中也通过一个叫 **Program** 的类及其子类来描述，定义在 Program.kt 文件当中。\n\n```kotlin\nsealed class Program {\n\tobject Empty: Program() { ... }\n    data class Buildscript(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class PluginManagement(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class Plugins(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class Stage1Sequence(val pluginManagement: PluginManagement?, val buildscript: Buildscript?, val plugins: Plugins?) : Stage1()\n    data class Script(val source: ProgramSource) : Program()\n    data class Staged(val stage1: Stage1, val stage2: Script) : Program()\n    abstract class Stage1 : Program()\n}\n```\n\n注意到所有在 classpath 阶段编译运行的代码块都继承自 Stage1 这个类。我认为这段代码定义中最有趣的是 `Stage1Sequence`，它通过类型的形式强制给出了几个代码块的顺序的定义。\n\n> **提示：**可以看到这还是一个密封的使用案例，所以不要总是说密封类没啥用，代码储备量的贫乏限制了大家的想象力。\n\n那么它究竟是怎么运行的呢？\n\n简单来说就是任意一个 Kotlin DSL 的 Gradle 脚本都会把分属于不同阶段的部分拆分开，每一个部分都会编译成两个类，叫做 **Program** 和 **Build_gradle**，其中 Program 类的 execute 函数是调用入口，DSL 脚本的内容则被编译成 Build_gradle 类的构造函数。\n\n![Kotlin DSL 的编译运行示意图](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417092350607.png)\n\n有朋友肯定会发出疑问，两个阶段分别编译出不同的两个类，但名字是一样的，这不会冲突吗？当然不会，二者运行时用的 classloader 都是不一样的。而且需要特别注意的是，我们会在 classpath 阶段的 buildscript 代码块中添加 classpath，所以这个阶段与 body 阶段运行时的 classpath 是不一样的，因此不是所有在 body 阶段能访问到的类和成员都能在 classpath 阶段访问到。\n\n我们以之前改造好的根目录下的 build.gradle.kts 为例，它的内容如下：\n\n```kotlin\n// Top-level(build file where you can add configuration options common to all sub-projects/modules.)\nbuildscript {\n    val kotlin_version: String by extra(\"1.4.30\")\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:4.0.1\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n\n        classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n        // For(Kotlin projects, you need to add Dokka.)\n        classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n    }\n}\n\nsubprojects {\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    afterEvaluate {\n        if (plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n            group = \"com.bennyhuo\"\n            version = \"1.0\"\n\n            apply(plugin = \"com.vanniktech.maven.publish\")\n        }\n    }\n}\n\ntasks.register<Delete>(\"clean\") {\n    delete(rootProject.buildDir)\n}\n```\n\n编译时会分成两部分，其中 \n\n* classpath 阶段的内容为：\n\n  ```kotlin\n  buildscript {\n      val kotlin_version: String by extra(\"1.4.30\")\n      repositories {\n          maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n      }\n      dependencies {\n          classpath(\"com.android.tools.build:gradle:4.0.1\")\n          classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n  \n          classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n          // For(Kotlin projects, you need to add Dokka.)\n          classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n      }\n  }\n  ```\n\n* body 阶段的内容为：\n\n  ```kotlin\n  // Top-level(build file where you can add configuration options common to all sub-projects/modules.)\n  subprojects {\n      repositories {\n          maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n      }\n      afterEvaluate {\n          if (plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n              group = \"com.bennyhuo\"\n              version = \"1.0\"\n  \n              apply(plugin = \"com.vanniktech.maven.publish\")\n          }\n      }\n  }\n  \n  tasks.register<Delete>(\"clean\") {\n      delete(rootProject.buildDir)\n  }\n  ```\n\n由于 body 阶段的 classloader 包含了 classpath 阶段添加的依赖，因此在 body 阶段可以访问所有前面 dependencies 当中添加的 maven 依赖库中的类。\n\n大家也可以单步调试一下这个脚本来深入了解一下它。值得一提的是，Gradle 在编译运行时会生成两个不同的 jar 包来存储 **Program** 和 **Gradle_build** 类，因此我们可以通过加载它的 classloader 找到这两个 jar 包的路径。\n\n在 buildscript 当中随便找个位置打断点，启动调试之后，就可以看到下面的情景，顺着 classloader 就可以看到生成的 jar 在 `<用户目录>/.gradle/caches/jars-8/` 下：\n\n![classpath stage 的脚本编译生成的 jar](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416171142126.png)\n\n我们找到这个 jar 包，里面正如我们前面所讲，两个类，反编译之后如下：\n\n```java\npublic final class Program extends StagedProgram {\n    public void execute(Host var1, KotlinScriptHost<?> var2) {\n        var1.setupEmbeddedKotlinFor(var2);\n\n        try {\n            // 运行 classpath 阶段的脚本\n            new Build_gradle(var2, (Project)var2.getTarget());\n        } catch (Throwable var5) {\n            var1.handleScriptException(var5, Build_gradle.class, var2);\n        }\n\n        var1.applyPluginsTo(var2, MultiPluginRequests.EMPTY);\n        var1.applyBasePluginsTo((Project)var2.getTarget());\n        // 加载并运行 body 阶段的脚本\n        var1.evaluateSecondStageOf(this, var2, \"Project/TopLevel/stage2\", HashCode.fromBytes(...), var1.accessorsClassPathFor(var2));\n    }\n\n   \t...\n}\n```\n\n```java\npublic class Build_gradle extends CompiledKotlinBuildscriptBlock {\n   public final Project $$implicitReceiver0;\n\t\n   public Build_gradle(KotlinScriptHost var1, Project var2) {\n      super(var1);\n      this.$$implicitReceiver0 = var2;\n      // 运行 buildscript 块\n      ((Build_gradle)this).buildscript((Function1)null.INSTANCE);\n      Unit var10001 = Unit.INSTANCE;\n   }\n}\n```\n\n实际上我们可以看到 classpath 阶段的脚本运行完之后马上就开始编译、加载和运行 body 阶段的脚本了。\n\n接下来我们再看下 body 阶段，同样断点运行到 body 对应的脚本时，我们可以看到调用栈其实跟 classpath 是一致的，调用顺序是 \n\n![脚本的调用顺序](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417093245689.png)\n\n其中第二个 eval 就是在运行 body 阶段的脚本了：\n\n![body stage 的脚本编译生成的 jar](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416170811407.png)\n\n这与我们反编译看到的 classpath 当中的 Program 的代码时一致的。\n\n我们也把 body 阶段的 jar 反编译后贴出来，我稍微加了点儿注释，大家可以大致感受一下对应的脚本内容：\n\n```java\npublic final class Program extends ExecutableProgram {\n    public void execute(Host var1, KotlinScriptHost<?> var2) {\n        try {\n            new Build_gradle(var2, (Project)var2.getTarget());\n        } catch (Throwable var5) {\n            var1.handleScriptException(var5, Build_gradle.class, var2);\n        }\n    }\n}\n```\n\n```java\npublic class Build_gradle extends CompiledKotlinBuildScript {\n   public final Project $$implicitReceiver0;\n   public final Delete $$result;\n\n   public Build_gradle(KotlinScriptHost var1, Project var2) {\n      super(var1);\n      this.$$implicitReceiver0 = var2;\n       // 调用 subprojects\n      this.$$implicitReceiver0.subprojects((Action)null.INSTANCE);\n       // 定义 task \"clean\"\n      Project $this$task$iv = this.$$implicitReceiver0;\n      String name$iv = \"clean\";\n       // task \"clean\" 的配置代码\n      Function1 configuration$iv = (Function1)(new Function1() \n         ...\n         public final void invoke(@NotNull Delete $this$task) {\n             // 对应于 group = \"build\"\n            $this$task.setGroup(\"build\");\n             \n             // 对应于 delete(rootProject.buildDir)\n            Object[] var10001 = new Object[1];\n            Project var10004 = Build_gradle.this.$$implicitReceiver0.getRootProject();\n            Intrinsics.checkExpressionValueIsNotNull(var10004, \"rootProject\");\n            var10001[0] = var10004.getBuildDir();\n            $this$task.delete(var10001);\n         }\n      });\n       \n       // 对应于 task<Delete>(...)，前面的 configuration$iv 对应于 Lambda 表达式\n      int $i$f$task = false;\n      Task var9 = ProjectExtensionsKt.task($this$task$iv, name$iv, Reflection.getOrCreateKotlinClass(Delete.class), configuration$iv);\n      this.$$result = (Delete)var9;\n   }\n}\n```\n\n截止目前，我想大家应该能够明白 Gradle Kotlin DSL 脚本是如何运行的了。\n\n接下来我们就看看如何实现扩展的定义。\n\n## 2. 定义一个像 mavenCentral 一样的函数\n\n我们定义一个类似于 mavenCentral 的函数 tencentCloud 来方便我们添加腾讯云的 maven 仓库镜像，并以此来说明扩展的定义有哪些注意事项。最终的效果是：\n\n```kotlin\nrepositories {\n    tencentCloud()\n    //等价于：maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n代码很好写，repositories { ... } 的参数的 Receiver 是 RepositoryHandler：\n\n```kotlin\nfun RepositoryHandler.tencentCloud() {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n接下来问题就是：我们应该把这个扩展函数写在哪里呢？\n\n### 2.1 定义在根工程的 build.gradle.kts 当中\n\n按照我们前面的分析，只要定义在 Gradle 脚本当中，不管写到哪里，都相当于定义了在了 Build_gradle 的构造函数当中，这样一个局部的函数只能在当前范围内使用：\n\n**build.gradle.kts(rootProject)**\n\n```kotlin\nfun RepositoryHandler.tencentCloud() {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n\nbuildscript {\n    repositories {\n        tencentCloud() // ERROR!! IDE 可能不报错，但编译报错\n    }\n    ...\n}\nsubprojects {\n    repositories {\n        tencentCloud() // OK，都在 body 阶段的 Build_gradle 构造内部\n    }\n   \t...\n}\n```\n\n**build.gradle.kts(:app)**\n\n```kotlin\nbuildscript {\n    repositories {\n        tencentCloud() // ERROR!! 不在同一个作用域内\n    }\n}\n```\n\n效果不理想，但不管怎么样，我们现在已经实现了相同运行阶段的文件范围内的扩展实现。\n\n### 2.2 定义在 buildSrc 当中\n\nbuildSrc 是一个神奇的存在，工程当中所有的脚本都可以访问到它当中的类和函数。我们可以在 BuildTreePreparingProjectsPreparer 的 prepareProjects 方法当中看到对 buildSrc 的处理：\n\n**文件：BuildTreePreparingProjectsPreparer.java**\n\n```java\npublic void prepareProjects(GradleInternal gradle) {\n\t...\n    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());\n    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);\n    ...\n    // Build buildSrc and export classpath to root project\n    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);\n\t// Evaluate projects\n    delegate.prepareProjects(gradle);\n\t...\n}\n```\n\n在 evaluate project 之前，buildSrc 模块的代码就被添加到了 baseProjectClassLoaderScope 当中，这个 classloaderScope 实际上是后续所有 project 的脚本都能访问到的。\n\n这样看来，在 build.gradle.kts 当中任意代码运行之前，buildSrc 的代码就已经在 classpath 当中了，因此把我们的扩展添加到 buildSrc 当中，就能解决整个工程的脚本访问的问题。\n\n至此，我们实现了为整个工程的构建脚本定义扩展。这一点与我们在 buildSrc 当中定义依赖的版本常量的思路实际上也是一致的。\n\n### 2.3 定义在 init.gradle.kts 当中\n\n接下来我们就要考虑，有没有什么办法让我的电脑上所有的工程都能支持这个扩展呢？\n\n我们很自然地想到 init.gradle.kts，因为 Gradle 会在处理编译流程之前就加载运行这个脚本；如果我们把它放到 **<用户目录>/.gradle/** 目录下，那么所有的工程在启动编译时都会默认执行这个脚本。\n\n不过事情并不是想想的那样顺利，因为 init.gradle.kts 当中直接定义这个扩展函数也会同样只能在局部范围内有效，达不到我们的目标。\n\n那是不是只要比 project 当中的 buildscript 执行得早，并且我们提前通过常规的 classpath 函数添加依赖，就能让 project 当中的 buildscript 访问到呢？不行。例如：\n\n```kotlin\nbeforeProject {\n    buildscript {\n        repositories {\n            mavenLocal()\n        }\n        dependencies {\n            classpath(\"com.bennyhuo.gradle:repos:1.0-SNAPSHOT\")\n        }\n    }\n}\n```\n\n我把我们的扩展发布到 maven 的仓库当中，然后通过常规的 classpath 的方式引入，我们非常清楚这段代码一定会比我们在工程当中的 buildscript 先运行，但 classpath 调用之后实际上是添加到了 body 阶段的 classloader 当中的，而在 classpath 阶段运行的 buildscript 使用的 classloader 实际上是 body 阶段的父 classloader，因而达不到我们的目的。\n\n那怎么办？经过我反复的调试，暂时没有找到很好的正规途径的办法。\n\n常规操作搞不定就只能骚操作了。思路也很简单，找到加载 buildSrc 的那个 classloader，它其实也是加载运行 classpath 阶段的 buildscript  代码的 classloader，我们在里面添加一下我们自己的依赖即可。重点就在 BuildTreePreparingProjectsPreparer 的 prepareProjects 当中:\n\n**文件：BuildTreePreparingProjectsPreparer.java**\n\n```java\npublic void prepareProjects(GradleInternal gradle) {\n\t...\n    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());\n    // 这个 classloader 被 gradle 持有，我们可以通过 gradle 实例获取到它\n    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);\n    ...\n    // Build buildSrc and export classpath to root project\n    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);\n\t// Evaluate projects\n    delegate.prepareProjects(gradle);\n\t...\n}\n```\n\n再看 buildBuildSrcAndLockClassloader 方法：\n\n```java\nprivate void buildBuildSrcAndLockClassloader(GradleInternal gradle, ClassLoaderScope baseProjectClassLoaderScope) {\n    ClassPath buildSrcClassPath = buildSourceBuilder.buildAndGetClassPath(gradle);\n    // 重点看这一句，export 可以添加一个 `ClassPath` 类型的实例\n    baseProjectClassLoaderScope.export(buildSrcClassPath).lock();\n}\n```\n\n因此只要我们自己也调用一下这个 export 方法，把我们自己编译好的 jar 包作为 ClassPath 传进去，问题就解决了。\n\n当然，上帝在为我们打开了一扇窗户的同时又装上了不锈钢纱窗。事情并不是那么直接就能办到的，因为后面那个 lock，它的意思真的就是 lock。\n\n**文件：DefaultClassLoaderScope.java**\n\n```java\npublic ClassLoaderScope export(ClassPath classPath) {\n    ...\n    // 必须是非锁定状态，如果已经 lock，这里抛出断言异常\n    assertNotLocked();\n    // 在解析了所有的 classpath 之后才会创建，buildSrc 添加的时候为 null\n    if (exportingClassLoader != null) {\n        ...\n    } else {\n        // 命中这个分支\n        export = export.plus(classPath);\n    }\n    return this;\n}\n```\n\nlock 了之后，我们想要直接调用 export 方法来添加我们自己的 jar 包的愿望落空，不过上帝还是给我们的不锈钢纱窗留了一把钥匙的，那就是 Java 反射。我们可以通过反射来直接修改 export，无视 lock 的状态，代码如下：\n\n```kotlin\nimport org.gradle.api.internal.GradleInternal\nimport org.gradle.api.internal.initialization.DefaultClassLoaderScope\nimport org.gradle.internal.classpath.ClassPath\nimport org.gradle.internal.classpath.DefaultClassPath\n\n// 获取当前脚本所在目录下的 repos-1.0-SNAPSHOT.jar 文件\nval depFile = file(\"repos-1.0-SNAPSHOT.jar\")\n// 在 project evaluate 之前调用，比 buildscript 早\nbeforeProject {\n    if (this == rootProject){\n        val gradleInternal = gradle as GradleInternal\n        val field = DefaultClassLoaderScope::class.java.getDeclaredField(\"export\")\n        field.isAccessible = true\n        val oldClassPath = field.get(gradleInternal.baseProjectClassLoaderScope()) as ClassPath\n        field.set(gradleInternal.baseProjectClassLoaderScope(), oldClassPath + DefaultClassPath.of(depFile))\n    }\n}\n```\n\n把扩展函数编译成的 jar 文件也放到 **<用户目录>/.gradle/** 中：\n\n![init 脚本和 jar 依赖的文件路径](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417085046475.png)\n\n这样运行时就会把这个 jar 添加到 baseProjectClassLoaderScope 当中，所有的工程就都能访问到它了。\n\n需要注意的是，我们的示例是基于 Gradle 7.0 的，不同版本可能会存在差异。\n\n### 2.4 如果是 Groovy 呢？\n\n之所以这么麻烦，就是因为我们需要兼顾 Kotlin 的静态类型的特性。如果是 Groovy 版本的特性，那么问题就简单多了，你只需要在 init.gradle 当中添加以下代码：\n\n```groovy\nRepositoryHandler.metaClass.tencentCloud {\n    delegate.maven {\n      url \"https://mirrors.tencent.com/nexus/repository/maven-public/\"\n    }\n}\n```\n\n后面访问 RepositoryHandler 的 tencentCloud 方法的时候就能够动态调用到这个扩展了。这实际上是 Groovy 元编程的内容，我们就不展开介绍了。\n\n## 3. 小结\n\n本节我们以实现一个简单的扩展为背景，先了解了一下 Kotlin DSL 的运行机制，接着又给出了在各个范围内实现扩展的方法。\n\n一个很小的需求，实际上需要我们了解的背景知识还是很多的。\n\n很多时候我们的学习和成长都是以点筑面，大厦固然高，但抵不住我一层一层地爬。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/Add-extensions-to-build-scripts.md","raw":"---\ntitle:  如何为 Gradle 的 KTS 脚本添加扩展？ \nkeywords: Gradle Groovy Kotlin KTS \ndate: 2021/04/18\ndescription: \ntags: \n    - gradle\n    - groovy\n    - kotlin\n    - kts \n---\n\n> 本质上还是要搞清楚 KTS 是怎么运行的 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1BU4y1b7Wk&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n要知道在 Groovy 当中想要做到这一点并不难，毕竟作为一门动态类型的语言，只要运行时能够访问到即可，反正又不需要 IDE 代码提示。但在 Kotlin 这里情况就显得有点儿麻烦了，因为我们添加的扩展要在编译的时候就能够让编译器访问到。\n\n## 1. Kotlin DSL 的 Gradle 脚本是怎么运行的？\n\n为了搞清楚怎么添加扩展，我们同样需要搞清楚采用 Kotlin DSL 的 Gradle 脚本是怎么运行的。但受限于篇幅，我就不带着大家一步一步去看源码了，大家有兴趣可以在 Gradle 源码当中找到 org.gradle.kotlin.dsl 包，其中就是有关 Kotlin DSL 的支持的实现。\n\n![Gradle Kotlin DSL 的源码路径](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png)\n\n有了前面“[你的 Gradle 脚本是怎么运行起来的？](http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=793373419&lang=zh_CN#rd)”这个视频的基础，相信大家已经了解了 Gradle 脚本运行时的两个阶段：\n\n* classpath 阶段\n* body 阶段\n\n其实 Kotlin DSL 也是如此，只不过运行的时候具体的形式稍微有些差异。\n\nKotlin DSL 版本的脚本被称为 \"Program\"，它在 Gradle 的实现当中也通过一个叫 **Program** 的类及其子类来描述，定义在 Program.kt 文件当中。\n\n```kotlin\nsealed class Program {\n\tobject Empty: Program() { ... }\n    data class Buildscript(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class PluginManagement(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class Plugins(override val fragment: ProgramSourceFragment) : Stage1(), FragmentHolder\n    data class Stage1Sequence(val pluginManagement: PluginManagement?, val buildscript: Buildscript?, val plugins: Plugins?) : Stage1()\n    data class Script(val source: ProgramSource) : Program()\n    data class Staged(val stage1: Stage1, val stage2: Script) : Program()\n    abstract class Stage1 : Program()\n}\n```\n\n注意到所有在 classpath 阶段编译运行的代码块都继承自 Stage1 这个类。我认为这段代码定义中最有趣的是 `Stage1Sequence`，它通过类型的形式强制给出了几个代码块的顺序的定义。\n\n> **提示：**可以看到这还是一个密封的使用案例，所以不要总是说密封类没啥用，代码储备量的贫乏限制了大家的想象力。\n\n那么它究竟是怎么运行的呢？\n\n简单来说就是任意一个 Kotlin DSL 的 Gradle 脚本都会把分属于不同阶段的部分拆分开，每一个部分都会编译成两个类，叫做 **Program** 和 **Build_gradle**，其中 Program 类的 execute 函数是调用入口，DSL 脚本的内容则被编译成 Build_gradle 类的构造函数。\n\n![Kotlin DSL 的编译运行示意图](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417092350607.png)\n\n有朋友肯定会发出疑问，两个阶段分别编译出不同的两个类，但名字是一样的，这不会冲突吗？当然不会，二者运行时用的 classloader 都是不一样的。而且需要特别注意的是，我们会在 classpath 阶段的 buildscript 代码块中添加 classpath，所以这个阶段与 body 阶段运行时的 classpath 是不一样的，因此不是所有在 body 阶段能访问到的类和成员都能在 classpath 阶段访问到。\n\n我们以之前改造好的根目录下的 build.gradle.kts 为例，它的内容如下：\n\n```kotlin\n// Top-level(build file where you can add configuration options common to all sub-projects/modules.)\nbuildscript {\n    val kotlin_version: String by extra(\"1.4.30\")\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:4.0.1\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n\n        classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n        // For(Kotlin projects, you need to add Dokka.)\n        classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n    }\n}\n\nsubprojects {\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    afterEvaluate {\n        if (plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n            group = \"com.bennyhuo\"\n            version = \"1.0\"\n\n            apply(plugin = \"com.vanniktech.maven.publish\")\n        }\n    }\n}\n\ntasks.register<Delete>(\"clean\") {\n    delete(rootProject.buildDir)\n}\n```\n\n编译时会分成两部分，其中 \n\n* classpath 阶段的内容为：\n\n  ```kotlin\n  buildscript {\n      val kotlin_version: String by extra(\"1.4.30\")\n      repositories {\n          maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n      }\n      dependencies {\n          classpath(\"com.android.tools.build:gradle:4.0.1\")\n          classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n  \n          classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n          // For(Kotlin projects, you need to add Dokka.)\n          classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n      }\n  }\n  ```\n\n* body 阶段的内容为：\n\n  ```kotlin\n  // Top-level(build file where you can add configuration options common to all sub-projects/modules.)\n  subprojects {\n      repositories {\n          maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n      }\n      afterEvaluate {\n          if (plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n              group = \"com.bennyhuo\"\n              version = \"1.0\"\n  \n              apply(plugin = \"com.vanniktech.maven.publish\")\n          }\n      }\n  }\n  \n  tasks.register<Delete>(\"clean\") {\n      delete(rootProject.buildDir)\n  }\n  ```\n\n由于 body 阶段的 classloader 包含了 classpath 阶段添加的依赖，因此在 body 阶段可以访问所有前面 dependencies 当中添加的 maven 依赖库中的类。\n\n大家也可以单步调试一下这个脚本来深入了解一下它。值得一提的是，Gradle 在编译运行时会生成两个不同的 jar 包来存储 **Program** 和 **Gradle_build** 类，因此我们可以通过加载它的 classloader 找到这两个 jar 包的路径。\n\n在 buildscript 当中随便找个位置打断点，启动调试之后，就可以看到下面的情景，顺着 classloader 就可以看到生成的 jar 在 `<用户目录>/.gradle/caches/jars-8/` 下：\n\n![classpath stage 的脚本编译生成的 jar](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416171142126.png)\n\n我们找到这个 jar 包，里面正如我们前面所讲，两个类，反编译之后如下：\n\n```java\npublic final class Program extends StagedProgram {\n    public void execute(Host var1, KotlinScriptHost<?> var2) {\n        var1.setupEmbeddedKotlinFor(var2);\n\n        try {\n            // 运行 classpath 阶段的脚本\n            new Build_gradle(var2, (Project)var2.getTarget());\n        } catch (Throwable var5) {\n            var1.handleScriptException(var5, Build_gradle.class, var2);\n        }\n\n        var1.applyPluginsTo(var2, MultiPluginRequests.EMPTY);\n        var1.applyBasePluginsTo((Project)var2.getTarget());\n        // 加载并运行 body 阶段的脚本\n        var1.evaluateSecondStageOf(this, var2, \"Project/TopLevel/stage2\", HashCode.fromBytes(...), var1.accessorsClassPathFor(var2));\n    }\n\n   \t...\n}\n```\n\n```java\npublic class Build_gradle extends CompiledKotlinBuildscriptBlock {\n   public final Project $$implicitReceiver0;\n\t\n   public Build_gradle(KotlinScriptHost var1, Project var2) {\n      super(var1);\n      this.$$implicitReceiver0 = var2;\n      // 运行 buildscript 块\n      ((Build_gradle)this).buildscript((Function1)null.INSTANCE);\n      Unit var10001 = Unit.INSTANCE;\n   }\n}\n```\n\n实际上我们可以看到 classpath 阶段的脚本运行完之后马上就开始编译、加载和运行 body 阶段的脚本了。\n\n接下来我们再看下 body 阶段，同样断点运行到 body 对应的脚本时，我们可以看到调用栈其实跟 classpath 是一致的，调用顺序是 \n\n![脚本的调用顺序](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417093245689.png)\n\n其中第二个 eval 就是在运行 body 阶段的脚本了：\n\n![body stage 的脚本编译生成的 jar](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416170811407.png)\n\n这与我们反编译看到的 classpath 当中的 Program 的代码时一致的。\n\n我们也把 body 阶段的 jar 反编译后贴出来，我稍微加了点儿注释，大家可以大致感受一下对应的脚本内容：\n\n```java\npublic final class Program extends ExecutableProgram {\n    public void execute(Host var1, KotlinScriptHost<?> var2) {\n        try {\n            new Build_gradle(var2, (Project)var2.getTarget());\n        } catch (Throwable var5) {\n            var1.handleScriptException(var5, Build_gradle.class, var2);\n        }\n    }\n}\n```\n\n```java\npublic class Build_gradle extends CompiledKotlinBuildScript {\n   public final Project $$implicitReceiver0;\n   public final Delete $$result;\n\n   public Build_gradle(KotlinScriptHost var1, Project var2) {\n      super(var1);\n      this.$$implicitReceiver0 = var2;\n       // 调用 subprojects\n      this.$$implicitReceiver0.subprojects((Action)null.INSTANCE);\n       // 定义 task \"clean\"\n      Project $this$task$iv = this.$$implicitReceiver0;\n      String name$iv = \"clean\";\n       // task \"clean\" 的配置代码\n      Function1 configuration$iv = (Function1)(new Function1() \n         ...\n         public final void invoke(@NotNull Delete $this$task) {\n             // 对应于 group = \"build\"\n            $this$task.setGroup(\"build\");\n             \n             // 对应于 delete(rootProject.buildDir)\n            Object[] var10001 = new Object[1];\n            Project var10004 = Build_gradle.this.$$implicitReceiver0.getRootProject();\n            Intrinsics.checkExpressionValueIsNotNull(var10004, \"rootProject\");\n            var10001[0] = var10004.getBuildDir();\n            $this$task.delete(var10001);\n         }\n      });\n       \n       // 对应于 task<Delete>(...)，前面的 configuration$iv 对应于 Lambda 表达式\n      int $i$f$task = false;\n      Task var9 = ProjectExtensionsKt.task($this$task$iv, name$iv, Reflection.getOrCreateKotlinClass(Delete.class), configuration$iv);\n      this.$$result = (Delete)var9;\n   }\n}\n```\n\n截止目前，我想大家应该能够明白 Gradle Kotlin DSL 脚本是如何运行的了。\n\n接下来我们就看看如何实现扩展的定义。\n\n## 2. 定义一个像 mavenCentral 一样的函数\n\n我们定义一个类似于 mavenCentral 的函数 tencentCloud 来方便我们添加腾讯云的 maven 仓库镜像，并以此来说明扩展的定义有哪些注意事项。最终的效果是：\n\n```kotlin\nrepositories {\n    tencentCloud()\n    //等价于：maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n代码很好写，repositories { ... } 的参数的 Receiver 是 RepositoryHandler：\n\n```kotlin\nfun RepositoryHandler.tencentCloud() {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n接下来问题就是：我们应该把这个扩展函数写在哪里呢？\n\n### 2.1 定义在根工程的 build.gradle.kts 当中\n\n按照我们前面的分析，只要定义在 Gradle 脚本当中，不管写到哪里，都相当于定义了在了 Build_gradle 的构造函数当中，这样一个局部的函数只能在当前范围内使用：\n\n**build.gradle.kts(rootProject)**\n\n```kotlin\nfun RepositoryHandler.tencentCloud() {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n\nbuildscript {\n    repositories {\n        tencentCloud() // ERROR!! IDE 可能不报错，但编译报错\n    }\n    ...\n}\nsubprojects {\n    repositories {\n        tencentCloud() // OK，都在 body 阶段的 Build_gradle 构造内部\n    }\n   \t...\n}\n```\n\n**build.gradle.kts(:app)**\n\n```kotlin\nbuildscript {\n    repositories {\n        tencentCloud() // ERROR!! 不在同一个作用域内\n    }\n}\n```\n\n效果不理想，但不管怎么样，我们现在已经实现了相同运行阶段的文件范围内的扩展实现。\n\n### 2.2 定义在 buildSrc 当中\n\nbuildSrc 是一个神奇的存在，工程当中所有的脚本都可以访问到它当中的类和函数。我们可以在 BuildTreePreparingProjectsPreparer 的 prepareProjects 方法当中看到对 buildSrc 的处理：\n\n**文件：BuildTreePreparingProjectsPreparer.java**\n\n```java\npublic void prepareProjects(GradleInternal gradle) {\n\t...\n    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());\n    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);\n    ...\n    // Build buildSrc and export classpath to root project\n    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);\n\t// Evaluate projects\n    delegate.prepareProjects(gradle);\n\t...\n}\n```\n\n在 evaluate project 之前，buildSrc 模块的代码就被添加到了 baseProjectClassLoaderScope 当中，这个 classloaderScope 实际上是后续所有 project 的脚本都能访问到的。\n\n这样看来，在 build.gradle.kts 当中任意代码运行之前，buildSrc 的代码就已经在 classpath 当中了，因此把我们的扩展添加到 buildSrc 当中，就能解决整个工程的脚本访问的问题。\n\n至此，我们实现了为整个工程的构建脚本定义扩展。这一点与我们在 buildSrc 当中定义依赖的版本常量的思路实际上也是一致的。\n\n### 2.3 定义在 init.gradle.kts 当中\n\n接下来我们就要考虑，有没有什么办法让我的电脑上所有的工程都能支持这个扩展呢？\n\n我们很自然地想到 init.gradle.kts，因为 Gradle 会在处理编译流程之前就加载运行这个脚本；如果我们把它放到 **<用户目录>/.gradle/** 目录下，那么所有的工程在启动编译时都会默认执行这个脚本。\n\n不过事情并不是想想的那样顺利，因为 init.gradle.kts 当中直接定义这个扩展函数也会同样只能在局部范围内有效，达不到我们的目标。\n\n那是不是只要比 project 当中的 buildscript 执行得早，并且我们提前通过常规的 classpath 函数添加依赖，就能让 project 当中的 buildscript 访问到呢？不行。例如：\n\n```kotlin\nbeforeProject {\n    buildscript {\n        repositories {\n            mavenLocal()\n        }\n        dependencies {\n            classpath(\"com.bennyhuo.gradle:repos:1.0-SNAPSHOT\")\n        }\n    }\n}\n```\n\n我把我们的扩展发布到 maven 的仓库当中，然后通过常规的 classpath 的方式引入，我们非常清楚这段代码一定会比我们在工程当中的 buildscript 先运行，但 classpath 调用之后实际上是添加到了 body 阶段的 classloader 当中的，而在 classpath 阶段运行的 buildscript 使用的 classloader 实际上是 body 阶段的父 classloader，因而达不到我们的目的。\n\n那怎么办？经过我反复的调试，暂时没有找到很好的正规途径的办法。\n\n常规操作搞不定就只能骚操作了。思路也很简单，找到加载 buildSrc 的那个 classloader，它其实也是加载运行 classpath 阶段的 buildscript  代码的 classloader，我们在里面添加一下我们自己的依赖即可。重点就在 BuildTreePreparingProjectsPreparer 的 prepareProjects 当中:\n\n**文件：BuildTreePreparingProjectsPreparer.java**\n\n```java\npublic void prepareProjects(GradleInternal gradle) {\n\t...\n    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());\n    // 这个 classloader 被 gradle 持有，我们可以通过 gradle 实例获取到它\n    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);\n    ...\n    // Build buildSrc and export classpath to root project\n    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);\n\t// Evaluate projects\n    delegate.prepareProjects(gradle);\n\t...\n}\n```\n\n再看 buildBuildSrcAndLockClassloader 方法：\n\n```java\nprivate void buildBuildSrcAndLockClassloader(GradleInternal gradle, ClassLoaderScope baseProjectClassLoaderScope) {\n    ClassPath buildSrcClassPath = buildSourceBuilder.buildAndGetClassPath(gradle);\n    // 重点看这一句，export 可以添加一个 `ClassPath` 类型的实例\n    baseProjectClassLoaderScope.export(buildSrcClassPath).lock();\n}\n```\n\n因此只要我们自己也调用一下这个 export 方法，把我们自己编译好的 jar 包作为 ClassPath 传进去，问题就解决了。\n\n当然，上帝在为我们打开了一扇窗户的同时又装上了不锈钢纱窗。事情并不是那么直接就能办到的，因为后面那个 lock，它的意思真的就是 lock。\n\n**文件：DefaultClassLoaderScope.java**\n\n```java\npublic ClassLoaderScope export(ClassPath classPath) {\n    ...\n    // 必须是非锁定状态，如果已经 lock，这里抛出断言异常\n    assertNotLocked();\n    // 在解析了所有的 classpath 之后才会创建，buildSrc 添加的时候为 null\n    if (exportingClassLoader != null) {\n        ...\n    } else {\n        // 命中这个分支\n        export = export.plus(classPath);\n    }\n    return this;\n}\n```\n\nlock 了之后，我们想要直接调用 export 方法来添加我们自己的 jar 包的愿望落空，不过上帝还是给我们的不锈钢纱窗留了一把钥匙的，那就是 Java 反射。我们可以通过反射来直接修改 export，无视 lock 的状态，代码如下：\n\n```kotlin\nimport org.gradle.api.internal.GradleInternal\nimport org.gradle.api.internal.initialization.DefaultClassLoaderScope\nimport org.gradle.internal.classpath.ClassPath\nimport org.gradle.internal.classpath.DefaultClassPath\n\n// 获取当前脚本所在目录下的 repos-1.0-SNAPSHOT.jar 文件\nval depFile = file(\"repos-1.0-SNAPSHOT.jar\")\n// 在 project evaluate 之前调用，比 buildscript 早\nbeforeProject {\n    if (this == rootProject){\n        val gradleInternal = gradle as GradleInternal\n        val field = DefaultClassLoaderScope::class.java.getDeclaredField(\"export\")\n        field.isAccessible = true\n        val oldClassPath = field.get(gradleInternal.baseProjectClassLoaderScope()) as ClassPath\n        field.set(gradleInternal.baseProjectClassLoaderScope(), oldClassPath + DefaultClassPath.of(depFile))\n    }\n}\n```\n\n把扩展函数编译成的 jar 文件也放到 **<用户目录>/.gradle/** 中：\n\n![init 脚本和 jar 依赖的文件路径](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417085046475.png)\n\n这样运行时就会把这个 jar 添加到 baseProjectClassLoaderScope 当中，所有的工程就都能访问到它了。\n\n需要注意的是，我们的示例是基于 Gradle 7.0 的，不同版本可能会存在差异。\n\n### 2.4 如果是 Groovy 呢？\n\n之所以这么麻烦，就是因为我们需要兼顾 Kotlin 的静态类型的特性。如果是 Groovy 版本的特性，那么问题就简单多了，你只需要在 init.gradle 当中添加以下代码：\n\n```groovy\nRepositoryHandler.metaClass.tencentCloud {\n    delegate.maven {\n      url \"https://mirrors.tencent.com/nexus/repository/maven-public/\"\n    }\n}\n```\n\n后面访问 RepositoryHandler 的 tencentCloud 方法的时候就能够动态调用到这个扩展了。这实际上是 Groovy 元编程的内容，我们就不展开介绍了。\n\n## 3. 小结\n\n本节我们以实现一个简单的扩展为背景，先了解了一下 Kotlin DSL 的运行机制，接着又给出了在各个范围内实现扩展的方法。\n\n一个很小的需求，实际上需要我们了解的背景知识还是很多的。\n\n很多时候我们的学习和成长都是以点筑面，大厦固然高，但抵不住我一层一层地爬。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"Add-extensions-to-build-scripts","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002x0008lduzhd5cbcxv","content":"<blockquote>\n<p>本质上还是要搞清楚 KTS 是怎么运行的 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1BU4y1b7Wk&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<span id=\"more\"></span>\n\n\n\n\n<p>要知道在 Groovy 当中想要做到这一点并不难，毕竟作为一门动态类型的语言，只要运行时能够访问到即可，反正又不需要 IDE 代码提示。但在 Kotlin 这里情况就显得有点儿麻烦了，因为我们添加的扩展要在编译的时候就能够让编译器访问到。</p>\n<h2 id=\"1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？\"><a href=\"#1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？\" class=\"headerlink\" title=\"1. Kotlin DSL 的 Gradle 脚本是怎么运行的？\"></a>1. Kotlin DSL 的 Gradle 脚本是怎么运行的？</h2><p>为了搞清楚怎么添加扩展，我们同样需要搞清楚采用 Kotlin DSL 的 Gradle 脚本是怎么运行的。但受限于篇幅，我就不带着大家一步一步去看源码了，大家有兴趣可以在 Gradle 源码当中找到 org.gradle.kotlin.dsl 包，其中就是有关 Kotlin DSL 的支持的实现。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png\" alt=\"Gradle Kotlin DSL 的源码路径\"></p>\n<p>有了前面“<a href=\"http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=793373419&lang=zh_CN#rd\">你的 Gradle 脚本是怎么运行起来的？</a>”这个视频的基础，相信大家已经了解了 Gradle 脚本运行时的两个阶段：</p>\n<ul>\n<li>classpath 阶段</li>\n<li>body 阶段</li>\n</ul>\n<p>其实 Kotlin DSL 也是如此，只不过运行的时候具体的形式稍微有些差异。</p>\n<p>Kotlin DSL 版本的脚本被称为 “Program”，它在 Gradle 的实现当中也通过一个叫 <strong>Program</strong> 的类及其子类来描述，定义在 Program.kt 文件当中。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">object</span> Empty: Program() &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buildscript</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PluginManagement</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Plugins</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stage1Sequence</span></span>(<span class=\"keyword\">val</span> pluginManagement: PluginManagement?, <span class=\"keyword\">val</span> buildscript: Buildscript?, <span class=\"keyword\">val</span> plugins: Plugins?) : Stage1()</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Script</span></span>(<span class=\"keyword\">val</span> source: ProgramSource) : Program()</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Staged</span></span>(<span class=\"keyword\">val</span> stage1: Stage1, <span class=\"keyword\">val</span> stage2: Script) : Program()</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stage1</span> : <span class=\"type\">Program</span></span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到所有在 classpath 阶段编译运行的代码块都继承自 Stage1 这个类。我认为这段代码定义中最有趣的是 <code>Stage1Sequence</code>，它通过类型的形式强制给出了几个代码块的顺序的定义。</p>\n<blockquote>\n<p><strong>提示：</strong>可以看到这还是一个密封的使用案例，所以不要总是说密封类没啥用，代码储备量的贫乏限制了大家的想象力。</p>\n</blockquote>\n<p>那么它究竟是怎么运行的呢？</p>\n<p>简单来说就是任意一个 Kotlin DSL 的 Gradle 脚本都会把分属于不同阶段的部分拆分开，每一个部分都会编译成两个类，叫做 <strong>Program</strong> 和 <strong>Build_gradle</strong>，其中 Program 类的 execute 函数是调用入口，DSL 脚本的内容则被编译成 Build_gradle 类的构造函数。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417092350607.png\" alt=\"Kotlin DSL 的编译运行示意图\"></p>\n<p>有朋友肯定会发出疑问，两个阶段分别编译出不同的两个类，但名字是一样的，这不会冲突吗？当然不会，二者运行时用的 classloader 都是不一样的。而且需要特别注意的是，我们会在 classpath 阶段的 buildscript 代码块中添加 classpath，所以这个阶段与 body 阶段运行时的 classpath 是不一样的，因此不是所有在 body 阶段能访问到的类和成员都能在 classpath 阶段访问到。</p>\n<p>我们以之前改造好的根目录下的 build.gradle.kts 为例，它的内容如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterEvaluate &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">            group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">            version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            apply(plugin = <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译时会分成两部分，其中 </p>\n<ul>\n<li><p>classpath 阶段的内容为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>body 阶段的内容为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterEvaluate &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">            group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">            version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            apply(plugin = <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>由于 body 阶段的 classloader 包含了 classpath 阶段添加的依赖，因此在 body 阶段可以访问所有前面 dependencies 当中添加的 maven 依赖库中的类。</p>\n<p>大家也可以单步调试一下这个脚本来深入了解一下它。值得一提的是，Gradle 在编译运行时会生成两个不同的 jar 包来存储 <strong>Program</strong> 和 <strong>Gradle_build</strong> 类，因此我们可以通过加载它的 classloader 找到这两个 jar 包的路径。</p>\n<p>在 buildscript 当中随便找个位置打断点，启动调试之后，就可以看到下面的情景，顺着 classloader 就可以看到生成的 jar 在 <code>&lt;用户目录&gt;/.gradle/caches/jars-8/</code> 下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416171142126.png\" alt=\"classpath stage 的脚本编译生成的 jar\"></p>\n<p>我们找到这个 jar 包，里面正如我们前面所讲，两个类，反编译之后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> <span class=\"keyword\">extends</span> <span class=\"title\">StagedProgram</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> </span>&#123;</span><br><span class=\"line\">        var1.setupEmbeddedKotlinFor(var2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 运行 classpath 阶段的脚本</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Build_gradle(var2, (Project)var2.getTarget());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var5) &#123;</span><br><span class=\"line\">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var1.applyPluginsTo(var2, MultiPluginRequests.EMPTY);</span><br><span class=\"line\">        var1.applyBasePluginsTo((Project)var2.getTarget());</span><br><span class=\"line\">        <span class=\"comment\">// 加载并运行 body 阶段的脚本</span></span><br><span class=\"line\">        var1.evaluateSecondStageOf(<span class=\"keyword\">this</span>, var2, <span class=\"string\">&quot;Project/TopLevel/stage2&quot;</span>, HashCode.fromBytes(...), var1.accessorsClassPathFor(var2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build_gradle</span> <span class=\"keyword\">extends</span> <span class=\"title\">CompiledKotlinBuildscriptBlock</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Project $$implicitReceiver0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Build_gradle</span><span class=\"params\">(KotlinScriptHost var1, Project var2)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0 = var2;</span><br><span class=\"line\">      <span class=\"comment\">// 运行 buildscript 块</span></span><br><span class=\"line\">      ((Build_gradle)<span class=\"keyword\">this</span>).buildscript((Function1)<span class=\"keyword\">null</span>.INSTANCE);</span><br><span class=\"line\">      Unit var10001 = Unit.INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上我们可以看到 classpath 阶段的脚本运行完之后马上就开始编译、加载和运行 body 阶段的脚本了。</p>\n<p>接下来我们再看下 body 阶段，同样断点运行到 body 对应的脚本时，我们可以看到调用栈其实跟 classpath 是一致的，调用顺序是 </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417093245689.png\" alt=\"脚本的调用顺序\"></p>\n<p>其中第二个 eval 就是在运行 body 阶段的脚本了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416170811407.png\" alt=\"body stage 的脚本编译生成的 jar\"></p>\n<p>这与我们反编译看到的 classpath 当中的 Program 的代码时一致的。</p>\n<p>我们也把 body 阶段的 jar 反编译后贴出来，我稍微加了点儿注释，大家可以大致感受一下对应的脚本内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> <span class=\"keyword\">extends</span> <span class=\"title\">ExecutableProgram</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Build_gradle(var2, (Project)var2.getTarget());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var5) &#123;</span><br><span class=\"line\">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build_gradle</span> <span class=\"keyword\">extends</span> <span class=\"title\">CompiledKotlinBuildScript</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Project $$implicitReceiver0;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Delete $$result;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Build_gradle</span><span class=\"params\">(KotlinScriptHost var1, Project var2)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0 = var2;</span><br><span class=\"line\">       <span class=\"comment\">// 调用 subprojects</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0.subprojects((Action)<span class=\"keyword\">null</span>.INSTANCE);</span><br><span class=\"line\">       <span class=\"comment\">// 定义 task &quot;clean&quot;</span></span><br><span class=\"line\">      Project $<span class=\"keyword\">this</span>$task$iv = <span class=\"keyword\">this</span>.$$implicitReceiver0;</span><br><span class=\"line\">      String name$iv = <span class=\"string\">&quot;clean&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// task &quot;clean&quot; 的配置代码</span></span><br><span class=\"line\">      Function1 configuration$iv = (Function1)(<span class=\"keyword\">new</span> Function1() </span><br><span class=\"line\">         ...</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Delete $<span class=\"keyword\">this</span>$task)</span> </span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// 对应于 group = &quot;build&quot;</span></span><br><span class=\"line\">            $<span class=\"keyword\">this</span>$task.setGroup(<span class=\"string\">&quot;build&quot;</span>);</span><br><span class=\"line\">             </span><br><span class=\"line\">             <span class=\"comment\">// 对应于 delete(rootProject.buildDir)</span></span><br><span class=\"line\">            Object[] var10001 = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">            Project var10004 = Build_gradle.<span class=\"keyword\">this</span>.$$implicitReceiver0.getRootProject();</span><br><span class=\"line\">            Intrinsics.checkExpressionValueIsNotNull(var10004, <span class=\"string\">&quot;rootProject&quot;</span>);</span><br><span class=\"line\">            var10001[<span class=\"number\">0</span>] = var10004.getBuildDir();</span><br><span class=\"line\">            $<span class=\"keyword\">this</span>$task.delete(var10001);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">// 对应于 task&lt;Delete&gt;(...)，前面的 configuration$iv 对应于 Lambda 表达式</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> $i$f$task = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      Task var9 = ProjectExtensionsKt.task($<span class=\"keyword\">this</span>$task$iv, name$iv, Reflection.getOrCreateKotlinClass(Delete.class), configuration$iv);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$result = (Delete)var9;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>截止目前，我想大家应该能够明白 Gradle Kotlin DSL 脚本是如何运行的了。</p>\n<p>接下来我们就看看如何实现扩展的定义。</p>\n<h2 id=\"2-定义一个像-mavenCentral-一样的函数\"><a href=\"#2-定义一个像-mavenCentral-一样的函数\" class=\"headerlink\" title=\"2. 定义一个像 mavenCentral 一样的函数\"></a>2. 定义一个像 mavenCentral 一样的函数</h2><p>我们定义一个类似于 mavenCentral 的函数 tencentCloud 来方便我们添加腾讯云的 maven 仓库镜像，并以此来说明扩展的定义有哪些注意事项。最终的效果是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    tencentCloud()</span><br><span class=\"line\">    <span class=\"comment\">//等价于：maven(&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很好写，repositories { … } 的参数的 Receiver 是 RepositoryHandler：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> RepositoryHandler.<span class=\"title\">tencentCloud</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来问题就是：我们应该把这个扩展函数写在哪里呢？</p>\n<h3 id=\"2-1-定义在根工程的-build-gradle-kts-当中\"><a href=\"#2-1-定义在根工程的-build-gradle-kts-当中\" class=\"headerlink\" title=\"2.1 定义在根工程的 build.gradle.kts 当中\"></a>2.1 定义在根工程的 build.gradle.kts 当中</h3><p>按照我们前面的分析，只要定义在 Gradle 脚本当中，不管写到哪里，都相当于定义了在了 Build_gradle 的构造函数当中，这样一个局部的函数只能在当前范围内使用：</p>\n<p><strong>build.gradle.kts(rootProject)</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> RepositoryHandler.<span class=\"title\">tencentCloud</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// ERROR!! IDE 可能不报错，但编译报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// OK，都在 body 阶段的 Build_gradle 构造内部</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>build.gradle.kts(:app)</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// ERROR!! 不在同一个作用域内</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果不理想，但不管怎么样，我们现在已经实现了相同运行阶段的文件范围内的扩展实现。</p>\n<h3 id=\"2-2-定义在-buildSrc-当中\"><a href=\"#2-2-定义在-buildSrc-当中\" class=\"headerlink\" title=\"2.2 定义在 buildSrc 当中\"></a>2.2 定义在 buildSrc 当中</h3><p>buildSrc 是一个神奇的存在，工程当中所有的脚本都可以访问到它当中的类和函数。我们可以在 BuildTreePreparingProjectsPreparer 的 prepareProjects 方法当中看到对 buildSrc 的处理：</p>\n<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareProjects</span><span class=\"params\">(GradleInternal gradle)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class=\"line\">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Build buildSrc and export classpath to root project</span></span><br><span class=\"line\">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class=\"line\">\t<span class=\"comment\">// Evaluate projects</span></span><br><span class=\"line\">    delegate.prepareProjects(gradle);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 evaluate project 之前，buildSrc 模块的代码就被添加到了 baseProjectClassLoaderScope 当中，这个 classloaderScope 实际上是后续所有 project 的脚本都能访问到的。</p>\n<p>这样看来，在 build.gradle.kts 当中任意代码运行之前，buildSrc 的代码就已经在 classpath 当中了，因此把我们的扩展添加到 buildSrc 当中，就能解决整个工程的脚本访问的问题。</p>\n<p>至此，我们实现了为整个工程的构建脚本定义扩展。这一点与我们在 buildSrc 当中定义依赖的版本常量的思路实际上也是一致的。</p>\n<h3 id=\"2-3-定义在-init-gradle-kts-当中\"><a href=\"#2-3-定义在-init-gradle-kts-当中\" class=\"headerlink\" title=\"2.3 定义在 init.gradle.kts 当中\"></a>2.3 定义在 init.gradle.kts 当中</h3><p>接下来我们就要考虑，有没有什么办法让我的电脑上所有的工程都能支持这个扩展呢？</p>\n<p>我们很自然地想到 init.gradle.kts，因为 Gradle 会在处理编译流程之前就加载运行这个脚本；如果我们把它放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 目录下，那么所有的工程在启动编译时都会默认执行这个脚本。</p>\n<p>不过事情并不是想想的那样顺利，因为 init.gradle.kts 当中直接定义这个扩展函数也会同样只能在局部范围内有效，达不到我们的目标。</p>\n<p>那是不是只要比 project 当中的 buildscript 执行得早，并且我们提前通过常规的 classpath 函数添加依赖，就能让 project 当中的 buildscript 访问到呢？不行。例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeProject &#123;</span><br><span class=\"line\">    buildscript &#123;</span><br><span class=\"line\">        repositories &#123;</span><br><span class=\"line\">            mavenLocal()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dependencies &#123;</span><br><span class=\"line\">            classpath(<span class=\"string\">&quot;com.bennyhuo.gradle:repos:1.0-SNAPSHOT&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我把我们的扩展发布到 maven 的仓库当中，然后通过常规的 classpath 的方式引入，我们非常清楚这段代码一定会比我们在工程当中的 buildscript 先运行，但 classpath 调用之后实际上是添加到了 body 阶段的 classloader 当中的，而在 classpath 阶段运行的 buildscript 使用的 classloader 实际上是 body 阶段的父 classloader，因而达不到我们的目的。</p>\n<p>那怎么办？经过我反复的调试，暂时没有找到很好的正规途径的办法。</p>\n<p>常规操作搞不定就只能骚操作了。思路也很简单，找到加载 buildSrc 的那个 classloader，它其实也是加载运行 classpath 阶段的 buildscript  代码的 classloader，我们在里面添加一下我们自己的依赖即可。重点就在 BuildTreePreparingProjectsPreparer 的 prepareProjects 当中:</p>\n<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareProjects</span><span class=\"params\">(GradleInternal gradle)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class=\"line\">    <span class=\"comment\">// 这个 classloader 被 gradle 持有，我们可以通过 gradle 实例获取到它</span></span><br><span class=\"line\">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Build buildSrc and export classpath to root project</span></span><br><span class=\"line\">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class=\"line\">\t<span class=\"comment\">// Evaluate projects</span></span><br><span class=\"line\">    delegate.prepareProjects(gradle);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看 buildBuildSrcAndLockClassloader 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buildBuildSrcAndLockClassloader</span><span class=\"params\">(GradleInternal gradle, ClassLoaderScope baseProjectClassLoaderScope)</span> </span>&#123;</span><br><span class=\"line\">    ClassPath buildSrcClassPath = buildSourceBuilder.buildAndGetClassPath(gradle);</span><br><span class=\"line\">    <span class=\"comment\">// 重点看这一句，export 可以添加一个 `ClassPath` 类型的实例</span></span><br><span class=\"line\">    baseProjectClassLoaderScope.export(buildSrcClassPath).lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此只要我们自己也调用一下这个 export 方法，把我们自己编译好的 jar 包作为 ClassPath 传进去，问题就解决了。</p>\n<p>当然，上帝在为我们打开了一扇窗户的同时又装上了不锈钢纱窗。事情并不是那么直接就能办到的，因为后面那个 lock，它的意思真的就是 lock。</p>\n<p><strong>文件：DefaultClassLoaderScope.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ClassLoaderScope <span class=\"title\">export</span><span class=\"params\">(ClassPath classPath)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 必须是非锁定状态，如果已经 lock，这里抛出断言异常</span></span><br><span class=\"line\">    assertNotLocked();</span><br><span class=\"line\">    <span class=\"comment\">// 在解析了所有的 classpath 之后才会创建，buildSrc 添加的时候为 null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exportingClassLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 命中这个分支</span></span><br><span class=\"line\">        export = export.plus(classPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lock 了之后，我们想要直接调用 export 方法来添加我们自己的 jar 包的愿望落空，不过上帝还是给我们的不锈钢纱窗留了一把钥匙的，那就是 Java 反射。我们可以通过反射来直接修改 export，无视 lock 的状态，代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.<span class=\"keyword\">internal</span>.GradleInternal</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.<span class=\"keyword\">internal</span>.initialization.DefaultClassLoaderScope</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.<span class=\"keyword\">internal</span>.classpath.ClassPath</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.<span class=\"keyword\">internal</span>.classpath.DefaultClassPath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前脚本所在目录下的 repos-1.0-SNAPSHOT.jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> depFile = file(<span class=\"string\">&quot;repos-1.0-SNAPSHOT.jar&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 在 project evaluate 之前调用，比 buildscript 早</span></span><br><span class=\"line\">beforeProject &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == rootProject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> gradleInternal = gradle <span class=\"keyword\">as</span> GradleInternal</span><br><span class=\"line\">        <span class=\"keyword\">val</span> field = DefaultClassLoaderScope::<span class=\"keyword\">class</span>.java.getDeclaredField(<span class=\"string\">&quot;export&quot;</span>)</span><br><span class=\"line\">        field.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> oldClassPath = field.<span class=\"keyword\">get</span>(gradleInternal.baseProjectClassLoaderScope()) <span class=\"keyword\">as</span> ClassPath</span><br><span class=\"line\">        field.<span class=\"keyword\">set</span>(gradleInternal.baseProjectClassLoaderScope(), oldClassPath + DefaultClassPath.of(depFile))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把扩展函数编译成的 jar 文件也放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 中：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417085046475.png\" alt=\"init 脚本和 jar 依赖的文件路径\"></p>\n<p>这样运行时就会把这个 jar 添加到 baseProjectClassLoaderScope 当中，所有的工程就都能访问到它了。</p>\n<p>需要注意的是，我们的示例是基于 Gradle 7.0 的，不同版本可能会存在差异。</p>\n<h3 id=\"2-4-如果是-Groovy-呢？\"><a href=\"#2-4-如果是-Groovy-呢？\" class=\"headerlink\" title=\"2.4 如果是 Groovy 呢？\"></a>2.4 如果是 Groovy 呢？</h3><p>之所以这么麻烦，就是因为我们需要兼顾 Kotlin 的静态类型的特性。如果是 Groovy 版本的特性，那么问题就简单多了，你只需要在 init.gradle 当中添加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RepositoryHandler.metaClass.tencentCloud &#123;</span><br><span class=\"line\">    delegate.maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后面访问 RepositoryHandler 的 tencentCloud 方法的时候就能够动态调用到这个扩展了。这实际上是 Groovy 元编程的内容，我们就不展开介绍了。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本节我们以实现一个简单的扩展为背景，先了解了一下 Kotlin DSL 的运行机制，接着又给出了在各个范围内实现扩展的方法。</p>\n<p>一个很小的需求，实际上需要我们了解的背景知识还是很多的。</p>\n<p>很多时候我们的学习和成长都是以点筑面，大厦固然高，但抵不住我一层一层地爬。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本质上还是要搞清楚 KTS 是怎么运行的 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1BU4y1b7Wk&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","more":"<p>要知道在 Groovy 当中想要做到这一点并不难，毕竟作为一门动态类型的语言，只要运行时能够访问到即可，反正又不需要 IDE 代码提示。但在 Kotlin 这里情况就显得有点儿麻烦了，因为我们添加的扩展要在编译的时候就能够让编译器访问到。</p>\n<h2 id=\"1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？\"><a href=\"#1-Kotlin-DSL-的-Gradle-脚本是怎么运行的？\" class=\"headerlink\" title=\"1. Kotlin DSL 的 Gradle 脚本是怎么运行的？\"></a>1. Kotlin DSL 的 Gradle 脚本是怎么运行的？</h2><p>为了搞清楚怎么添加扩展，我们同样需要搞清楚采用 Kotlin DSL 的 Gradle 脚本是怎么运行的。但受限于篇幅，我就不带着大家一步一步去看源码了，大家有兴趣可以在 Gradle 源码当中找到 org.gradle.kotlin.dsl 包，其中就是有关 Kotlin DSL 的支持的实现。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png\" alt=\"Gradle Kotlin DSL 的源码路径\"></p>\n<p>有了前面“<a href=\"http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=793373419&lang=zh_CN#rd\">你的 Gradle 脚本是怎么运行起来的？</a>”这个视频的基础，相信大家已经了解了 Gradle 脚本运行时的两个阶段：</p>\n<ul>\n<li>classpath 阶段</li>\n<li>body 阶段</li>\n</ul>\n<p>其实 Kotlin DSL 也是如此，只不过运行的时候具体的形式稍微有些差异。</p>\n<p>Kotlin DSL 版本的脚本被称为 “Program”，它在 Gradle 的实现当中也通过一个叫 <strong>Program</strong> 的类及其子类来描述，定义在 Program.kt 文件当中。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">object</span> Empty: Program() &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buildscript</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PluginManagement</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Plugins</span></span>(<span class=\"keyword\">override</span> <span class=\"keyword\">val</span> fragment: ProgramSourceFragment) : Stage1(), FragmentHolder</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stage1Sequence</span></span>(<span class=\"keyword\">val</span> pluginManagement: PluginManagement?, <span class=\"keyword\">val</span> buildscript: Buildscript?, <span class=\"keyword\">val</span> plugins: Plugins?) : Stage1()</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Script</span></span>(<span class=\"keyword\">val</span> source: ProgramSource) : Program()</span><br><span class=\"line\">    <span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Staged</span></span>(<span class=\"keyword\">val</span> stage1: Stage1, <span class=\"keyword\">val</span> stage2: Script) : Program()</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stage1</span> : <span class=\"type\">Program</span></span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到所有在 classpath 阶段编译运行的代码块都继承自 Stage1 这个类。我认为这段代码定义中最有趣的是 <code>Stage1Sequence</code>，它通过类型的形式强制给出了几个代码块的顺序的定义。</p>\n<blockquote>\n<p><strong>提示：</strong>可以看到这还是一个密封的使用案例，所以不要总是说密封类没啥用，代码储备量的贫乏限制了大家的想象力。</p>\n</blockquote>\n<p>那么它究竟是怎么运行的呢？</p>\n<p>简单来说就是任意一个 Kotlin DSL 的 Gradle 脚本都会把分属于不同阶段的部分拆分开，每一个部分都会编译成两个类，叫做 <strong>Program</strong> 和 <strong>Build_gradle</strong>，其中 Program 类的 execute 函数是调用入口，DSL 脚本的内容则被编译成 Build_gradle 类的构造函数。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417092350607.png\" alt=\"Kotlin DSL 的编译运行示意图\"></p>\n<p>有朋友肯定会发出疑问，两个阶段分别编译出不同的两个类，但名字是一样的，这不会冲突吗？当然不会，二者运行时用的 classloader 都是不一样的。而且需要特别注意的是，我们会在 classpath 阶段的 buildscript 代码块中添加 classpath，所以这个阶段与 body 阶段运行时的 classpath 是不一样的，因此不是所有在 body 阶段能访问到的类和成员都能在 classpath 阶段访问到。</p>\n<p>我们以之前改造好的根目录下的 build.gradle.kts 为例，它的内容如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterEvaluate &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">            group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">            version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            apply(plugin = <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译时会分成两部分，其中 </p>\n<ul>\n<li><p>classpath 阶段的内容为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>body 阶段的内容为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Top-level(build file where you can add configuration options common to all sub-projects/modules.)</span></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    afterEvaluate &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">            group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">            version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            apply(plugin = <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>由于 body 阶段的 classloader 包含了 classpath 阶段添加的依赖，因此在 body 阶段可以访问所有前面 dependencies 当中添加的 maven 依赖库中的类。</p>\n<p>大家也可以单步调试一下这个脚本来深入了解一下它。值得一提的是，Gradle 在编译运行时会生成两个不同的 jar 包来存储 <strong>Program</strong> 和 <strong>Gradle_build</strong> 类，因此我们可以通过加载它的 classloader 找到这两个 jar 包的路径。</p>\n<p>在 buildscript 当中随便找个位置打断点，启动调试之后，就可以看到下面的情景，顺着 classloader 就可以看到生成的 jar 在 <code>&lt;用户目录&gt;/.gradle/caches/jars-8/</code> 下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416171142126.png\" alt=\"classpath stage 的脚本编译生成的 jar\"></p>\n<p>我们找到这个 jar 包，里面正如我们前面所讲，两个类，反编译之后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> <span class=\"keyword\">extends</span> <span class=\"title\">StagedProgram</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> </span>&#123;</span><br><span class=\"line\">        var1.setupEmbeddedKotlinFor(var2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 运行 classpath 阶段的脚本</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Build_gradle(var2, (Project)var2.getTarget());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var5) &#123;</span><br><span class=\"line\">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var1.applyPluginsTo(var2, MultiPluginRequests.EMPTY);</span><br><span class=\"line\">        var1.applyBasePluginsTo((Project)var2.getTarget());</span><br><span class=\"line\">        <span class=\"comment\">// 加载并运行 body 阶段的脚本</span></span><br><span class=\"line\">        var1.evaluateSecondStageOf(<span class=\"keyword\">this</span>, var2, <span class=\"string\">&quot;Project/TopLevel/stage2&quot;</span>, HashCode.fromBytes(...), var1.accessorsClassPathFor(var2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build_gradle</span> <span class=\"keyword\">extends</span> <span class=\"title\">CompiledKotlinBuildscriptBlock</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Project $$implicitReceiver0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Build_gradle</span><span class=\"params\">(KotlinScriptHost var1, Project var2)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0 = var2;</span><br><span class=\"line\">      <span class=\"comment\">// 运行 buildscript 块</span></span><br><span class=\"line\">      ((Build_gradle)<span class=\"keyword\">this</span>).buildscript((Function1)<span class=\"keyword\">null</span>.INSTANCE);</span><br><span class=\"line\">      Unit var10001 = Unit.INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上我们可以看到 classpath 阶段的脚本运行完之后马上就开始编译、加载和运行 body 阶段的脚本了。</p>\n<p>接下来我们再看下 body 阶段，同样断点运行到 body 对应的脚本时，我们可以看到调用栈其实跟 classpath 是一致的，调用顺序是 </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417093245689.png\" alt=\"脚本的调用顺序\"></p>\n<p>其中第二个 eval 就是在运行 body 阶段的脚本了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416170811407.png\" alt=\"body stage 的脚本编译生成的 jar\"></p>\n<p>这与我们反编译看到的 classpath 当中的 Program 的代码时一致的。</p>\n<p>我们也把 body 阶段的 jar 反编译后贴出来，我稍微加了点儿注释，大家可以大致感受一下对应的脚本内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span> <span class=\"keyword\">extends</span> <span class=\"title\">ExecutableProgram</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Host var1, KotlinScriptHost&lt;?&gt; var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Build_gradle(var2, (Project)var2.getTarget());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var5) &#123;</span><br><span class=\"line\">            var1.handleScriptException(var5, Build_gradle.class, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Build_gradle</span> <span class=\"keyword\">extends</span> <span class=\"title\">CompiledKotlinBuildScript</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Project $$implicitReceiver0;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Delete $$result;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Build_gradle</span><span class=\"params\">(KotlinScriptHost var1, Project var2)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0 = var2;</span><br><span class=\"line\">       <span class=\"comment\">// 调用 subprojects</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$implicitReceiver0.subprojects((Action)<span class=\"keyword\">null</span>.INSTANCE);</span><br><span class=\"line\">       <span class=\"comment\">// 定义 task &quot;clean&quot;</span></span><br><span class=\"line\">      Project $<span class=\"keyword\">this</span>$task$iv = <span class=\"keyword\">this</span>.$$implicitReceiver0;</span><br><span class=\"line\">      String name$iv = <span class=\"string\">&quot;clean&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// task &quot;clean&quot; 的配置代码</span></span><br><span class=\"line\">      Function1 configuration$iv = (Function1)(<span class=\"keyword\">new</span> Function1() </span><br><span class=\"line\">         ...</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Delete $<span class=\"keyword\">this</span>$task)</span> </span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// 对应于 group = &quot;build&quot;</span></span><br><span class=\"line\">            $<span class=\"keyword\">this</span>$task.setGroup(<span class=\"string\">&quot;build&quot;</span>);</span><br><span class=\"line\">             </span><br><span class=\"line\">             <span class=\"comment\">// 对应于 delete(rootProject.buildDir)</span></span><br><span class=\"line\">            Object[] var10001 = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">            Project var10004 = Build_gradle.<span class=\"keyword\">this</span>.$$implicitReceiver0.getRootProject();</span><br><span class=\"line\">            Intrinsics.checkExpressionValueIsNotNull(var10004, <span class=\"string\">&quot;rootProject&quot;</span>);</span><br><span class=\"line\">            var10001[<span class=\"number\">0</span>] = var10004.getBuildDir();</span><br><span class=\"line\">            $<span class=\"keyword\">this</span>$task.delete(var10001);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">// 对应于 task&lt;Delete&gt;(...)，前面的 configuration$iv 对应于 Lambda 表达式</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> $i$f$task = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      Task var9 = ProjectExtensionsKt.task($<span class=\"keyword\">this</span>$task$iv, name$iv, Reflection.getOrCreateKotlinClass(Delete.class), configuration$iv);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$$result = (Delete)var9;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>截止目前，我想大家应该能够明白 Gradle Kotlin DSL 脚本是如何运行的了。</p>\n<p>接下来我们就看看如何实现扩展的定义。</p>\n<h2 id=\"2-定义一个像-mavenCentral-一样的函数\"><a href=\"#2-定义一个像-mavenCentral-一样的函数\" class=\"headerlink\" title=\"2. 定义一个像 mavenCentral 一样的函数\"></a>2. 定义一个像 mavenCentral 一样的函数</h2><p>我们定义一个类似于 mavenCentral 的函数 tencentCloud 来方便我们添加腾讯云的 maven 仓库镜像，并以此来说明扩展的定义有哪些注意事项。最终的效果是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    tencentCloud()</span><br><span class=\"line\">    <span class=\"comment\">//等价于：maven(&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很好写，repositories { … } 的参数的 Receiver 是 RepositoryHandler：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> RepositoryHandler.<span class=\"title\">tencentCloud</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来问题就是：我们应该把这个扩展函数写在哪里呢？</p>\n<h3 id=\"2-1-定义在根工程的-build-gradle-kts-当中\"><a href=\"#2-1-定义在根工程的-build-gradle-kts-当中\" class=\"headerlink\" title=\"2.1 定义在根工程的 build.gradle.kts 当中\"></a>2.1 定义在根工程的 build.gradle.kts 当中</h3><p>按照我们前面的分析，只要定义在 Gradle 脚本当中，不管写到哪里，都相当于定义了在了 Build_gradle 的构造函数当中，这样一个局部的函数只能在当前范围内使用：</p>\n<p><strong>build.gradle.kts(rootProject)</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> RepositoryHandler.<span class=\"title\">tencentCloud</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// ERROR!! IDE 可能不报错，但编译报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// OK，都在 body 阶段的 Build_gradle 构造内部</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>build.gradle.kts(:app)</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        tencentCloud() <span class=\"comment\">// ERROR!! 不在同一个作用域内</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果不理想，但不管怎么样，我们现在已经实现了相同运行阶段的文件范围内的扩展实现。</p>\n<h3 id=\"2-2-定义在-buildSrc-当中\"><a href=\"#2-2-定义在-buildSrc-当中\" class=\"headerlink\" title=\"2.2 定义在 buildSrc 当中\"></a>2.2 定义在 buildSrc 当中</h3><p>buildSrc 是一个神奇的存在，工程当中所有的脚本都可以访问到它当中的类和函数。我们可以在 BuildTreePreparingProjectsPreparer 的 prepareProjects 方法当中看到对 buildSrc 的处理：</p>\n<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareProjects</span><span class=\"params\">(GradleInternal gradle)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class=\"line\">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Build buildSrc and export classpath to root project</span></span><br><span class=\"line\">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class=\"line\">\t<span class=\"comment\">// Evaluate projects</span></span><br><span class=\"line\">    delegate.prepareProjects(gradle);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 evaluate project 之前，buildSrc 模块的代码就被添加到了 baseProjectClassLoaderScope 当中，这个 classloaderScope 实际上是后续所有 project 的脚本都能访问到的。</p>\n<p>这样看来，在 build.gradle.kts 当中任意代码运行之前，buildSrc 的代码就已经在 classpath 当中了，因此把我们的扩展添加到 buildSrc 当中，就能解决整个工程的脚本访问的问题。</p>\n<p>至此，我们实现了为整个工程的构建脚本定义扩展。这一点与我们在 buildSrc 当中定义依赖的版本常量的思路实际上也是一致的。</p>\n<h3 id=\"2-3-定义在-init-gradle-kts-当中\"><a href=\"#2-3-定义在-init-gradle-kts-当中\" class=\"headerlink\" title=\"2.3 定义在 init.gradle.kts 当中\"></a>2.3 定义在 init.gradle.kts 当中</h3><p>接下来我们就要考虑，有没有什么办法让我的电脑上所有的工程都能支持这个扩展呢？</p>\n<p>我们很自然地想到 init.gradle.kts，因为 Gradle 会在处理编译流程之前就加载运行这个脚本；如果我们把它放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 目录下，那么所有的工程在启动编译时都会默认执行这个脚本。</p>\n<p>不过事情并不是想想的那样顺利，因为 init.gradle.kts 当中直接定义这个扩展函数也会同样只能在局部范围内有效，达不到我们的目标。</p>\n<p>那是不是只要比 project 当中的 buildscript 执行得早，并且我们提前通过常规的 classpath 函数添加依赖，就能让 project 当中的 buildscript 访问到呢？不行。例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeProject &#123;</span><br><span class=\"line\">    buildscript &#123;</span><br><span class=\"line\">        repositories &#123;</span><br><span class=\"line\">            mavenLocal()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dependencies &#123;</span><br><span class=\"line\">            classpath(<span class=\"string\">&quot;com.bennyhuo.gradle:repos:1.0-SNAPSHOT&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我把我们的扩展发布到 maven 的仓库当中，然后通过常规的 classpath 的方式引入，我们非常清楚这段代码一定会比我们在工程当中的 buildscript 先运行，但 classpath 调用之后实际上是添加到了 body 阶段的 classloader 当中的，而在 classpath 阶段运行的 buildscript 使用的 classloader 实际上是 body 阶段的父 classloader，因而达不到我们的目的。</p>\n<p>那怎么办？经过我反复的调试，暂时没有找到很好的正规途径的办法。</p>\n<p>常规操作搞不定就只能骚操作了。思路也很简单，找到加载 buildSrc 的那个 classloader，它其实也是加载运行 classpath 阶段的 buildscript  代码的 classloader，我们在里面添加一下我们自己的依赖即可。重点就在 BuildTreePreparingProjectsPreparer 的 prepareProjects 当中:</p>\n<p><strong>文件：BuildTreePreparingProjectsPreparer.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareProjects</span><span class=\"params\">(GradleInternal gradle)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    ClassLoaderScope baseProjectClassLoaderScope = parentClassLoaderScope.createChild(settings.getBuildSrcDir().getAbsolutePath());</span><br><span class=\"line\">    <span class=\"comment\">// 这个 classloader 被 gradle 持有，我们可以通过 gradle 实例获取到它</span></span><br><span class=\"line\">    gradle.setBaseProjectClassLoaderScope(baseProjectClassLoaderScope);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Build buildSrc and export classpath to root project</span></span><br><span class=\"line\">    buildBuildSrcAndLockClassloader(gradle, baseProjectClassLoaderScope);</span><br><span class=\"line\">\t<span class=\"comment\">// Evaluate projects</span></span><br><span class=\"line\">    delegate.prepareProjects(gradle);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看 buildBuildSrcAndLockClassloader 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buildBuildSrcAndLockClassloader</span><span class=\"params\">(GradleInternal gradle, ClassLoaderScope baseProjectClassLoaderScope)</span> </span>&#123;</span><br><span class=\"line\">    ClassPath buildSrcClassPath = buildSourceBuilder.buildAndGetClassPath(gradle);</span><br><span class=\"line\">    <span class=\"comment\">// 重点看这一句，export 可以添加一个 `ClassPath` 类型的实例</span></span><br><span class=\"line\">    baseProjectClassLoaderScope.export(buildSrcClassPath).lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此只要我们自己也调用一下这个 export 方法，把我们自己编译好的 jar 包作为 ClassPath 传进去，问题就解决了。</p>\n<p>当然，上帝在为我们打开了一扇窗户的同时又装上了不锈钢纱窗。事情并不是那么直接就能办到的，因为后面那个 lock，它的意思真的就是 lock。</p>\n<p><strong>文件：DefaultClassLoaderScope.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ClassLoaderScope <span class=\"title\">export</span><span class=\"params\">(ClassPath classPath)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 必须是非锁定状态，如果已经 lock，这里抛出断言异常</span></span><br><span class=\"line\">    assertNotLocked();</span><br><span class=\"line\">    <span class=\"comment\">// 在解析了所有的 classpath 之后才会创建，buildSrc 添加的时候为 null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exportingClassLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 命中这个分支</span></span><br><span class=\"line\">        export = export.plus(classPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lock 了之后，我们想要直接调用 export 方法来添加我们自己的 jar 包的愿望落空，不过上帝还是给我们的不锈钢纱窗留了一把钥匙的，那就是 Java 反射。我们可以通过反射来直接修改 export，无视 lock 的状态，代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.<span class=\"keyword\">internal</span>.GradleInternal</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.<span class=\"keyword\">internal</span>.initialization.DefaultClassLoaderScope</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.<span class=\"keyword\">internal</span>.classpath.ClassPath</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.<span class=\"keyword\">internal</span>.classpath.DefaultClassPath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前脚本所在目录下的 repos-1.0-SNAPSHOT.jar 文件</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> depFile = file(<span class=\"string\">&quot;repos-1.0-SNAPSHOT.jar&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 在 project evaluate 之前调用，比 buildscript 早</span></span><br><span class=\"line\">beforeProject &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == rootProject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> gradleInternal = gradle <span class=\"keyword\">as</span> GradleInternal</span><br><span class=\"line\">        <span class=\"keyword\">val</span> field = DefaultClassLoaderScope::<span class=\"keyword\">class</span>.java.getDeclaredField(<span class=\"string\">&quot;export&quot;</span>)</span><br><span class=\"line\">        field.isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> oldClassPath = field.<span class=\"keyword\">get</span>(gradleInternal.baseProjectClassLoaderScope()) <span class=\"keyword\">as</span> ClassPath</span><br><span class=\"line\">        field.<span class=\"keyword\">set</span>(gradleInternal.baseProjectClassLoaderScope(), oldClassPath + DefaultClassPath.of(depFile))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把扩展函数编译成的 jar 文件也放到 <strong>&lt;用户目录&gt;/.gradle/</strong> 中：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210417085046475.png\" alt=\"init 脚本和 jar 依赖的文件路径\"></p>\n<p>这样运行时就会把这个 jar 添加到 baseProjectClassLoaderScope 当中，所有的工程就都能访问到它了。</p>\n<p>需要注意的是，我们的示例是基于 Gradle 7.0 的，不同版本可能会存在差异。</p>\n<h3 id=\"2-4-如果是-Groovy-呢？\"><a href=\"#2-4-如果是-Groovy-呢？\" class=\"headerlink\" title=\"2.4 如果是 Groovy 呢？\"></a>2.4 如果是 Groovy 呢？</h3><p>之所以这么麻烦，就是因为我们需要兼顾 Kotlin 的静态类型的特性。如果是 Groovy 版本的特性，那么问题就简单多了，你只需要在 init.gradle 当中添加以下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RepositoryHandler.metaClass.tencentCloud &#123;</span><br><span class=\"line\">    delegate.maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后面访问 RepositoryHandler 的 tencentCloud 方法的时候就能够动态调用到这个扩展了。这实际上是 Groovy 元编程的内容，我们就不展开介绍了。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本节我们以实现一个简单的扩展为背景，先了解了一下 Kotlin DSL 的运行机制，接着又给出了在各个范围内实现扩展的方法。</p>\n<p>一个很小的需求，实际上需要我们了解的背景知识还是很多的。</p>\n<p>很多时候我们的学习和成长都是以点筑面，大厦固然高，但抵不住我一层一层地爬。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"如何为 Gradle 的 KTS 脚本添加扩展？","path":"2021/04/18/Add-extensions-to-build-scripts/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210416165202793.png","excerpt":"<blockquote>\n<p>本质上还是要搞清楚 KTS 是怎么运行的 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1BU4y1b7Wk&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","date":{"_isAMomentObject":true,"_i":"2021-04-17T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-04-17T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["gradle","groovy","kotlin","kts"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"ReleasableVar，可以为空的 Kotlin 非空类型 var","date":"2018-11-25T16:00:00.000Z","_content":"\n# 0. 题外话：Hadi 的插件\n\n上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：\n\n* Nyan Process Bar\n* Presentation Assistant\n\n也有同学问我ppt的，上周一的文章末尾有提供哈~\n\n好了下面我们言归正传~\n\n# 1. 描述下需求\n\n前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 `null`，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：\n\n```kotlin\nclass MainActivity: Activity {\n    lateinit var image: Bitmap\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        image = null // You cannot do that!!\n    }\n}\n```\n\n<!--more-->\n\n你想着 Activity 的 `onStop` 调用了之后到被回收还得等一会儿呢，甚至 `onDestroy` 都会过一会儿才会被执行到，所以 `image` 可能会在内存被持有一段时间。所以幸好我们可以通过 `recycle` 方法先告诉 `Bitmap` 该释放内存了，不然的话我们只能等着 `Activity` 回收的时候 `image` 引用的对象才可以回收。\n\n不可空类型能够置为 `null` 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。\n\n# 2. 解决办法\n\n想来想去，这个只能官方提供一个方法了，就像 `lateinitVar::isInitialized` 一样，提供一个 `lateinitVar::release()` 然后把 backingfield 的值给清空了不就好了吗？\n\n这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：\n\n```kotlin\nfun <T : Any> releasableNotNull() = ReleasableNotNull<T>()\n\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Not Initialized or released already.\")\n    }\n\n    fun isInitialized() = value != null\n\n    fun release() {\n        value = null\n    }\n}\n```\n\n然后用的时候也很简单：\n\n```kotlin\nclass Foo {\n    var bar by releasableNotNull<String>()\n    \n    ...\n}\n```\n\n额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。\n\n```kotlin\nfun <R> KProperty0<R>.release() {\n    isAccessible = true\n    (getDelegate() as? ReleasableNotNull<*>)?.release()\n        ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n}\n```\n我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 `lateinit` 定义一个判断是否初始化的方法：\n\n```kotlin\nval <R> KProperty0<R>.isInitialized: Boolean\n    get() {\n        isAccessible = true\n        return (getDelegate() as? ReleasableNotNull<*>)?.isInitialized()\n            ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n    }\n```\n\n# 3. 干掉反射\n\n然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 `null`，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。\n\n其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 `KProperty0` 的 `receiver` 拿到属性代理对象了，所以我们需要的只是一个`WeakHashMap`，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 `WeakIdentityMap` 的集合，对应于有弱引用功能的 `IdentityHashMap`：\n\n```kotlin\ninternal lateinit var releasableRefs: WeakIdentityMap<Any, MutableMap<String, ReleasableNotNull<*>>>\n```\n\n那么我们只需要在前面的 `setValue` 当中绑定他们：\n\n```kotlin\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        if (this.value == null) {\n            var map = releasableRefs[thisRef]\n            if(map == null){\n                map = HashMap()\n                releasableRefs[thisRef] = map\n            }\n            map[property.name] = this\n        }\n        this.value = value\n    }\n    \n    ...\n```\n\nMap 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：\n\n```kotlin\nval <R> KProperty0<R>.isInitialized: Boolean\n    get() {\n        return (this as? CallableReference)?.let {\n            releasableRefs[it.boundReceiver]?.get(this.name)?.isInitialized()\n        } ?: false\n    }\n\nfun <R> KProperty0<R>.release() {\n    (this as? CallableReference)?.let {\n        releasableRefs[it.boundReceiver]?.get(this.name)?.release()\n    }\n}\n```\n\n# 4. 怎么用？\n\n啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 `KProperty0` 是啥，它其实就是一个顶级变量或者已经绑定完 `receiver` 的变量，例如：\n\n```kotlin\nvar varInPackage = \"Hello\"\n\nclass Foo {\n    var bar = \"World\"\n}\n```\n这两个属性我们通过下面的属性引用得到的就是 `KProperty0` 的实例：\n\n```kotlin\n::varInPackage\n\nFoo()::bar\n```\n\n换句话说，我们开头给出的那个 `image` 的例子就可以这样写了：\n\n```kotlin\nclass MainActivity: Activity {\n    var image by releasableNotNull<Bitmap>()\n    \n    ...\n    \n    override fun onDestroy(){\n        super.onDestroy()\n        image.recycle()\n        ::image.release() // You simply make the backing value null, thus making the gc of this Bitmap instance possible. \n    }\n}\n```\n\n# 5. 你想直接用？\n\n我已经把这东西扔到 jCenter了~\n\n```\ncompile \"com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0\"\n```\n\n完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：\n\nhttps://github.com/enbandari/ReleasableVar\n\n","source":"_posts/ReleasableVar.md","raw":"---\ntitle: ReleasableVar，可以为空的 Kotlin 非空类型 var\ndate: 2018/11/26\ntags:\n  - Kotlin\n  - PropertyDelegate\n---\n\n# 0. 题外话：Hadi 的插件\n\n上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：\n\n* Nyan Process Bar\n* Presentation Assistant\n\n也有同学问我ppt的，上周一的文章末尾有提供哈~\n\n好了下面我们言归正传~\n\n# 1. 描述下需求\n\n前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 `null`，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：\n\n```kotlin\nclass MainActivity: Activity {\n    lateinit var image: Bitmap\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        image = null // You cannot do that!!\n    }\n}\n```\n\n<!--more-->\n\n你想着 Activity 的 `onStop` 调用了之后到被回收还得等一会儿呢，甚至 `onDestroy` 都会过一会儿才会被执行到，所以 `image` 可能会在内存被持有一段时间。所以幸好我们可以通过 `recycle` 方法先告诉 `Bitmap` 该释放内存了，不然的话我们只能等着 `Activity` 回收的时候 `image` 引用的对象才可以回收。\n\n不可空类型能够置为 `null` 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。\n\n# 2. 解决办法\n\n想来想去，这个只能官方提供一个方法了，就像 `lateinitVar::isInitialized` 一样，提供一个 `lateinitVar::release()` 然后把 backingfield 的值给清空了不就好了吗？\n\n这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：\n\n```kotlin\nfun <T : Any> releasableNotNull() = ReleasableNotNull<T>()\n\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Not Initialized or released already.\")\n    }\n\n    fun isInitialized() = value != null\n\n    fun release() {\n        value = null\n    }\n}\n```\n\n然后用的时候也很简单：\n\n```kotlin\nclass Foo {\n    var bar by releasableNotNull<String>()\n    \n    ...\n}\n```\n\n额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。\n\n```kotlin\nfun <R> KProperty0<R>.release() {\n    isAccessible = true\n    (getDelegate() as? ReleasableNotNull<*>)?.release()\n        ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n}\n```\n我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 `lateinit` 定义一个判断是否初始化的方法：\n\n```kotlin\nval <R> KProperty0<R>.isInitialized: Boolean\n    get() {\n        isAccessible = true\n        return (getDelegate() as? ReleasableNotNull<*>)?.isInitialized()\n            ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n    }\n```\n\n# 3. 干掉反射\n\n然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 `null`，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。\n\n其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 `KProperty0` 的 `receiver` 拿到属性代理对象了，所以我们需要的只是一个`WeakHashMap`，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 `WeakIdentityMap` 的集合，对应于有弱引用功能的 `IdentityHashMap`：\n\n```kotlin\ninternal lateinit var releasableRefs: WeakIdentityMap<Any, MutableMap<String, ReleasableNotNull<*>>>\n```\n\n那么我们只需要在前面的 `setValue` 当中绑定他们：\n\n```kotlin\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        if (this.value == null) {\n            var map = releasableRefs[thisRef]\n            if(map == null){\n                map = HashMap()\n                releasableRefs[thisRef] = map\n            }\n            map[property.name] = this\n        }\n        this.value = value\n    }\n    \n    ...\n```\n\nMap 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：\n\n```kotlin\nval <R> KProperty0<R>.isInitialized: Boolean\n    get() {\n        return (this as? CallableReference)?.let {\n            releasableRefs[it.boundReceiver]?.get(this.name)?.isInitialized()\n        } ?: false\n    }\n\nfun <R> KProperty0<R>.release() {\n    (this as? CallableReference)?.let {\n        releasableRefs[it.boundReceiver]?.get(this.name)?.release()\n    }\n}\n```\n\n# 4. 怎么用？\n\n啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 `KProperty0` 是啥，它其实就是一个顶级变量或者已经绑定完 `receiver` 的变量，例如：\n\n```kotlin\nvar varInPackage = \"Hello\"\n\nclass Foo {\n    var bar = \"World\"\n}\n```\n这两个属性我们通过下面的属性引用得到的就是 `KProperty0` 的实例：\n\n```kotlin\n::varInPackage\n\nFoo()::bar\n```\n\n换句话说，我们开头给出的那个 `image` 的例子就可以这样写了：\n\n```kotlin\nclass MainActivity: Activity {\n    var image by releasableNotNull<Bitmap>()\n    \n    ...\n    \n    override fun onDestroy(){\n        super.onDestroy()\n        image.recycle()\n        ::image.release() // You simply make the backing value null, thus making the gc of this Bitmap instance possible. \n    }\n}\n```\n\n# 5. 你想直接用？\n\n我已经把这东西扔到 jCenter了~\n\n```\ncompile \"com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0\"\n```\n\n完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：\n\nhttps://github.com/enbandari/ReleasableVar\n\n","slug":"ReleasableVar","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002x0009lduzaxwd5jkg","content":"<h1 id=\"0-题外话：Hadi-的插件\"><a href=\"#0-题外话：Hadi-的插件\" class=\"headerlink\" title=\"0. 题外话：Hadi 的插件\"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p>\n<ul>\n<li>Nyan Process Bar</li>\n<li>Presentation Assistant</li>\n</ul>\n<p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p>\n<p>好了下面我们言归正传~</p>\n<h1 id=\"1-描述下需求\"><a href=\"#1-描述下需求\" class=\"headerlink\" title=\"1. 描述下需求\"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> image: Bitmap</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        image = <span class=\"literal\">null</span> <span class=\"comment\">// You cannot do that!!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p>\n<p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p>\n<h1 id=\"2-解决办法\"><a href=\"#2-解决办法\" class=\"headerlink\" title=\"2. 解决办法\"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p>\n<p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> <span class=\"title\">releasableNotNull</span><span class=\"params\">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isInitialized</span><span class=\"params\">()</span></span> = value != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        value = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后用的时候也很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar <span class=\"keyword\">by</span> releasableNotNull&lt;String&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">    (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class=\"line\">        ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class=\"line\">            ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-干掉反射\"><a href=\"#3-干掉反射\" class=\"headerlink\" title=\"3. 干掉反射\"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p>\n<p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> map = releasableRefs[thisRef]</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                map = HashMap()</span><br><span class=\"line\">                releasableRefs[thisRef] = map</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map[property.name] = <span class=\"keyword\">this</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span>? CallableReference)?.let &#123;</span><br><span class=\"line\">            releasableRefs[it.boundReceiver]?.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>.name)?.isInitialized()</span><br><span class=\"line\">        &#125; ?: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span>? CallableReference)?.let &#123;</span><br><span class=\"line\">        releasableRefs[it.boundReceiver]?.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>.name)?.release()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-怎么用？\"><a href=\"#4-怎么用？\" class=\"headerlink\" title=\"4. 怎么用？\"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> varInPackage = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::varInPackage</span><br><span class=\"line\"></span><br><span class=\"line\">Foo()::bar</span><br></pre></td></tr></table></figure>\n\n<p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> image <span class=\"keyword\">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        ::image.release() <span class=\"comment\">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-你想直接用？\"><a href=\"#5-你想直接用？\" class=\"headerlink\" title=\"5. 你想直接用？\"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure>\n\n<p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p>\n<p><a href=\"https://github.com/enbandari/ReleasableVar\">https://github.com/enbandari/ReleasableVar</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"0-题外话：Hadi-的插件\"><a href=\"#0-题外话：Hadi-的插件\" class=\"headerlink\" title=\"0. 题外话：Hadi 的插件\"></a>0. 题外话：Hadi 的插件</h1><p>上周的 JetBrains 开发者大会，Hadi 的两个插件比较亮眼，这里有小伙伴如果没有听到最后一场，可能不知道它们是啥，它们分别是：</p>\n<ul>\n<li>Nyan Process Bar</li>\n<li>Presentation Assistant</li>\n</ul>\n<p>也有同学问我ppt的，上周一的文章末尾有提供哈~</p>\n<p>好了下面我们言归正传~</p>\n<h1 id=\"1-描述下需求\"><a href=\"#1-描述下需求\" class=\"headerlink\" title=\"1. 描述下需求\"></a>1. 描述下需求</h1><p>前不久跟群里小伙伴讨论的时候，发现他们有一个需求，那就是在一个变量使用完之后要将其置为 <code>null</code>，但是呢，又不愿意将它声明为可空类型，这个需求实在是。。大概就像这样吧：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> image: Bitmap</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        image = <span class=\"literal\">null</span> <span class=\"comment\">// You cannot do that!!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>你想着 Activity 的 <code>onStop</code> 调用了之后到被回收还得等一会儿呢，甚至 <code>onDestroy</code> 都会过一会儿才会被执行到，所以 <code>image</code> 可能会在内存被持有一段时间。所以幸好我们可以通过 <code>recycle</code> 方法先告诉 <code>Bitmap</code> 该释放内存了，不然的话我们只能等着 <code>Activity</code> 回收的时候 <code>image</code> 引用的对象才可以回收。</p>\n<p>不可空类型能够置为 <code>null</code> 看上去是个合理的需求，只要我确定在这之后不再使用就好了。好吧，既然合理，我们就想想办法。</p>\n<h1 id=\"2-解决办法\"><a href=\"#2-解决办法\" class=\"headerlink\" title=\"2. 解决办法\"></a>2. 解决办法</h1><p>想来想去，这个只能官方提供一个方法了，就像 <code>lateinitVar::isInitialized</code> 一样，提供一个 <code>lateinitVar::release()</code> 然后把 backingfield 的值给清空了不就好了吗？</p>\n<p>这么看来不用官方了，我们自己似乎也可以搞定，写个属性代理即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> <span class=\"title\">releasableNotNull</span><span class=\"params\">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isInitialized</span><span class=\"params\">()</span></span> = value != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        value = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后用的时候也很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar <span class=\"keyword\">by</span> releasableNotNull&lt;String&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额，可是怎么才能调用到属性代理对象的方法呢？调用不到的话岂不是白折腾。。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">    (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class=\"line\">        ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用反射其实可以很轻松的拿到代理对象的，那么这个故事就快要讲完了——不仅如此，我们还可以仿造 <code>lateinit</code> 定义一个判断是否初始化的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.isInitialized()</span><br><span class=\"line\">            ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-干掉反射\"><a href=\"#3-干掉反射\" class=\"headerlink\" title=\"3. 干掉反射\"></a>3. 干掉反射</h1><p>然后就有人说，我靠你居然用反射！你作弊！。。。。其实如果用反射，最好的办法是用 Java 反射直接设置为 <code>null</code>，但这个神不知鬼不觉的，你敢用么。算了算了，咱不用反射了好吧。</p>\n<p>其实我们只需要对被代理的属性所在对象与属性代理对象进行绑定，我们就很轻易的通过 <code>KProperty0</code> 的 <code>receiver</code> 拿到属性代理对象了，所以我们需要的只是一个<code>WeakHashMap</code>，当然，这里雀神也提示我说小心对象的相等判断问题，因为这里我们希望每一个对象引用都是不同的，所以我从网上扒了一个 <code>WeakIdentityMap</code> 的集合，对应于有弱引用功能的 <code>IdentityHashMap</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> releasableRefs: WeakIdentityMap&lt;Any, MutableMap&lt;String, ReleasableNotNull&lt;*&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们只需要在前面的 <code>setValue</code> 当中绑定他们：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> map = releasableRefs[thisRef]</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                map = HashMap()</span><br><span class=\"line\">                releasableRefs[thisRef] = map</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map[property.name] = <span class=\"keyword\">this</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>Map 里面又是一个 Map，这意思是说一个对象里面可能有多个成员被代理。接着改写我们的扩展方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;R&gt; KProperty0&lt;R&gt;.isInitialized: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span>? CallableReference)?.let &#123;</span><br><span class=\"line\">            releasableRefs[it.boundReceiver]?.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>.name)?.isInitialized()</span><br><span class=\"line\">        &#125; ?: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span>? CallableReference)?.let &#123;</span><br><span class=\"line\">        releasableRefs[it.boundReceiver]?.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>.name)?.release()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-怎么用？\"><a href=\"#4-怎么用？\" class=\"headerlink\" title=\"4. 怎么用？\"></a>4. 怎么用？</h1><p>啊，我忘了一件最重要的事儿，也许有小伙伴还不知道 <code>KProperty0</code> 是啥，它其实就是一个顶级变量或者已经绑定完 <code>receiver</code> 的变量，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> varInPackage = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个属性我们通过下面的属性引用得到的就是 <code>KProperty0</code> 的实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::varInPackage</span><br><span class=\"line\"></span><br><span class=\"line\">Foo()::bar</span><br></pre></td></tr></table></figure>\n\n<p>换句话说，我们开头给出的那个 <code>image</code> 的例子就可以这样写了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> image <span class=\"keyword\">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        ::image.release() <span class=\"comment\">// You simply make the backing value null, thus making the gc of this Bitmap instance possible. </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-你想直接用？\"><a href=\"#5-你想直接用？\" class=\"headerlink\" title=\"5. 你想直接用？\"></a>5. 你想直接用？</h1><p>我已经把这东西扔到 jCenter了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &quot;com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0&quot;</span><br></pre></td></tr></table></figure>\n\n<p>完整的源码其实也就那么前面那么几行，有兴趣也可以来我的 Github 给我点个 star：</p>\n<p><a href=\"https://github.com/enbandari/ReleasableVar\">https://github.com/enbandari/ReleasableVar</a></p>","popularPost_tmp_postPath":true},{"title":"[Android Studio 技巧] 快捷键的使用","keywords":"IDE 快捷键","date":"2021-05-09T16:00:00.000Z","description":null,"_content":"\n> 有关 Android Studio 快捷键，看这个视频就够了 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1g64y1279B&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/android-studio-shortcuts.md","raw":"---\ntitle:  \"[Android Studio 技巧] 快捷键的使用\" \nkeywords: IDE 快捷键 \ndate: 2021/05/10\ndescription: \ntags: \n    - android studio\n    - 技巧\n    - 快捷键 \n---\n\n> 有关 Android Studio 快捷键，看这个视频就够了 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1g64y1279B&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"android-studio-shortcuts","published":1,"updated":"2021-06-03T23:33:20.395Z","_id":"ckohi002y000blduz1s99alop","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>有关 Android Studio 快捷键，看这个视频就够了 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1g64y1279B&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<span id=\"more\"></span>\n\n\n\n\n\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>有关 Android Studio 快捷键，看这个视频就够了 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1g64y1279B&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","more":"<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Fri Jun 04 2021 07:33:20 GMT+0800 (China Standard Time)","title":"[Android Studio 技巧] 快捷键的使用","path":"2021/05/10/android-studio-shortcuts/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>有关 Android Studio 快捷键，看这个视频就够了 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1g64y1279B&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","date":{"_isAMomentObject":true,"_i":"2021-05-09T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-05-09T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["android studio","技巧","快捷键"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"注解处理器教程[全]","date":"2018-10-02T16:00:00.000Z","_content":"\n我在做 [基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计](https://coding.imooc.com/class/232.html) 这门课的时候，顺便做了一个注解处理器的框架，叫 [Tieguanyin(铁观音)](https://github.com/enbandari/TieGuanYin)，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 `Intent` 来传递，有了这个框架我们就可以省去这个麻烦的步骤。\n\n在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。\n\n<!-- more -->\n\n# 视频源码\n\n见 Github 项目：[Apt-Tutorials](https://github.com/enbandari/Apt-Tutorials)\n\n# 视频观看\n\n## 1. 课程简介\n\n作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/l0728uxh61x.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=1\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=jA5kQwGM-tU&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=1\n\n## 2. 搭建工程\n\n这一节主要介绍注解处理器工程的结构。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/o07284u5rju.html\n\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=2\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=p3oBTIcWty0&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=2\n\n## 3. 解析注解\n\n这一节主要介绍如何解析注解获取被标注的元素信息。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/z07286r97mz.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=3\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=CPhdkOG6RRw&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=3\n\n## 4. 生成常量\n\n这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/k0728tn7sty.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=4\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=X13WcxWMVA4&index=4&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP\n\n## 5. 生成 start 方法\n\n这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/x0728j7j7a6.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=5\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=a66T8ImLAMw&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=5\n\n## 6. 生成注入和状态保存的方法\n\n这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/d0728uitqdr.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=6\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=fCUje0sjwos&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=6\n\n\n## 7. 生成 Kotlin 代码\n\n这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/l0728y2inrf.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=7\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=2Z6qBTo3r-k&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=7\n\n\n## 8. 小结\n\n这一节对整个课程作了一个总结。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/m072848g85p.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=8\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=aQHmOIS88Zo&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=8\n\n---\n\n欢迎关注 Kotlin 公众号：\n\n![Kotlin 公众号](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg)\n\n","source":"_posts/apt-tutorials.md","raw":"---\ntitle: 注解处理器教程[全]\ndate: 2018/10/03\ntags:\n  - Kotlin\n  - APT\n---\n\n我在做 [基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计](https://coding.imooc.com/class/232.html) 这门课的时候，顺便做了一个注解处理器的框架，叫 [Tieguanyin(铁观音)](https://github.com/enbandari/TieGuanYin)，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 `Intent` 来传递，有了这个框架我们就可以省去这个麻烦的步骤。\n\n在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。\n\n<!-- more -->\n\n# 视频源码\n\n见 Github 项目：[Apt-Tutorials](https://github.com/enbandari/Apt-Tutorials)\n\n# 视频观看\n\n## 1. 课程简介\n\n作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/l0728uxh61x.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=1\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=jA5kQwGM-tU&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=1\n\n## 2. 搭建工程\n\n这一节主要介绍注解处理器工程的结构。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/o07284u5rju.html\n\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=2\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=p3oBTIcWty0&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=2\n\n## 3. 解析注解\n\n这一节主要介绍如何解析注解获取被标注的元素信息。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/z07286r97mz.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=3\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=CPhdkOG6RRw&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=3\n\n## 4. 生成常量\n\n这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/k0728tn7sty.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=4\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=X13WcxWMVA4&index=4&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP\n\n## 5. 生成 start 方法\n\n这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/x0728j7j7a6.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=5\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=a66T8ImLAMw&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=5\n\n## 6. 生成注入和状态保存的方法\n\n这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/d0728uitqdr.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=6\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=fCUje0sjwos&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=6\n\n\n## 7. 生成 Kotlin 代码\n\n这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/l0728y2inrf.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=7\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=2Z6qBTo3r-k&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=7\n\n\n## 8. 小结\n\n这一节对整个课程作了一个总结。\n\n**腾讯视频：** \n\nhttps://v.qq.com/x/page/m072848g85p.html\n\n**Bilibili：** \n\nhttps://www.bilibili.com/video/av32905508/?p=8\n\n**Youtube：**\n\nhttps://www.youtube.com/watch?v=aQHmOIS88Zo&list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&index=8\n\n---\n\n欢迎关注 Kotlin 公众号：\n\n![Kotlin 公众号](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg)\n\n","slug":"apt-tutorials","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002y000clduze10j7z6u","content":"<p>我在做 <a href=\"https://coding.imooc.com/class/232.html\">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href=\"https://github.com/enbandari/TieGuanYin\">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p>\n<p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"视频源码\"><a href=\"#视频源码\" class=\"headerlink\" title=\"视频源码\"></a>视频源码</h1><p>见 Github 项目：<a href=\"https://github.com/enbandari/Apt-Tutorials\">Apt-Tutorials</a></p>\n<h1 id=\"视频观看\"><a href=\"#视频观看\" class=\"headerlink\" title=\"视频观看\"></a>视频观看</h1><h2 id=\"1-课程简介\"><a href=\"#1-课程简介\" class=\"headerlink\" title=\"1. 课程简介\"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/l0728uxh61x.html\">https://v.qq.com/x/page/l0728uxh61x.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=1\">https://www.bilibili.com/video/av32905508/?p=1</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1\">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p>\n<h2 id=\"2-搭建工程\"><a href=\"#2-搭建工程\" class=\"headerlink\" title=\"2. 搭建工程\"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/o07284u5rju.html\">https://v.qq.com/x/page/o07284u5rju.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=2\">https://www.bilibili.com/video/av32905508/?p=2</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2\">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p>\n<h2 id=\"3-解析注解\"><a href=\"#3-解析注解\" class=\"headerlink\" title=\"3. 解析注解\"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/z07286r97mz.html\">https://v.qq.com/x/page/z07286r97mz.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=3\">https://www.bilibili.com/video/av32905508/?p=3</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3\">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p>\n<h2 id=\"4-生成常量\"><a href=\"#4-生成常量\" class=\"headerlink\" title=\"4. 生成常量\"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/k0728tn7sty.html\">https://v.qq.com/x/page/k0728tn7sty.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=4\">https://www.bilibili.com/video/av32905508/?p=4</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP\">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p>\n<h2 id=\"5-生成-start-方法\"><a href=\"#5-生成-start-方法\" class=\"headerlink\" title=\"5. 生成 start 方法\"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/x0728j7j7a6.html\">https://v.qq.com/x/page/x0728j7j7a6.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=5\">https://www.bilibili.com/video/av32905508/?p=5</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5\">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p>\n<h2 id=\"6-生成注入和状态保存的方法\"><a href=\"#6-生成注入和状态保存的方法\" class=\"headerlink\" title=\"6. 生成注入和状态保存的方法\"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/d0728uitqdr.html\">https://v.qq.com/x/page/d0728uitqdr.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=6\">https://www.bilibili.com/video/av32905508/?p=6</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6\">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p>\n<h2 id=\"7-生成-Kotlin-代码\"><a href=\"#7-生成-Kotlin-代码\" class=\"headerlink\" title=\"7. 生成 Kotlin 代码\"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/l0728y2inrf.html\">https://v.qq.com/x/page/l0728y2inrf.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=7\">https://www.bilibili.com/video/av32905508/?p=7</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7\">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p>\n<h2 id=\"8-小结\"><a href=\"#8-小结\" class=\"headerlink\" title=\"8. 小结\"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/m072848g85p.html\">https://v.qq.com/x/page/m072848g85p.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=8\">https://www.bilibili.com/video/av32905508/?p=8</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8\">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p>\n<hr>\n<p>欢迎关注 Kotlin 公众号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg\" alt=\"Kotlin 公众号\"></p>\n","site":{"data":{}},"excerpt":"<p>我在做 <a href=\"https://coding.imooc.com/class/232.html\">基于 GitHub App 业务深度讲解 Kotlin1.2高级特性与框架设计</a> 这门课的时候，顺便做了一个注解处理器的框架，叫 <a href=\"https://github.com/enbandari/TieGuanYin\">Tieguanyin(铁观音)</a>，这个框架主要是用来解决 Activity 跳转时传参的问题，我们知道 Activity 如果需要参数，那么我们只能非常繁琐的使用 <code>Intent</code> 来传递，有了这个框架我们就可以省去这个麻烦的步骤。</p>\n<p>在这里，框架的内容其实不是重点，重点是，它是一个注解处理器的项目。为了让它的作用尽可能的放大，我对原框架做了简化，做了这套课程。</p>","more":"<h1 id=\"视频源码\"><a href=\"#视频源码\" class=\"headerlink\" title=\"视频源码\"></a>视频源码</h1><p>见 Github 项目：<a href=\"https://github.com/enbandari/Apt-Tutorials\">Apt-Tutorials</a></p>\n<h1 id=\"视频观看\"><a href=\"#视频观看\" class=\"headerlink\" title=\"视频观看\"></a>视频观看</h1><h2 id=\"1-课程简介\"><a href=\"#1-课程简介\" class=\"headerlink\" title=\"1. 课程简介\"></a>1. 课程简介</h2><p>作为课程的第一节，我们简单介绍了一下 Apt 的工作原理和流程，并对整个视频课程涉及的内容做了介绍。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/l0728uxh61x.html\">https://v.qq.com/x/page/l0728uxh61x.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=1\">https://www.bilibili.com/video/av32905508/?p=1</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1\">https://www.youtube.com/watch?v=jA5kQwGM-tU&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=1</a></p>\n<h2 id=\"2-搭建工程\"><a href=\"#2-搭建工程\" class=\"headerlink\" title=\"2. 搭建工程\"></a>2. 搭建工程</h2><p>这一节主要介绍注解处理器工程的结构。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/o07284u5rju.html\">https://v.qq.com/x/page/o07284u5rju.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=2\">https://www.bilibili.com/video/av32905508/?p=2</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2\">https://www.youtube.com/watch?v=p3oBTIcWty0&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=2</a></p>\n<h2 id=\"3-解析注解\"><a href=\"#3-解析注解\" class=\"headerlink\" title=\"3. 解析注解\"></a>3. 解析注解</h2><p>这一节主要介绍如何解析注解获取被标注的元素信息。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/z07286r97mz.html\">https://v.qq.com/x/page/z07286r97mz.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=3\">https://www.bilibili.com/video/av32905508/?p=3</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3\">https://www.youtube.com/watch?v=CPhdkOG6RRw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=3</a></p>\n<h2 id=\"4-生成常量\"><a href=\"#4-生成常量\" class=\"headerlink\" title=\"4. 生成常量\"></a>4. 生成常量</h2><p>这一节为被标注的属性生成一些常量字符串来作为它们的 Key，也展示了如何为生成的 Java 类添加常量。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/k0728tn7sty.html\">https://v.qq.com/x/page/k0728tn7sty.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=4\">https://www.bilibili.com/video/av32905508/?p=4</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP\">https://www.youtube.com/watch?v=X13WcxWMVA4&amp;index=4&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP</a></p>\n<h2 id=\"5-生成-start-方法\"><a href=\"#5-生成-start-方法\" class=\"headerlink\" title=\"5. 生成 start 方法\"></a>5. 生成 start 方法</h2><p>这一节为被标注的 Activity 生成携带被标注的属性作为参数的 start 的方法，也展示了如何为生成的 Java 类添加方法。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/x0728j7j7a6.html\">https://v.qq.com/x/page/x0728j7j7a6.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=5\">https://www.bilibili.com/video/av32905508/?p=5</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5\">https://www.youtube.com/watch?v=a66T8ImLAMw&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=5</a></p>\n<h2 id=\"6-生成注入和状态保存的方法\"><a href=\"#6-生成注入和状态保存的方法\" class=\"headerlink\" title=\"6. 生成注入和状态保存的方法\"></a>6. 生成注入和状态保存的方法</h2><p>这一节为被标注的 Activity 生成注入属性的 inject 方法和保存状态的 saveState 方法。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/d0728uitqdr.html\">https://v.qq.com/x/page/d0728uitqdr.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=6\">https://www.bilibili.com/video/av32905508/?p=6</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6\">https://www.youtube.com/watch?v=fCUje0sjwos&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=6</a></p>\n<h2 id=\"7-生成-Kotlin-代码\"><a href=\"#7-生成-Kotlin-代码\" class=\"headerlink\" title=\"7. 生成 Kotlin 代码\"></a>7. 生成 Kotlin 代码</h2><p>这一节主要通过为被标注的 Activity 生成扩展方法来介绍如何生成 Kotlin 代码。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/l0728y2inrf.html\">https://v.qq.com/x/page/l0728y2inrf.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=7\">https://www.bilibili.com/video/av32905508/?p=7</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7\">https://www.youtube.com/watch?v=2Z6qBTo3r-k&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=7</a></p>\n<h2 id=\"8-小结\"><a href=\"#8-小结\" class=\"headerlink\" title=\"8. 小结\"></a>8. 小结</h2><p>这一节对整个课程作了一个总结。</p>\n<p><strong>腾讯视频：</strong> </p>\n<p><a href=\"https://v.qq.com/x/page/m072848g85p.html\">https://v.qq.com/x/page/m072848g85p.html</a></p>\n<p><strong>Bilibili：</strong> </p>\n<p><a href=\"https://www.bilibili.com/video/av32905508/?p=8\">https://www.bilibili.com/video/av32905508/?p=8</a></p>\n<p><strong>Youtube：</strong></p>\n<p><a href=\"https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8\">https://www.youtube.com/watch?v=aQHmOIS88Zo&amp;list=PLGzwzBsMvr-lmXMu1YNfitwj6358b7VtP&amp;index=8</a></p>\n<hr>\n<p>欢迎关注 Kotlin 公众号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg\" alt=\"Kotlin 公众号\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(1) - 入门篇","keywords":"Kotlin 协程 入门","date":"2019-03-31T16:00:00.000Z","description":null,"_content":"\n> 假定你对协程（Coroutine）一点儿都不了解，通过阅读本文看看是否能让你明白协程是怎么一回事。 \n\n<!-- more -->\n\n\n\n\n## 1. 引子\n\n我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。\n\n这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。\n\n## 2. 需求确认\n\n在开始讲解协程之前，我们需要先确认几件事儿：\n\n1. 你用过线程对吧？\n2. 你写过回调对吧？\n3. 你用过 RxJava 类似的框架吗？\n\n看下你的答案：\n\n* 如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；\n* 如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；\n* 如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~\n\n\n## 3. 一个常规例子\n\n我们通过 Retrofit 发送一个网络请求，其中接口如下：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\") login: String): Call<User>\n}\n\ndata class User(val id: String, val name: String, val url: String)\n```\n\nRetrofit 初始化如下：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n那么我们请求网络时：\n\n```kotlin\ngitHubServiceApi.getUser(\"bennyhuo\").enqueue(object : Callback<User> {\n    override fun onFailure(call: Call<User>, t: Throwable) {\n        handler.post { showError(t) }\n    }\n\n    override fun onResponse(call: Call<User>, response: Response<User>) {\n        handler.post { response.body()?.let(::showUser) ?: showError(NullPointerException()) }\n    }\n})\n```\n\n请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？\n\n* 通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题\n* 回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试\n* 重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 `showError`，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复\n\nKotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。\n\n> 如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 `SwingUtilities.invokeLater{ ... }` (Java Swing)，或者 `setTimeout({ ... }, 0)` (Js) 等等。\n\n## 4. 改造成协程\n\n你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 `retryWhen`）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。\n\n对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。\n\n### 4.1 CallAdapter 的方式\n\n我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\") login: String): Deferred<User>\n}\n```\n\n> 注意 Deferred 是 Job 的子接口。\n\n那么我们需要为 Retrofit 添加对 `Deferred` 的支持，这需要用到开源库：\n\n```gradle\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n构造 Retrofit 实例时添加：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            //添加对 Deferred 的支持\n            .addCallAdapterFactory(CoroutineCallAdapterFactory())\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n那么这时候我们发起请求就可以这么写了：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\").await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n>说明： `Dispatchers.Main` 在不同的平台上的实现不同，如果在 Android 上为 `HandlerDispatcher`，在 Java Swing 上为 `SwingDispatcher` 等等。\n\n首先我们通过 `launch` 启动了一个协程，这类似于我们启动一个线程，`launch` 的参数有三个，依次为协程上下文、协程启动模式、协程体：\n\n```kotlin\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext, // 上下文\n    start: CoroutineStart = CoroutineStart.DEFAULT,  // 启动模式\n    block: suspend CoroutineScope.() -> Unit // 协程体\n): Job \n```\n\n**启动模式**不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。\n\n**上下文**可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，`Dispatchers.Main` 就是一个官方提供的上下文，它可以确保 `launch` 启动的协程体运行在 UI 线程当中（除非你自己在 `launch` 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。\n\n换句话说，在例子当中整个 `launch` 内部**你看到的代码**都是运行在 UI 线程的，尽管 `getUser` 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，`getUser` 返回了一个 `Deferred` 类型，它的 `await` 方法会返回一个 `User` 对象，意味着 `await` 需要等待请求结果返回才可以继续执行，那么 `await` 不会阻塞 UI 线程吗？\n\n答案是：不会。当然不会，不然那 `Deferred` 与 `Future` 又有什么区别呢？这里 `await` 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 `Continuation` 的接口的实例来返回结果：\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    public val context: CoroutineContext\n    public fun resumeWith(result: Result<T>)\n}\n```\n\n1.3 的源码其实并不是很直接，尽管我们可以再看下 `Result` 的源码，但我不想这么做。更容易理解的是之前版本的源码：\n\n```kotlin\n@SinceKotlin(\"1.1\")\npublic interface Continuation<in T> {\n    public val context: CoroutineContext\n    public fun resume(value: T)\n    public fun resumeWithException(exception: Throwable)\n}\n```\n\n相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 `Callback`：\n\n```java\npublic interface Callback<T> {\n  void onResponse(Call<T> call, Response<T> response);\n  void onFailure(Call<T> call, Throwable t);\n}\n```\n\n有结果正常返回的时候，`Continuation` 调用 `resume` 返回结果，否则调用 `resumeWithException` 来抛出异常，简直与 `Callback` 一模一样。\n\n所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        //showUser 在 await 的 Continuation 的回调函数调用后执行\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\").await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。\n\n这时候也许大家还是有问题：我并没有看到 `Continuation` 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，`await` 这个方法的签名其实并不像我们看到的那样：\n\n```kotlin\npublic suspend fun await(): T\n```\n\n它真实的签名其实是：\n\n```java\nkotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;\n```\n\n即接收一个 `Continuation` 实例，返回 `Object` 的这么个函数，所以前面的代码我们可以大致理解为：\n\n```kotlin\n//注意以下不是正确的代码，仅供大家理解协程使用\nGlobalScope.launch(Dispatchers.Main) {\n    gitHubServiceApi.getUser(\"bennyhuo\").await(object: Continuation<User>{\n            override fun resume(value: User) {\n                showUser(value)\n            }\n            override fun resumeWithException(exception: Throwable){\n                showError(exception)\n            }\n    })\n}\n```\n\n而在 `await` 当中，大致就是：\n\n```kotlin\n//注意以下并不是真实的实现，仅供大家理解协程使用\nfun await(continuation: Continuation<User>): Any {\n    ... // 切到非 UI 线程中执行，等待结果返回\n    try {\n        val user = ...\n        handler.post{ continuation.resume(user) }\n    } catch(e: Exception) {\n        handler.post{ continuation.resumeWithException(e) }\n    }\n}\n```\n\n这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。\n\n### 4.2 suspend 函数的方式\n\nsuspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 `Deferred` 的 `await` 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。\n\n> Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。\n\n首先我们修改接口方法：\n\n```kotlin\n@GET(\"users/{login}\")\nsuspend fun getUser(@Path(\"login\") login: String): User\n```\n\n这种情况 Retrofit 会根据接口方法的声明来构造 `Continuation`，并且在内部封装了 `Call` 的异步请求（使用 enqueue），进而得到 `User` 实例，具体原理后面我们有机会再介绍。使用方法如下：\n\n```kotlin\nGlobalScope.launch {\n    try {\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\"))\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n它的执行流程与 `Deferred.await` 类似，我们就不再详细分析了。\n\n## 5. 协程到底是什么\n\n好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。\n\n而**协程**可以帮你优雅的处理掉这些。\n\n协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：\n\n> Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.\n\n简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。\n\n> 关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。\n\n如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，[kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：\n\n```kotlin\npublic interface Job : CoroutineContext.Element {\n    ...\n    public val isActive: Boolean\n    public val isCompleted: Boolean\n    public val isCancelled: Boolean\n\n    public fun start(): Boolean\n    public fun cancel(cause: CancellationException? = null)\n    public suspend fun join()\n    ...\n}\n```\n\n我们再来看看 Thread 的定义：\n\n```java\npublic class Thread implements Runnable {\n    ...    \n    public final native boolean isAlive();\n    public synchronized void start() { ... }\n    @Deprecated\n    public final void stop() { ... }\n    public final void join() throws InterruptedException  { ... }\n    ...\n}\n```\n这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。\n\n而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。\n\n## 6. 小结\n\n我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。\n\n这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/basic-coroutines.md","raw":"---\ntitle:  破解 Kotlin 协程(1) - 入门篇 \nkeywords: Kotlin 协程 入门 \ndate: 2019/04/01\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 假定你对协程（Coroutine）一点儿都不了解，通过阅读本文看看是否能让你明白协程是怎么一回事。 \n\n<!-- more -->\n\n\n\n\n## 1. 引子\n\n我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。\n\n这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。\n\n## 2. 需求确认\n\n在开始讲解协程之前，我们需要先确认几件事儿：\n\n1. 你用过线程对吧？\n2. 你写过回调对吧？\n3. 你用过 RxJava 类似的框架吗？\n\n看下你的答案：\n\n* 如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；\n* 如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；\n* 如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~\n\n\n## 3. 一个常规例子\n\n我们通过 Retrofit 发送一个网络请求，其中接口如下：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\") login: String): Call<User>\n}\n\ndata class User(val id: String, val name: String, val url: String)\n```\n\nRetrofit 初始化如下：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n那么我们请求网络时：\n\n```kotlin\ngitHubServiceApi.getUser(\"bennyhuo\").enqueue(object : Callback<User> {\n    override fun onFailure(call: Call<User>, t: Throwable) {\n        handler.post { showError(t) }\n    }\n\n    override fun onResponse(call: Call<User>, response: Response<User>) {\n        handler.post { response.body()?.let(::showUser) ?: showError(NullPointerException()) }\n    }\n})\n```\n\n请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？\n\n* 通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题\n* 回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试\n* 重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 `showError`，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复\n\nKotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。\n\n> 如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 `SwingUtilities.invokeLater{ ... }` (Java Swing)，或者 `setTimeout({ ... }, 0)` (Js) 等等。\n\n## 4. 改造成协程\n\n你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 `retryWhen`）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。\n\n对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。\n\n### 4.1 CallAdapter 的方式\n\n我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\") login: String): Deferred<User>\n}\n```\n\n> 注意 Deferred 是 Job 的子接口。\n\n那么我们需要为 Retrofit 添加对 `Deferred` 的支持，这需要用到开源库：\n\n```gradle\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n构造 Retrofit 实例时添加：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            //添加对 Deferred 的支持\n            .addCallAdapterFactory(CoroutineCallAdapterFactory())\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n那么这时候我们发起请求就可以这么写了：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\").await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n>说明： `Dispatchers.Main` 在不同的平台上的实现不同，如果在 Android 上为 `HandlerDispatcher`，在 Java Swing 上为 `SwingDispatcher` 等等。\n\n首先我们通过 `launch` 启动了一个协程，这类似于我们启动一个线程，`launch` 的参数有三个，依次为协程上下文、协程启动模式、协程体：\n\n```kotlin\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext, // 上下文\n    start: CoroutineStart = CoroutineStart.DEFAULT,  // 启动模式\n    block: suspend CoroutineScope.() -> Unit // 协程体\n): Job \n```\n\n**启动模式**不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。\n\n**上下文**可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，`Dispatchers.Main` 就是一个官方提供的上下文，它可以确保 `launch` 启动的协程体运行在 UI 线程当中（除非你自己在 `launch` 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。\n\n换句话说，在例子当中整个 `launch` 内部**你看到的代码**都是运行在 UI 线程的，尽管 `getUser` 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，`getUser` 返回了一个 `Deferred` 类型，它的 `await` 方法会返回一个 `User` 对象，意味着 `await` 需要等待请求结果返回才可以继续执行，那么 `await` 不会阻塞 UI 线程吗？\n\n答案是：不会。当然不会，不然那 `Deferred` 与 `Future` 又有什么区别呢？这里 `await` 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 `Continuation` 的接口的实例来返回结果：\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    public val context: CoroutineContext\n    public fun resumeWith(result: Result<T>)\n}\n```\n\n1.3 的源码其实并不是很直接，尽管我们可以再看下 `Result` 的源码，但我不想这么做。更容易理解的是之前版本的源码：\n\n```kotlin\n@SinceKotlin(\"1.1\")\npublic interface Continuation<in T> {\n    public val context: CoroutineContext\n    public fun resume(value: T)\n    public fun resumeWithException(exception: Throwable)\n}\n```\n\n相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 `Callback`：\n\n```java\npublic interface Callback<T> {\n  void onResponse(Call<T> call, Response<T> response);\n  void onFailure(Call<T> call, Throwable t);\n}\n```\n\n有结果正常返回的时候，`Continuation` 调用 `resume` 返回结果，否则调用 `resumeWithException` 来抛出异常，简直与 `Callback` 一模一样。\n\n所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        //showUser 在 await 的 Continuation 的回调函数调用后执行\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\").await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。\n\n这时候也许大家还是有问题：我并没有看到 `Continuation` 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，`await` 这个方法的签名其实并不像我们看到的那样：\n\n```kotlin\npublic suspend fun await(): T\n```\n\n它真实的签名其实是：\n\n```java\nkotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;\n```\n\n即接收一个 `Continuation` 实例，返回 `Object` 的这么个函数，所以前面的代码我们可以大致理解为：\n\n```kotlin\n//注意以下不是正确的代码，仅供大家理解协程使用\nGlobalScope.launch(Dispatchers.Main) {\n    gitHubServiceApi.getUser(\"bennyhuo\").await(object: Continuation<User>{\n            override fun resume(value: User) {\n                showUser(value)\n            }\n            override fun resumeWithException(exception: Throwable){\n                showError(exception)\n            }\n    })\n}\n```\n\n而在 `await` 当中，大致就是：\n\n```kotlin\n//注意以下并不是真实的实现，仅供大家理解协程使用\nfun await(continuation: Continuation<User>): Any {\n    ... // 切到非 UI 线程中执行，等待结果返回\n    try {\n        val user = ...\n        handler.post{ continuation.resume(user) }\n    } catch(e: Exception) {\n        handler.post{ continuation.resumeWithException(e) }\n    }\n}\n```\n\n这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。\n\n### 4.2 suspend 函数的方式\n\nsuspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 `Deferred` 的 `await` 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。\n\n> Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。\n\n首先我们修改接口方法：\n\n```kotlin\n@GET(\"users/{login}\")\nsuspend fun getUser(@Path(\"login\") login: String): User\n```\n\n这种情况 Retrofit 会根据接口方法的声明来构造 `Continuation`，并且在内部封装了 `Call` 的异步请求（使用 enqueue），进而得到 `User` 实例，具体原理后面我们有机会再介绍。使用方法如下：\n\n```kotlin\nGlobalScope.launch {\n    try {\n        showUser(gitHubServiceApi.getUser(\"bennyhuo\"))\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n它的执行流程与 `Deferred.await` 类似，我们就不再详细分析了。\n\n## 5. 协程到底是什么\n\n好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。\n\n而**协程**可以帮你优雅的处理掉这些。\n\n协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：\n\n> Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.\n\n简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。\n\n> 关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。\n\n如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，[kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines) 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：\n\n```kotlin\npublic interface Job : CoroutineContext.Element {\n    ...\n    public val isActive: Boolean\n    public val isCompleted: Boolean\n    public val isCancelled: Boolean\n\n    public fun start(): Boolean\n    public fun cancel(cause: CancellationException? = null)\n    public suspend fun join()\n    ...\n}\n```\n\n我们再来看看 Thread 的定义：\n\n```java\npublic class Thread implements Runnable {\n    ...    \n    public final native boolean isAlive();\n    public synchronized void start() { ... }\n    @Deprecated\n    public final void stop() { ... }\n    public final void join() throws InterruptedException  { ... }\n    ...\n}\n```\n这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。\n\n而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。\n\n## 6. 小结\n\n我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。\n\n这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"basic-coroutines","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi002z000elduz2l2r4lg1","content":"<blockquote>\n<p>假定你对协程（Coroutine）一点儿都不了解，通过阅读本文看看是否能让你明白协程是怎么一回事。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-引子\"><a href=\"#1-引子\" class=\"headerlink\" title=\"1. 引子\"></a>1. 引子</h2><p>我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 <a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。</p>\n<p>这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。</p>\n<h2 id=\"2-需求确认\"><a href=\"#2-需求确认\" class=\"headerlink\" title=\"2. 需求确认\"></a>2. 需求确认</h2><p>在开始讲解协程之前，我们需要先确认几件事儿：</p>\n<ol>\n<li>你用过线程对吧？</li>\n<li>你写过回调对吧？</li>\n<li>你用过 RxJava 类似的框架吗？</li>\n</ol>\n<p>看下你的答案：</p>\n<ul>\n<li>如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；</li>\n<li>如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；</li>\n<li>如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~</li>\n</ul>\n<h2 id=\"3-一个常规例子\"><a href=\"#3-一个常规例子\" class=\"headerlink\" title=\"3. 一个常规例子\"></a>3. 一个常规例子</h2><p>我们通过 Retrofit 发送一个网络请求，其中接口如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Call&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">val</span> id: String, <span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> url: String)</span><br></pre></td></tr></table></figure>\n\n<p>Retrofit 初始化如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们请求网络时：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).enqueue(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">User</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        handler.post &#123; showError(t) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">User</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">User</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        handler.post &#123; response.body()?.let(::showUser) ?: showError(NullPointerException()) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？</p>\n<ul>\n<li>通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题</li>\n<li>回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试</li>\n<li>重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 <code>showError</code>，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复</li>\n</ul>\n<p>Kotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。</p>\n<blockquote>\n<p>如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 <code>SwingUtilities.invokeLater&#123; ... &#125;</code> (Java Swing)，或者 <code>setTimeout(&#123; ... &#125;, 0)</code> (Js) 等等。</p>\n</blockquote>\n<h2 id=\"4-改造成协程\"><a href=\"#4-改造成协程\" class=\"headerlink\" title=\"4. 改造成协程\"></a>4. 改造成协程</h2><p>你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 <code>retryWhen</code>）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。</p>\n<p>对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。</p>\n<h3 id=\"4-1-CallAdapter-的方式\"><a href=\"#4-1-CallAdapter-的方式\" class=\"headerlink\" title=\"4.1 CallAdapter 的方式\"></a>4.1 CallAdapter 的方式</h3><p>我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 Deferred 是 Job 的子接口。</p>\n</blockquote>\n<p>那么我们需要为 Retrofit 添加对 <code>Deferred</code> 的支持，这需要用到开源库：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>构造 Retrofit 实例时添加：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            <span class=\"comment\">//添加对 Deferred 的支持</span></span><br><span class=\"line\">            .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这时候我们发起请求就可以这么写了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>说明： <code>Dispatchers.Main</code> 在不同的平台上的实现不同，如果在 Android 上为 <code>HandlerDispatcher</code>，在 Java Swing 上为 <code>SwingDispatcher</code> 等等。</p>\n</blockquote>\n<p>首先我们通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个，依次为协程上下文、协程启动模式、协程体：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext, <span class=\"comment\">// 上下文</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,  <span class=\"comment\">// 启动模式</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">Unit</span> <span class=\"comment\">// 协程体</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: Job </span><br></pre></td></tr></table></figure>\n\n<p><strong>启动模式</strong>不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。</p>\n<p><strong>上下文</strong>可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保 <code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己在 <code>launch</code> 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。</p>\n<p>换句话说，在例子当中整个 <code>launch</code> 内部<strong>你看到的代码</strong>都是运行在 UI 线程的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，<code>getUser</code> 返回了一个 <code>Deferred</code> 类型，它的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么 <code>await</code> 不会阻塞 UI 线程吗？</p>\n<p>答案是：不会。当然不会，不然那 <code>Deferred</code> 与 <code>Future</code> 又有什么区别呢？这里 <code>await</code> 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 <code>Continuation</code> 的接口的实例来返回结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.3&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Continuation</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>&gt;)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1.3 的源码其实并不是很直接，尽管我们可以再看下 <code>Result</code> 的源码，但我不想这么做。更容易理解的是之前版本的源码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.1&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Continuation</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resume</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWithException</span><span class=\"params\">(exception: <span class=\"type\">Throwable</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 <code>Callback</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, Throwable t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果正常返回的时候，<code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常，简直与 <code>Callback</code> 一模一样。</p>\n<p>所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//showUser 在 await 的 Continuation 的回调函数调用后执行</span></span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。</p>\n<p>这时候也许大家还是有问题：我并没有看到 <code>Continuation</code> 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，<code>await</code> 这个方法的签名其实并不像我们看到的那样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">()</span></span>: T</span><br></pre></td></tr></table></figure>\n\n<p>它真实的签名其实是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure>\n\n<p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 的这么个函数，所以前面的代码我们可以大致理解为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意以下不是正确的代码，仅供大家理解协程使用</span></span><br><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await(<span class=\"keyword\">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resume</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">                showUser(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWithException</span><span class=\"params\">(exception: <span class=\"type\">Throwable</span>)</span></span>&#123;</span><br><span class=\"line\">                showError(exception)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而在 <code>await</code> 当中，大致就是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意以下并不是真实的实现，仅供大家理解协程使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">User</span>&gt;)</span></span>: Any &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> user = ...</span><br><span class=\"line\">        handler.post&#123; continuation.resume(user) &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e: Exception) &#123;</span><br><span class=\"line\">        handler.post&#123; continuation.resumeWithException(e) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。</p>\n<h3 id=\"4-2-suspend-函数的方式\"><a href=\"#4-2-suspend-函数的方式\" class=\"headerlink\" title=\"4.2 suspend 函数的方式\"></a>4.2 suspend 函数的方式</h3><p>suspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 <code>Deferred</code> 的 <code>await</code> 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。</p>\n<blockquote>\n<p>Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。</p>\n</blockquote>\n<p>首先我们修改接口方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure>\n\n<p>这种情况 Retrofit 会根据接口方法的声明来构造 <code>Continuation</code>，并且在内部封装了 <code>Call</code> 的异步请求（使用 enqueue），进而得到 <code>User</code> 实例，具体原理后面我们有机会再介绍。使用方法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的执行流程与 <code>Deferred.await</code> 类似，我们就不再详细分析了。</p>\n<h2 id=\"5-协程到底是什么\"><a href=\"#5-协程到底是什么\" class=\"headerlink\" title=\"5. 协程到底是什么\"></a>5. 协程到底是什么</h2><p>好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。</p>\n<p>而<strong>协程</strong>可以帮你优雅的处理掉这些。</p>\n<p>协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：</p>\n<blockquote>\n<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>\n</blockquote>\n<p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p>\n<blockquote>\n<p>关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。</p>\n</blockquote>\n<p>如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，<a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Job</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isActive: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isCompleted: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isCancelled: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cancel</span><span class=\"params\">(cause: <span class=\"type\">CancellationException</span>? = <span class=\"literal\">null</span>)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">join</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看 Thread 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    ...    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException  </span>&#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。</p>\n<p>而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。</p>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h2><p>我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。</p>\n<p>这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#x40;&#105;&#109;&#x6f;&#111;&#x63;&#46;&#99;&#x6f;&#109;\">&#x6b;&#x66;&#x40;&#105;&#109;&#x6f;&#111;&#x63;&#46;&#99;&#x6f;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>假定你对协程（Coroutine）一点儿都不了解，通过阅读本文看看是否能让你明白协程是怎么一回事。 </p>\n</blockquote>","more":"<h2 id=\"1-引子\"><a href=\"#1-引子\" class=\"headerlink\" title=\"1. 引子\"></a>1. 引子</h2><p>我之前写过一些协程的文章，很久以前了。那会儿还是很痛苦的，毕竟 <a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> 这样强大的框架还在襁褓当中，于是乎我写的几篇协程的文章几乎就是在告诉大家如何写这样一个框架——那种感觉简直糟糕透了，因为没有几个人会有这样的需求。</p>\n<p>这次准备从协程用户（也就是程序员你我他啦）的角度来写一下，希望对大家能有帮助。</p>\n<h2 id=\"2-需求确认\"><a href=\"#2-需求确认\" class=\"headerlink\" title=\"2. 需求确认\"></a>2. 需求确认</h2><p>在开始讲解协程之前，我们需要先确认几件事儿：</p>\n<ol>\n<li>你用过线程对吧？</li>\n<li>你写过回调对吧？</li>\n<li>你用过 RxJava 类似的框架吗？</li>\n</ol>\n<p>看下你的答案：</p>\n<ul>\n<li>如果上面的问题的回答都是 “Yes”，那么太好了，这篇文章非常适合你，因为你已经意识到回调有多么可怕，并且找到了解决方案；</li>\n<li>如果前两个是 “Yes”，没问题，至少你已经开始用回调了，你是协程潜在的用户；</li>\n<li>如果只有第一个是 “Yes”，那么，可能你刚刚开始学习线程，那你还是先打好基础再来吧~</li>\n</ul>\n<h2 id=\"3-一个常规例子\"><a href=\"#3-一个常规例子\" class=\"headerlink\" title=\"3. 一个常规例子\"></a>3. 一个常规例子</h2><p>我们通过 Retrofit 发送一个网络请求，其中接口如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Call&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">val</span> id: String, <span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> url: String)</span><br></pre></td></tr></table></figure>\n\n<p>Retrofit 初始化如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们请求网络时：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).enqueue(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">User</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        handler.post &#123; showError(t) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">User</span>&gt;, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">User</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        handler.post &#123; response.body()?.let(::showUser) ?: showError(NullPointerException()) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>请求结果回来之后，我们切换线程到 UI 线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？</p>\n<ul>\n<li>通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题</li>\n<li>回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试</li>\n<li>重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 <code>showError</code>，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复</li>\n</ul>\n<p>Kotlin 本身的语法已经让这段代码看上去好很多了，如果用 Java 写的话，你的直觉都会告诉你：你在写 Bug。</p>\n<blockquote>\n<p>如果你不是 Android 开发者，那么你可能不知道 handler 是什么东西，没关系，你可以替换为 <code>SwingUtilities.invokeLater&#123; ... &#125;</code> (Java Swing)，或者 <code>setTimeout(&#123; ... &#125;, 0)</code> (Js) 等等。</p>\n</blockquote>\n<h2 id=\"4-改造成协程\"><a href=\"#4-改造成协程\" class=\"headerlink\" title=\"4. 改造成协程\"></a>4. 改造成协程</h2><p>你当然可以改造成 RxJava 的风格，但 RxJava 比协程抽象多了，因为除非你熟练使用那些 operator，不然你根本不知道它在干嘛（试想一下 <code>retryWhen</code>）。协程就不一样了，毕竟编译器加持，它可以很简洁的表达出代码的逻辑，不要想它背后的实现逻辑，它的运行结果就是你直觉告诉你的那样。</p>\n<p>对于 Retrofit，改造成协程的写法，有两种，分别是通过 CallAdapter 和 suspend 函数。</p>\n<h3 id=\"4-1-CallAdapter-的方式\"><a href=\"#4-1-CallAdapter-的方式\" class=\"headerlink\" title=\"4.1 CallAdapter 的方式\"></a>4.1 CallAdapter 的方式</h3><p>我们先来看看 CallAdapter 的方式，这个方式的本质是让接口的方法返回一个协程的 Job：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 Deferred 是 Job 的子接口。</p>\n</blockquote>\n<p>那么我们需要为 Retrofit 添加对 <code>Deferred</code> 的支持，这需要用到开源库：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>构造 Retrofit 实例时添加：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            <span class=\"comment\">//添加对 Deferred 的支持</span></span><br><span class=\"line\">            .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这时候我们发起请求就可以这么写了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>说明： <code>Dispatchers.Main</code> 在不同的平台上的实现不同，如果在 Android 上为 <code>HandlerDispatcher</code>，在 Java Swing 上为 <code>SwingDispatcher</code> 等等。</p>\n</blockquote>\n<p>首先我们通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个，依次为协程上下文、协程启动模式、协程体：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext, <span class=\"comment\">// 上下文</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,  <span class=\"comment\">// 启动模式</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">Unit</span> <span class=\"comment\">// 协程体</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: Job </span><br></pre></td></tr></table></figure>\n\n<p><strong>启动模式</strong>不是一个很复杂的概念，不过我们暂且不管，默认直接允许调度执行。</p>\n<p><strong>上下文</strong>可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保 <code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己在 <code>launch</code> 的协程体内部进行线程切换、或者启动运行在其他有线程切换能力的上下文的协程）。</p>\n<p>换句话说，在例子当中整个 <code>launch</code> 内部<strong>你看到的代码</strong>都是运行在 UI 线程的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。这看上去有些费解，因为直觉告诉我们，<code>getUser</code> 返回了一个 <code>Deferred</code> 类型，它的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么 <code>await</code> 不会阻塞 UI 线程吗？</p>\n<p>答案是：不会。当然不会，不然那 <code>Deferred</code> 与 <code>Future</code> 又有什么区别呢？这里 <code>await</code> 就很可疑了，因为它实际上是一个 suspend 函数，这个函数只能在协程体或者其他 suspend 函数内部被调用，它就像是回调的语法糖一样，它通过一个叫 <code>Continuation</code> 的接口的实例来返回结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.3&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Continuation</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>&gt;)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1.3 的源码其实并不是很直接，尽管我们可以再看下 <code>Result</code> 的源码，但我不想这么做。更容易理解的是之前版本的源码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.1&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Continuation</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resume</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWithException</span><span class=\"params\">(exception: <span class=\"type\">Throwable</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家一下就能明白，这其实就是个回调嘛。如果还不明白，那就对比下 Retrofit 的 <code>Callback</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, Throwable t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果正常返回的时候，<code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常，简直与 <code>Callback</code> 一模一样。</p>\n<p>所以这时候你应该明白，这段代码的执行流程本质上是一个异步回调：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//showUser 在 await 的 Continuation 的回调函数调用后执行</span></span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而代码之所以可以看起来是同步的，那就是编译器的黑魔法了，你当然也可以叫它“语法糖”。</p>\n<p>这时候也许大家还是有问题：我并没有看到 <code>Continuation</code> 啊，没错，这正是我们前面说的编译器黑魔法了，在 Java 虚拟机上，<code>await</code> 这个方法的签名其实并不像我们看到的那样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">()</span></span>: T</span><br></pre></td></tr></table></figure>\n\n<p>它真实的签名其实是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure>\n\n<p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 的这么个函数，所以前面的代码我们可以大致理解为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意以下不是正确的代码，仅供大家理解协程使用</span></span><br><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>).await(<span class=\"keyword\">object</span>: Continuation&lt;User&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resume</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">                showUser(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWithException</span><span class=\"params\">(exception: <span class=\"type\">Throwable</span>)</span></span>&#123;</span><br><span class=\"line\">                showError(exception)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而在 <code>await</code> 当中，大致就是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意以下并不是真实的实现，仅供大家理解协程使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">User</span>&gt;)</span></span>: Any &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 切到非 UI 线程中执行，等待结果返回</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> user = ...</span><br><span class=\"line\">        handler.post&#123; continuation.resume(user) &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e: Exception) &#123;</span><br><span class=\"line\">        handler.post&#123; continuation.resumeWithException(e) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的回调大家一看就能明白。讲了这么多，请大家记住一点：从执行机制上来讲，协程跟回调没有什么本质的区别。</p>\n<h3 id=\"4-2-suspend-函数的方式\"><a href=\"#4-2-suspend-函数的方式\" class=\"headerlink\" title=\"4.2 suspend 函数的方式\"></a>4.2 suspend 函数的方式</h3><p>suspend 函数是 Kotlin 编译器对协程支持的唯一的黑魔法（表面上的，还有其他的我们后面讲原理的时候再说）了，我们前面已经通过 <code>Deferred</code> 的 <code>await</code> 方法对它有了个大概的了解，我们再来看看 Retrofit 当中它还可以怎么用。</p>\n<blockquote>\n<p>Retrofit 当前的 release 版本是 2.5.0，还不支持 suspend 函数。因此想要尝试下面的代码，需要最新的 Retrofit 源码的支持；当然，也许你看到这篇文章的时候，Retrofit 的新版本已经支持这一项特性了呢。</p>\n</blockquote>\n<p>首先我们修改接口方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: User</span><br></pre></td></tr></table></figure>\n\n<p>这种情况 Retrofit 会根据接口方法的声明来构造 <code>Continuation</code>，并且在内部封装了 <code>Call</code> 的异步请求（使用 enqueue），进而得到 <code>User</code> 实例，具体原理后面我们有机会再介绍。使用方法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(gitHubServiceApi.getUser(<span class=\"string\">&quot;bennyhuo&quot;</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的执行流程与 <code>Deferred.await</code> 类似，我们就不再详细分析了。</p>\n<h2 id=\"5-协程到底是什么\"><a href=\"#5-协程到底是什么\" class=\"headerlink\" title=\"5. 协程到底是什么\"></a>5. 协程到底是什么</h2><p>好，坚持读到这里的朋友们，你们一定是异步代码的“受害者”，你们肯定遇到过“回调地狱”，它让你的代码可读性急剧降低；也写过大量复杂的异步逻辑处理、异常处理，这让你的代码重复逻辑增加；因为回调的存在，还得经常处理线程切换，这似乎并不是一件难事，但随着代码体量的增加，它会让你抓狂，线上上报的异常因线程使用不当导致的可不在少数。</p>\n<p>而<strong>协程</strong>可以帮你优雅的处理掉这些。</p>\n<p>协程本身是一个脱离语言实现的概念，我们“很严谨”（哈哈）的给出维基百科的定义：</p>\n<blockquote>\n<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>\n</blockquote>\n<p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。这里还是需要有点儿操作系统的知识的，我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p>\n<blockquote>\n<p>关于并发和并行：正因为 CPU 时间片足够小，因此即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是 Magic。</p>\n</blockquote>\n<p>如果大家熟悉 Java 虚拟机的话，就想象一下 Thread 这个类到底是什么吧，为什么它的 run 方法会运行在另一个线程当中呢？谁负责执行这段代码的呢？显然，咋一看，Thread 其实是一个对象而已，run 方法里面包含了要执行的代码——仅此而已。协程也是如此，如果你只是看标准库的 API，那么就太抽象了，但我们开篇交代了，学习协程不要上来去接触标准库，<a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> 框架才是我们用户应该关心的，而这个框架里面对应于 Thread 的概念就是 Job 了，大家可以看下它的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Job</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isActive: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isCompleted: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> isCancelled: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cancel</span><span class=\"params\">(cause: <span class=\"type\">CancellationException</span>? = <span class=\"literal\">null</span>)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">join</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看 Thread 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    ...    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException  </span>&#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们非常贴心的省略了一些注释和不太相关的接口。我们发现，Thread 与 Job 基本上功能一致，它们都承载了一段代码逻辑（前者通过 run 方法，后者通过构造协程用到的 Lambda 或者函数），也都包含了这段代码的运行状态。</p>\n<p>而真正调度时二者才有了本质的差异，具体怎么调度，我们只需要知道调度结果就能很好的使用它们了。</p>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h2><p>我们先通过例子来引入，从大家最熟悉的代码到协程的例子开始，演化到协程的写法，让大家首先能从感性上对协程有个认识，最后我们给出了协程的定义，也告诉大家协程究竟能做什么。</p>\n<p>这篇文章没有追求什么内部原理，只是企图让大家对协程怎么用有个第一印象。如果大家仍然感觉到迷惑，不怕，后面我将再用几篇文章从例子入手来带着大家分析协程的运行，而原理的分析，会放到大家能够熟练掌握协程之后再来探讨。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#x40;&#105;&#109;&#x6f;&#111;&#x63;&#46;&#99;&#x6f;&#109;\">&#x6b;&#x66;&#x40;&#105;&#109;&#x6f;&#111;&#x63;&#46;&#99;&#x6f;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"C 语言版的 println？","keywords":"C 宏 泛型 println","date":"2020-06-13T16:00:00.000Z","description":null,"_content":"\n> Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 \n\n\n\n<!-- more -->\n\n\n\n\n```kotlin\nval name = \"bennyhuo\"\nprintln(name)\n\nval age = 30\nprintln(age)\n```\n\n不管什么变量类型，println 一律照单全收，是不是很方便？\n\n而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。\n\n有没有什么办法解决这些问题呢？\n\n## 问题一：自动换行\n\nprintf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 `\\n`，例如：\n\n```c\nint age = 30;\nprintf(\"%d\\n\", age);\n```\n\n解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：\n\n```c\n#include <stdio.h>\n#include <stdarg.h>\n\nvoid printlnf(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vprintf(format, args);\n    printf(\"\\n\");\n    va_end(args);\n}\n```\n\n这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。\n\n在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 `va_list` 来承载变长参数的值，使用 `va_start` 和 `va_end` 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 `va_list` 类型的参数做为后面需要被格式化的参数。\n\n用法起来嘛，还是可以的：\n\n```c\nprintlnf(\"%d\", 5); // 5\\n\n```\n\n不过实话这个函数定义并不是很美，看着太长了。\n\n在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）\n\n```c\n#define printlnf(format, ...) printf(format\"\\n\", ##__VA_ARGS__)\n```\n\n额，用宏实现就这么简单？\n\n首先我们注意一下 `format\"\\n\"`，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：\n\n```c\nchar *name = \"benny\"\"huo\"; // 1\nchar *name = \"bennyhuo\"; // 2\n```\n\n1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：\n\n```c\nprintlnf(\"Hello %s\", \"C\");\n```\n\n经过编译器预处理之后展开宏得到：\n\n```c\nprintf(\"Hello %s\"\"\\n\", \"C\");\n```\n\n所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：\n\n```c\nchar *format = \"Hello %s\";\nprintlnf(format, \"C\"); // error!\n```\n\n因为宏展开以后得到：\n\n```c\nchar *format = \"Hello %s\";\nprintf(format\"\\n\", \"C\"); // error!\n```\n\n不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。\n\n## 问题二：支持非字符串类型直接打印\n\nC 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：\n\n```c\nprintln(30);\n```\n\n这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 `_Generic`，可以支持泛型！\n\n妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：\n\n```c\nint value = _Generic(x,\n        int: 2,\n        double: 3,\n        char * : 4\n);\n```\n\n我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。\n\n不得不说，这语法中透露着年代感。但不管怎样，总算能用。\n\n我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？\n\n```c\nvoid println(??? format, ...) {\n  _Generic(format, ...);\n  ...\n}\n```\n\n假设将 format 定义为 `char*` 类型，那么泛型的判断豪无意义，因为 `_Generic` 永远会选择 `char*` 分支的返回值。\n\n既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：\n\n```c\n#define println(X) _Generic((X),  \\\n    int: printf(\"%d\\n\", X), \\\n    float: printf(\"%f\\n\", X), \\\n    char *: printf(\"%s\\n\", X), \\\n    double : printf(\"%0.4f\\n\", X) \\\n    )\n```\n\n这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：\n\n```c\nprintln(\"Hello\");\nprintln(3);\nprintln(0.3);\nprintln(34.0f);\n```\n\n## 问题三：打印文件名和行号\n\nC 当中提供了两个宏：\n\n* `__FILE__`：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。\n* `__LINE__`：展开之后就是所在的源代码文件行的行号，是个整型。\n\n有了这两个宏，那么实现这个功能也就不难做到了。\n\n首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：\n\n```c\n#define printlnf(format, ...) printf(\"(%s:%d) \"format\"\\n\", __FILE__, __LINE__, ##__VA_ARGS__)\n```\n\n使用效果如下：\n\n```c\nprintlnf(\"%d\", 30);\n```\n\n输出结果：\n\n```\n(C:\\Users\\bennyhuo\\WorkSpace\\Demos\\HelloCInClion\\main.c:48) 30\n```\n\n如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。\n\n## 小结\n\n我们通过改造 printf，得到了两套实现，其中：\n\n1. 在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；\n2. 支持直接打印常见类型，得到 println 的宏实现。\n\n二者也都可以根据需要添加对文件名和行号的输出支持。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/c-println.md","raw":"---\ntitle:  C 语言版的 println？ \nkeywords: C 宏 泛型 println \ndate: 2020/06/14\ndescription: \ntags: \n    - c\n    - macro\n    -  \n---\n\n> Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 \n\n\n\n<!-- more -->\n\n\n\n\n```kotlin\nval name = \"bennyhuo\"\nprintln(name)\n\nval age = 30\nprintln(age)\n```\n\n不管什么变量类型，println 一律照单全收，是不是很方便？\n\n而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。\n\n有没有什么办法解决这些问题呢？\n\n## 问题一：自动换行\n\nprintf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 `\\n`，例如：\n\n```c\nint age = 30;\nprintf(\"%d\\n\", age);\n```\n\n解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：\n\n```c\n#include <stdio.h>\n#include <stdarg.h>\n\nvoid printlnf(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vprintf(format, args);\n    printf(\"\\n\");\n    va_end(args);\n}\n```\n\n这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。\n\n在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 `va_list` 来承载变长参数的值，使用 `va_start` 和 `va_end` 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 `va_list` 类型的参数做为后面需要被格式化的参数。\n\n用法起来嘛，还是可以的：\n\n```c\nprintlnf(\"%d\", 5); // 5\\n\n```\n\n不过实话这个函数定义并不是很美，看着太长了。\n\n在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）\n\n```c\n#define printlnf(format, ...) printf(format\"\\n\", ##__VA_ARGS__)\n```\n\n额，用宏实现就这么简单？\n\n首先我们注意一下 `format\"\\n\"`，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：\n\n```c\nchar *name = \"benny\"\"huo\"; // 1\nchar *name = \"bennyhuo\"; // 2\n```\n\n1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：\n\n```c\nprintlnf(\"Hello %s\", \"C\");\n```\n\n经过编译器预处理之后展开宏得到：\n\n```c\nprintf(\"Hello %s\"\"\\n\", \"C\");\n```\n\n所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：\n\n```c\nchar *format = \"Hello %s\";\nprintlnf(format, \"C\"); // error!\n```\n\n因为宏展开以后得到：\n\n```c\nchar *format = \"Hello %s\";\nprintf(format\"\\n\", \"C\"); // error!\n```\n\n不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。\n\n## 问题二：支持非字符串类型直接打印\n\nC 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：\n\n```c\nprintln(30);\n```\n\n这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 `_Generic`，可以支持泛型！\n\n妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：\n\n```c\nint value = _Generic(x,\n        int: 2,\n        double: 3,\n        char * : 4\n);\n```\n\n我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。\n\n不得不说，这语法中透露着年代感。但不管怎样，总算能用。\n\n我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？\n\n```c\nvoid println(??? format, ...) {\n  _Generic(format, ...);\n  ...\n}\n```\n\n假设将 format 定义为 `char*` 类型，那么泛型的判断豪无意义，因为 `_Generic` 永远会选择 `char*` 分支的返回值。\n\n既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：\n\n```c\n#define println(X) _Generic((X),  \\\n    int: printf(\"%d\\n\", X), \\\n    float: printf(\"%f\\n\", X), \\\n    char *: printf(\"%s\\n\", X), \\\n    double : printf(\"%0.4f\\n\", X) \\\n    )\n```\n\n这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：\n\n```c\nprintln(\"Hello\");\nprintln(3);\nprintln(0.3);\nprintln(34.0f);\n```\n\n## 问题三：打印文件名和行号\n\nC 当中提供了两个宏：\n\n* `__FILE__`：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。\n* `__LINE__`：展开之后就是所在的源代码文件行的行号，是个整型。\n\n有了这两个宏，那么实现这个功能也就不难做到了。\n\n首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：\n\n```c\n#define printlnf(format, ...) printf(\"(%s:%d) \"format\"\\n\", __FILE__, __LINE__, ##__VA_ARGS__)\n```\n\n使用效果如下：\n\n```c\nprintlnf(\"%d\", 30);\n```\n\n输出结果：\n\n```\n(C:\\Users\\bennyhuo\\WorkSpace\\Demos\\HelloCInClion\\main.c:48) 30\n```\n\n如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。\n\n## 小结\n\n我们通过改造 printf，得到了两套实现，其中：\n\n1. 在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；\n2. 支持直接打印常见类型，得到 println 的宏实现。\n\n二者也都可以根据需要添加对文件名和行号的输出支持。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"c-println","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0030000glduz7qf84qgx","content":"<blockquote>\n<p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;bennyhuo&quot;</span></span><br><span class=\"line\">println(name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">30</span></span><br><span class=\"line\">println(age)</span><br></pre></td></tr></table></figure>\n\n<p>不管什么变量类型，println 一律照单全收，是不是很方便？</p>\n<p>而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。</p>\n<p>有没有什么办法解决这些问题呢？</p>\n<h2 id=\"问题一：自动换行\"><a href=\"#问题一：自动换行\" class=\"headerlink\" title=\"问题一：自动换行\"></a>问题一：自动换行</h2><p>printf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 <code>\\n</code>，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, age);</span><br></pre></td></tr></table></figure>\n\n<p>解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printlnf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* format, ...)</span> </span>&#123;</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, format);</span><br><span class=\"line\">    <span class=\"built_in\">vprintf</span>(format, args);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。</p>\n<p>在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 <code>va_list</code> 来承载变长参数的值，使用 <code>va_start</code> 和 <code>va_end</code> 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 <code>va_list</code> 类型的参数做为后面需要被格式化的参数。</p>\n<p>用法起来嘛，还是可以的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 5\\n</span></span><br></pre></td></tr></table></figure>\n\n<p>不过实话这个函数定义并不是很美，看着太长了。</p>\n<p>在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> printlnf(format, ...) printf(format<span class=\"meta-string\">&quot;\\n&quot;</span>, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n\n<p>额，用宏实现就这么简单？</p>\n<p>首先我们注意一下 <code>format&quot;\\n&quot;</code>，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;benny&quot;</span><span class=\"string\">&quot;huo&quot;</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;bennyhuo&quot;</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;Hello %s&quot;</span>, <span class=\"string\">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>经过编译器预处理之后展开宏得到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s&quot;</span><span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *format = <span class=\"string\">&quot;Hello %s&quot;</span>;</span><br><span class=\"line\">printlnf(format, <span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<p>因为宏展开以后得到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *format = <span class=\"string\">&quot;Hello %s&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(format<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<p>不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。</p>\n<h2 id=\"问题二：支持非字符串类型直接打印\"><a href=\"#问题二：支持非字符串类型直接打印\" class=\"headerlink\" title=\"问题二：支持非字符串类型直接打印\"></a>问题二：支持非字符串类型直接打印</h2><p>C 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 <code>_Generic</code>，可以支持泛型！</p>\n<p>妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> value = _Generic(x,</span><br><span class=\"line\">        <span class=\"keyword\">int</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"keyword\">double</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">        <span class=\"keyword\">char</span> * : <span class=\"number\">4</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。</p>\n<p>不得不说，这语法中透露着年代感。但不管怎样，总算能用。</p>\n<p>我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">println</span><span class=\"params\">(??? format, ...)</span> </span>&#123;</span><br><span class=\"line\">  _Generic(format, ...);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设将 format 定义为 <code>char*</code> 类型，那么泛型的判断豪无意义，因为 <code>_Generic</code> 永远会选择 <code>char*</code> 分支的返回值。</p>\n<p>既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> println(X) _Generic((X),  \\</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">float</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">double</span> : <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%0.4f\\n&quot;</span>, X) \\</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n\n<p>这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">println(<span class=\"number\">3</span>);</span><br><span class=\"line\">println(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">println(<span class=\"number\">34.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题三：打印文件名和行号\"><a href=\"#问题三：打印文件名和行号\" class=\"headerlink\" title=\"问题三：打印文件名和行号\"></a>问题三：打印文件名和行号</h2><p>C 当中提供了两个宏：</p>\n<ul>\n<li><code>__FILE__</code>：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。</li>\n<li><code>__LINE__</code>：展开之后就是所在的源代码文件行的行号，是个整型。</li>\n</ul>\n<p>有了这两个宏，那么实现这个功能也就不难做到了。</p>\n<p>首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> printlnf(format, ...) printf(<span class=\"meta-string\">&quot;(%s:%d) &quot;</span>format<span class=\"meta-string\">&quot;\\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n\n<p>使用效果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(C:\\Users\\bennyhuo\\WorkSpace\\Demos\\HelloCInClion\\main.c:48) 30</span><br></pre></td></tr></table></figure>\n\n<p>如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>我们通过改造 printf，得到了两套实现，其中：</p>\n<ol>\n<li>在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；</li>\n<li>支持直接打印常见类型，得到 println 的宏实现。</li>\n</ol>\n<p>二者也都可以根据需要添加对文件名和行号的输出支持。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 </p>\n</blockquote>","more":"<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> name = <span class=\"string\">&quot;bennyhuo&quot;</span></span><br><span class=\"line\">println(name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> age = <span class=\"number\">30</span></span><br><span class=\"line\">println(age)</span><br></pre></td></tr></table></figure>\n\n<p>不管什么变量类型，println 一律照单全收，是不是很方便？</p>\n<p>而我们的 C 语言呢，想要打印个变量可就没那么轻松了，不仅如此，换行符都得我们手动输入，如果能同时打印出对应的代码文件和行号查问题就更方便了。</p>\n<p>有没有什么办法解决这些问题呢？</p>\n<h2 id=\"问题一：自动换行\"><a href=\"#问题一：自动换行\" class=\"headerlink\" title=\"问题一：自动换行\"></a>问题一：自动换行</h2><p>printf 是不会自动换行的，因此每次我们都需要在格式化字符串当中加一个 <code>\\n</code>，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, age);</span><br></pre></td></tr></table></figure>\n\n<p>解决换行的问题很简单，我们只需要定义一个函数 printlnf，在打印了需要打印的内容之后跟一个换行符的输出即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printlnf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* format, ...)</span> </span>&#123;</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, format);</span><br><span class=\"line\">    <span class=\"built_in\">vprintf</span>(format, args);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里打印换行符比较容易理解，不过对于变长参数的处理就有点儿晦涩了，至少不像我们在 Kotlin 当中可以直接拿到一个数组来处理变长参数。</p>\n<p>在 C 当中，我们无法知道有多少个变长参数，通常支持变长参数的函数需要通过前面的固定的参数来携带这个信息，例如 printf 可以通过格式化字符串 format 当中的格式符来判定后面有多少个参数。好在我们在这个场景下只要能把 println 的变长参数透传给 printf 就行了（当然我们实际上是透传给了 vprintf），多少个其实我们可以不关心。按照 C 标准的提供的方法，我们可以使用 <code>va_list</code> 来承载变长参数的值，使用 <code>va_start</code> 和 <code>va_end</code> 来获取和清除变长参数，vprintf 实际上就是 printf 的一个变种，它可以直接接受 <code>va_list</code> 类型的参数做为后面需要被格式化的参数。</p>\n<p>用法起来嘛，还是可以的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 5\\n</span></span><br></pre></td></tr></table></figure>\n\n<p>不过实话这个函数定义并不是很美，看着太长了。</p>\n<p>在 C 语言当中，还有一套强大的预处理机制，如果我们用宏来实现 printlnf，效果会怎样呢？（我似乎想到了 rust 的 println!）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> printlnf(format, ...) printf(format<span class=\"meta-string\">&quot;\\n&quot;</span>, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n\n<p>额，用宏实现就这么简单？</p>\n<p>首先我们注意一下 <code>format&quot;\\n&quot;</code>，这个语法特别有意思，在 C 当中我们可以直接拼接字符串字面量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;benny&quot;</span><span class=\"string\">&quot;huo&quot;</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;bennyhuo&quot;</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>1 和 2 是等价的，字面量连接在一起可以直接实现拼接的效果。那么我们定义的宏当中 format 如果是一个字符串字面量的话，自然就能实现拼接效果了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;Hello %s&quot;</span>, <span class=\"string\">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>经过编译器预处理之后展开宏得到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s&quot;</span><span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>所以换行的问题就解决了。当然，宏的这个实现方案有个缺点，format 必须是字符串字面量，下面的用法是错误的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *format = <span class=\"string\">&quot;Hello %s&quot;</span>;</span><br><span class=\"line\">printlnf(format, <span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<p>因为宏展开以后得到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *format = <span class=\"string\">&quot;Hello %s&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(format<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<p>不管怎样，我们总是可以在一定的场景下通过上面的实现来解决为 printf 自动追加一个换行符的问题。</p>\n<h2 id=\"问题二：支持非字符串类型直接打印\"><a href=\"#问题二：支持非字符串类型直接打印\" class=\"headerlink\" title=\"问题二：支持非字符串类型直接打印\"></a>问题二：支持非字符串类型直接打印</h2><p>C 毕竟不是面向对象的语言，我们也很难说有一个统一的办法把所有的结构体转成字符串（字符数组），因此我们的要求也不高，对于基本类型，可以实现类似下面的效果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这要是在 C++ 当中，我们直接重载一下这个函数即可，但 C 语言不支持啊（实际上 C++ 的重载会用参数类型去修饰函数名来生成最终的函数符号），不过 C11 新增了一个特性 <code>_Generic</code>，可以支持泛型！</p>\n<p>妈呀，C 语言居然也有泛型，惊喜不惊喜！让我们来看看它的用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> value = _Generic(x,</span><br><span class=\"line\">        <span class=\"keyword\">int</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"keyword\">double</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">        <span class=\"keyword\">char</span> * : <span class=\"number\">4</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以把它当做一个特殊的函数，第一个参数 x 是需要提取类型的变量，第二个参数则是一个类似于 switch case 的分支语句，如果 x 是 int 类型，那么返回值就是 2，如果是 double 类型，那么返回 3，等等。</p>\n<p>不得不说，这语法中透露着年代感。但不管怎样，总算能用。</p>\n<p>我们来试着考虑实现一个 println 的函数或者宏，不过很快我们就会发现函数是无法实现的，只能使用宏。为什么呢？因为这里的参数 x 的类型是需要在编译的时候确定的，如果我们试图实现 println 函数的话，那么参数的类型要怎么定义呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">println</span><span class=\"params\">(??? format, ...)</span> </span>&#123;</span><br><span class=\"line\">  _Generic(format, ...);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设将 format 定义为 <code>char*</code> 类型，那么泛型的判断豪无意义，因为 <code>_Generic</code> 永远会选择 <code>char*</code> 分支的返回值。</p>\n<p>既然如此， format 就不能有类型咯。谁的参数可以没有（或者不能有）类型？宏呗。所以我们只好实现一个宏版本的 println 了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> println(X) _Generic((X),  \\</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">float</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *: <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, X), \\</span><br><span class=\"line\">    <span class=\"keyword\">double</span> : <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%0.4f\\n&quot;</span>, X) \\</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n\n<p>这当中可以支持更多的类型，我们就举上面的几个为例。具体用法呢：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">println(<span class=\"number\">3</span>);</span><br><span class=\"line\">println(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">println(<span class=\"number\">34.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题三：打印文件名和行号\"><a href=\"#问题三：打印文件名和行号\" class=\"headerlink\" title=\"问题三：打印文件名和行号\"></a>问题三：打印文件名和行号</h2><p>C 当中提供了两个宏：</p>\n<ul>\n<li><code>__FILE__</code>：展开之后就是文件的全路径（具体结果当然也跟编译器实现和参数有关系）。</li>\n<li><code>__LINE__</code>：展开之后就是所在的源代码文件行的行号，是个整型。</li>\n</ul>\n<p>有了这两个宏，那么实现这个功能也就不难做到了。</p>\n<p>首先需要考虑的就是用函数实现还是用宏实现的问题。由于需要打印调用点的位置，而函数的实现会影响调用栈，因此这里使用只能宏来实现。宏调用会直接展开在调用处，因此行号和文件名都是正确的结果，实现方式也比较简单，我们给出 printlnf  的实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> printlnf(format, ...) printf(<span class=\"meta-string\">&quot;(%s:%d) &quot;</span>format<span class=\"meta-string\">&quot;\\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n\n<p>使用效果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printlnf(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(C:\\Users\\bennyhuo\\WorkSpace\\Demos\\HelloCInClion\\main.c:48) 30</span><br></pre></td></tr></table></figure>\n\n<p>如果大家使用 CLion 开发，可以直接点击输出的文件和行号跳转到对应的源码位置，方便吧。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>我们通过改造 printf，得到了两套实现，其中：</p>\n<ol>\n<li>在原有 printf 上增加换行，其他功能不变，得到 printlnf 函数和宏实现；</li>\n<li>支持直接打印常见类型，得到 println 的宏实现。</li>\n</ol>\n<p>二者也都可以根据需要添加对文件名和行号的输出支持。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"C 语言版的 println？","path":"2020/06/14/c-println/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>Kotlin 当中的 println 非常好用，可是 C 当中我们常用的 printf 却总是需要格式化字符，并且需要手动提供换行符。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-06-13T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-06-13T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["c","macro"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"破解 Kotlin 协程(8) - Android 篇","keywords":"Kotlin 协程 Android Anko","date":"2019-05-26T16:00:00.000Z","description":null,"_content":"\n> Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ \n\n\n\n<!-- more -->\n\n\n\n\n我们曾经提到过，如果在 Android 上做开发，那么我们需要引入\n\n```gradle\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version'\n```  \n\n这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。\n\n~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）\n\n```gradle\n//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式\nimplementation \"org.jetbrains.anko:anko-sdk27-coroutines:$anko_version\"\n//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造\nimplementation \"org.jetbrains.anko:anko-coroutines:$anko_version\"\n```\n\n简单来说：\n\n* kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器\n* ~~anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨~~\n* ~~anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。~~\n\n协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。\n\n## 2. UI 生命周期作用域\n\nAndroid 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。\n\n### 2.1 使用 MainScope\n\n协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 `MainScope` 这个函数，我们具体看下它的使用方法：\n\n```kotlin\nval mainScope = MainScope()\nlaunchButton.setOnClickListener {\n    mainScope.launch {\n        log(1)\n        textView.text = async(Dispatchers.IO) {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello1111\"\n        }.await()\n        log(4)\n    }\n}\n```\n\n我们发现它其实与其他的 `CoroutineScope` 用起来没什么不一样的地方，通过同一个叫 `mainScope` 的实例启动的协程，都会遵循它的作用域定义，那么 `MainScope` 的定义时怎样的呢？\n\n```kotlin\npublic fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)\n```\n\n原来就是 `SupervisorJob` 整合了 `Dispatchers.Main` 而已，它的异常传播是自上而下的，这一点与 `supervisorScope` 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：\n\n```\n2019-04-29 06:51:00.657 D: [main] 1\n2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2\n2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3\n2019-04-29 06:51:01.664 D: [main] 4\n```\n\n如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：\n\n```kotlin\nval mainScope = MainScope()\n\nlaunchButton.setOnClickListener {\n    mainScope.launch {\n        ...\n    }\n}\n\ncancelButton.setOnClickListener {\n    mainScope.cancel()\n    log(\"MainScope is cancelled.\")\n}\n```\n\n如果我们快速依次点击上面的两个按钮，结果就显而易见了：\n\n```\n2019-04-29 07:12:20.625 D: [main] 1\n2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2\n2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.\n```\n\n### 2.2 构造带有作用域的抽象 Activity\n\n尽管我们前面体验了 `MainScope` 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。\n\n官方推荐我们定义一个抽象的 `Activity`，例如：\n\n```kotlin\nabstract class ScopedActivity: Activity(), CoroutineScope by MainScope(){\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n}\n```\n\n这样在 `Activity` 退出的时候，对应的作用域就会被取消，所有在该 `Activity` 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：\n\n```kotlin\nclass CoroutineActivity : ScopedActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_coroutine)\n        launchButton.setOnClickListener {\n            launch { // 直接调用 ScopedActivity 也就是 MainScope 的方法\n                ...\n            }\n        }\n    }\n    \n    suspend fun anotherOps() = coroutineScope {\n        ...\n    }\n}\n```\n\n除了在当前 `Activity` 内部获得 `MainScope` 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 `Presenter` 通常也需要与 `Activity` 保持同样的生命周期，因此必要时也可以将该作用域传递过去：\n\n```kotlin\nclass CoroutinePresenter(private val scope: CoroutineScope): CoroutineScope by scope{\n    fun getUserData(){\n        launch { ... }\n    }\n}\n```\n\n多数情况下，`Presenter` 的方法也会被 `Activity` 直接调用，因此也可以将 `Presenter` 的方法生命成 `suspend` 方法，然后用 `coroutineScope` 嵌套作用域，这样 `MainScope` 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：\n\n```kotlin\nclass CoroutinePresenter {\n    suspend fun getUserData() = coroutineScope {\n        launch { ... }\n    }\n}\n```\n\n### 2.3 更友好地为 Activity 提供作用域\n\n抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 `Activity` 实现这个接口就可以拥有作用域以及自动取消的能力呢？\n\n首先我们定义一个接口：\n\n```kotlin\ninterface ScopedActivity {\n    val scope: CoroutineScope\n}\n```\n\n我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 `scope` 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：\n\n```kotlin\ninterface MainScoped {\n    companion object {\n        internal val scopeMap = IdentityHashMap<MainScoped, MainScope>()\n    }\n    val mainScope: CoroutineScope\n        get() = scopeMap[this as Activity]!!\n}\n```\n\n接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun createScope(){\n        //或者改为 lazy 实现，即用到时再创建\n        val activity = this as Activity\n        scopeMap[activity] ?: MainScope().also { scopeMap[activity] = it }\n    }\n\n    fun destroyScope(){\n        scopeMap.remove(this as Activity)?.cancel()\n    }\n}\n```\n\n因为我们需要 `Activity` 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。\n\n接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 `Application.ActivityLifecycleCallbacks` 最合适不过了：\n\n```kotlin\nclass ActivityLifecycleCallbackImpl: Application.ActivityLifecycleCallbacks {\n    ...\n    override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {\n        (activity as? MainScoped)?.createScope()\n    }\n\n    override fun onActivityDestroyed(activity: Activity) {\n        (activity as? MainScoped)?.destroyScope()\n    }\n}\n```\n\n剩下的就是在 `Application` 里面注册一下这个监听了，这个大家都会，我就不给出代码了。\n\n我们看下如何使用：\n\n```kotlin\nclass CoroutineActivity : Activity(), MainScoped {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        launchButton.setOnClickListener {            \n            scope.launch {\n                ...\n            }\n        }\n    }\n}\n```\n\n我们也可以增加一些有用的方法来简化这个操作：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun <T> withScope(block: CoroutineScope.() -> T) = with(scope, block)\n}\n```\n\n这样在 `Activity` 当中还可以这样写：\n\n```kotlin\nwithScope {\n    launch { ... }\n}   \n```\n\n> 注意，示例当中用到了 `IdentityHashMap`，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 `IdentityConcurrentHashMap`，即便如此，从设计上 `scope` 也不太应该在其他线程访问。\n\n按照这个思路，我提供了一套更加完善的方案，不仅支持 `Activity` 还支持 support-fragment 版本在 25.1.0 以上的版本的 `Fragment`，并且类似于 Anko 提供了一些有用的基于 `MainScope` 的 listener 扩展，引入这个框架即可使用：\n\n```gradle\napi 'com.bennyhuo.kotlin:coroutines-android-mainscope:1.0'\n```\n\n### 2.4 Androidx 的协程支持\n\nAndroid 官方对于协程的支持也是非常积极的。\n\nKTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：\n\n```kotlin\nimplementation \"androidx.lifecycle:lifecycle-runtime-ktx:$ktx_version\"\n```\n\n`lifecycle-runtime-ktx` 提供了 `LifecycleCoroutineScope` 类以及其获得方式，例如我们可以直接在 `MainActivity` 中使用 `lifecycleScope` 来获取这个实例：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        button.setOnClickListener {\n            lifecycleScope.launch {\n                ...// 执行协程体\n            }\n        }\n    }\n}\n```\n\n这当然是因为 `MainActivity` 的父类实现了 `LifecycleOwner` 这个接口，而 `lifecycleScope` 则正是它的扩展成员。\n\n如果想要在 `ViewModel` 当中使用作用域，我们需要再添加以下依赖：\n\n```kotlin\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$ktx_version\"\n```\n\n使用方法类似：\n\n```kotlin\nclass MainViewModel : ViewModel() {\n    fun fetchData() {\n        viewModelScope.launch {\n            ... // 执行协程体\n        }\n    }\n}\n```\n\n`ViewModel` 的作用域会在它的 `clear` 函数调用时取消。\n\n## 3. 谨慎使用 GlobalScope\n\n### 3.1 GlobalScope 存在什么问题\n\n我们之前做例子经常使用 `GlobalScope`，但 `GlobalScope` 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 `MainScope` 之后，内部再使用  `GlobalScope`  启动协程，意味着 `MainScope` 就不会起到应有的作用。\n\n这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 `onClick` 扩展：\n\n```kotlin\nfun View.onClick(\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: View) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }\n    }\n}\n```\n\n也许我们也就是图个方便，毕竟 `onClick` 写起来可比 `setOnClickListener` 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 `onClick` 启动的协程并不会随着 `Activity` 的销毁而被取消，其中的风险需要自己思考清楚。\n\n当然，Anko 会这么做的根本原因在于 `OnClickListener` 根本拿不到有生命周期加持的作用域。不用 `GlobalScope` 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun View.onClickSuspend(handler: suspend CoroutineScope.(v: View) -> Unit) {\n        setOnClickListener { v ->\n            scope.launch {   handler(v)   }\n        }\n    }\n}\n```\n\n我们在前面定义的 `MainScoped` 接口中，可以通过 `scope` 拿到有生命周期加持的 `MainScope` 实例，那么直接用它启动协程来运行 `OnClickListener` 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。\n\n这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。\n\n当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。\n\n### 3.2 协程版 AutoDisposable\n\n当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。\n\n大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。\n\n因此大家一定会用到 Uber 的开源框架 [AutoDispose](https://github.com/uber/AutoDispose)。它其实就是利用 `View` 的 `OnAttachStateChangeListener` ，当 `View` 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。\n\n```java\n  static final class Listener extends MainThreadDisposable implements View.OnAttachStateChangeListener {\n    private final View view;\n    private final CompletableObserver observer;\n\n    Listener(View view, CompletableObserver observer) {\n      this.view = view;\n      this.observer = observer;\n    }\n\n    @Override public void onViewAttachedToWindow(View v) { }\n\n    @Override public void onViewDetachedFromWindow(View v) {\n      if (!isDisposed()) {\n      //看到没看到没看到没？\n        observer.onComplete();\n      }\n    }\n\n    @Override protected void onDispose() {\n      view.removeOnAttachStateChangeListener(this);\n    }\n  }\n```\n\n考虑到前面提到的 Anko 扩展 `onClick` 无法取消协程的问题，我们也可以搞一个 `onClickAutoDisposable`。\n\n```kotlin\nfun View.onClickAutoDisposable (\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: View) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }.asAutoDisposable(v)\n    }\n}\n```\n\n我们知道 `launch` 会启动一个 `Job`，因此我们可以通过 `asAutoDisposable` 来将其转换成支持自动取消的类型：\n\n```kotlin\nfun Job.asAutoDisposable(view: View) = AutoDisposableJob(view, this)\n```\n\n那么 `AutoDisposableJob` 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：\n\n```kotlin\nclass AutoDisposableJob(private val view: View, private val wrapped: Job)\n    //我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口\n     : Job by wrapped, OnAttachStateChangeListener {\n    override fun onViewAttachedToWindow(v: View?) = Unit\n\n    override fun onViewDetachedFromWindow(v: View?) {\n        //当 View 被移除的时候，取消协程\n        cancel()\n        view.removeOnAttachStateChangeListener(this)\n    }\n\n    private fun isViewAttached() =\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && view.isAttachedToWindow || view.windowToken != null\n\n    init {\n        if(isViewAttached()) {\n            view.addOnAttachStateChangeListener(this)\n        } else {\n            cancel()\n        }\n\n        //协程执行完毕时要及时移除 listener 免得造成泄露\n        invokeOnCompletion() {\n            view.removeOnAttachStateChangeListener(this)\n        }\n    }\n}\n```\n\n这样的话，我们就可以使用这个扩展了：\n\n```kotlin\nbutton.onClickAutoDisposable{\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n当 `button` 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 `Activity` 的 `onDestroy` 而取消，但它与 `View` 的点击事件紧密结合，即便 `Activity` 没有被销毁，`View` 本身被移除时也会直接将监听中的协程取消掉。\n\n\n如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：\n\n```gradle\napi \"com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0\"\n```\n\n添加到依赖当中即可使用。\n\n\n## 4. 合理使用调度器\n\n在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。\n\n比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 `Dispatchers.Main` 来启动协程，如果涉及到一些 io 操作，使用 `async` 将其调度到 `Dispatchers.IO` 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。\n\n对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。\n\n## 5. 小结\n\n这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。\n\n\n\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-android.md","raw":"---\ntitle:  破解 Kotlin 协程(8) - Android 篇  \nkeywords: Kotlin 协程 Android Anko \ndate: 2019/05/27\ndescription: \ntags: \n    - kotlin\n    - coroutine\n    - android \n---\n\n> Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ \n\n\n\n<!-- more -->\n\n\n\n\n我们曾经提到过，如果在 Android 上做开发，那么我们需要引入\n\n```gradle\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version'\n```  \n\n这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。\n\n~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）\n\n```gradle\n//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式\nimplementation \"org.jetbrains.anko:anko-sdk27-coroutines:$anko_version\"\n//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造\nimplementation \"org.jetbrains.anko:anko-coroutines:$anko_version\"\n```\n\n简单来说：\n\n* kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器\n* ~~anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨~~\n* ~~anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。~~\n\n协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。\n\n## 2. UI 生命周期作用域\n\nAndroid 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。\n\n### 2.1 使用 MainScope\n\n协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 `MainScope` 这个函数，我们具体看下它的使用方法：\n\n```kotlin\nval mainScope = MainScope()\nlaunchButton.setOnClickListener {\n    mainScope.launch {\n        log(1)\n        textView.text = async(Dispatchers.IO) {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello1111\"\n        }.await()\n        log(4)\n    }\n}\n```\n\n我们发现它其实与其他的 `CoroutineScope` 用起来没什么不一样的地方，通过同一个叫 `mainScope` 的实例启动的协程，都会遵循它的作用域定义，那么 `MainScope` 的定义时怎样的呢？\n\n```kotlin\npublic fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)\n```\n\n原来就是 `SupervisorJob` 整合了 `Dispatchers.Main` 而已，它的异常传播是自上而下的，这一点与 `supervisorScope` 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：\n\n```\n2019-04-29 06:51:00.657 D: [main] 1\n2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2\n2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3\n2019-04-29 06:51:01.664 D: [main] 4\n```\n\n如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：\n\n```kotlin\nval mainScope = MainScope()\n\nlaunchButton.setOnClickListener {\n    mainScope.launch {\n        ...\n    }\n}\n\ncancelButton.setOnClickListener {\n    mainScope.cancel()\n    log(\"MainScope is cancelled.\")\n}\n```\n\n如果我们快速依次点击上面的两个按钮，结果就显而易见了：\n\n```\n2019-04-29 07:12:20.625 D: [main] 1\n2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2\n2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.\n```\n\n### 2.2 构造带有作用域的抽象 Activity\n\n尽管我们前面体验了 `MainScope` 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。\n\n官方推荐我们定义一个抽象的 `Activity`，例如：\n\n```kotlin\nabstract class ScopedActivity: Activity(), CoroutineScope by MainScope(){\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n}\n```\n\n这样在 `Activity` 退出的时候，对应的作用域就会被取消，所有在该 `Activity` 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：\n\n```kotlin\nclass CoroutineActivity : ScopedActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_coroutine)\n        launchButton.setOnClickListener {\n            launch { // 直接调用 ScopedActivity 也就是 MainScope 的方法\n                ...\n            }\n        }\n    }\n    \n    suspend fun anotherOps() = coroutineScope {\n        ...\n    }\n}\n```\n\n除了在当前 `Activity` 内部获得 `MainScope` 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 `Presenter` 通常也需要与 `Activity` 保持同样的生命周期，因此必要时也可以将该作用域传递过去：\n\n```kotlin\nclass CoroutinePresenter(private val scope: CoroutineScope): CoroutineScope by scope{\n    fun getUserData(){\n        launch { ... }\n    }\n}\n```\n\n多数情况下，`Presenter` 的方法也会被 `Activity` 直接调用，因此也可以将 `Presenter` 的方法生命成 `suspend` 方法，然后用 `coroutineScope` 嵌套作用域，这样 `MainScope` 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：\n\n```kotlin\nclass CoroutinePresenter {\n    suspend fun getUserData() = coroutineScope {\n        launch { ... }\n    }\n}\n```\n\n### 2.3 更友好地为 Activity 提供作用域\n\n抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 `Activity` 实现这个接口就可以拥有作用域以及自动取消的能力呢？\n\n首先我们定义一个接口：\n\n```kotlin\ninterface ScopedActivity {\n    val scope: CoroutineScope\n}\n```\n\n我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 `scope` 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：\n\n```kotlin\ninterface MainScoped {\n    companion object {\n        internal val scopeMap = IdentityHashMap<MainScoped, MainScope>()\n    }\n    val mainScope: CoroutineScope\n        get() = scopeMap[this as Activity]!!\n}\n```\n\n接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun createScope(){\n        //或者改为 lazy 实现，即用到时再创建\n        val activity = this as Activity\n        scopeMap[activity] ?: MainScope().also { scopeMap[activity] = it }\n    }\n\n    fun destroyScope(){\n        scopeMap.remove(this as Activity)?.cancel()\n    }\n}\n```\n\n因为我们需要 `Activity` 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。\n\n接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 `Application.ActivityLifecycleCallbacks` 最合适不过了：\n\n```kotlin\nclass ActivityLifecycleCallbackImpl: Application.ActivityLifecycleCallbacks {\n    ...\n    override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {\n        (activity as? MainScoped)?.createScope()\n    }\n\n    override fun onActivityDestroyed(activity: Activity) {\n        (activity as? MainScoped)?.destroyScope()\n    }\n}\n```\n\n剩下的就是在 `Application` 里面注册一下这个监听了，这个大家都会，我就不给出代码了。\n\n我们看下如何使用：\n\n```kotlin\nclass CoroutineActivity : Activity(), MainScoped {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        launchButton.setOnClickListener {            \n            scope.launch {\n                ...\n            }\n        }\n    }\n}\n```\n\n我们也可以增加一些有用的方法来简化这个操作：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun <T> withScope(block: CoroutineScope.() -> T) = with(scope, block)\n}\n```\n\n这样在 `Activity` 当中还可以这样写：\n\n```kotlin\nwithScope {\n    launch { ... }\n}   \n```\n\n> 注意，示例当中用到了 `IdentityHashMap`，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 `IdentityConcurrentHashMap`，即便如此，从设计上 `scope` 也不太应该在其他线程访问。\n\n按照这个思路，我提供了一套更加完善的方案，不仅支持 `Activity` 还支持 support-fragment 版本在 25.1.0 以上的版本的 `Fragment`，并且类似于 Anko 提供了一些有用的基于 `MainScope` 的 listener 扩展，引入这个框架即可使用：\n\n```gradle\napi 'com.bennyhuo.kotlin:coroutines-android-mainscope:1.0'\n```\n\n### 2.4 Androidx 的协程支持\n\nAndroid 官方对于协程的支持也是非常积极的。\n\nKTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：\n\n```kotlin\nimplementation \"androidx.lifecycle:lifecycle-runtime-ktx:$ktx_version\"\n```\n\n`lifecycle-runtime-ktx` 提供了 `LifecycleCoroutineScope` 类以及其获得方式，例如我们可以直接在 `MainActivity` 中使用 `lifecycleScope` 来获取这个实例：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        button.setOnClickListener {\n            lifecycleScope.launch {\n                ...// 执行协程体\n            }\n        }\n    }\n}\n```\n\n这当然是因为 `MainActivity` 的父类实现了 `LifecycleOwner` 这个接口，而 `lifecycleScope` 则正是它的扩展成员。\n\n如果想要在 `ViewModel` 当中使用作用域，我们需要再添加以下依赖：\n\n```kotlin\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$ktx_version\"\n```\n\n使用方法类似：\n\n```kotlin\nclass MainViewModel : ViewModel() {\n    fun fetchData() {\n        viewModelScope.launch {\n            ... // 执行协程体\n        }\n    }\n}\n```\n\n`ViewModel` 的作用域会在它的 `clear` 函数调用时取消。\n\n## 3. 谨慎使用 GlobalScope\n\n### 3.1 GlobalScope 存在什么问题\n\n我们之前做例子经常使用 `GlobalScope`，但 `GlobalScope` 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 `MainScope` 之后，内部再使用  `GlobalScope`  启动协程，意味着 `MainScope` 就不会起到应有的作用。\n\n这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 `onClick` 扩展：\n\n```kotlin\nfun View.onClick(\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: View) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }\n    }\n}\n```\n\n也许我们也就是图个方便，毕竟 `onClick` 写起来可比 `setOnClickListener` 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 `onClick` 启动的协程并不会随着 `Activity` 的销毁而被取消，其中的风险需要自己思考清楚。\n\n当然，Anko 会这么做的根本原因在于 `OnClickListener` 根本拿不到有生命周期加持的作用域。不用 `GlobalScope` 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：\n\n```kotlin\ninterface MainScoped {\n    ...\n    fun View.onClickSuspend(handler: suspend CoroutineScope.(v: View) -> Unit) {\n        setOnClickListener { v ->\n            scope.launch {   handler(v)   }\n        }\n    }\n}\n```\n\n我们在前面定义的 `MainScoped` 接口中，可以通过 `scope` 拿到有生命周期加持的 `MainScope` 实例，那么直接用它启动协程来运行 `OnClickListener` 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。\n\n这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。\n\n当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。\n\n### 3.2 协程版 AutoDisposable\n\n当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。\n\n大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。\n\n因此大家一定会用到 Uber 的开源框架 [AutoDispose](https://github.com/uber/AutoDispose)。它其实就是利用 `View` 的 `OnAttachStateChangeListener` ，当 `View` 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。\n\n```java\n  static final class Listener extends MainThreadDisposable implements View.OnAttachStateChangeListener {\n    private final View view;\n    private final CompletableObserver observer;\n\n    Listener(View view, CompletableObserver observer) {\n      this.view = view;\n      this.observer = observer;\n    }\n\n    @Override public void onViewAttachedToWindow(View v) { }\n\n    @Override public void onViewDetachedFromWindow(View v) {\n      if (!isDisposed()) {\n      //看到没看到没看到没？\n        observer.onComplete();\n      }\n    }\n\n    @Override protected void onDispose() {\n      view.removeOnAttachStateChangeListener(this);\n    }\n  }\n```\n\n考虑到前面提到的 Anko 扩展 `onClick` 无法取消协程的问题，我们也可以搞一个 `onClickAutoDisposable`。\n\n```kotlin\nfun View.onClickAutoDisposable (\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: View) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }.asAutoDisposable(v)\n    }\n}\n```\n\n我们知道 `launch` 会启动一个 `Job`，因此我们可以通过 `asAutoDisposable` 来将其转换成支持自动取消的类型：\n\n```kotlin\nfun Job.asAutoDisposable(view: View) = AutoDisposableJob(view, this)\n```\n\n那么 `AutoDisposableJob` 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：\n\n```kotlin\nclass AutoDisposableJob(private val view: View, private val wrapped: Job)\n    //我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口\n     : Job by wrapped, OnAttachStateChangeListener {\n    override fun onViewAttachedToWindow(v: View?) = Unit\n\n    override fun onViewDetachedFromWindow(v: View?) {\n        //当 View 被移除的时候，取消协程\n        cancel()\n        view.removeOnAttachStateChangeListener(this)\n    }\n\n    private fun isViewAttached() =\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && view.isAttachedToWindow || view.windowToken != null\n\n    init {\n        if(isViewAttached()) {\n            view.addOnAttachStateChangeListener(this)\n        } else {\n            cancel()\n        }\n\n        //协程执行完毕时要及时移除 listener 免得造成泄露\n        invokeOnCompletion() {\n            view.removeOnAttachStateChangeListener(this)\n        }\n    }\n}\n```\n\n这样的话，我们就可以使用这个扩展了：\n\n```kotlin\nbutton.onClickAutoDisposable{\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n当 `button` 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 `Activity` 的 `onDestroy` 而取消，但它与 `View` 的点击事件紧密结合，即便 `Activity` 没有被销毁，`View` 本身被移除时也会直接将监听中的协程取消掉。\n\n\n如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：\n\n```gradle\napi \"com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0\"\n```\n\n添加到依赖当中即可使用。\n\n\n## 4. 合理使用调度器\n\n在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。\n\n比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 `Dispatchers.Main` 来启动协程，如果涉及到一些 io 操作，使用 `async` 将其调度到 `Dispatchers.IO` 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。\n\n对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。\n\n## 5. 小结\n\n这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。\n\n\n\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-android","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0031000jlduzaalz74iu","content":"<blockquote>\n<p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version&#x27;</span></span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class=\"line\"></span><br><span class=\"line\">~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）</span><br><span class=\"line\"></span><br><span class=\"line\">```gradle</span><br><span class=\"line\"><span class=\"comment\">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;org.jetbrains.anko:anko-sdk27-coroutines:$anko_version&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;org.jetbrains.anko:anko-coroutines:$anko_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>简单来说：</p>\n<ul>\n<li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li>\n<li><del>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</del></li>\n<li><del>anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</del></li>\n</ul>\n<p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p>\n<h2 id=\"2-UI-生命周期作用域\"><a href=\"#2-UI-生命周期作用域\" class=\"headerlink\" title=\"2. UI 生命周期作用域\"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p>\n<h3 id=\"2-1-使用-MainScope\"><a href=\"#2-1-使用-MainScope\" class=\"headerlink\" title=\"2.1 使用 MainScope\"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">launchButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;Hello1111&quot;</span></span><br><span class=\"line\">        &#125;.await()</span><br><span class=\"line\">        log(<span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MainScope</span><span class=\"params\">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>\n\n<p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class=\"line\">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class=\"line\">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure>\n\n<p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\"></span><br><span class=\"line\">launchButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.launch &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cancelButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.cancel()</span><br><span class=\"line\">    log(<span class=\"string\">&quot;MainScope is cancelled.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class=\"line\">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class=\"line\">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-构造带有作用域的抽象-Activity\"><a href=\"#2-2-构造带有作用域的抽象-Activity\" class=\"headerlink\" title=\"2.2 构造带有作用域的抽象 Activity\"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p>\n<p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopedActivity</span>: <span class=\"type\">Activity</span></span>(), CoroutineScope <span class=\"keyword\">by</span> MainScope()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineActivity</span> : <span class=\"type\">ScopedActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_coroutine)</span><br><span class=\"line\">        launchButton.setOnClickListener &#123;</span><br><span class=\"line\">            launch &#123; <span class=\"comment\">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">anotherOps</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutinePresenter</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> scope: CoroutineScope): CoroutineScope <span class=\"keyword\">by</span> scope&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        launch &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutinePresenter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserData</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">        launch &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-更友好地为-Activity-提供作用域\"><a href=\"#2-3-更友好地为-Activity-提供作用域\" class=\"headerlink\" title=\"2.3 更友好地为 Activity 提供作用域\"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p>\n<p>首先我们定义一个接口：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScopedActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> scope: CoroutineScope</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mainScope: CoroutineScope</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = scopeMap[<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity]!!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createScope</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> activity = <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity</span><br><span class=\"line\">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroyScope</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        scopeMap.remove(<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity)?.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p>\n<p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityLifecycleCallbackImpl</span>: <span class=\"type\">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        (activity <span class=\"keyword\">as</span>? MainScoped)?.createScope()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>)</span></span> &#123;</span><br><span class=\"line\">        (activity <span class=\"keyword\">as</span>? MainScoped)?.destroyScope()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p>\n<p>我们看下如何使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineActivity</span> : <span class=\"type\">Activity</span></span>(), MainScoped &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        launchButton.setOnClickListener &#123;            </span><br><span class=\"line\">            scope.launch &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以增加一些有用的方法来简化这个操作：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withScope</span><span class=\"params\">(block: <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span> = with(scope, block)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在 <code>Activity</code> 当中还可以这样写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">withScope &#123;</span><br><span class=\"line\">    launch &#123; ... &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p>\n</blockquote>\n<p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api <span class=\"string\">&#x27;com.bennyhuo.kotlin:coroutines-android-mainscope:1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-Androidx-的协程支持\"><a href=\"#2-4-Androidx-的协程支持\" class=\"headerlink\" title=\"2.4 Androidx 的协程支持\"></a>2.4 Androidx 的协程支持</h3><p>Android 官方对于协程的支持也是非常积极的。</p>\n<p>KTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-runtime-ktx:<span class=\"variable\">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>lifecycle-runtime-ktx</code> 提供了 <code>LifecycleCoroutineScope</code> 类以及其获得方式，例如我们可以直接在 <code>MainActivity</code> 中使用 <code>lifecycleScope</code> 来获取这个实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        button.setOnClickListener &#123;</span><br><span class=\"line\">            lifecycleScope.launch &#123;</span><br><span class=\"line\">                ...<span class=\"comment\">// 执行协程体</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这当然是因为 <code>MainActivity</code> 的父类实现了 <code>LifecycleOwner</code> 这个接口，而 <code>lifecycleScope</code> 则正是它的扩展成员。</p>\n<p>如果想要在 <code>ViewModel</code> 当中使用作用域，我们需要再添加以下依赖：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:<span class=\"variable\">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用方法类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainViewModel</span> : <span class=\"type\">ViewModel</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        viewModelScope.launch &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 执行协程体</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ViewModel</code> 的作用域会在它的 <code>clear</code> 函数调用时取消。</p>\n<h2 id=\"3-谨慎使用-GlobalScope\"><a href=\"#3-谨慎使用-GlobalScope\" class=\"headerlink\" title=\"3. 谨慎使用 GlobalScope\"></a>3. 谨慎使用 GlobalScope</h2><h3 id=\"3-1-GlobalScope-存在什么问题\"><a href=\"#3-1-GlobalScope-存在什么问题\" class=\"headerlink\" title=\"3.1 GlobalScope 存在什么问题\"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用  <code>GlobalScope</code>  启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p>\n<p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClick</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p>\n<p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickSuspend</span><span class=\"params\">(handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">            scope.launch &#123;   handler(v)   &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p>\n<p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p>\n<p>当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。</p>\n<h3 id=\"3-2-协程版-AutoDisposable\"><a href=\"#3-2-协程版-AutoDisposable\" class=\"headerlink\" title=\"3.2 协程版 AutoDisposable\"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p>\n<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>\n<p>因此大家一定会用到 Uber 的开源框架 <a href=\"https://github.com/uber/AutoDispose\">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span> <span class=\"keyword\">extends</span> <span class=\"title\">MainThreadDisposable</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> View view;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompletableObserver observer;</span><br><span class=\"line\"></span><br><span class=\"line\">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.view = view;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(View v)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//看到没看到没看到没？</span></span><br><span class=\"line\">      observer.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickAutoDisposable</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;.asAutoDisposable(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Job.<span class=\"title\">asAutoDisposable</span><span class=\"params\">(view: <span class=\"type\">View</span>)</span></span> = AutoDisposableJob(view, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoDisposableJob</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> view: View, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Job)</span><br><span class=\"line\">    <span class=\"comment\">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class=\"line\">     : Job <span class=\"keyword\">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> = <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 View 被移除的时候，取消协程</span></span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isViewAttached</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isViewAttached()) &#123;</span><br><span class=\"line\">            view.addOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class=\"line\">        invokeOnCompletion() &#123;</span><br><span class=\"line\">            view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们就可以使用这个扩展了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClickAutoDisposable&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p>\n<p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api <span class=\"string\">&quot;com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>添加到依赖当中即可使用。</p>\n<h2 id=\"4-合理使用调度器\"><a href=\"#4-合理使用调度器\" class=\"headerlink\" title=\"4. 合理使用调度器\"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p>\n<p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p>\n<p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ </p>\n</blockquote>","more":"<p>我们曾经提到过，如果在 Android 上做开发，那么我们需要引入</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutine_version&#x27;</span></span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">这个框架里面包含了 Android 专属的 `Dispatcher`，我们可以通过 `Dispatchers.Main` 来拿到这个实例；也包含了 `MainScope`，用于与 Android 作用域相结合。</span><br><span class=\"line\"></span><br><span class=\"line\">~~Anko 也提供了一些比较方便的方法，例如 `onClick` 等等，如果需要，也可以引入它的依赖：~~（Anko 已经停止维护）</span><br><span class=\"line\"></span><br><span class=\"line\">```gradle</span><br><span class=\"line\"><span class=\"comment\">//提供 onClick 类似的便捷的 listener，接收 suspend Lambda 表达式</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;org.jetbrains.anko:anko-sdk27-coroutines:$anko_version&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//提供 bg 、asReference，未跟进 kotlin 1.3 的正式版协程，不过代码比较简单，如果需要可以自己改造</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;org.jetbrains.anko:anko-coroutines:$anko_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>简单来说：</p>\n<ul>\n<li>kotlinx-coroutines-android 这个框架是必选项，主要提供了专属调度器</li>\n<li><del>anko-sdk27-coroutines 是可选项，提供了一些 UI 组件更为简洁的扩展，例如 onClick，但它也有自己的问题，我们后面详细探讨</del></li>\n<li><del>anko-coroutines 仅供参考，未跟进 1.3 正式版协程，因此在 1.3 之后的版本中尽量不要使用，提供的两个方法都比较简单，如果需要，可自行改造使用。</del></li>\n</ul>\n<p>协程的原理和用法我们已经探讨了很多了，关于 Android 上面的协程使用，我们就只给出几点实践的建议。</p>\n<h2 id=\"2-UI-生命周期作用域\"><a href=\"#2-UI-生命周期作用域\" class=\"headerlink\" title=\"2. UI 生命周期作用域\"></a>2. UI 生命周期作用域</h2><p>Android 开发经常想到的一点就是让发出去的请求能够在当前 UI 或者 Activity 退出或者销毁的时候能够自动取消，我们在用 RxJava 的时候也有过各种各样的方案来解决这个问题。</p>\n<h3 id=\"2-1-使用-MainScope\"><a href=\"#2-1-使用-MainScope\" class=\"headerlink\" title=\"2.1 使用 MainScope\"></a>2.1 使用 MainScope</h3><p>协程有一个很天然的特性能刚够支持这一点，那就是作用域。官方也提供了 <code>MainScope</code> 这个函数，我们具体看下它的使用方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">launchButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        textView.text = async(Dispatchers.IO) &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;Hello1111&quot;</span></span><br><span class=\"line\">        &#125;.await()</span><br><span class=\"line\">        log(<span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现它其实与其他的 <code>CoroutineScope</code> 用起来没什么不一样的地方，通过同一个叫 <code>mainScope</code> 的实例启动的协程，都会遵循它的作用域定义，那么 <code>MainScope</code> 的定义时怎样的呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">MainScope</span><span class=\"params\">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>\n\n<p>原来就是 <code>SupervisorJob</code> 整合了 <code>Dispatchers.Main</code> 而已，它的异常传播是自上而下的，这一点与 <code>supervisorScope</code> 的行为一致，此外，作用域内的调度是基于 Android 主线程的调度器的，因此作用域内除非明确声明调度器，协程体都调度在主线程执行。因此上述示例的运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-04-29 06:51:00.657 D: [main] 1</span><br><span class=\"line\">2019-04-29 06:51:00.659 D: [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">2019-04-29 06:51:01.662 D: [DefaultDispatcher-worker-2] 3</span><br><span class=\"line\">2019-04-29 06:51:01.664 D: [main] 4</span><br></pre></td></tr></table></figure>\n\n<p>如果我们在触发前面的操作之后立即在其他位置触发作用域的取消，那么该作用域内的协程将不再继续执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\"></span><br><span class=\"line\">launchButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.launch &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">cancelButton.setOnClickListener &#123;</span><br><span class=\"line\">    mainScope.cancel()</span><br><span class=\"line\">    log(<span class=\"string\">&quot;MainScope is cancelled.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们快速依次点击上面的两个按钮，结果就显而易见了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-04-29 07:12:20.625 D: [main] 1</span><br><span class=\"line\">2019-04-29 07:12:20.629 D: [DefaultDispatcher-worker-2] 2</span><br><span class=\"line\">2019-04-29 07:12:21.046 D: [main] MainScope is cancelled.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-构造带有作用域的抽象-Activity\"><a href=\"#2-2-构造带有作用域的抽象-Activity\" class=\"headerlink\" title=\"2.2 构造带有作用域的抽象 Activity\"></a>2.2 构造带有作用域的抽象 Activity</h3><p>尽管我们前面体验了 <code>MainScope</code> 发现它可以很方便的控制所有它范围内的协程的取消，以及能够无缝将异步任务切回主线程，这都是我们想要的特性，不过写法上还是不够美观。</p>\n<p>官方推荐我们定义一个抽象的 <code>Activity</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopedActivity</span>: <span class=\"type\">Activity</span></span>(), CoroutineScope <span class=\"keyword\">by</span> MainScope()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy()</span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在 <code>Activity</code> 退出的时候，对应的作用域就会被取消，所有在该 <code>Activity</code> 中发起的请求都会被取消掉。使用时，只需要继承这个抽象类即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineActivity</span> : <span class=\"type\">ScopedActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_coroutine)</span><br><span class=\"line\">        launchButton.setOnClickListener &#123;</span><br><span class=\"line\">            launch &#123; <span class=\"comment\">// 直接调用 ScopedActivity 也就是 MainScope 的方法</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">anotherOps</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了在当前 <code>Activity</code> 内部获得 <code>MainScope</code> 的能力外，还可以将这个 Scope 实例传递给其他需要的模块，例如 <code>Presenter</code> 通常也需要与 <code>Activity</code> 保持同样的生命周期，因此必要时也可以将该作用域传递过去：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutinePresenter</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> scope: CoroutineScope): CoroutineScope <span class=\"keyword\">by</span> scope&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        launch &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多数情况下，<code>Presenter</code> 的方法也会被 <code>Activity</code> 直接调用，因此也可以将 <code>Presenter</code> 的方法生命成 <code>suspend</code> 方法，然后用 <code>coroutineScope</code> 嵌套作用域，这样 <code>MainScope</code> 被取消后，嵌套的子作用域一样也会被取消，进而达到取消全部子协程的目的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutinePresenter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserData</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">        launch &#123; ... &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-更友好地为-Activity-提供作用域\"><a href=\"#2-3-更友好地为-Activity-提供作用域\" class=\"headerlink\" title=\"2.3 更友好地为 Activity 提供作用域\"></a>2.3 更友好地为 Activity 提供作用域</h3><p>抽象类很多时候会打破我们的继承体系，这对于开发体验的伤害还是很大的，因此我们是不是可以考虑构造一个接口，只要 <code>Activity</code> 实现这个接口就可以拥有作用域以及自动取消的能力呢？</p>\n<p>首先我们定义一个接口：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ScopedActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> scope: CoroutineScope</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们有一个朴实的愿望就是希望实现这个接口就可以自动获得作用域，不过问题来了，这个 <code>scope</code> 成员要怎么实现呢？留给接口实现方的话显然不是很理想，自己实现吧，又碍于自己是个接口，因此我们只能这样处理：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> scopeMap = IdentityHashMap&lt;MainScoped, MainScope&gt;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> mainScope: CoroutineScope</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = scopeMap[<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity]!!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来的事情就是在合适的实际去创建和取消对应的作用域了，我们接着定义两个方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createScope</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//或者改为 lazy 实现，即用到时再创建</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> activity = <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity</span><br><span class=\"line\">        scopeMap[activity] ?: MainScope().also &#123; scopeMap[activity] = it &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroyScope</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        scopeMap.remove(<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Activity)?.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们需要 <code>Activity</code> 去实现这个接口，因此直接强转即可，当然如果考虑健壮性，可以做一些异常处理，这里作为示例仅提供核心实现。</p>\n<p>接下来就是考虑在哪儿完成创建和取消呢？显然这件事儿用 <code>Application.ActivityLifecycleCallbacks</code> 最合适不过了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityLifecycleCallbackImpl</span>: <span class=\"type\">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        (activity <span class=\"keyword\">as</span>? MainScoped)?.createScope()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>)</span></span> &#123;</span><br><span class=\"line\">        (activity <span class=\"keyword\">as</span>? MainScoped)?.destroyScope()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>剩下的就是在 <code>Application</code> 里面注册一下这个监听了，这个大家都会，我就不给出代码了。</p>\n<p>我们看下如何使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineActivity</span> : <span class=\"type\">Activity</span></span>(), MainScoped &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        launchButton.setOnClickListener &#123;            </span><br><span class=\"line\">            scope.launch &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以增加一些有用的方法来简化这个操作：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withScope</span><span class=\"params\">(block: <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span> = with(scope, block)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在 <code>Activity</code> 当中还可以这样写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">withScope &#123;</span><br><span class=\"line\">    launch &#123; ... &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，示例当中用到了 <code>IdentityHashMap</code>，这表明对于 scope 的读写是非线程安全的，因此不要在其他线程试图去获取它的值，除非你引入第三方或者自己实现一个 <code>IdentityConcurrentHashMap</code>，即便如此，从设计上 <code>scope</code> 也不太应该在其他线程访问。</p>\n</blockquote>\n<p>按照这个思路，我提供了一套更加完善的方案，不仅支持 <code>Activity</code> 还支持 support-fragment 版本在 25.1.0 以上的版本的 <code>Fragment</code>，并且类似于 Anko 提供了一些有用的基于 <code>MainScope</code> 的 listener 扩展，引入这个框架即可使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api <span class=\"string\">&#x27;com.bennyhuo.kotlin:coroutines-android-mainscope:1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-Androidx-的协程支持\"><a href=\"#2-4-Androidx-的协程支持\" class=\"headerlink\" title=\"2.4 Androidx 的协程支持\"></a>2.4 Androidx 的协程支持</h3><p>Android 官方对于协程的支持也是非常积极的。</p>\n<p>KTX 为 Jetpack 的 Lifecycle 相关的组件都提供了已经绑定了生命周期的作用域供我们直接使用，添加 Lifecycle 相应的基础组件之后，再添加以下组件即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-runtime-ktx:<span class=\"variable\">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>lifecycle-runtime-ktx</code> 提供了 <code>LifecycleCoroutineScope</code> 类以及其获得方式，例如我们可以直接在 <code>MainActivity</code> 中使用 <code>lifecycleScope</code> 来获取这个实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        button.setOnClickListener &#123;</span><br><span class=\"line\">            lifecycleScope.launch &#123;</span><br><span class=\"line\">                ...<span class=\"comment\">// 执行协程体</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这当然是因为 <code>MainActivity</code> 的父类实现了 <code>LifecycleOwner</code> 这个接口，而 <code>lifecycleScope</code> 则正是它的扩展成员。</p>\n<p>如果想要在 <code>ViewModel</code> 当中使用作用域，我们需要再添加以下依赖：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:<span class=\"variable\">$ktx_version</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用方法类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainViewModel</span> : <span class=\"type\">ViewModel</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        viewModelScope.launch &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 执行协程体</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ViewModel</code> 的作用域会在它的 <code>clear</code> 函数调用时取消。</p>\n<h2 id=\"3-谨慎使用-GlobalScope\"><a href=\"#3-谨慎使用-GlobalScope\" class=\"headerlink\" title=\"3. 谨慎使用 GlobalScope\"></a>3. 谨慎使用 GlobalScope</h2><h3 id=\"3-1-GlobalScope-存在什么问题\"><a href=\"#3-1-GlobalScope-存在什么问题\" class=\"headerlink\" title=\"3.1 GlobalScope 存在什么问题\"></a>3.1 GlobalScope 存在什么问题</h3><p>我们之前做例子经常使用 <code>GlobalScope</code>，但 <code>GlobalScope</code> 不会继承外部作用域，因此大家使用时一定要注意，如果在使用了绑定生命周期的 <code>MainScope</code> 之后，内部再使用  <code>GlobalScope</code>  启动协程，意味着 <code>MainScope</code> 就不会起到应有的作用。</p>\n<p>这里需要小心的是如果使用了一些没有依赖作用域的构造器，那么一定要小心。例如 Anko 当中的 <code>onClick</code> 扩展：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClick</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也许我们也就是图个方便，毕竟 <code>onClick</code> 写起来可比 <code>setOnClickListener</code> 要少很多字符，同时名称上看也更加有事件机制的味道，但隐藏的风险就是通过 <code>onClick</code> 启动的协程并不会随着 <code>Activity</code> 的销毁而被取消，其中的风险需要自己思考清楚。</p>\n<p>当然，Anko 会这么做的根本原因在于 <code>OnClickListener</code> 根本拿不到有生命周期加持的作用域。不用 <code>GlobalScope</code> 就无法启动协程，怎么办？结合我们前面给出的例子，其实这个事儿完全有别的解法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainScoped</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickSuspend</span><span class=\"params\">(handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">            scope.launch &#123;   handler(v)   &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在前面定义的 <code>MainScoped</code> 接口中，可以通过 <code>scope</code> 拿到有生命周期加持的 <code>MainScope</code> 实例，那么直接用它启动协程来运行 <code>OnClickListener</code> 问题不就解决了嘛。所以这里的关键点在于如何拿到作用域。</p>\n<p>这样的 listener 我已经为大家在框架中定义好啦，请参见 2.3。</p>\n<p>当然，如果项目已经集成了 AndroidX，还是更加推荐大家直接使用官方的作用域扩展。另外需要注意的是，Anko 已经停止维护，不再建议使用了。</p>\n<h3 id=\"3-2-协程版-AutoDisposable\"><a href=\"#3-2-协程版-AutoDisposable\" class=\"headerlink\" title=\"3.2 协程版 AutoDisposable\"></a>3.2 协程版 AutoDisposable</h3><p>当然除了直接使用一个合适的作用域来启动协程之外，我们还有别的办法来确保协程及时被取消。</p>\n<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>\n<p>因此大家一定会用到 Uber 的开源框架 <a href=\"https://github.com/uber/AutoDispose\">AutoDispose</a>。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span> <span class=\"keyword\">extends</span> <span class=\"title\">MainThreadDisposable</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> View view;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompletableObserver observer;</span><br><span class=\"line\"></span><br><span class=\"line\">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.view = view;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(View v)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//看到没看到没看到没？</span></span><br><span class=\"line\">      observer.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>考虑到前面提到的 Anko 扩展 <code>onClick</code> 无法取消协程的问题，我们也可以搞一个 <code>onClickAutoDisposable</code>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickAutoDisposable</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">View</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;.asAutoDisposable(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道 <code>launch</code> 会启动一个 <code>Job</code>，因此我们可以通过 <code>asAutoDisposable</code> 来将其转换成支持自动取消的类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Job.<span class=\"title\">asAutoDisposable</span><span class=\"params\">(view: <span class=\"type\">View</span>)</span></span> = AutoDisposableJob(view, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么 <code>AutoDisposableJob</code> 的实现只要参考 AutoDisposable 的实现依样画葫芦就好了 ：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoDisposableJob</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> view: View, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Job)</span><br><span class=\"line\">    <span class=\"comment\">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class=\"line\">     : Job <span class=\"keyword\">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> = <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 View 被移除的时候，取消协程</span></span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isViewAttached</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isViewAttached()) &#123;</span><br><span class=\"line\">            view.addOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class=\"line\">        invokeOnCompletion() &#123;</span><br><span class=\"line\">            view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们就可以使用这个扩展了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClickAutoDisposable&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令，尽管这种情况下协程的执行不会跟随 <code>Activity</code> 的 <code>onDestroy</code> 而取消，但它与 <code>View</code> 的点击事件紧密结合，即便 <code>Activity</code> 没有被销毁，<code>View</code> 本身被移除时也会直接将监听中的协程取消掉。</p>\n<p>如果大家想要用这个扩展，我已经帮大家放到 jcenter 啦，直接使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">api <span class=\"string\">&quot;com.bennyhuo.kotlin:coroutines-android-autodisposable:1.0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>添加到依赖当中即可使用。</p>\n<h2 id=\"4-合理使用调度器\"><a href=\"#4-合理使用调度器\" class=\"headerlink\" title=\"4. 合理使用调度器\"></a>4. 合理使用调度器</h2><p>在 Android 上使用协程，更多的就是简化异步逻辑的写法，使用场景更多与 RxJava 类似。在使用 RxJava 的时候，我就发现有不少开发者仅仅用到了它的切线程的功能，而且由于本身 RxJava 切线程 API 简单易用，还会造成很多无脑线程切换的操作，这样实际上是不好的。那么使用协程就更要注意这个问题了，因为协程切换线程的方式被 RxJava 更简洁，更透明，本来这是好事情，就怕被滥用。</p>\n<p>比较推荐的写法是，绝大多数 UI 逻辑在 UI 线程中处理，即使在 UI 中用 <code>Dispatchers.Main</code> 来启动协程，如果涉及到一些 io 操作，使用 <code>async</code> 将其调度到 <code>Dispatchers.IO</code> 上，结果返回时协程会帮我们切回到主线程——这非常类似 Nodejs 这样的单线程的工作模式。</p>\n<p>对于一些 UI 不相关的逻辑，例如批量离线数据下载任务，通常默认的调度器就足够使用了。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>这一篇文章，主要是基于我们前面讲了的理论知识，进一步往 Android 的具体实战角度迁移，相比其他类型的应用，Android 作为 UI 程序最大的特点就是异步要协调好 UI 的生命周期，协程也不例外。一旦我们把协程的作用域规则以及协程与 UI 生命周期的关系熟稔于心，那么相信大家使用协程时一定会得心应手的。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"破解 Kotlin 协程(8) - Android 篇","path":"2019/05/27/coroutine-android/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>Android 上面使用协程来替代回调或者 RxJava 实际上是一件非常轻松的事儿，我们甚至可以在更大的范围内结合 UI 的生命周期做控制协程的执行状态~ </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2019-05-26T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2019-05-26T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","coroutine","android"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"破解 Kotlin 协程(5) - 协程取消篇","keywords":"Kotlin 协程 协程取消 任务停止","date":"2019-04-29T16:00:00.000Z","description":null,"_content":"\n> 协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。 \n\n<!-- more -->\n\n\n\n\n## 1. 线程的中断\n\n我们先从大家熟悉的话题讲起。线程有一个被废弃的 `stop` 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 `stop` 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，`stop` 还不让用，那该怎么办？\n\n```kotlin\nval thread = thread {\n    ...\n}\nthread.stop() // !!! Deprecated!!!\n```\n\n我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。\n\n```kotlin\nval thread = thread {\n    try {\n        Thread.sleep(10000)\n    } catch (e: InterruptedException) {\n        log(\"Interrupted, do cleaning stuff.\")\n    }\n}\nthread.interrupt()\n```\n\n像 `sleep` 这样的方法调用，文档明确指出它支持 `InterruptedException`，因此当线程被标记为中断状态时，它就会抛出 `InterruptedException` ，那么我们自然就可以捕获异常并做资源清理了。\n\n所以请注意所谓的协作式的任务终止，协程的取消也就是 `cancel` 机制的思路也是如此。\n\n## 2. 协程类似的例子\n\n我们来看一个协程取消的例子：\n\n```kotlin\nfun main() = runBlocking {\n    val job1 = launch { // ①\n        log(1)\n        delay(1000) // ②\n        log(2)\n    }\n    delay(100)\n    log(3)\n    job1.cancel() // ③\n    log(4)\n}\n```\n\n这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 `runBlocking` 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。`runBlocking` 会启动一个 `Job`，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。\n\n这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 `delay`， `delay` 与线程的 `sleep` 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 `delay` 还没有回调的时候协程就被取消了，因为 `delay` 可以响应取消，因此 `delay` 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 `delay` 会抛一个 `CancellationException`：\n\n```kotlin\n...\nlog(1)\ntry {\n    delay(1000)\n} catch (e: Exception) {\n    log(\"cancelled. $e\")\n}\nlog(2)\n...\n```\n\n那么输出的结果就不一样了：\n\n```\n06:54:56:361 [main] 1\n06:54:56:408 [main] 3\n06:54:56:411 [main] 4\n06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine{Cancelling}@e73f9ac\n06:54:56:413 [main] 2\n```\n\n大家看，这与线程的中断逻辑是不是非常的类似呢？\n\n## 3. 完善我们之前的例子\n\n之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> { continuation ->\n    getUser(object : Callback<User> {\n        override fun onSuccess(value: User) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n```\n\n加取消逻辑，那需要我们的 `getUser` 回调版本支持取消，我们看下我们的 `getUser` 是怎么实现的：\n\n```kotlin\nfun getUser(callback: Callback<User>) {\n    val call = OkHttpClient().newCall(\n            Request.Builder()\n                    .get().url(\"https://api.github.com/users/bennyhuo\")\n                    .build())\n\n    call.enqueue(object : okhttp3.Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            callback.onError(e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            response.body()?.let {\n                try {\n                    callback.onSuccess(User.from(it.string()))\n                } catch (e: Exception) {\n                    callback.onError(e) // 这里可能是解析异常\n                }\n            }?: callback.onError(NullPointerException(\"ResponseBody is null.\"))\n        }\n    })\n}\n```\n\n我们发了个网络请求给 Github，让它把一个叫 `bennyhuo` 的用户信息返回来，我们知道 OkHttp 的这个 `Call` 是支持 `cancel` 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 `getUser` 好了，这样还能省掉我们自己的 `Callback` 回调过程：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation ->\n    val call = OkHttpClient().newCall(...)\n\n    continuation.invokeOnCancellation { // ①\n        log(\"invokeOnCancellation: cancel the request.\")\n        call.cancel()\n    }\n\n    call.enqueue(object : okhttp3.Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            log(\"onFailure: $e\")\n            continuation.resumeWithException(e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            log(\"onResponse: ${response.code()}\")\n            response.body()?.let {\n                try {\n                    continuation.resume(User.from(it.string()))\n                } catch (e: Exception) {\n                    continuation.resumeWithException(e)\n                }\n            } ?: continuation.resumeWithException(NullPointerException(\"ResponseBody is null.\"))\n        }\n    })\n}\n```\n\n我们这里用到了 `suspendCancellableCoroutine`，而不是之前的 `suspendCoroutine`，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 `Continuation` 包装成了一个 `CancellableContinuation`，通过调用它的 `invokeOnCancellation` 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 `getUserCoroutine` 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。\n\n那么我们在调用它的时候，如果遇到了取消，会怎么样呢？\n\n```kotlin\nval job1 = launch { //①\n    log(1)\n    val user = getUserCoroutine()\n    log(user)\n    log(2)\n}\ndelay(10)\nlog(3)\njob1.cancel()\nlog(4)\n```\n\n注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 `getUserCoroutine` 被挂起了，因此结果大概率是：\n\n```kotlin\n07:31:30:751 [main] 1\n07:31:31:120 [main] 3\n07:31:31:124 [main] invokeOnCancellation: cancel the request.\n07:31:31:129 [main] 4\n07:31:31:131 [OkHttp https://api.github.com/...] onFailure: java.io.IOException: Canceled\n```\n\n我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 `Continuation.resume` 、 `Continuation.resumeWithException` 或者 `Continuation.resumeWith` 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 `continuation.resumeWithException(e)` 不会有任何副作用。\n\n## 4. 再谈 Retrofit 的协程扩展\n\n### 4.1 Jake Wharton 的 Adapter 存在的问题\n\n我在[破解 Kotlin 协程 - 入门篇](https://www.bennyhuo.com/2019/04/01/basic-coroutines/) 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，\n\n```gradle\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUserCoroutine(@Path(\"login\") login: String): Deferred<User>\n}\n```\n定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .addCallAdapterFactory(CoroutineCallAdapterFactory()) // 这里添加 Adapter\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n用的时候就这样：\n\n```kotlin\nval deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\ntry {\n    showUser(deferred.await())\n} catch (e: Exception) {\n    showError(e)\n}\n```\n\n如果要取消，我们可以直接调用 `deferred.cancel()`，例如：\n\n```kotlin\nlog(\"1\")\nval deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\nlog(\"2\")\nwithContext(Dispatchers.IO){\n    deferred.cancel()\n}\ntry {\n    showUser(deferred.await())\n} catch (e: Exception) {\n    showError(e)\n}\n```\n\n运行结果如下：\n\n```\n12:59:54:185 [DefaultDispatcher-worker-1] 1\n12:59:54:587 [DefaultDispatcher-worker-1] 2\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=CompletableDeferredImpl{Cancelled}@36699211\n```\n\n这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：\n\n```kotlin\n...\noverride fun adapt(call: Call<T>): Deferred<T> {\n      val deferred = CompletableDeferred<T>()\n\n      deferred.invokeOnCompletion { // ①\n        if (deferred.isCancelled) {\n          call.cancel()\n        }\n      }\n\n      call.enqueue(object : Callback<T> {\n        ...\n      }     \n}\n...\n```\n\n注意 ① 处，`invokeOnCompletion` 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 `Call` 的取消即可。\n\n这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：\n\n```kotlin\nval job = GlobalScope.launch {\n    log(\"1\")\n    val deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\n    log(\"2\")\n    deferred.invokeOnCompletion {\n        log(\"invokeOnCompletion, $it, ${deferred.isCancelled}\")\n    }\n    try {\n        showUser(deferred.await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n    log(3)\n}\ndelay(10)\njob.cancelAndJoin()\n```\n\n我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 `getUserCoroutine` 返回的 `Deferred` 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：\n\n```kotlin\n13:06:54:332 [DefaultDispatcher-worker-1] 1\n13:06:54:829 [DefaultDispatcher-worker-1] 2\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine{Cancelling}@19aea38c\n13:06:54:846 [DefaultDispatcher-worker-1] 3\n13:06:56:937 [OkHttp https://api.github.com/...] invokeOnCompletion, null, false\n```\n\n我们看到在调用 `deferred.await()` 的时候抛了个取消异常，这主要是因为 `await()` 所在的协程已经被我们用 `cancelAndJoin()` 取消，但从随后  `invokeOnCompletion` 的回调结果来看， `getUserCoroutine` 返回的 `Deferred`  并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。\n\n所以问题究竟在哪里？在 `CoroutineCallAdapterFactory` 的实现中，为了实现异步转换，手动创建了一个 `CompletableDeferred`：\n\n```kotlin\noverride fun adapt(call: Call<T>): Deferred<T> {\n  val deferred = CompletableDeferred<T>() // ①\n  ...\n}\n```\n\n这个 `CompletableDeferred` 本身就是一个 `Job` 的实现，它的构造可接受一个 `Job` 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 `GlobalScope.launch` 启动了一个协程一样。如果大家在 Android 当中使用 `MainScope`，那么同样因为前面说到的这个原因，导致 `CompletableDeferred` 没有办法被取消。\n\n> @阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。\n\n说到这里我们再简单回顾下，作用域主要有 `GlobalScope`、`coroutineScope`、`supervisorScope`，对于取消，除了 `supervisorScope` 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 `MainScope` 就是一个调度到 UI 线程的 `supervisorScope`；`coroutineScope` 的逻辑则是父子相互取消的逻辑；而 `GlobalScope` 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。\n\n那么有没有办法解决这个问题呢？\n\n直接解决还是比较困难的，因为 `CompletableDeferred` 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。\n\n### 4.2 如何正确的将回调转换为协程\n\n前面我们提到既然 `adapt` 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？\n\n其实我们前面在讲 `getUserCoroutine` 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation ->\n    ...\n}\n```\n\n`suspendCancellableCoroutine` 跟最初我们提到的 `suspendCoroutine` 一样，都是要获取当前协程的 `Continuation` 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：\n\n```kotlin\npublic suspend fun <T : Any> Call<T>.await(): T {\n    return suspendCancellableCoroutine { continuation ->\n        enqueue(object : Callback<T> {\n            override fun onResponse(call: Call<T>?, response: Response<T?>) {\n                continuation.resumeWith(runCatching { // ①\n                    if (response.isSuccessful) {\n                        response.body()\n                            ?: throw NullPointerException(\"Response body is null: $response\")\n                    } else {\n                        throw HttpException(response)\n                    }\n                })\n            }\n\n            override fun onFailure(call: Call<T>, t: Throwable) {\n                if (continuation.isCancelled) return // ②\n                continuation.resumeWithException(t)\n            }\n        })\n\n        continuation.invokeOnCancellation {\n            try {\n                cancel()\n            } catch (ex: Throwable) {  // ③\n                //Ignore cancel exception \n            }\n        }\n    }\n}\n```\n\n大家看着这段代码会不会很眼熟？这与我们 `getUserCoroutine` 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：\n\n* ① 处 `runCatching` 可以将一段代码的运行结果或者抛出的异常封装到一个 `Result` 类型当中，Kotlin 1.3 开始新增了 `Continuation.resumeWith(Result)` 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。\n* ② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 `Continuation` 的取消发起的，因此这时候没必要再调用 `continuation.resumeWithException(t)` 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用  `continuation.resumeWithException(t)`  也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。\n* ③ 处，尽管 `Call.cancel` 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 `cancel` 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。\n\n需要指出的是，这段代码片段源自 [gildor/kotlin-coroutines-retrofit](https://github.com/gildor/kotlin-coroutines-retrofit) ，大家也可以直接添加依赖进行使用：\n\n```gradle\ncompile 'ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0'\n```\n\n这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。\n\n## 5. 小结\n\n这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。\n\n再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。\n\n当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-cancellation.md","raw":"---\ntitle:  破解 Kotlin 协程(5) - 协程取消篇  \nkeywords: Kotlin 协程 协程取消 任务停止 \ndate: 2019/04/30\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。 \n\n<!-- more -->\n\n\n\n\n## 1. 线程的中断\n\n我们先从大家熟悉的话题讲起。线程有一个被废弃的 `stop` 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 `stop` 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，`stop` 还不让用，那该怎么办？\n\n```kotlin\nval thread = thread {\n    ...\n}\nthread.stop() // !!! Deprecated!!!\n```\n\n我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。\n\n```kotlin\nval thread = thread {\n    try {\n        Thread.sleep(10000)\n    } catch (e: InterruptedException) {\n        log(\"Interrupted, do cleaning stuff.\")\n    }\n}\nthread.interrupt()\n```\n\n像 `sleep` 这样的方法调用，文档明确指出它支持 `InterruptedException`，因此当线程被标记为中断状态时，它就会抛出 `InterruptedException` ，那么我们自然就可以捕获异常并做资源清理了。\n\n所以请注意所谓的协作式的任务终止，协程的取消也就是 `cancel` 机制的思路也是如此。\n\n## 2. 协程类似的例子\n\n我们来看一个协程取消的例子：\n\n```kotlin\nfun main() = runBlocking {\n    val job1 = launch { // ①\n        log(1)\n        delay(1000) // ②\n        log(2)\n    }\n    delay(100)\n    log(3)\n    job1.cancel() // ③\n    log(4)\n}\n```\n\n这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 `runBlocking` 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。`runBlocking` 会启动一个 `Job`，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。\n\n这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 `delay`， `delay` 与线程的 `sleep` 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 `delay` 还没有回调的时候协程就被取消了，因为 `delay` 可以响应取消，因此 `delay` 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 `delay` 会抛一个 `CancellationException`：\n\n```kotlin\n...\nlog(1)\ntry {\n    delay(1000)\n} catch (e: Exception) {\n    log(\"cancelled. $e\")\n}\nlog(2)\n...\n```\n\n那么输出的结果就不一样了：\n\n```\n06:54:56:361 [main] 1\n06:54:56:408 [main] 3\n06:54:56:411 [main] 4\n06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine{Cancelling}@e73f9ac\n06:54:56:413 [main] 2\n```\n\n大家看，这与线程的中断逻辑是不是非常的类似呢？\n\n## 3. 完善我们之前的例子\n\n之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> { continuation ->\n    getUser(object : Callback<User> {\n        override fun onSuccess(value: User) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n```\n\n加取消逻辑，那需要我们的 `getUser` 回调版本支持取消，我们看下我们的 `getUser` 是怎么实现的：\n\n```kotlin\nfun getUser(callback: Callback<User>) {\n    val call = OkHttpClient().newCall(\n            Request.Builder()\n                    .get().url(\"https://api.github.com/users/bennyhuo\")\n                    .build())\n\n    call.enqueue(object : okhttp3.Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            callback.onError(e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            response.body()?.let {\n                try {\n                    callback.onSuccess(User.from(it.string()))\n                } catch (e: Exception) {\n                    callback.onError(e) // 这里可能是解析异常\n                }\n            }?: callback.onError(NullPointerException(\"ResponseBody is null.\"))\n        }\n    })\n}\n```\n\n我们发了个网络请求给 Github，让它把一个叫 `bennyhuo` 的用户信息返回来，我们知道 OkHttp 的这个 `Call` 是支持 `cancel` 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 `getUser` 好了，这样还能省掉我们自己的 `Callback` 回调过程：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation ->\n    val call = OkHttpClient().newCall(...)\n\n    continuation.invokeOnCancellation { // ①\n        log(\"invokeOnCancellation: cancel the request.\")\n        call.cancel()\n    }\n\n    call.enqueue(object : okhttp3.Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            log(\"onFailure: $e\")\n            continuation.resumeWithException(e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            log(\"onResponse: ${response.code()}\")\n            response.body()?.let {\n                try {\n                    continuation.resume(User.from(it.string()))\n                } catch (e: Exception) {\n                    continuation.resumeWithException(e)\n                }\n            } ?: continuation.resumeWithException(NullPointerException(\"ResponseBody is null.\"))\n        }\n    })\n}\n```\n\n我们这里用到了 `suspendCancellableCoroutine`，而不是之前的 `suspendCoroutine`，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 `Continuation` 包装成了一个 `CancellableContinuation`，通过调用它的 `invokeOnCancellation` 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 `getUserCoroutine` 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。\n\n那么我们在调用它的时候，如果遇到了取消，会怎么样呢？\n\n```kotlin\nval job1 = launch { //①\n    log(1)\n    val user = getUserCoroutine()\n    log(user)\n    log(2)\n}\ndelay(10)\nlog(3)\njob1.cancel()\nlog(4)\n```\n\n注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 `getUserCoroutine` 被挂起了，因此结果大概率是：\n\n```kotlin\n07:31:30:751 [main] 1\n07:31:31:120 [main] 3\n07:31:31:124 [main] invokeOnCancellation: cancel the request.\n07:31:31:129 [main] 4\n07:31:31:131 [OkHttp https://api.github.com/...] onFailure: java.io.IOException: Canceled\n```\n\n我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 `Continuation.resume` 、 `Continuation.resumeWithException` 或者 `Continuation.resumeWith` 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 `continuation.resumeWithException(e)` 不会有任何副作用。\n\n## 4. 再谈 Retrofit 的协程扩展\n\n### 4.1 Jake Wharton 的 Adapter 存在的问题\n\n我在[破解 Kotlin 协程 - 入门篇](https://www.bennyhuo.com/2019/04/01/basic-coroutines/) 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，\n\n```gradle\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUserCoroutine(@Path(\"login\") login: String): Deferred<User>\n}\n```\n定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：\n\n```kotlin\nval gitHubServiceApi by lazy {\n    val retrofit = retrofit2.Retrofit.Builder()\n            .baseUrl(\"https://api.github.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .addCallAdapterFactory(CoroutineCallAdapterFactory()) // 这里添加 Adapter\n            .build()\n\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n用的时候就这样：\n\n```kotlin\nval deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\ntry {\n    showUser(deferred.await())\n} catch (e: Exception) {\n    showError(e)\n}\n```\n\n如果要取消，我们可以直接调用 `deferred.cancel()`，例如：\n\n```kotlin\nlog(\"1\")\nval deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\nlog(\"2\")\nwithContext(Dispatchers.IO){\n    deferred.cancel()\n}\ntry {\n    showUser(deferred.await())\n} catch (e: Exception) {\n    showError(e)\n}\n```\n\n运行结果如下：\n\n```\n12:59:54:185 [DefaultDispatcher-worker-1] 1\n12:59:54:587 [DefaultDispatcher-worker-1] 2\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=CompletableDeferredImpl{Cancelled}@36699211\n```\n\n这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：\n\n```kotlin\n...\noverride fun adapt(call: Call<T>): Deferred<T> {\n      val deferred = CompletableDeferred<T>()\n\n      deferred.invokeOnCompletion { // ①\n        if (deferred.isCancelled) {\n          call.cancel()\n        }\n      }\n\n      call.enqueue(object : Callback<T> {\n        ...\n      }     \n}\n...\n```\n\n注意 ① 处，`invokeOnCompletion` 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 `Call` 的取消即可。\n\n这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：\n\n```kotlin\nval job = GlobalScope.launch {\n    log(\"1\")\n    val deferred = gitHubServiceApi.getUserCoroutine(\"bennyhuo\")\n    log(\"2\")\n    deferred.invokeOnCompletion {\n        log(\"invokeOnCompletion, $it, ${deferred.isCancelled}\")\n    }\n    try {\n        showUser(deferred.await())\n    } catch (e: Exception) {\n        showError(e)\n    }\n    log(3)\n}\ndelay(10)\njob.cancelAndJoin()\n```\n\n我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 `getUserCoroutine` 返回的 `Deferred` 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：\n\n```kotlin\n13:06:54:332 [DefaultDispatcher-worker-1] 1\n13:06:54:829 [DefaultDispatcher-worker-1] 2\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine{Cancelling}@19aea38c\n13:06:54:846 [DefaultDispatcher-worker-1] 3\n13:06:56:937 [OkHttp https://api.github.com/...] invokeOnCompletion, null, false\n```\n\n我们看到在调用 `deferred.await()` 的时候抛了个取消异常，这主要是因为 `await()` 所在的协程已经被我们用 `cancelAndJoin()` 取消，但从随后  `invokeOnCompletion` 的回调结果来看， `getUserCoroutine` 返回的 `Deferred`  并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。\n\n所以问题究竟在哪里？在 `CoroutineCallAdapterFactory` 的实现中，为了实现异步转换，手动创建了一个 `CompletableDeferred`：\n\n```kotlin\noverride fun adapt(call: Call<T>): Deferred<T> {\n  val deferred = CompletableDeferred<T>() // ①\n  ...\n}\n```\n\n这个 `CompletableDeferred` 本身就是一个 `Job` 的实现，它的构造可接受一个 `Job` 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 `GlobalScope.launch` 启动了一个协程一样。如果大家在 Android 当中使用 `MainScope`，那么同样因为前面说到的这个原因，导致 `CompletableDeferred` 没有办法被取消。\n\n> @阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。\n\n说到这里我们再简单回顾下，作用域主要有 `GlobalScope`、`coroutineScope`、`supervisorScope`，对于取消，除了 `supervisorScope` 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 `MainScope` 就是一个调度到 UI 线程的 `supervisorScope`；`coroutineScope` 的逻辑则是父子相互取消的逻辑；而 `GlobalScope` 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。\n\n那么有没有办法解决这个问题呢？\n\n直接解决还是比较困难的，因为 `CompletableDeferred` 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。\n\n### 4.2 如何正确的将回调转换为协程\n\n前面我们提到既然 `adapt` 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？\n\n其实我们前面在讲 `getUserCoroutine` 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation ->\n    ...\n}\n```\n\n`suspendCancellableCoroutine` 跟最初我们提到的 `suspendCoroutine` 一样，都是要获取当前协程的 `Continuation` 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：\n\n```kotlin\npublic suspend fun <T : Any> Call<T>.await(): T {\n    return suspendCancellableCoroutine { continuation ->\n        enqueue(object : Callback<T> {\n            override fun onResponse(call: Call<T>?, response: Response<T?>) {\n                continuation.resumeWith(runCatching { // ①\n                    if (response.isSuccessful) {\n                        response.body()\n                            ?: throw NullPointerException(\"Response body is null: $response\")\n                    } else {\n                        throw HttpException(response)\n                    }\n                })\n            }\n\n            override fun onFailure(call: Call<T>, t: Throwable) {\n                if (continuation.isCancelled) return // ②\n                continuation.resumeWithException(t)\n            }\n        })\n\n        continuation.invokeOnCancellation {\n            try {\n                cancel()\n            } catch (ex: Throwable) {  // ③\n                //Ignore cancel exception \n            }\n        }\n    }\n}\n```\n\n大家看着这段代码会不会很眼熟？这与我们 `getUserCoroutine` 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：\n\n* ① 处 `runCatching` 可以将一段代码的运行结果或者抛出的异常封装到一个 `Result` 类型当中，Kotlin 1.3 开始新增了 `Continuation.resumeWith(Result)` 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。\n* ② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 `Continuation` 的取消发起的，因此这时候没必要再调用 `continuation.resumeWithException(t)` 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用  `continuation.resumeWithException(t)`  也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。\n* ③ 处，尽管 `Call.cancel` 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 `cancel` 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。\n\n需要指出的是，这段代码片段源自 [gildor/kotlin-coroutines-retrofit](https://github.com/gildor/kotlin-coroutines-retrofit) ，大家也可以直接添加依赖进行使用：\n\n```gradle\ncompile 'ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0'\n```\n\n这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。\n\n## 5. 小结\n\n这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。\n\n再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。\n\n当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-cancellation","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0031000klduzgk9b0pey","content":"<blockquote>\n<p>协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-线程的中断\"><a href=\"#1-线程的中断\" class=\"headerlink\" title=\"1. 线程的中断\"></a>1. 线程的中断</h2><p>我们先从大家熟悉的话题讲起。线程有一个被废弃的 <code>stop</code> 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 <code>stop</code> 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，<code>stop</code> 还不让用，那该怎么办？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = thread &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.stop() <span class=\"comment\">// !!! Deprecated!!!</span></span><br></pre></td></tr></table></figure>\n\n<p>我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = thread &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10000</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: InterruptedException) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;Interrupted, do cleaning stuff.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.interrupt()</span><br></pre></td></tr></table></figure>\n\n<p>像 <code>sleep</code> 这样的方法调用，文档明确指出它支持 <code>InterruptedException</code>，因此当线程被标记为中断状态时，它就会抛出 <code>InterruptedException</code> ，那么我们自然就可以捕获异常并做资源清理了。</p>\n<p>所以请注意所谓的协作式的任务终止，协程的取消也就是 <code>cancel</code> 机制的思路也是如此。</p>\n<h2 id=\"2-协程类似的例子\"><a href=\"#2-协程类似的例子\" class=\"headerlink\" title=\"2. 协程类似的例子\"></a>2. 协程类似的例子</h2><p>我们来看一个协程取消的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job1 = launch &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>) <span class=\"comment\">// ②</span></span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    job1.cancel() <span class=\"comment\">// ③</span></span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 <code>runBlocking</code> 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。<code>runBlocking</code> 会启动一个 <code>Job</code>，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。</p>\n<p>这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 <code>delay</code>， <code>delay</code> 与线程的 <code>sleep</code> 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 <code>delay</code> 还没有回调的时候协程就被取消了，因为 <code>delay</code> 可以响应取消，因此 <code>delay</code> 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 <code>delay</code> 会抛一个 <code>CancellationException</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;cancelled. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">2</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>那么输出的结果就不一样了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06:54:56:361 [main] 1</span><br><span class=\"line\">06:54:56:408 [main] 3</span><br><span class=\"line\">06:54:56:411 [main] 4</span><br><span class=\"line\">06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;StandaloneCoroutine&#123;Cancelling&#125;@e73f9ac</span><br><span class=\"line\">06:54:56:413 [main] 2</span><br></pre></td></tr></table></figure>\n\n<p>大家看，这与线程的中断逻辑是不是非常的类似呢？</p>\n<h2 id=\"3-完善我们之前的例子\"><a href=\"#3-完善我们之前的例子\" class=\"headerlink\" title=\"3. 完善我们之前的例子\"></a>3. 完善我们之前的例子</h2><p>之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resume(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resumeWithException(t)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加取消逻辑，那需要我们的 <code>getUser</code> 回调版本支持取消，我们看下我们的 <code>getUser</code> 是怎么实现的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>&lt;<span class=\"type\">User</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> call = OkHttpClient().newCall(</span><br><span class=\"line\">            Request.Builder()</span><br><span class=\"line\">                    .<span class=\"keyword\">get</span>().url(<span class=\"string\">&quot;https://api.github.com/users/bennyhuo&quot;</span>)</span><br><span class=\"line\">                    .build())</span><br><span class=\"line\"></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">object</span> : okhttp3.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>, e: <span class=\"type\">IOException</span>)</span></span> &#123;</span><br><span class=\"line\">            callback.onError(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>, response: <span class=\"type\">Response</span>)</span></span> &#123;</span><br><span class=\"line\">            response.body()?.let &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    callback.onSuccess(User.from(it.string()))</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                    callback.onError(e) <span class=\"comment\">// 这里可能是解析异常</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;?: callback.onError(NullPointerException(<span class=\"string\">&quot;ResponseBody is null.&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发了个网络请求给 Github，让它把一个叫 <code>bennyhuo</code> 的用户信息返回来，我们知道 OkHttp 的这个 <code>Call</code> 是支持 <code>cancel</code> 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 <code>getUser</code> 好了，这样还能省掉我们自己的 <code>Callback</code> 回调过程：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> call = OkHttpClient().newCall(...)</span><br><span class=\"line\"></span><br><span class=\"line\">    continuation.invokeOnCancellation &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        log(<span class=\"string\">&quot;invokeOnCancellation: cancel the request.&quot;</span>)</span><br><span class=\"line\">        call.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">object</span> : okhttp3.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>, e: <span class=\"type\">IOException</span>)</span></span> &#123;</span><br><span class=\"line\">            log(<span class=\"string\">&quot;onFailure: <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">            continuation.resumeWithException(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>, response: <span class=\"type\">Response</span>)</span></span> &#123;</span><br><span class=\"line\">            log(<span class=\"string\">&quot;onResponse: <span class=\"subst\">$&#123;response.code()&#125;</span>&quot;</span>)</span><br><span class=\"line\">            response.body()?.let &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    continuation.resume(User.from(it.string()))</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                    continuation.resumeWithException(e)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; ?: continuation.resumeWithException(NullPointerException(<span class=\"string\">&quot;ResponseBody is null.&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里用到了 <code>suspendCancellableCoroutine</code>，而不是之前的 <code>suspendCoroutine</code>，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 <code>Continuation</code> 包装成了一个 <code>CancellableContinuation</code>，通过调用它的 <code>invokeOnCancellation</code> 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 <code>getUserCoroutine</code> 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。</p>\n<p>那么我们在调用它的时候，如果遇到了取消，会怎么样呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job1 = launch &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> user = getUserCoroutine()</span><br><span class=\"line\">    log(user)</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">delay(<span class=\"number\">10</span>)</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job1.cancel()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 <code>getUserCoroutine</code> 被挂起了，因此结果大概率是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">30</span>:<span class=\"number\">751</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">120</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">124</span> [main] invokeOnCancellation: cancel the request.</span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">129</span> [main] <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">131</span> [OkHttp https:<span class=\"comment\">//api.github.com/...] onFailure: java.io.IOException: Canceled</span></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 <code>Continuation.resume</code> 、 <code>Continuation.resumeWithException</code> 或者 <code>Continuation.resumeWith</code> 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 <code>continuation.resumeWithException(e)</code> 不会有任何副作用。</p>\n<h2 id=\"4-再谈-Retrofit-的协程扩展\"><a href=\"#4-再谈-Retrofit-的协程扩展\" class=\"headerlink\" title=\"4. 再谈 Retrofit 的协程扩展\"></a>4. 再谈 Retrofit 的协程扩展</h2><h3 id=\"4-1-Jake-Wharton-的-Adapter-存在的问题\"><a href=\"#4-1-Jake-Wharton-的-Adapter-存在的问题\" class=\"headerlink\" title=\"4.1 Jake Wharton 的 Adapter 存在的问题\"></a>4.1 Jake Wharton 的 Adapter 存在的问题</h3><p>我在<a href=\"https://www.bennyhuo.com/2019/04/01/basic-coroutines/\">破解 Kotlin 协程 - 入门篇</a> 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .addCallAdapterFactory(CoroutineCallAdapterFactory()) <span class=\"comment\">// 这里添加 Adapter</span></span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用的时候就这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    showUser(deferred.await())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    showError(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要取消，我们可以直接调用 <code>deferred.cancel()</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\">log(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">    deferred.cancel()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    showUser(deferred.await())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    showError(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:59:54:185 [DefaultDispatcher-worker-1] 1</span><br><span class=\"line\">12:59:54:587 [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;CompletableDeferredImpl&#123;Cancelled&#125;@36699211</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">adapt</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> deferred = CompletableDeferred&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">      deferred.invokeOnCompletion &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deferred.isCancelled) &#123;</span><br><span class=\"line\">          call.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      call.enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &#125;     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>注意 ① 处，<code>invokeOnCompletion</code> 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 <code>Call</code> 的取消即可。</p>\n<p>这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\">    log(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    deferred.invokeOnCompletion &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;invokeOnCompletion, <span class=\"variable\">$it</span>, <span class=\"subst\">$&#123;deferred.isCancelled&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(deferred.await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">delay(<span class=\"number\">10</span>)</span><br><span class=\"line\">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>\n\n<p>我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 <code>getUserCoroutine</code> 返回的 <code>Deferred</code> 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">332</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">829</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@19aea38c</span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">846</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">56</span>:<span class=\"number\">937</span> [OkHttp https:<span class=\"comment\">//api.github.com/...] invokeOnCompletion, null, false</span></span><br></pre></td></tr></table></figure>\n\n<p>我们看到在调用 <code>deferred.await()</code> 的时候抛了个取消异常，这主要是因为 <code>await()</code> 所在的协程已经被我们用 <code>cancelAndJoin()</code> 取消，但从随后  <code>invokeOnCompletion</code> 的回调结果来看， <code>getUserCoroutine</code> 返回的 <code>Deferred</code>  并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。</p>\n<p>所以问题究竟在哪里？在 <code>CoroutineCallAdapterFactory</code> 的实现中，为了实现异步转换，手动创建了一个 <code>CompletableDeferred</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">adapt</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> deferred = CompletableDeferred&lt;T&gt;() <span class=\"comment\">// ①</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>CompletableDeferred</code> 本身就是一个 <code>Job</code> 的实现，它的构造可接受一个 <code>Job</code> 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 <code>GlobalScope.launch</code> 启动了一个协程一样。如果大家在 Android 当中使用 <code>MainScope</code>，那么同样因为前面说到的这个原因，导致 <code>CompletableDeferred</code> 没有办法被取消。</p>\n<blockquote>\n<p>@阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。</p>\n</blockquote>\n<p>说到这里我们再简单回顾下，作用域主要有 <code>GlobalScope</code>、<code>coroutineScope</code>、<code>supervisorScope</code>，对于取消，除了 <code>supervisorScope</code> 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 <code>MainScope</code> 就是一个调度到 UI 线程的 <code>supervisorScope</code>；<code>coroutineScope</code> 的逻辑则是父子相互取消的逻辑；而 <code>GlobalScope</code> 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。</p>\n<p>那么有没有办法解决这个问题呢？</p>\n<p>直接解决还是比较困难的，因为 <code>CompletableDeferred</code> 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。</p>\n<h3 id=\"4-2-如何正确的将回调转换为协程\"><a href=\"#4-2-如何正确的将回调转换为协程\" class=\"headerlink\" title=\"4.2 如何正确的将回调转换为协程\"></a>4.2 如何正确的将回调转换为协程</h3><p>前面我们提到既然 <code>adapt</code> 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？</p>\n<p>其实我们前面在讲 <code>getUserCoroutine</code> 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspendCancellableCoroutine</code> 跟最初我们提到的 <code>suspendCoroutine</code> 一样，都是要获取当前协程的 <code>Continuation</code> 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">await</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;?, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>?&gt;)</span></span> &#123;</span><br><span class=\"line\">                continuation.resumeWith(runCatching &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (response.isSuccessful) &#123;</span><br><span class=\"line\">                        response.body()</span><br><span class=\"line\">                            ?: <span class=\"keyword\">throw</span> NullPointerException(<span class=\"string\">&quot;Response body is null: <span class=\"variable\">$response</span>&quot;</span>)</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> HttpException(response)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (continuation.isCancelled) <span class=\"keyword\">return</span> <span class=\"comment\">// ②</span></span><br><span class=\"line\">                continuation.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                cancel()</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ex: Throwable) &#123;  <span class=\"comment\">// ③</span></span><br><span class=\"line\">                <span class=\"comment\">//Ignore cancel exception </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家看着这段代码会不会很眼熟？这与我们 <code>getUserCoroutine</code> 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：</p>\n<ul>\n<li>① 处 <code>runCatching</code> 可以将一段代码的运行结果或者抛出的异常封装到一个 <code>Result</code> 类型当中，Kotlin 1.3 开始新增了 <code>Continuation.resumeWith(Result)</code> 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。</li>\n<li>② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 <code>Continuation</code> 的取消发起的，因此这时候没必要再调用 <code>continuation.resumeWithException(t)</code> 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用  <code>continuation.resumeWithException(t)</code>  也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。</li>\n<li>③ 处，尽管 <code>Call.cancel</code> 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 <code>cancel</code> 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。</li>\n</ul>\n<p>需要指出的是，这段代码片段源自 <a href=\"https://github.com/gildor/kotlin-coroutines-retrofit\">gildor/kotlin-coroutines-retrofit</a> ，大家也可以直接添加依赖进行使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&#x27;ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。</p>\n<p>再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。</p>\n<p>当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#x66;&#x40;&#x69;&#109;&#x6f;&#111;&#99;&#46;&#99;&#x6f;&#x6d;\">&#107;&#x66;&#x40;&#x69;&#109;&#x6f;&#111;&#99;&#46;&#99;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>协程的任务的取消需要靠协程内部调用的协作支持，这就类似于我们线程中断以及对中断状态的响应一样。 </p>\n</blockquote>","more":"<h2 id=\"1-线程的中断\"><a href=\"#1-线程的中断\" class=\"headerlink\" title=\"1. 线程的中断\"></a>1. 线程的中断</h2><p>我们先从大家熟悉的话题讲起。线程有一个被废弃的 <code>stop</code> 方法，这个方法会让线程立即死掉，并且释放它持有的锁，这样会让它正在读写的存储处于一个不安全的状态，因此 <code>stop</code> 被废弃了。如果我们启动了一个线程并让它执行一些任务，但很快我们就后悔了，<code>stop</code> 还不让用，那该怎么办？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = thread &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.stop() <span class=\"comment\">// !!! Deprecated!!!</span></span><br></pre></td></tr></table></figure>\n\n<p>我们应该想办法让线程内部正在运行的任务跟我们合作把任务停掉，这样线程内部的任务停止之前还有机会清理一些资源，比如关闭流等等。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = thread &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10000</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: InterruptedException) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;Interrupted, do cleaning stuff.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.interrupt()</span><br></pre></td></tr></table></figure>\n\n<p>像 <code>sleep</code> 这样的方法调用，文档明确指出它支持 <code>InterruptedException</code>，因此当线程被标记为中断状态时，它就会抛出 <code>InterruptedException</code> ，那么我们自然就可以捕获异常并做资源清理了。</p>\n<p>所以请注意所谓的协作式的任务终止，协程的取消也就是 <code>cancel</code> 机制的思路也是如此。</p>\n<h2 id=\"2-协程类似的例子\"><a href=\"#2-协程类似的例子\" class=\"headerlink\" title=\"2. 协程类似的例子\"></a>2. 协程类似的例子</h2><p>我们来看一个协程取消的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job1 = launch &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>) <span class=\"comment\">// ②</span></span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    job1.cancel() <span class=\"comment\">// ③</span></span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次我们用了一个不一样的写法，我们没有用 suspend main，而是直接用 <code>runBlocking</code> 启动协程，这个方法在 Native 上也存在，都是基于当前线程启动一个类似于 Android 的 Looper 的死循环，或者叫消息队列，可以不断的发送消息给它进行处理。<code>runBlocking</code> 会启动一个 <code>Job</code>，因此这里也存在默认的作用域，不过这对于我们今天的讨论暂时没有太大影响。</p>\n<p>这段代码 ① 处启动了一个子协程，它内部先输出 1，接着开始 <code>delay</code>， <code>delay</code> 与线程的 <code>sleep</code> 不同，它不会阻塞线程，你可以认为它实际上就是触发了一个延时任务，告诉协程调度系统 1000ms 之后再来执行后面的这段代码（也就是 log(2)）；而在这期间，我们在 ③ 处对刚才启动的协程触发了取消，因此在 ② 处的 <code>delay</code> 还没有回调的时候协程就被取消了，因为 <code>delay</code> 可以响应取消，因此 <code>delay</code> 后面的代码就不会再次调度了，不调度的原因也很简单，② 处的 <code>delay</code> 会抛一个 <code>CancellationException</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;cancelled. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">2</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>那么输出的结果就不一样了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06:54:56:361 [main] 1</span><br><span class=\"line\">06:54:56:408 [main] 3</span><br><span class=\"line\">06:54:56:411 [main] 4</span><br><span class=\"line\">06:54:56:413 [main] cancelled. kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;StandaloneCoroutine&#123;Cancelling&#125;@e73f9ac</span><br><span class=\"line\">06:54:56:413 [main] 2</span><br></pre></td></tr></table></figure>\n\n<p>大家看，这与线程的中断逻辑是不是非常的类似呢？</p>\n<h2 id=\"3-完善我们之前的例子\"><a href=\"#3-完善我们之前的例子\" class=\"headerlink\" title=\"3. 完善我们之前的例子\"></a>3. 完善我们之前的例子</h2><p>之前我们有个例子，上一篇文章已经加入了异常处理逻辑，那么这次我们给它加上取消逻辑。之前是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resume(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resumeWithException(t)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加取消逻辑，那需要我们的 <code>getUser</code> 回调版本支持取消，我们看下我们的 <code>getUser</code> 是怎么实现的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>&lt;<span class=\"type\">User</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> call = OkHttpClient().newCall(</span><br><span class=\"line\">            Request.Builder()</span><br><span class=\"line\">                    .<span class=\"keyword\">get</span>().url(<span class=\"string\">&quot;https://api.github.com/users/bennyhuo&quot;</span>)</span><br><span class=\"line\">                    .build())</span><br><span class=\"line\"></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">object</span> : okhttp3.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>, e: <span class=\"type\">IOException</span>)</span></span> &#123;</span><br><span class=\"line\">            callback.onError(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>, response: <span class=\"type\">Response</span>)</span></span> &#123;</span><br><span class=\"line\">            response.body()?.let &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    callback.onSuccess(User.from(it.string()))</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                    callback.onError(e) <span class=\"comment\">// 这里可能是解析异常</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;?: callback.onError(NullPointerException(<span class=\"string\">&quot;ResponseBody is null.&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发了个网络请求给 Github，让它把一个叫 <code>bennyhuo</code> 的用户信息返回来，我们知道 OkHttp 的这个 <code>Call</code> 是支持 <code>cancel</code> 的， 取消后，网络请求过程中如果读取到这个取消的状态，就会把请求给停止掉。既然这样，我们干脆直接改造 <code>getUser</code> 好了，这样还能省掉我们自己的 <code>Callback</code> 回调过程：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> call = OkHttpClient().newCall(...)</span><br><span class=\"line\"></span><br><span class=\"line\">    continuation.invokeOnCancellation &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        log(<span class=\"string\">&quot;invokeOnCancellation: cancel the request.&quot;</span>)</span><br><span class=\"line\">        call.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">object</span> : okhttp3.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>, e: <span class=\"type\">IOException</span>)</span></span> &#123;</span><br><span class=\"line\">            log(<span class=\"string\">&quot;onFailure: <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">            continuation.resumeWithException(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>, response: <span class=\"type\">Response</span>)</span></span> &#123;</span><br><span class=\"line\">            log(<span class=\"string\">&quot;onResponse: <span class=\"subst\">$&#123;response.code()&#125;</span>&quot;</span>)</span><br><span class=\"line\">            response.body()?.let &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    continuation.resume(User.from(it.string()))</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                    continuation.resumeWithException(e)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; ?: continuation.resumeWithException(NullPointerException(<span class=\"string\">&quot;ResponseBody is null.&quot;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里用到了 <code>suspendCancellableCoroutine</code>，而不是之前的 <code>suspendCoroutine</code>，这就是为了让我们的挂起函数支持协程的取消。该方法将获取到的 <code>Continuation</code> 包装成了一个 <code>CancellableContinuation</code>，通过调用它的 <code>invokeOnCancellation</code> 方法可以设置一个取消事件的回调，一旦这个回调被调用，那么意味着 <code>getUserCoroutine</code> 调用所在的协程被取消了，这时候我们也要相应的做出取消的响应，也就是把 OkHttp 发出去的请求给取消掉。</p>\n<p>那么我们在调用它的时候，如果遇到了取消，会怎么样呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job1 = launch &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> user = getUserCoroutine()</span><br><span class=\"line\">    log(user)</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">delay(<span class=\"number\">10</span>)</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job1.cancel()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>注意我们启动 ① 之后仅仅延迟了 10ms 就取消了它，网络请求的速度一般来讲还不会这么快，因此取消的时候大概率 <code>getUserCoroutine</code> 被挂起了，因此结果大概率是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">30</span>:<span class=\"number\">751</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">120</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">124</span> [main] invokeOnCancellation: cancel the request.</span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">129</span> [main] <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">31</span>:<span class=\"number\">31</span>:<span class=\"number\">131</span> [OkHttp https:<span class=\"comment\">//api.github.com/...] onFailure: java.io.IOException: Canceled</span></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，取消的回调被调用了，OkHttp 在收到我们的取消指令之后，也确实停止了网络请求，并且回调给我们一个 IO 异常，这时候我们的协程已经被取消，在处于取消状态的协程上调用 <code>Continuation.resume</code> 、 <code>Continuation.resumeWithException</code> 或者 <code>Continuation.resumeWith</code> 都会被忽略，因此 OkHttp 回调中我们收到 IO 异常后调用的 <code>continuation.resumeWithException(e)</code> 不会有任何副作用。</p>\n<h2 id=\"4-再谈-Retrofit-的协程扩展\"><a href=\"#4-再谈-Retrofit-的协程扩展\" class=\"headerlink\" title=\"4. 再谈 Retrofit 的协程扩展\"></a>4. 再谈 Retrofit 的协程扩展</h2><h3 id=\"4-1-Jake-Wharton-的-Adapter-存在的问题\"><a href=\"#4-1-Jake-Wharton-的-Adapter-存在的问题\" class=\"headerlink\" title=\"4.1 Jake Wharton 的 Adapter 存在的问题\"></a>4.1 Jake Wharton 的 Adapter 存在的问题</h3><p>我在<a href=\"https://www.bennyhuo.com/2019/04/01/basic-coroutines/\">破解 Kotlin 协程 - 入门篇</a> 提到了 Jake Wharton 大神为 Retrofit 写的 协程 Adapter，</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>它确实可以完成网络请求，不过有细心的小伙伴发现了它的问题：它怎么取消呢？我们把使用它的代码贴出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubServiceApi</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET(<span class=\"meta-string\">&quot;users/&#123;login&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">(<span class=\"meta\">@Path(<span class=\"meta-string\">&quot;login&quot;</span>)</span> login: <span class=\"type\">String</span>)</span></span>: Deferred&lt;User&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好接口，创建 Retrofit 实例的时候传入对应的 Adapter：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> gitHubServiceApi <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(<span class=\"string\">&quot;https://api.github.com&quot;</span>)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .addCallAdapterFactory(CoroutineCallAdapterFactory()) <span class=\"comment\">// 这里添加 Adapter</span></span><br><span class=\"line\">            .build()</span><br><span class=\"line\"></span><br><span class=\"line\">    retrofit.create(GitHubServiceApi::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用的时候就这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    showUser(deferred.await())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    showError(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要取消，我们可以直接调用 <code>deferred.cancel()</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\">log(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">    deferred.cancel()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    showUser(deferred.await())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">    showError(e)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:59:54:185 [DefaultDispatcher-worker-1] 1</span><br><span class=\"line\">12:59:54:587 [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">kotlinx.coroutines.JobCancellationException: Job was cancelled; job&#x3D;CompletableDeferredImpl&#123;Cancelled&#125;@36699211</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，其实网络请求确实是被取消的，这一点我们可以看下源码的处理：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">adapt</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> deferred = CompletableDeferred&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">      deferred.invokeOnCompletion &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deferred.isCancelled) &#123;</span><br><span class=\"line\">          call.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      call.enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &#125;     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>注意 ① 处，<code>invokeOnCompletion</code> 在协程进入完成状态时触发，包括异常和正常完成，那么在这时候如果发现它的状态是已经取消的，那么结果就直接调用 <code>Call</code> 的取消即可。</p>\n<p>这看上去确实很正常啊~ 不过 @阿永 在公众号的评论里面提到了一个 Case，仔细一看还真是有问题。我们给出示例来复现这个 Case：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = gitHubServiceApi.getUserCoroutine(<span class=\"string\">&quot;bennyhuo&quot;</span>)</span><br><span class=\"line\">    log(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    deferred.invokeOnCompletion &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;invokeOnCompletion, <span class=\"variable\">$it</span>, <span class=\"subst\">$&#123;deferred.isCancelled&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        showUser(deferred.await())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        showError(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">delay(<span class=\"number\">10</span>)</span><br><span class=\"line\">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>\n\n<p>我们启动一个协程，在其中执行网络请求，那么正常来说，这时候 <code>getUserCoroutine</code> 返回的 <code>Deferred</code> 可以当做一个子协程，它应当遵循默认的作用域规则，在父作用域取消时被取消掉，但现实却并不是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">332</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">829</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\">kotlinx.coroutines.JobCancellationException: Job was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@19aea38c</span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">54</span>:<span class=\"number\">846</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">06</span>:<span class=\"number\">56</span>:<span class=\"number\">937</span> [OkHttp https:<span class=\"comment\">//api.github.com/...] invokeOnCompletion, null, false</span></span><br></pre></td></tr></table></figure>\n\n<p>我们看到在调用 <code>deferred.await()</code> 的时候抛了个取消异常，这主要是因为 <code>await()</code> 所在的协程已经被我们用 <code>cancelAndJoin()</code> 取消，但从随后  <code>invokeOnCompletion</code> 的回调结果来看， <code>getUserCoroutine</code> 返回的 <code>Deferred</code>  并没有被取消，再仔细一看，时间上这个回调比前面的操作晚了 2s，那必然是网络请求返回之后才回调的。</p>\n<p>所以问题究竟在哪里？在 <code>CoroutineCallAdapterFactory</code> 的实现中，为了实现异步转换，手动创建了一个 <code>CompletableDeferred</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">adapt</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> deferred = CompletableDeferred&lt;T&gt;() <span class=\"comment\">// ①</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>CompletableDeferred</code> 本身就是一个 <code>Job</code> 的实现，它的构造可接受一个 <code>Job</code> 实例作为它的父协程，那么问题来了，这里并没有告诉它父协程究竟是谁，因此也就谈不上作用域的事儿了，这好像我们用 <code>GlobalScope.launch</code> 启动了一个协程一样。如果大家在 Android 当中使用 <code>MainScope</code>，那么同样因为前面说到的这个原因，导致 <code>CompletableDeferred</code> 没有办法被取消。</p>\n<blockquote>\n<p>@阿永 在公众号评论中提到这个问题，并提到了一个比较好的解决方案，下面我们为大家详细介绍。感谢 @阿永。</p>\n</blockquote>\n<p>说到这里我们再简单回顾下，作用域主要有 <code>GlobalScope</code>、<code>coroutineScope</code>、<code>supervisorScope</code>，对于取消，除了 <code>supervisorScope</code> 比较特别是单向取消，即父协程取消后子协程都取消，Android 中 <code>MainScope</code> 就是一个调度到 UI 线程的 <code>supervisorScope</code>；<code>coroutineScope</code> 的逻辑则是父子相互取消的逻辑；而 <code>GlobalScope</code> 会启动一个全新的作用域，与它外部隔离，内部遵循默认的协程作用域规则。</p>\n<p>那么有没有办法解决这个问题呢？</p>\n<p>直接解决还是比较困难的，因为 <code>CompletableDeferred</code> 构造所处的调用环境不是 suspend 函数，因而也没有办法拿到（很可能根本就没有！）父协程。</p>\n<h3 id=\"4-2-如何正确的将回调转换为协程\"><a href=\"#4-2-如何正确的将回调转换为协程\" class=\"headerlink\" title=\"4.2 如何正确的将回调转换为协程\"></a>4.2 如何正确的将回调转换为协程</h3><p>前面我们提到既然 <code>adapt</code> 方法不是 suspend 方法，那么我们是不是应该在其他位置创建协程呢？</p>\n<p>其实我们前面在讲 <code>getUserCoroutine</code> 的时候就不断为大家展示了如何将一个回调转换为协程调用的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspendCancellableCoroutine</code> 跟最初我们提到的 <code>suspendCoroutine</code> 一样，都是要获取当前协程的 <code>Continuation</code> 实例，这实际上就相当于要继承当前协程的上下文，因此我们只需要在真正需要切换协程的时候再去做这个转换即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> Call<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">await</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class=\"line\">        enqueue(<span class=\"keyword\">object</span> : Callback&lt;T&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResponse</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;?, response: <span class=\"type\">Response</span>&lt;<span class=\"type\">T</span>?&gt;)</span></span> &#123;</span><br><span class=\"line\">                continuation.resumeWith(runCatching &#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (response.isSuccessful) &#123;</span><br><span class=\"line\">                        response.body()</span><br><span class=\"line\">                            ?: <span class=\"keyword\">throw</span> NullPointerException(<span class=\"string\">&quot;Response body is null: <span class=\"variable\">$response</span>&quot;</span>)</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> HttpException(response)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFailure</span><span class=\"params\">(call: <span class=\"type\">Call</span>&lt;<span class=\"type\">T</span>&gt;, t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (continuation.isCancelled) <span class=\"keyword\">return</span> <span class=\"comment\">// ②</span></span><br><span class=\"line\">                continuation.resumeWithException(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        continuation.invokeOnCancellation &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                cancel()</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ex: Throwable) &#123;  <span class=\"comment\">// ③</span></span><br><span class=\"line\">                <span class=\"comment\">//Ignore cancel exception </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家看着这段代码会不会很眼熟？这与我们 <code>getUserCoroutine</code> 的写法几乎如出一辙，不过有几处细节值得关注，我用数字标注了他们的位置：</p>\n<ul>\n<li>① 处 <code>runCatching</code> 可以将一段代码的运行结果或者抛出的异常封装到一个 <code>Result</code> 类型当中，Kotlin 1.3 开始新增了 <code>Continuation.resumeWith(Result)</code> 这个方法， 这个点比起我们前面的写法更具 Kotlin 风格。</li>\n<li>② 处在异常抛出时，判断了是否已经被取消。实际上如果网络请求被取消，这个回调确实会被调到，那么由于取消的操作是协程的由 <code>Continuation</code> 的取消发起的，因此这时候没必要再调用 <code>continuation.resumeWithException(t)</code> 来将异常再抛回来了。尽管我们前面其实也提到过，这时候继续调用  <code>continuation.resumeWithException(t)</code>  也没有任何逻辑上的副作用，但性能上多少还是会有一些开销。</li>\n<li>③ 处，尽管 <code>Call.cancel</code> 的调用比较安全，但网络环境和状态难免情况复杂，因此对异常进行捕获会让这段代码更加健壮。如果 <code>cancel</code> 抛异常而没有捕获的话，那么等同于协程体内部抛出异常，具体如何传播看所在作用域的相关定义了。</li>\n</ul>\n<p>需要指出的是，这段代码片段源自 <a href=\"https://github.com/gildor/kotlin-coroutines-retrofit\">gildor/kotlin-coroutines-retrofit</a> ，大家也可以直接添加依赖进行使用：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&#x27;ru.gildor.coroutines:kotlin-coroutines-retrofit:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个框架代码量很少，但经过各路 Kotlin 协程专家的锤炼，逻辑手法很细腻，值得大家学习。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>这篇文章我们从线程中断的概念切入，类比学习协程的取消，实际上大家就会发现这二者从逻辑上和场景上有多么的相似。接着我们将之前我们一直提到的回调转协程的例子进一步升级，支持取消，这样大家就可以轻易的将回调转变为协程的挂起调用了。最后我们还分析了一下 Retrofit 的协程扩展的一些问题和解决方法，这个例子也进一步可以引发我们对协程作用域以及如何将现有程序协程化的思考。</p>\n<p>再稍微提一句，协程不是一个简单的东西，毕竟它的原理涉及到对操作系统调度、程序运行机制这样程序界毕竟原始的话题，但你说如果我对前面提到的这些都不是很熟悉或者根本没有接触过，是不是就要跟协程拜拜了呢，其实也不是，只不过如果你对这些都不熟悉，那么可能需要多加练习培养出感觉，而不必一开始就关注原理和细节，依样画葫芦一样可以用的很好，就像大家不知道 RxJava 原理一样可以用的很好一样，协程也可以做到这一点的。</p>\n<p>当然，作为一个有追求的程序员，我们不止要会用，还要用得好，无论如何我们都需要知道来龙去脉，这其中涉及到的基础知识的欠缺也是需要尽快补充的，不能偷懒哈 ：）</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#x66;&#x40;&#x69;&#109;&#x6f;&#111;&#99;&#46;&#99;&#x6f;&#x6d;\">&#107;&#x66;&#x40;&#x69;&#109;&#x6f;&#111;&#99;&#46;&#99;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(9) - Channel 篇","keywords":"Kotlin 协程 Channel 生产消费者","date":"2019-09-15T16:00:00.000Z","description":null,"_content":"\n> `Channel` 实际上就是协程在生产消费者模型上的应用，把过去你用 `BlockingQueue` 实现的功能替换成 `Channel`，也许会有新的发现~ \n\n<!-- more -->\n\n\n\n\n## 1. 认识 Channel \n\nChannel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：\n\n```kotlin\nsuspend fun main() {\n    val channel = Channel<Int>()\n\n    val producer = GlobalScope.launch {\n        var i = 0\n        while (true){\n            channel.send(i++)\n            delay(1000)\n        }\n    }\n\n    val consumer = GlobalScope.launch {\n        while(true){\n            val element = channel.receive()\n            Logger.debug(element)\n        }\n    }\n\n    producer.join()\n    consumer.join()\n}\n```\n\n我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。\n\n例子的运行机制是，producer 当中每隔 1s 向 `Channel` 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？\n\n## 2. Channel 的容量\n\n如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 `BlockingQueue`，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 `Channel` 的缓冲区的定义：\n\n```kotlin\npublic fun <E> Channel(capacity: Int = RENDEZVOUS): Channel<E> =\n    when (capacity) {\n        RENDEZVOUS -> RendezvousChannel()\n        UNLIMITED -> LinkedListChannel()\n        CONFLATED -> ConflatedChannel()\n        else -> ArrayChannel(capacity)\n    }\n```\n\n我们构造 `Channel` 的时候调用了一个叫 `Channel` 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。\n\n> 类似的还有 String，不信你去试试\n\n它有一个参数叫 capacity，指定缓冲区的容量，默认值 `RENDEZVOUS` 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：\n\n```kotlin\nval producer = GlobalScope.launch {\n    var i = 0\n    while (true){\n        i++ //为了方便输出日志，我们将自增放到前面\n        Logger.debug(\"before send $i\")\n        channel.send(i)\n        Logger.debug(\"before after $i\")\n        delay(1000)\n    }\n}\n\nval consumer = GlobalScope.launch {\n    while(true){\n        delay(2000) //receive 之前延迟 2s\n        val element = channel.receive()\n        Logger.debug(element)\n    }\n}\n```\n\n我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：\n\n```\n07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1\n07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1\n07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1\n07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2\n07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2\n07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2\n```\n\n`UNLIMITED` 比较好理解，来者不拒，从它给出的实现 `LinkedListChannel` 来看，这一点也与我们的 `LinkedBlockingQueue` 有异曲同工之妙。\n\n`CONFLATED`，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。\n\n剩下的就是 `ArrayChannel` 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 `ArrayBlockingQueue`。\n\n## 3. 迭代 Channel\n\n前面我们在发送和读取 `Channel` 的时候用了 `while(true)`，因为我们想要去不断的进行读写操作，`Channel` 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 `Channel` 的 iterator：\n\n```kotlin\nval consumer = GlobalScope.launch {\n    val iterator = channel.iterator()\n    while(iterator.hasNext()){ // 挂起点\n        val element = iterator.next()\n        Logger.debug(element)\n        delay(2000)\n    }\n}\n```\n\n那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 `Channel` 当中读取元素了。\n\n这个写法自然可以简化成 for each：\n\n```kotlin\nval consumer = GlobalScope.launch {\n    for (element in channel) {\n        Logger.debug(element)\n        delay(2000)\n    }\n}\n```\n\n## 4. produce 和 actor\n\n前面我们在协程外部定义 `Channel`，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者\n和消费者呢？\n\n```kotlin\nval receiveChannel: ReceiveChannel<Int> = GlobalScope.produce {\n    while(true){\n        delay(1000)\n        send(2)\n    }\n}\n```\n\n我们可以通过 `produce` 这个方法启动一个生产者协程，并返回一个 `ReceiveChannel`，其他协程就可以拿着这个 `Channel` 来接收数据了。反过来，我们可以用 `actor` 启动一个消费者协程：\n\n```kotlin\nval sendChannel: SendChannel<Int> = GlobalScope.actor<Int> {\n    while(true){\n        val element = receive()\n    }\n}\n```\n\n> ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。\n\n`produce` 和 `actor` 与 `launch` 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 `Channel` 绑定到了一起，因此 `Channel` 的关闭也会在协程结束时自动完成，以 `produce` 为例，它构造出了一个 `ProducerCoroutine` 的对象：\n\n```kotlin\ninternal open class ProducerCoroutine<E>(\n    parentContext: CoroutineContext, channel: Channel<E>\n) : ChannelCoroutine<E>(parentContext, channel, active = true), ProducerScope<E> {\n    ...\n    override fun onCompleted(value: Unit) {\n        _channel.close() // 协程完成时\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        val processed = _channel.close(cause) // 协程取消时\n        if (!processed && !handled) handleCoroutineException(context, cause)\n    }\n}\n```\n\n注意到在协程完成和取消的方法调用中，对应的 `_channel` 都会被关闭。\n\n这样看上去还是挺有用的。不过截止这俩 API `produce` 和 `actor` 目前都没有稳定，前者仍被标记为 `ExperimentalCoroutinesApi`，后者则标记为 `ObsoleteCoroutinesApi`，这就比较尴尬了，明摆着不让用嘛。`actor` 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 `actor` API 也不过就是提供了一个 `SendChannel` 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 `Flow`——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。\n\n虽然 `produce` 没有被标记为 `ObsoleteCoroutinesApi`，显然它作为 `actor` 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。\n\n## 5. Channel 的关闭\n\n前我们提到了 `produce` 和 `actor` 返回的 `Channel` 都会伴随着对应的协程执行完毕而关闭。哦，原来 `Channel` 还有一个关闭的概念。\n\n`Channel` 和我们后面的文章即将要探讨的 `Flow` 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 `Channel`，如果我们调用了它的 `close`，它会立即停止接受新元素，也就是说这时候它的 `isClosedForSend` 会立即返回 `true`，而由于 `Channel` 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 `isClosedForReceive` 才会返回 `true`。\n\n```kotlin\nval channel = Channel<Int>(3)\n\nval producer = GlobalScope.launch {\n    List(5){\n        channel.send(it)\n        Logger.debug(\"send $it\")\n    }\n    channel.close()\n    Logger.debug(\"close channel. ClosedForSend = ${channel.isClosedForSend} ClosedForReceive = ${channel.isClosedForReceive}\")\n}\n\nval consumer = GlobalScope.launch {\n    for (element in channel) {\n        Logger.debug(\"receive: $element\")\n        delay(1000)\n    }\n\n    Logger.debug(\"After Consuming. ClosedForSend = ${channel.isClosedForSend} ClosedForReceive = ${channel.isClosedForReceive}\")\n}\n```\n\n我们把例子稍作修改，开了一个缓冲区大小为 3 的 `Channel`，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 `Channel`，而在 consumer 协程当中每秒读取一个， 结果如下：\n\n```\n11:05:20:678 [DefaultDispatcher-worker-1]  send 0\n11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0\n11:05:20:678 [DefaultDispatcher-worker-1]  send 1\n11:05:20:678 [DefaultDispatcher-worker-1]  send 2\n11:05:20:678 [DefaultDispatcher-worker-1]  send 3\n11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1\n11:05:21:688 [DefaultDispatcher-worker-3]  send 4\n11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend =true ClosedForReceive = false\n11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2\n11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3\n11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4\n11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend =true ClosedForReceive = true\n```\n\n下面我们来探讨下 `Channel` 关闭的意义。\n\n一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 `Channel` 的关闭是个什么概念呢？我们前面提到过，`Channel` 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 `Channel` 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 `Channel` 了。嗯，看上去好像没什么问题是吧？\n\nBut，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 `Channel` 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：\n\n> 女：咱俩没戏，你别傻等了。\n> 男：哦。（您的消息未发送成功）\n\n那么 `Channel` 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。\n\n还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，`Channel` 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。\n\n> 扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。\n\n## 6. BroadcastChannel\n\n前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。\n\n直接创建 `broadcastChannel` 的方法跟普通的 `Channel` 似乎也没什么太多的不一样：\n\n```kotlin\nval broadcastChannel = broadcastChannel<Int>(5)\n```\n\n如果要订阅，那么只需要调用：\n\n```kotlin\nval receiveChannel = broadcastChannel.openSubscription()\n```\n\n这样我们就得到了一个 `ReceiveChannel`，获取订阅的消息，只需要调用它的 `receive`。\n\n我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：\n\n```kotlin\nval producer = GlobalScope.launch {\n    List(5) {\n        broadcastChannel.send(it)\n        Logger.debug(\"send $it\")\n    }\n    channel.close()\n}\n    \nList(3) { index ->\n    GlobalScope.launch {\n        val receiveChannel = broadcast.openSubscription()\n        for (element in receiveChannel) {\n            Logger.debug(\"[$index] receive: $element\")\n            delay(1000)\n        }\n    }\n}.forEach { it.join() }\n    \nproducer.join()\n```\n\n输出结果如下：\n\n```\n12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-7]  send 0\n12:34:59:657 [DefaultDispatcher-worker-7]  send 1\n12:34:59:658 [DefaultDispatcher-worker-7]  send 2\n12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-8]  send 3\n12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-8]  send 4\n12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3\n12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3\n12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3\n12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4\n12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4\n12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4\n```\n\n这里请大家重点关注每一个收端协程都可以读取到每一个元素。\n\n> 日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。\n\n除了直接创建以外，我们也可以直接用前面定义的普通的 `Channel` 来做个转换：\n\n```kotlin\nval channel = Channel<Int>()\nval broadcast = channel.broadcast(3)\n```\n\n其中，参数表示缓冲区的大小。\n\n实际上这里得到的这个 `broadcastChannel` 可以认为与原 `Channel` 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：\n\n```kotlin\nfun <E> ReceiveChannel<E>.broadcast(\n    capacity: Int = 1,\n    start: CoroutineStart = CoroutineStart.LAZY\n): broadcastChannel<E> =\n    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) {\n        for (e in this@broadcast) {  //这实际上就是在读取原 Channel\n            send(e)\n        }\n    }\n```\n\n哦~原来对于 `BroadcastChannel`，官方也提供类似于 `produce` 和 `actor` 的方式，我们可以通过 `CoroutineScope.broadcast` 来直接启动一个协程，并返回一个 `BroadcastChannel`。\n\n需要注意的是，从原始的 `Channel` 转换到 `BroadcastChannel` 其实就是对原 `Channel` 的一个读取操作，如果还有其他协程也在读这个原始的 `Channel`，那么会与 `BroadcastChannel` 产生互斥关系。\n\n另外，`BroadcastChannel` 相关的 API 大部分被标记为 `ExperimentalCoroutinesApi`，后续也许还会有调整。\n\n## 7. Channel 版本的序列生成器\n\n前面的文章我们讲到过 `Sequence`，它的生成器是基于标准库的协程的 API 实现的，实际上 `Channel` 本身也可以用来生成序列，例如：\n\n```kotlin\nval channel = GlobalScope.produce(Dispatchers.Unconfined) {\n    Logger.debug(\"A\")\n    send(1)\n    Logger.debug(\"B\")\n    send(2)\n    Logger.debug(\"Done\")\n}\n\nfor (item in channel) {\n    Logger.debug(\"Got $item\")\n}\n```\n\n有了前面的基础这个就很容易看懂了，`produce` 创建的协程返回了一个缓冲区大小为 0 的 `Channel`，为了问题描述起来比较容易，我们传入了一个 `Dispatchers.Unconfined` 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 `A` 并在 `send(1)` 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 `channel` 的 `iterator` 的 `hasNext` 方法的调用，这个 `hasNext` 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 `send(1)` 挂起的位置继续执行，因此会看到日志 `B` 输出，然后再挂起到 `send(2)` 这里，这时候 `hasNext` 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：\n\n```\n22:33:56:073 [main @coroutine#1]  A\n22:33:56:172 [main @coroutine#1]  B\n22:33:56:173 [main]  Got 1\n22:33:56:173 [main @coroutine#1]  Done\n22:33:56:176 [main]  Got 2\n```\n\n我们看到 `B` 居然比 `Got 1` 先输出，同样，`Done` 也比 `Got 2` 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 `hasNext` 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 `Channel` 模拟 `sequence`。如果类似的代码换作 `sequence`，是这样的：\n\n```kotlin\nval sequence = sequence {\n    Logger.debug(\"A\")\n    yield(1)\n    Logger.debug(\"B\")\n    yield(2)\n    Logger.debug(\"Done\")\n}\n\nLogger.debug(\"before sequence\")\n\nfor (item in sequence) {\n    Logger.debug(\"Got $item\")\n}\n```\n\n`sequence` 的执行顺序要直观的多，它没有调度器的概念，而且 `sequence` 的 `iterator` 的 `hasNext` 和 `next` 都不是挂起函数，在 `hasNext` 的时候同样会触发元素的查找，这时候就会触发 `sequence` 内部逻辑的执行，因此这次实际上是先触发了 `hasNext` 才会输出 A，`yield` 把 1 传出来作为 `sequence` 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：\n\n```kotlin\n22:33:55:600 [main]  A\n22:33:55:603 [main]  Got 1\n22:33:55:604 [main]  B\n22:33:55:604 [main]  Got 2\n22:33:55:604 [main]  Done\n```\n\n`sequence` 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。\n\n所以我们可以在 `Channel` 的例子里面切换不同的调度器来生成元素，例如：\n\n```kotlin\nval channel = GlobalScope.produce(Dispatchers.Unconfined) {\n    Logger.debug(1)\n    send(1)\n    withContext(Dispatchers.IO){\n        Logger.debug(2)\n        send(2)\n    }\n    Logger.debug(\"Done\")\n}\n```\n\nsequence 就不行了。\n\n当然，单纯的用 `Channel` 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。\n\n## 8. Channel 的内部结构\n\n前面我们提到 `sequence` 无法享受更上层的协程框架概念下的各种能力，还有一点 `sequence` 显然不是线程安全的，而 `Channel` 可以在并发场景下使用。\n\n`Channel` 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 `AbstractSendChannel` 当中：\n\n```kotlin\ninternal abstract class AbstractSendChannel<E> : SendChannel<E> {\n    protected val queue = LockFreeLinkedListHead()\n    ...    \n}\n```\n\n`LockFreeLinkedListHead` 本身其实就是一个双向链表的节点，实际上 `Channel` 把它首尾相连成为了循环链表，而这个 `queque` 就是哨兵(sentinel)节点。有新的元素添加时，就在 `queue` 的前面插入，实际上就相当于在整个队列的最后插入元素了。\n\n它所谓的 `LockFree` 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：\n\n```kotlin\npublic actual open class LockFreeLinkedListNode {\n    private val _next = atomic<Any>(this) // Node | Removed | OpDescriptor\n    private val _prev = atomic<Any>(this) // Node | Removed\n    ...   \n}\n```\n\n它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -> A -> B -> C 在 A 、B 之间插件 X 时会需要先修改 X -> B 再修改 A -> X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -> B -> C。\n\n这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 `LockFreeLinkedListNode` 在 Jvm 上的实现。\n\n而对于数组版本，`ArrayChannel` 就相对粗暴了，内部就是一个数组：\n\n```kotlin\n//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容\nprivate var buffer: Array<Any?> = arrayOfNulls<Any?>(min(capacity, 8))\n```\n对这个数组读写时则直接用了一个 `ReentrantLock` 进行加锁。\n\n这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 `ConcurrentHashMap` 的实现，JDK 7 的实现中对于段数组的读写采用了 `UnSafe` 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 `UnSafe` 的 CAS。\n\n> 协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。\n\n## 9. 小结\n\n`Channel` 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，`Channel` 可以让他们更加方便的协作起来。实际上 `Channel` 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 `channel`，就说 Java NIO 当中也存在 `Channel` 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-channel.md","raw":"---\ntitle:  破解 Kotlin 协程(9) - Channel 篇  \nkeywords: Kotlin 协程 Channel 生产消费者 \ndate: 2019/09/16\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> `Channel` 实际上就是协程在生产消费者模型上的应用，把过去你用 `BlockingQueue` 实现的功能替换成 `Channel`，也许会有新的发现~ \n\n<!-- more -->\n\n\n\n\n## 1. 认识 Channel \n\nChannel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：\n\n```kotlin\nsuspend fun main() {\n    val channel = Channel<Int>()\n\n    val producer = GlobalScope.launch {\n        var i = 0\n        while (true){\n            channel.send(i++)\n            delay(1000)\n        }\n    }\n\n    val consumer = GlobalScope.launch {\n        while(true){\n            val element = channel.receive()\n            Logger.debug(element)\n        }\n    }\n\n    producer.join()\n    consumer.join()\n}\n```\n\n我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。\n\n例子的运行机制是，producer 当中每隔 1s 向 `Channel` 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？\n\n## 2. Channel 的容量\n\n如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 `BlockingQueue`，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 `Channel` 的缓冲区的定义：\n\n```kotlin\npublic fun <E> Channel(capacity: Int = RENDEZVOUS): Channel<E> =\n    when (capacity) {\n        RENDEZVOUS -> RendezvousChannel()\n        UNLIMITED -> LinkedListChannel()\n        CONFLATED -> ConflatedChannel()\n        else -> ArrayChannel(capacity)\n    }\n```\n\n我们构造 `Channel` 的时候调用了一个叫 `Channel` 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。\n\n> 类似的还有 String，不信你去试试\n\n它有一个参数叫 capacity，指定缓冲区的容量，默认值 `RENDEZVOUS` 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：\n\n```kotlin\nval producer = GlobalScope.launch {\n    var i = 0\n    while (true){\n        i++ //为了方便输出日志，我们将自增放到前面\n        Logger.debug(\"before send $i\")\n        channel.send(i)\n        Logger.debug(\"before after $i\")\n        delay(1000)\n    }\n}\n\nval consumer = GlobalScope.launch {\n    while(true){\n        delay(2000) //receive 之前延迟 2s\n        val element = channel.receive()\n        Logger.debug(element)\n    }\n}\n```\n\n我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：\n\n```\n07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1\n07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1\n07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1\n07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2\n07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2\n07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2\n```\n\n`UNLIMITED` 比较好理解，来者不拒，从它给出的实现 `LinkedListChannel` 来看，这一点也与我们的 `LinkedBlockingQueue` 有异曲同工之妙。\n\n`CONFLATED`，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。\n\n剩下的就是 `ArrayChannel` 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 `ArrayBlockingQueue`。\n\n## 3. 迭代 Channel\n\n前面我们在发送和读取 `Channel` 的时候用了 `while(true)`，因为我们想要去不断的进行读写操作，`Channel` 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 `Channel` 的 iterator：\n\n```kotlin\nval consumer = GlobalScope.launch {\n    val iterator = channel.iterator()\n    while(iterator.hasNext()){ // 挂起点\n        val element = iterator.next()\n        Logger.debug(element)\n        delay(2000)\n    }\n}\n```\n\n那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 `Channel` 当中读取元素了。\n\n这个写法自然可以简化成 for each：\n\n```kotlin\nval consumer = GlobalScope.launch {\n    for (element in channel) {\n        Logger.debug(element)\n        delay(2000)\n    }\n}\n```\n\n## 4. produce 和 actor\n\n前面我们在协程外部定义 `Channel`，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者\n和消费者呢？\n\n```kotlin\nval receiveChannel: ReceiveChannel<Int> = GlobalScope.produce {\n    while(true){\n        delay(1000)\n        send(2)\n    }\n}\n```\n\n我们可以通过 `produce` 这个方法启动一个生产者协程，并返回一个 `ReceiveChannel`，其他协程就可以拿着这个 `Channel` 来接收数据了。反过来，我们可以用 `actor` 启动一个消费者协程：\n\n```kotlin\nval sendChannel: SendChannel<Int> = GlobalScope.actor<Int> {\n    while(true){\n        val element = receive()\n    }\n}\n```\n\n> ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。\n\n`produce` 和 `actor` 与 `launch` 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 `Channel` 绑定到了一起，因此 `Channel` 的关闭也会在协程结束时自动完成，以 `produce` 为例，它构造出了一个 `ProducerCoroutine` 的对象：\n\n```kotlin\ninternal open class ProducerCoroutine<E>(\n    parentContext: CoroutineContext, channel: Channel<E>\n) : ChannelCoroutine<E>(parentContext, channel, active = true), ProducerScope<E> {\n    ...\n    override fun onCompleted(value: Unit) {\n        _channel.close() // 协程完成时\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        val processed = _channel.close(cause) // 协程取消时\n        if (!processed && !handled) handleCoroutineException(context, cause)\n    }\n}\n```\n\n注意到在协程完成和取消的方法调用中，对应的 `_channel` 都会被关闭。\n\n这样看上去还是挺有用的。不过截止这俩 API `produce` 和 `actor` 目前都没有稳定，前者仍被标记为 `ExperimentalCoroutinesApi`，后者则标记为 `ObsoleteCoroutinesApi`，这就比较尴尬了，明摆着不让用嘛。`actor` 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 `actor` API 也不过就是提供了一个 `SendChannel` 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 `Flow`——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。\n\n虽然 `produce` 没有被标记为 `ObsoleteCoroutinesApi`，显然它作为 `actor` 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。\n\n## 5. Channel 的关闭\n\n前我们提到了 `produce` 和 `actor` 返回的 `Channel` 都会伴随着对应的协程执行完毕而关闭。哦，原来 `Channel` 还有一个关闭的概念。\n\n`Channel` 和我们后面的文章即将要探讨的 `Flow` 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 `Channel`，如果我们调用了它的 `close`，它会立即停止接受新元素，也就是说这时候它的 `isClosedForSend` 会立即返回 `true`，而由于 `Channel` 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 `isClosedForReceive` 才会返回 `true`。\n\n```kotlin\nval channel = Channel<Int>(3)\n\nval producer = GlobalScope.launch {\n    List(5){\n        channel.send(it)\n        Logger.debug(\"send $it\")\n    }\n    channel.close()\n    Logger.debug(\"close channel. ClosedForSend = ${channel.isClosedForSend} ClosedForReceive = ${channel.isClosedForReceive}\")\n}\n\nval consumer = GlobalScope.launch {\n    for (element in channel) {\n        Logger.debug(\"receive: $element\")\n        delay(1000)\n    }\n\n    Logger.debug(\"After Consuming. ClosedForSend = ${channel.isClosedForSend} ClosedForReceive = ${channel.isClosedForReceive}\")\n}\n```\n\n我们把例子稍作修改，开了一个缓冲区大小为 3 的 `Channel`，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 `Channel`，而在 consumer 协程当中每秒读取一个， 结果如下：\n\n```\n11:05:20:678 [DefaultDispatcher-worker-1]  send 0\n11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0\n11:05:20:678 [DefaultDispatcher-worker-1]  send 1\n11:05:20:678 [DefaultDispatcher-worker-1]  send 2\n11:05:20:678 [DefaultDispatcher-worker-1]  send 3\n11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1\n11:05:21:688 [DefaultDispatcher-worker-3]  send 4\n11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend =true ClosedForReceive = false\n11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2\n11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3\n11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4\n11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend =true ClosedForReceive = true\n```\n\n下面我们来探讨下 `Channel` 关闭的意义。\n\n一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 `Channel` 的关闭是个什么概念呢？我们前面提到过，`Channel` 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 `Channel` 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 `Channel` 了。嗯，看上去好像没什么问题是吧？\n\nBut，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 `Channel` 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：\n\n> 女：咱俩没戏，你别傻等了。\n> 男：哦。（您的消息未发送成功）\n\n那么 `Channel` 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。\n\n还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，`Channel` 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。\n\n> 扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。\n\n## 6. BroadcastChannel\n\n前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。\n\n直接创建 `broadcastChannel` 的方法跟普通的 `Channel` 似乎也没什么太多的不一样：\n\n```kotlin\nval broadcastChannel = broadcastChannel<Int>(5)\n```\n\n如果要订阅，那么只需要调用：\n\n```kotlin\nval receiveChannel = broadcastChannel.openSubscription()\n```\n\n这样我们就得到了一个 `ReceiveChannel`，获取订阅的消息，只需要调用它的 `receive`。\n\n我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：\n\n```kotlin\nval producer = GlobalScope.launch {\n    List(5) {\n        broadcastChannel.send(it)\n        Logger.debug(\"send $it\")\n    }\n    channel.close()\n}\n    \nList(3) { index ->\n    GlobalScope.launch {\n        val receiveChannel = broadcast.openSubscription()\n        for (element in receiveChannel) {\n            Logger.debug(\"[$index] receive: $element\")\n            delay(1000)\n        }\n    }\n}.forEach { it.join() }\n    \nproducer.join()\n```\n\n输出结果如下：\n\n```\n12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0\n12:34:59:656 [DefaultDispatcher-worker-7]  send 0\n12:34:59:657 [DefaultDispatcher-worker-7]  send 1\n12:34:59:658 [DefaultDispatcher-worker-7]  send 2\n12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1\n12:35:00:664 [DefaultDispatcher-worker-8]  send 3\n12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2\n12:35:01:669 [DefaultDispatcher-worker-8]  send 4\n12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3\n12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3\n12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3\n12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4\n12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4\n12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4\n```\n\n这里请大家重点关注每一个收端协程都可以读取到每一个元素。\n\n> 日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。\n\n除了直接创建以外，我们也可以直接用前面定义的普通的 `Channel` 来做个转换：\n\n```kotlin\nval channel = Channel<Int>()\nval broadcast = channel.broadcast(3)\n```\n\n其中，参数表示缓冲区的大小。\n\n实际上这里得到的这个 `broadcastChannel` 可以认为与原 `Channel` 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：\n\n```kotlin\nfun <E> ReceiveChannel<E>.broadcast(\n    capacity: Int = 1,\n    start: CoroutineStart = CoroutineStart.LAZY\n): broadcastChannel<E> =\n    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) {\n        for (e in this@broadcast) {  //这实际上就是在读取原 Channel\n            send(e)\n        }\n    }\n```\n\n哦~原来对于 `BroadcastChannel`，官方也提供类似于 `produce` 和 `actor` 的方式，我们可以通过 `CoroutineScope.broadcast` 来直接启动一个协程，并返回一个 `BroadcastChannel`。\n\n需要注意的是，从原始的 `Channel` 转换到 `BroadcastChannel` 其实就是对原 `Channel` 的一个读取操作，如果还有其他协程也在读这个原始的 `Channel`，那么会与 `BroadcastChannel` 产生互斥关系。\n\n另外，`BroadcastChannel` 相关的 API 大部分被标记为 `ExperimentalCoroutinesApi`，后续也许还会有调整。\n\n## 7. Channel 版本的序列生成器\n\n前面的文章我们讲到过 `Sequence`，它的生成器是基于标准库的协程的 API 实现的，实际上 `Channel` 本身也可以用来生成序列，例如：\n\n```kotlin\nval channel = GlobalScope.produce(Dispatchers.Unconfined) {\n    Logger.debug(\"A\")\n    send(1)\n    Logger.debug(\"B\")\n    send(2)\n    Logger.debug(\"Done\")\n}\n\nfor (item in channel) {\n    Logger.debug(\"Got $item\")\n}\n```\n\n有了前面的基础这个就很容易看懂了，`produce` 创建的协程返回了一个缓冲区大小为 0 的 `Channel`，为了问题描述起来比较容易，我们传入了一个 `Dispatchers.Unconfined` 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 `A` 并在 `send(1)` 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 `channel` 的 `iterator` 的 `hasNext` 方法的调用，这个 `hasNext` 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 `send(1)` 挂起的位置继续执行，因此会看到日志 `B` 输出，然后再挂起到 `send(2)` 这里，这时候 `hasNext` 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：\n\n```\n22:33:56:073 [main @coroutine#1]  A\n22:33:56:172 [main @coroutine#1]  B\n22:33:56:173 [main]  Got 1\n22:33:56:173 [main @coroutine#1]  Done\n22:33:56:176 [main]  Got 2\n```\n\n我们看到 `B` 居然比 `Got 1` 先输出，同样，`Done` 也比 `Got 2` 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 `hasNext` 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 `Channel` 模拟 `sequence`。如果类似的代码换作 `sequence`，是这样的：\n\n```kotlin\nval sequence = sequence {\n    Logger.debug(\"A\")\n    yield(1)\n    Logger.debug(\"B\")\n    yield(2)\n    Logger.debug(\"Done\")\n}\n\nLogger.debug(\"before sequence\")\n\nfor (item in sequence) {\n    Logger.debug(\"Got $item\")\n}\n```\n\n`sequence` 的执行顺序要直观的多，它没有调度器的概念，而且 `sequence` 的 `iterator` 的 `hasNext` 和 `next` 都不是挂起函数，在 `hasNext` 的时候同样会触发元素的查找，这时候就会触发 `sequence` 内部逻辑的执行，因此这次实际上是先触发了 `hasNext` 才会输出 A，`yield` 把 1 传出来作为 `sequence` 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：\n\n```kotlin\n22:33:55:600 [main]  A\n22:33:55:603 [main]  Got 1\n22:33:55:604 [main]  B\n22:33:55:604 [main]  Got 2\n22:33:55:604 [main]  Done\n```\n\n`sequence` 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。\n\n所以我们可以在 `Channel` 的例子里面切换不同的调度器来生成元素，例如：\n\n```kotlin\nval channel = GlobalScope.produce(Dispatchers.Unconfined) {\n    Logger.debug(1)\n    send(1)\n    withContext(Dispatchers.IO){\n        Logger.debug(2)\n        send(2)\n    }\n    Logger.debug(\"Done\")\n}\n```\n\nsequence 就不行了。\n\n当然，单纯的用 `Channel` 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。\n\n## 8. Channel 的内部结构\n\n前面我们提到 `sequence` 无法享受更上层的协程框架概念下的各种能力，还有一点 `sequence` 显然不是线程安全的，而 `Channel` 可以在并发场景下使用。\n\n`Channel` 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 `AbstractSendChannel` 当中：\n\n```kotlin\ninternal abstract class AbstractSendChannel<E> : SendChannel<E> {\n    protected val queue = LockFreeLinkedListHead()\n    ...    \n}\n```\n\n`LockFreeLinkedListHead` 本身其实就是一个双向链表的节点，实际上 `Channel` 把它首尾相连成为了循环链表，而这个 `queque` 就是哨兵(sentinel)节点。有新的元素添加时，就在 `queue` 的前面插入，实际上就相当于在整个队列的最后插入元素了。\n\n它所谓的 `LockFree` 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：\n\n```kotlin\npublic actual open class LockFreeLinkedListNode {\n    private val _next = atomic<Any>(this) // Node | Removed | OpDescriptor\n    private val _prev = atomic<Any>(this) // Node | Removed\n    ...   \n}\n```\n\n它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -> A -> B -> C 在 A 、B 之间插件 X 时会需要先修改 X -> B 再修改 A -> X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -> B -> C。\n\n这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 `LockFreeLinkedListNode` 在 Jvm 上的实现。\n\n而对于数组版本，`ArrayChannel` 就相对粗暴了，内部就是一个数组：\n\n```kotlin\n//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容\nprivate var buffer: Array<Any?> = arrayOfNulls<Any?>(min(capacity, 8))\n```\n对这个数组读写时则直接用了一个 `ReentrantLock` 进行加锁。\n\n这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 `ConcurrentHashMap` 的实现，JDK 7 的实现中对于段数组的读写采用了 `UnSafe` 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 `UnSafe` 的 CAS。\n\n> 协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。\n\n## 9. 小结\n\n`Channel` 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，`Channel` 可以让他们更加方便的协作起来。实际上 `Channel` 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 `channel`，就说 Java NIO 当中也存在 `Channel` 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-channel","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0032000mlduzdvynbshc","content":"<blockquote>\n<p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-认识-Channel\"><a href=\"#1-认识-Channel\" class=\"headerlink\" title=\"1. 认识 Channel\"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            channel.send(i++)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> element = channel.receive()</span><br><span class=\"line\">            Logger.debug(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    producer.join()</span><br><span class=\"line\">    consumer.join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p>\n<p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p>\n<h2 id=\"2-Channel-的容量\"><a href=\"#2-Channel-的容量\" class=\"headerlink\" title=\"2. Channel 的容量\"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> <span class=\"title\">Channel</span><span class=\"params\">(capacity: <span class=\"type\">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (capacity) &#123;</span><br><span class=\"line\">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class=\"line\">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class=\"line\">        CONFLATED -&gt; ConflatedChannel()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; ArrayChannel(capacity)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p>\n<blockquote>\n<p>类似的还有 String，不信你去试试</p>\n</blockquote>\n<p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        i++ <span class=\"comment\">//为了方便输出日志，我们将自增放到前面</span></span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;before send <span class=\"variable\">$i</span>&quot;</span>)</span><br><span class=\"line\">        channel.send(i)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;before after <span class=\"variable\">$i</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>) <span class=\"comment\">//receive 之前延迟 2s</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = channel.receive()</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class=\"line\">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class=\"line\">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class=\"line\">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class=\"line\">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class=\"line\">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure>\n\n<p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p>\n<p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p>\n<p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p>\n<h2 id=\"3-迭代-Channel\"><a href=\"#3-迭代-Channel\" class=\"headerlink\" title=\"3. 迭代 Channel\"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> iterator = channel.iterator()</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext())&#123; <span class=\"comment\">// 挂起点</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = iterator.next()</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p>\n<p>这个写法自然可以简化成 for each：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-produce-和-actor\"><a href=\"#4-produce-和-actor\" class=\"headerlink\" title=\"4. produce 和 actor\"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> receiveChannel: ReceiveChannel&lt;<span class=\"built_in\">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sendChannel: SendChannel&lt;<span class=\"built_in\">Int</span>&gt; = GlobalScope.actor&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = receive()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p>\n</blockquote>\n<p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerCoroutine</span>&lt;<span class=\"type\">E</span>&gt;</span>(</span><br><span class=\"line\">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class=\"line\">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class=\"literal\">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCompleted</span><span class=\"params\">(value: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        _channel.close() <span class=\"comment\">// 协程完成时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCancelled</span><span class=\"params\">(cause: <span class=\"type\">Throwable</span>, handled: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> processed = _channel.close(cause) <span class=\"comment\">// 协程取消时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p>\n<p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p>\n<p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p>\n<h2 id=\"5-Channel-的关闭\"><a href=\"#5-Channel-的关闭\" class=\"headerlink\" title=\"5. Channel 的关闭\"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p>\n<p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    List(<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        channel.send(it)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;send <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.close()</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;close channel. ClosedForSend = <span class=\"subst\">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class=\"subst\">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;receive: <span class=\"variable\">$element</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;After Consuming. ClosedForSend = <span class=\"subst\">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class=\"subst\">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class=\"line\">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class=\"line\">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class=\"line\">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend &#x3D;true ClosedForReceive &#x3D; false</span><br><span class=\"line\">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class=\"line\">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class=\"line\">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class=\"line\">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend &#x3D;true ClosedForReceive &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p>\n<p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p>\n<p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p>\n<blockquote>\n<p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p>\n</blockquote>\n<p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p>\n<p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p>\n<blockquote>\n<p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p>\n</blockquote>\n<h2 id=\"6-BroadcastChannel\"><a href=\"#6-BroadcastChannel\" class=\"headerlink\" title=\"6. BroadcastChannel\"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p>\n<p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> broadcastChannel = broadcastChannel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果要订阅，那么只需要调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p>\n<p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    List(<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        broadcastChannel.send(it)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;send <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">List(<span class=\"number\">3</span>) &#123; index -&gt;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> receiveChannel) &#123;</span><br><span class=\"line\">            Logger.debug(<span class=\"string\">&quot;[<span class=\"variable\">$index</span>] receive: <span class=\"variable\">$element</span>&quot;</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.forEach &#123; it.join() &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">producer.join()</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class=\"line\">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class=\"line\">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class=\"line\">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class=\"line\">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class=\"line\">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure>\n\n<p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p>\n<blockquote>\n<p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p>\n</blockquote>\n<p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br><span class=\"line\"><span class=\"keyword\">val</span> broadcast = channel.broadcast(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，参数表示缓冲区的大小。</p>\n<p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> ReceiveChannel<span class=\"type\">&lt;E&gt;</span>.<span class=\"title\">broadcast</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    capacity: <span class=\"type\">Int</span> = <span class=\"number\">1</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class=\"line\">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (e <span class=\"keyword\">in</span> <span class=\"keyword\">this</span><span class=\"symbol\">@broadcast</span>) &#123;  <span class=\"comment\">//这实际上就是在读取原 Channel</span></span><br><span class=\"line\">            send(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p>\n<p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p>\n<p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p>\n<h2 id=\"7-Channel-版本的序列生成器\"><a href=\"#7-Channel-版本的序列生成器\" class=\"headerlink\" title=\"7. Channel 版本的序列生成器\"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\">    send(<span class=\"number\">1</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;B&quot;</span>)</span><br><span class=\"line\">    send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Got <span class=\"variable\">$item</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:33:56:073 [main @coroutine#1]  A</span><br><span class=\"line\">22:33:56:172 [main @coroutine#1]  B</span><br><span class=\"line\">22:33:56:173 [main]  Got 1</span><br><span class=\"line\">22:33:56:173 [main @coroutine#1]  Done</span><br><span class=\"line\">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure>\n\n<p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sequence = sequence &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\">    yield(<span class=\"number\">1</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;B&quot;</span>)</span><br><span class=\"line\">    yield(<span class=\"number\">2</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Logger.debug(<span class=\"string\">&quot;before sequence&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> sequence) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Got <span class=\"variable\">$item</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">600</span> [main]  A</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">603</span> [main]  Got <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  B</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  Got <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  Done</span><br></pre></td></tr></table></figure>\n\n<p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p>\n<p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"number\">1</span>)</span><br><span class=\"line\">    send(<span class=\"number\">1</span>)</span><br><span class=\"line\">    withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">        Logger.debug(<span class=\"number\">2</span>)</span><br><span class=\"line\">        send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sequence 就不行了。</p>\n<p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p>\n<h2 id=\"8-Channel-的内部结构\"><a href=\"#8-Channel-的内部结构\" class=\"headerlink\" title=\"8. Channel 的内部结构\"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p>\n<p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractSendChannel</span>&lt;<span class=\"type\">E</span>&gt; : <span class=\"type\">SendChannel</span>&lt;<span class=\"type\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">val</span> queue = LockFreeLinkedListHead()</span><br><span class=\"line\">    ...    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p>\n<p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockFreeLinkedListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _next = atomic&lt;Any&gt;(<span class=\"keyword\">this</span>) <span class=\"comment\">// Node | Removed | OpDescriptor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _prev = atomic&lt;Any&gt;(<span class=\"keyword\">this</span>) <span class=\"comment\">// Node | Removed</span></span><br><span class=\"line\">    ...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p>\n<p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p>\n<p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class=\"number\">8</span>))</span><br></pre></td></tr></table></figure>\n<p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p>\n<p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p>\n<blockquote>\n<p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p>\n</blockquote>\n<h2 id=\"9-小结\"><a href=\"#9-小结\" class=\"headerlink\" title=\"9. 小结\"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#105;&#x6d;&#x6f;&#111;&#x63;&#x2e;&#x63;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#105;&#x6d;&#x6f;&#111;&#x63;&#x2e;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><code>Channel</code> 实际上就是协程在生产消费者模型上的应用，把过去你用 <code>BlockingQueue</code> 实现的功能替换成 <code>Channel</code>，也许会有新的发现~ </p>\n</blockquote>","more":"<h2 id=\"1-认识-Channel\"><a href=\"#1-认识-Channel\" class=\"headerlink\" title=\"1. 认识 Channel\"></a>1. 认识 Channel</h2><p>Channel 实际上就是一个队列，而且是并发安全的，它可以用来连接协程，实现不同协程的通信。废话不多说，直接看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            channel.send(i++)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> element = channel.receive()</span><br><span class=\"line\">            Logger.debug(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    producer.join()</span><br><span class=\"line\">    consumer.join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们构造了两个协程，分别叫他们 producer 和 consumer，我们没有明确的指定调度器，所以他们的调度器都是默认的，在 Java 虚拟机上就是那个大家都很熟悉的线程池：他们可以运行在不同的线程上，当然也可以运行在同一个线程上。</p>\n<p>例子的运行机制是，producer 当中每隔 1s 向 <code>Channel</code> 中发送一个数字，而 consumer 那边则是一直在读取 Channel 来获取这个数字并打印，我们能够发现这里发端是比收端慢的，在没有值可以读到的时候，receive 是挂起的，直到有新元素 send 过来——所以你知道了 receive 是一个挂起函数，那么 send 呢？</p>\n<h2 id=\"2-Channel-的容量\"><a href=\"#2-Channel-的容量\" class=\"headerlink\" title=\"2. Channel 的容量\"></a>2. Channel 的容量</h2><p>如果你自己去 IDE 写了这段代码，你会发现 send 也是挂起函数。额，发端为什么会挂起？想想我们以前熟知的 <code>BlockingQueue</code>，我们往里面添加元素的时候，元素在队列里实际上是占用了空间的，如果这个队列空间不足，那么再往里面添加的时候就是两种情况：1. 阻塞，等待队列腾出空间；2. 抛异常，拒绝添加元素。send 也会面临同样的问题，我们说 Channel 实际上就是一个队列嘛，队列不应该有缓冲区吗，那么这个缓冲区一旦满了，并且也一直没有人调用 receive 取走元素的话，send 不就挂起了嘛。那么接下来我们看下 <code>Channel</code> 的缓冲区的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> <span class=\"title\">Channel</span><span class=\"params\">(capacity: <span class=\"type\">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (capacity) &#123;</span><br><span class=\"line\">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class=\"line\">        UNLIMITED -&gt; LinkedListChannel()</span><br><span class=\"line\">        CONFLATED -&gt; ConflatedChannel()</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; ArrayChannel(capacity)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们构造 <code>Channel</code> 的时候调用了一个叫 <code>Channel</code> 的函数，hmm，这玩意儿确实不是它的构造器，在 Kotlin 当中我们可以随便定义一个顶级函数跟某些类名一样来伪装成构造器，这本质上就是个工厂方法。</p>\n<blockquote>\n<p>类似的还有 String，不信你去试试</p>\n</blockquote>\n<p>它有一个参数叫 capacity，指定缓冲区的容量，默认值 <code>RENDEZVOUS</code> 就是 0，这个词本意就是描述“不见不散”的场景，所以你不来 receive，我这 send 就一直搁这儿挂起等着。换句话说，我们开头的例子里面，如果 consumer 不 receive，producer 里面的第一个 send 就给挂起了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        i++ <span class=\"comment\">//为了方便输出日志，我们将自增放到前面</span></span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;before send <span class=\"variable\">$i</span>&quot;</span>)</span><br><span class=\"line\">        channel.send(i)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;before after <span class=\"variable\">$i</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>) <span class=\"comment\">//receive 之前延迟 2s</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = channel.receive()</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们故意让收端的节奏放慢，你就会发现，send 总是会挂起，直到 receive 之后才会继续往下执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">07:11:23:119 [DefaultDispatcher-worker-2 @coroutine#1]  before send 1</span><br><span class=\"line\">07:11:24:845 [DefaultDispatcher-worker-2 @coroutine#2]  1</span><br><span class=\"line\">07:11:24:846 [DefaultDispatcher-worker-2 @coroutine#1]  before after 1</span><br><span class=\"line\">07:11:25:849 [DefaultDispatcher-worker-4 @coroutine#1]  before send 2</span><br><span class=\"line\">07:11:26:850 [DefaultDispatcher-worker-2 @coroutine#2]  2</span><br><span class=\"line\">07:11:26:850 [DefaultDispatcher-worker-3 @coroutine#1]  before after 2</span><br></pre></td></tr></table></figure>\n\n<p><code>UNLIMITED</code> 比较好理解，来者不拒，从它给出的实现 <code>LinkedListChannel</code> 来看，这一点也与我们的 <code>LinkedBlockingQueue</code> 有异曲同工之妙。</p>\n<p><code>CONFLATED</code>，这个词是合并的意思，跟 inflate 是同一个词根，con- 前缀表示反着来，那是不是说我发了个 1、2、3、4、5 那边收的时候就会收到一个 [1,2,3,4,5] 的集合呢？毕竟字面意思是合并嘛。但实际上这个的效果是只保留最后一个元素，不是合并，应该是置换，换句话说，这个类型的 Channel 有一个元素大小的缓冲区，但每次有新元素过来，都会用新的替换旧的，也就是说我发了个 1、2、3、4、5 之后收端才接收的话，就只能收到 5 了。</p>\n<p>剩下的就是 <code>ArrayChannel</code> 了，它接收一个值作为缓冲区容量的大小，这也比较类似于 <code>ArrayBlockingQueue</code>。</p>\n<h2 id=\"3-迭代-Channel\"><a href=\"#3-迭代-Channel\" class=\"headerlink\" title=\"3. 迭代 Channel\"></a>3. 迭代 Channel</h2><p>前面我们在发送和读取 <code>Channel</code> 的时候用了 <code>while(true)</code>，因为我们想要去不断的进行读写操作，<code>Channel</code> 本身实际上也有点儿像序列，可以一个一个读，所以我们在读取的时候也可以直接获取一个 <code>Channel</code> 的 iterator：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> iterator = channel.iterator()</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext())&#123; <span class=\"comment\">// 挂起点</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = iterator.next()</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这个时候，iterator.hasNext() 是挂起函数，在判断是否有下一个元素的时候实际上就需要去 <code>Channel</code> 当中读取元素了。</p>\n<p>这个写法自然可以简化成 for each：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">        Logger.debug(element)</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-produce-和-actor\"><a href=\"#4-produce-和-actor\" class=\"headerlink\" title=\"4. produce 和 actor\"></a>4. produce 和 actor</h2><p>前面我们在协程外部定义 <code>Channel</code>，并在协程当中访问它，实现了一个简单的生产-消费者的示例，那么有没有便捷的办法构造生产者<br>和消费者呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> receiveChannel: ReceiveChannel&lt;<span class=\"built_in\">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 <code>produce</code> 这个方法启动一个生产者协程，并返回一个 <code>ReceiveChannel</code>，其他协程就可以拿着这个 <code>Channel</code> 来接收数据了。反过来，我们可以用 <code>actor</code> 启动一个消费者协程：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sendChannel: SendChannel&lt;<span class=\"built_in\">Int</span>&gt; = GlobalScope.actor&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> element = receive()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ReceiveChannel 和 SendChannel 都是 Channel 的父接口，前者定义了 receive，后者定义了 send，Channel 也因此既可以 receive 又可以 send。</p>\n</blockquote>\n<p><code>produce</code> 和 <code>actor</code> 与 <code>launch</code> 一样都被称作“协程启动器”。通过这两个协程的启动器启动的协程也自然的与返回的 <code>Channel</code> 绑定到了一起，因此 <code>Channel</code> 的关闭也会在协程结束时自动完成，以 <code>produce</code> 为例，它构造出了一个 <code>ProducerCoroutine</code> 的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerCoroutine</span>&lt;<span class=\"type\">E</span>&gt;</span>(</span><br><span class=\"line\">    parentContext: CoroutineContext, channel: Channel&lt;E&gt;</span><br><span class=\"line\">) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class=\"literal\">true</span>), ProducerScope&lt;E&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCompleted</span><span class=\"params\">(value: <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">        _channel.close() <span class=\"comment\">// 协程完成时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCancelled</span><span class=\"params\">(cause: <span class=\"type\">Throwable</span>, handled: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> processed = _channel.close(cause) <span class=\"comment\">// 协程取消时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到在协程完成和取消的方法调用中，对应的 <code>_channel</code> 都会被关闭。</p>\n<p>这样看上去还是挺有用的。不过截止这俩 API <code>produce</code> 和 <code>actor</code> 目前都没有稳定，前者仍被标记为 <code>ExperimentalCoroutinesApi</code>，后者则标记为 <code>ObsoleteCoroutinesApi</code>，这就比较尴尬了，明摆着不让用嘛。<code>actor</code> 的文档中提到的 issue 的讨论也说明相比基于 Actor 模型的并发框架，Kotlin 协程提供的这个 <code>actor</code> API 也不过就是提供了一个 <code>SendChannel</code> 的返回值而已。当然，协程的负责人也有实现一套更复杂的 Actor 的想法，只是这一段时间的高优明显是 <code>Flow</code>——这货从协程框架的 v1.2 开始公测，到协程 v1.3 就稳定，真是神速，我们后面的文章会介绍它。</p>\n<p>虽然 <code>produce</code> 没有被标记为 <code>ObsoleteCoroutinesApi</code>，显然它作为 <code>actor</code> 的另一半，不可能单独转正的，这俩 API 我的建议是看看就好了。</p>\n<h2 id=\"5-Channel-的关闭\"><a href=\"#5-Channel-的关闭\" class=\"headerlink\" title=\"5. Channel 的关闭\"></a>5. Channel 的关闭</h2><p>前我们提到了 <code>produce</code> 和 <code>actor</code> 返回的 <code>Channel</code> 都会伴随着对应的协程执行完毕而关闭。哦，原来 <code>Channel</code> 还有一个关闭的概念。</p>\n<p><code>Channel</code> 和我们后面的文章即将要探讨的 <code>Flow</code> 不同，它是在线的，是一个热数据源，换句话说就是有想要收数据，就要有人在对面给他发，就像发微信一样。既然这样，就难免曲终人散，对于一个 <code>Channel</code>，如果我们调用了它的 <code>close</code>，它会立即停止接受新元素，也就是说这时候它的 <code>isClosedForSend</code> 会立即返回 <code>true</code>，而由于 <code>Channel</code> 缓冲区的存在，这时候可能还有一些元素没有被处理完，所以要等所有的元素都被读取之后 <code>isClosedForReceive</code> 才会返回 <code>true</code>。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    List(<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        channel.send(it)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;send <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.close()</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;close channel. ClosedForSend = <span class=\"subst\">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class=\"subst\">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> consumer = GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;receive: <span class=\"variable\">$element</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;After Consuming. ClosedForSend = <span class=\"subst\">$&#123;channel.isClosedForSend&#125;</span> ClosedForReceive = <span class=\"subst\">$&#123;channel.isClosedForReceive&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们把例子稍作修改，开了一个缓冲区大小为 3 的 <code>Channel</code>，在 producer 协程里面快速的发送元素出去，发送5个之后关闭 <code>Channel</code>，而在 consumer 协程当中每秒读取一个， 结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 0</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-3]  receive: 0</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 1</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 2</span><br><span class=\"line\">11:05:20:678 [DefaultDispatcher-worker-1]  send 3</span><br><span class=\"line\">11:05:21:688 [DefaultDispatcher-worker-3]  receive: 1</span><br><span class=\"line\">11:05:21:688 [DefaultDispatcher-worker-3]  send 4</span><br><span class=\"line\">11:05:21:689 [DefaultDispatcher-worker-3]  close channel. ClosedForSend &#x3D;true ClosedForReceive &#x3D; false</span><br><span class=\"line\">11:05:22:693 [DefaultDispatcher-worker-3]  receive: 2</span><br><span class=\"line\">11:05:23:694 [DefaultDispatcher-worker-4]  receive: 3</span><br><span class=\"line\">11:05:24:698 [DefaultDispatcher-worker-4]  receive: 4</span><br><span class=\"line\">11:05:25:700 [DefaultDispatcher-worker-4]  After Consuming. ClosedForSend &#x3D;true ClosedForReceive &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来探讨下 <code>Channel</code> 关闭的意义。</p>\n<p>一说起关闭，我们就容易想到 IO，如果不关闭可能造成资源泄露，那么 <code>Channel</code> 的关闭是个什么概念呢？我们前面提到过，<code>Channel</code> 其实内部的资源就是个缓冲区，这个东西本质上就是个线性表，就是一块儿内存，所以如果我们开了一个 <code>Channel</code> 而不去关闭它，其实也不会造成什么资源泄露，发端如果自己已经发完，它就可以不理会这个 <code>Channel</code> 了。嗯，看上去好像没什么问题是吧？</p>\n<p>But，这时候在接收端就比较尴尬了，它不知道会不会有数据发过来，如果 <code>Channel</code> 是微信，那么接收端打开微信的窗口可能一直看到的是『对方正在输入』，然后它就一直这样了，孤独终老。所以这里的关闭更多像是一种约定：</p>\n<blockquote>\n<p>女：咱俩没戏，你别傻等了。<br>男：哦。（您的消息未发送成功）</p>\n</blockquote>\n<p>那么 <code>Channel</code> 的关闭究竟应该有谁来处理呢？正常的通信，如果是单向的，就好比领导讲话，讲完都会说『我讲完了』，你不能在领导还没讲完的时候就说『我听完了』，所以单向通信的情况比较推荐由发端处理关闭；而对于双向通信的情况，就要考虑协商了，双向通信从技术上两端是对等的，但业务场景下通常来说不是，建议由主导的一方处理关闭。</p>\n<p>还有一些复杂的情况，前面我们看到的例子都是一对一的收发，其实还有一对多，多对多的情况，这种也仍然存在主导一方，<code>Channel</code> 的生命周期最好由主导方来维护。官方文档给出的扇入(fan-in)和扇出(fan-out)，其实就是这种情况。</p>\n<blockquote>\n<p>扇入和扇出的概念可能大家不是很熟悉，网上的说法不是很通俗，大家就想象它是一把折扇，折扇的边射向圆心就是扇入，这种情况圆心如果是通信的一端，那它就是接收方，如果是一个函数，那它就是被调用方。扇入越大，说明模块的复用程度越高，以函数为例，如果一个函数被调用的次数越多，那说明复用的程度越高。扇出就是反过来的情况，描述的是复杂度高的情形，例如一个 Model，负责调用网络模块、数据库、文件等很多模块。</p>\n</blockquote>\n<h2 id=\"6-BroadcastChannel\"><a href=\"#6-BroadcastChannel\" class=\"headerlink\" title=\"6. BroadcastChannel\"></a>6. BroadcastChannel</h2><p>前面提到了一对多的情形，从数据处理的本身来讲，虽然有多个接收端，同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。</p>\n<p>直接创建 <code>broadcastChannel</code> 的方法跟普通的 <code>Channel</code> 似乎也没什么太多的不一样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> broadcastChannel = broadcastChannel&lt;<span class=\"built_in\">Int</span>&gt;(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果要订阅，那么只需要调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就得到了一个 <code>ReceiveChannel</code>，获取订阅的消息，只需要调用它的 <code>receive</code>。</p>\n<p>我们看一个完整一点儿的例子，例子中我们在发端发送 1 - 5，并启动 3 个协程同时接收广播：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> producer = GlobalScope.launch &#123;</span><br><span class=\"line\">    List(<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        broadcastChannel.send(it)</span><br><span class=\"line\">        Logger.debug(<span class=\"string\">&quot;send <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">List(<span class=\"number\">3</span>) &#123; index -&gt;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> receiveChannel = broadcast.openSubscription()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> receiveChannel) &#123;</span><br><span class=\"line\">            Logger.debug(<span class=\"string\">&quot;[<span class=\"variable\">$index</span>] receive: <span class=\"variable\">$element</span>&quot;</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.forEach &#123; it.join() &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">producer.join()</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-6]  [2] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-3]  [1] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-5]  [0] receive: 0</span><br><span class=\"line\">12:34:59:656 [DefaultDispatcher-worker-7]  send 0</span><br><span class=\"line\">12:34:59:657 [DefaultDispatcher-worker-7]  send 1</span><br><span class=\"line\">12:34:59:658 [DefaultDispatcher-worker-7]  send 2</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-3]  [0] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-5]  [1] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-6]  [2] receive: 1</span><br><span class=\"line\">12:35:00:664 [DefaultDispatcher-worker-8]  send 3</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-8]  [0] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-3]  [1] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-6]  [2] receive: 2</span><br><span class=\"line\">12:35:01:669 [DefaultDispatcher-worker-8]  send 4</span><br><span class=\"line\">12:35:02:674 [DefaultDispatcher-worker-8]  [0] receive: 3</span><br><span class=\"line\">12:35:02:674 [DefaultDispatcher-worker-7]  [1] receive: 3</span><br><span class=\"line\">12:35:02:675 [DefaultDispatcher-worker-3]  [2] receive: 3</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-8]  [1] receive: 4</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-3]  [0] receive: 4</span><br><span class=\"line\">12:35:03:678 [DefaultDispatcher-worker-1]  [2] receive: 4</span><br></pre></td></tr></table></figure>\n\n<p>这里请大家重点关注每一个收端协程都可以读取到每一个元素。</p>\n<blockquote>\n<p>日志顺序不能非常直观的反映数据的读写顺序，如果大家自己再次运行，顺序上可能也有出入。</p>\n</blockquote>\n<p>除了直接创建以外，我们也可以直接用前面定义的普通的 <code>Channel</code> 来做个转换：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = Channel&lt;<span class=\"built_in\">Int</span>&gt;()</span><br><span class=\"line\"><span class=\"keyword\">val</span> broadcast = channel.broadcast(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，参数表示缓冲区的大小。</p>\n<p>实际上这里得到的这个 <code>broadcastChannel</code> 可以认为与原 <code>Channel</code> 是级联关系，这个扩展方法的源码其实很清晰的为我们展示了这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> ReceiveChannel<span class=\"type\">&lt;E&gt;</span>.<span class=\"title\">broadcast</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    capacity: <span class=\"type\">Int</span> = <span class=\"number\">1</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.LAZY</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: broadcastChannel&lt;E&gt; =</span><br><span class=\"line\">    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (e <span class=\"keyword\">in</span> <span class=\"keyword\">this</span><span class=\"symbol\">@broadcast</span>) &#123;  <span class=\"comment\">//这实际上就是在读取原 Channel</span></span><br><span class=\"line\">            send(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>哦~原来对于 <code>BroadcastChannel</code>，官方也提供类似于 <code>produce</code> 和 <code>actor</code> 的方式，我们可以通过 <code>CoroutineScope.broadcast</code> 来直接启动一个协程，并返回一个 <code>BroadcastChannel</code>。</p>\n<p>需要注意的是，从原始的 <code>Channel</code> 转换到 <code>BroadcastChannel</code> 其实就是对原 <code>Channel</code> 的一个读取操作，如果还有其他协程也在读这个原始的 <code>Channel</code>，那么会与 <code>BroadcastChannel</code> 产生互斥关系。</p>\n<p>另外，<code>BroadcastChannel</code> 相关的 API 大部分被标记为 <code>ExperimentalCoroutinesApi</code>，后续也许还会有调整。</p>\n<h2 id=\"7-Channel-版本的序列生成器\"><a href=\"#7-Channel-版本的序列生成器\" class=\"headerlink\" title=\"7. Channel 版本的序列生成器\"></a>7. Channel 版本的序列生成器</h2><p>前面的文章我们讲到过 <code>Sequence</code>，它的生成器是基于标准库的协程的 API 实现的，实际上 <code>Channel</code> 本身也可以用来生成序列，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\">    send(<span class=\"number\">1</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;B&quot;</span>)</span><br><span class=\"line\">    send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> channel) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Got <span class=\"variable\">$item</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了前面的基础这个就很容易看懂了，<code>produce</code> 创建的协程返回了一个缓冲区大小为 0 的 <code>Channel</code>，为了问题描述起来比较容易，我们传入了一个 <code>Dispatchers.Unconfined</code> 调度器，意味着协程会立即在当前协程执行到第一个挂起点，所以会立即输出 <code>A</code> 并在 <code>send(1)</code> 处挂起，直到后面的 for 循环读到第一个值时，实际上就是 <code>channel</code> 的 <code>iterator</code> 的 <code>hasNext</code> 方法的调用，这个 <code>hasNext</code> 方法会检查是否有下一个元素，是一个挂起函数，在检查的过程中就会让前面启动的协程从 <code>send(1)</code> 挂起的位置继续执行，因此会看到日志 <code>B</code> 输出，然后再挂起到 <code>send(2)</code> 这里，这时候 <code>hasNext</code> 结束挂起，for 循环终于输出第一个元素，依次类推。输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:33:56:073 [main @coroutine#1]  A</span><br><span class=\"line\">22:33:56:172 [main @coroutine#1]  B</span><br><span class=\"line\">22:33:56:173 [main]  Got 1</span><br><span class=\"line\">22:33:56:173 [main @coroutine#1]  Done</span><br><span class=\"line\">22:33:56:176 [main]  Got 2</span><br></pre></td></tr></table></figure>\n\n<p>我们看到 <code>B</code> 居然比 <code>Got 1</code> 先输出，同样，<code>Done</code> 也比 <code>Got 2</code> 先输出，这个看上去比较不符合直觉，不过挂起恢复的执行顺序确实如此，关键点就是我们前面提到的 <code>hasNext</code> 方法会挂起并触发了协程内部从挂起点继续执行的操作。如果你选择了其他调度器，当然也会有其他合理的结果输出。不管怎么样，我们体验了一把用 <code>Channel</code> 模拟 <code>sequence</code>。如果类似的代码换作 <code>sequence</code>，是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> sequence = sequence &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\">    yield(<span class=\"number\">1</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;B&quot;</span>)</span><br><span class=\"line\">    yield(<span class=\"number\">2</span>)</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Logger.debug(<span class=\"string\">&quot;before sequence&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (item <span class=\"keyword\">in</span> sequence) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Got <span class=\"variable\">$item</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sequence</code> 的执行顺序要直观的多，它没有调度器的概念，而且 <code>sequence</code> 的 <code>iterator</code> 的 <code>hasNext</code> 和 <code>next</code> 都不是挂起函数，在 <code>hasNext</code> 的时候同样会触发元素的查找，这时候就会触发 <code>sequence</code> 内部逻辑的执行，因此这次实际上是先触发了 <code>hasNext</code> 才会输出 A，<code>yield</code> 把 1 传出来作为 <code>sequence</code> 的第一个元素，这样就会有 Got 1 这样的输出，完整输出如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">600</span> [main]  A</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">603</span> [main]  Got <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  B</span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  Got <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">33</span>:<span class=\"number\">55</span>:<span class=\"number\">604</span> [main]  Done</span><br></pre></td></tr></table></figure>\n\n<p><code>sequence</code> 本质上就是基于标准库的协程 API 实现的，没有上层协程框架的作用域以及 Job 这样的概念。</p>\n<p>所以我们可以在 <code>Channel</code> 的例子里面切换不同的调度器来生成元素，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channel = GlobalScope.produce(Dispatchers.Unconfined) &#123;</span><br><span class=\"line\">    Logger.debug(<span class=\"number\">1</span>)</span><br><span class=\"line\">    send(<span class=\"number\">1</span>)</span><br><span class=\"line\">    withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">        Logger.debug(<span class=\"number\">2</span>)</span><br><span class=\"line\">        send(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Logger.debug(<span class=\"string\">&quot;Done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sequence 就不行了。</p>\n<p>当然，单纯的用 <code>Channel</code> 当做序列生成器来使用有点儿小题大做，这里更多的是告诉大家存在这样的可能性，大家在将来遇到合适的场景时，就可以灵活运用了。</p>\n<h2 id=\"8-Channel-的内部结构\"><a href=\"#8-Channel-的内部结构\" class=\"headerlink\" title=\"8. Channel 的内部结构\"></a>8. Channel 的内部结构</h2><p>前面我们提到 <code>sequence</code> 无法享受更上层的协程框架概念下的各种能力，还有一点 <code>sequence</code> 显然不是线程安全的，而 <code>Channel</code> 可以在并发场景下使用。</p>\n<p><code>Channel</code> 内部结构我们主要说下缓冲区分别是链表和数组的版本。链表版本的定义主要是在 <code>AbstractSendChannel</code> 当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractSendChannel</span>&lt;<span class=\"type\">E</span>&gt; : <span class=\"type\">SendChannel</span>&lt;<span class=\"type\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">val</span> queue = LockFreeLinkedListHead()</span><br><span class=\"line\">    ...    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LockFreeLinkedListHead</code> 本身其实就是一个双向链表的节点，实际上 <code>Channel</code> 把它首尾相连成为了循环链表，而这个 <code>queque</code> 就是哨兵(sentinel)节点。有新的元素添加时，就在 <code>queue</code> 的前面插入，实际上就相当于在整个队列的最后插入元素了。</p>\n<p>它所谓的 <code>LockFree</code> 在 Java 虚拟机上其实是通过原子读写来实现的， 对于链表来说，需要修改的无非就是前后节点的引用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockFreeLinkedListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _next = atomic&lt;Any&gt;(<span class=\"keyword\">this</span>) <span class=\"comment\">// Node | Removed | OpDescriptor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _prev = atomic&lt;Any&gt;(<span class=\"keyword\">this</span>) <span class=\"comment\">// Node | Removed</span></span><br><span class=\"line\">    ...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的实现基于一篇论文中提到的无锁链表的实现，由于 CAS 原子操作通常只能修改一个引用，对于需要原子同时修改前后节点引用的情形是不适用的，例如单链表插入节点时需要修改两个引用，分别是操作节点的前一个节点的 next 和自己的 next，即 Head -&gt; A -&gt; B -&gt; C 在 A 、B 之间插件 X 时会需要先修改 X -&gt; B 再修改 A -&gt; X，如果这个过程中 A 被删除，那么可能的结果是 X 一并被删除，得到的链表是 Head -&gt; B -&gt; C。</p>\n<p>这个无锁链表的实现通过引入 prev 来辅助解决这个问题，即在 A 被删除的问题发生的同时，其实我们是可以做到 X.next = B，X.prev = A 的，这时候判断如果 A 已经被移除了，那么 B.prev 本来是 A，结果就变成了 Head，这时候就可以将 X.prev 再次赋值为 B.prev 来修复，当然这个过程稍稍有些复杂，有兴趣的同学也可以参考 <code>LockFreeLinkedListNode</code> 在 Jvm 上的实现。</p>\n<p>而对于数组版本，<code>ArrayChannel</code> 就相对粗暴了，内部就是一个数组：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缓冲区大小大于 8，会先分配大小为 8 的数组，在后续进行扩容</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class=\"number\">8</span>))</span><br></pre></td></tr></table></figure>\n<p>对这个数组读写时则直接用了一个 <code>ReentrantLock</code> 进行加锁。</p>\n<p>这里是不是有优化的空间呢？其实对于数组的元素，我们同样可以进行 CAS 读写，如果大家有兴趣，可以参考下 <code>ConcurrentHashMap</code> 的实现，JDK 7 的实现中对于段数组的读写采用了 <code>UnSafe</code> 的 CAS 读写，JDK 1.8 直接干掉了分段，对于桶的读写也采用了 <code>UnSafe</code> 的 CAS。</p>\n<blockquote>\n<p>协程在 Js 和 Native 上的实现就要简单得多，因为它们的协程都只是在单线程上运行，基本不需要处理并发问题。</p>\n</blockquote>\n<h2 id=\"9-小结\"><a href=\"#9-小结\" class=\"headerlink\" title=\"9. 小结\"></a>9. 小结</h2><p><code>Channel</code> 的出现，应该说为协程注入了灵魂。每一个独立的协程不再是孤独的个体，<code>Channel</code> 可以让他们更加方便的协作起来。实际上 <code>Channel</code> 的概念并不是 Kotlin 原创的，且不说 Golang 里面的 <code>channel</code>，就说 Java NIO 当中也存在 <code>Channel</code> 这样的概念，其实这时候大家很容易就应该想到多路复用，多路复用的时候我们还能像前面那样简单的挂起吗？或者不挂起我们该怎么办呢？且看下回分解。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#105;&#x6d;&#x6f;&#111;&#x63;&#x2e;&#x63;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#105;&#x6d;&#x6f;&#111;&#x63;&#x2e;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(3) - 协程调度篇","keywords":"Kotlin 异步编程 协程","date":"2019-04-10T16:00:00.000Z","description":null,"_content":"\n> 上一篇我们知道了协程启动的几种模式，也通过示例认识了 `launch` 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。 \n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg)\n\n## 1. 协程上下文\n\n调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。\n\n前面我们提到 `launch` 函数有三个参数，第一个参数叫 **上下文**，它的接口类型是 `CoroutineContext`，通常我们见到的上下文的类型是 `CombinedContext` 或者 `EmptyCoroutineContext`，一个表示上下文的组合，另一个表示什么都没有。我们来看下 `CoroutineContext` 的接口方法：\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    public operator fun <E : Element> get(key: Key<E>): E?\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n    public operator fun plus(context: CoroutineContext): CoroutineContext = ...\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    public interface Key<E : Element>\n\n    public interface Element : CoroutineContext {\n        public val key: Key<*>\n        ...\n    }\n}\n```\n\n不知道大家有没有发现，它简直就是一个以 `Key` 为索引的 `List`：\n\n| CoroutineContext | List |\n| --- | --- | \n| get(Key) | get(Int) |\n| plus(CoroutineContext) | plus(List) |\n| minusKey(Key) | removeAt(Int) |\n\n> 表中的 `List.plus(List)` 实际上指的是扩展方法 `Collection<T>.plus(elements: Iterable<T>): List<T>` \n\n`CoroutineContext` 作为一个集合，它的元素就是源码中看到的 `Element`，每一个 `Element` 都有一个 `key`，因此它可以作为元素出现，同时它也是 `CoroutineContext` 的子接口，因此也可以作为集合出现。\n\n讲到这里，大家就会明白，`CoroutineContext` 原来是个数据结构啊。如果大家对于 `List` 的递归定义比较熟悉的话，那么对于 `CombinedContext` 和 `EmptyCoroutineContext` 也就很容易理解了，例如 scala 的 `List`是这么定义的：\n\n```scala\nsealed abstract class List[+A] extends ... {\n    ...\n    def head: A\n    def tail: List[A]\n    ...\n}\n```\n\n在模式匹配的时候，`List(1,2,3,4)` 是可以匹配 `x::y` 的，`x` 就是 1，`y` 则是 `List(2,3,4)`。\n\n`CombinedContext` 的定义也非常类似：\n\n```kotlin\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n    ...\n}\n```\n只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 `coroutineContext` 大多是这个 `CombinedContext` 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 `Key` 来查找，例如：\n\n```kotlin\nsuspend fun main(){\n    GlobalScope.launch {\n        println(coroutineContext[Job]) // \"coroutine#1\":StandaloneCoroutine{Active}@1ff62014\n    }\n    println(coroutineContext[Job]) // null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例\n}\n```\n\n这里的 `Job` 实际上是对它的 `companion object` 的引用\n\n```kotlin\npublic interface Job : CoroutineContext.Element {\n    /**\n     * Key for [Job] instance in the coroutine context.\n     */\n    public companion object Key : CoroutineContext.Key<Job> { ... }\n    ...\n}\n```\n\n> 所以我们也可以仿照 `Thread.currentThread()` 来一个获取当前 `Job` 的方法：\n>\n> ```kotlin\n> suspend inline fun Job.Key.currentJob() = coroutineContext[Job]\n>\n> suspend fun coroutineJob(){\n>     GlobalScope.launch {\n>         log(Job.currentJob())\n>     }\n>     log(Job.currentJob())\n> }\n> ```\n\n我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：\n\n```kotlin\nGlobalScope.launch(CoroutineName(\"Hello\")) {\n    ...\n}\n```\n\n如果有多个上下文需要添加，直接用 `+` 就可以了：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main + CoroutineName(\"Hello\")) {\n    ...\n}\n```\n\n> `Dispatchers.Main` 是调度器的一个实现，不用担心，我们很快就会认识它了。\n\n## 2. 协程拦截器\n\n费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。\n\n```kotlin\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n    \n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n    ...\n}\n```\n\n拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。\n\n它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 `Continuation` 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。\n\n我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。\n\n```kotlin\nclass MyContinuationInterceptor: ContinuationInterceptor{\n    override val key = ContinuationInterceptor\n    override fun <T> interceptContinuation(continuation: Continuation<T>) = MyContinuation(continuation)\n}\n\nclass MyContinuation<T>(val continuation: Continuation<T>): Continuation<T> {\n    override val context = continuation.context\n    override fun resumeWith(result: Result<T>) {\n        log(\"<MyContinuation> $result\" )\n        continuation.resumeWith(result)\n    }\n}\n```\n\n我们只是在回调处打了一行日志。接下来我们把用例拿出来：\n\n```kotlin\nsuspend fun main() {\n    GlobalScope.launch(MyContinuationInterceptor()) {\n        log(1)\n        val job = async {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello\"\n        }\n        log(4)\n        val result = job.await()\n        log(\"5. $result\")\n    }.join()\n    log(6)\n}\n```\n\n这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 `launch` 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 `async` 启动了一个协程，`async` 与 `launch` 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 `async` 启动的 `Job` 也就是实际上的 `Deferred` 可以有返回结果，可以通过 `await` 方法获取。\n\n可想而知，`result` 的值就是 Hello。那么这段程序运行的结果如何呢？\n\n```\n15:31:55:989 [main] <MyContinuation> Success(kotlin.Unit)  // ①\n15:31:55:992 [main] 1\n15:31:56:000 [main] <MyContinuation> Success(kotlin.Unit) // ②\n15:31:56:000 [main] 2\n15:31:56:031 [main] 4\n15:31:57:029 [kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit) // ③\n15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello) // ④\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6\n```\n\n> “// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。\n\n大家可能就要奇怪了，你不是说 `Continuation` 是回调么，这里面回调调用也就一次啊（`await` 那里），怎么日志打印了四次呢？\n\n别慌，我们按顺序给大家介绍。\n\n首先，所有协程启动的时候，都会有一次 `Continuation.resumeWith`  的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。\n\n其次，`delay` 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。\n\n最后，④ 处的日志就很容易理解了，正是我们的返回结果。\n\n可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 `delay`，在 JVM 上 `delay` 实际上是在一个 `ScheduledExcecutor` 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，`delay` 就不会切线程了，毕竟人家是单线程的。\n\n如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。\n\n> 思考：拦截器可以有多个吗？\n\n## 3. 调度器\n\n### 3.1 概述\n\n有了前面的基础，我们对于调度器的介绍就变得水到渠成了。\n\n```kotlin\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    ...\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n    ...\n}\n```\n\n它本身是协程上下文的子类，同时实现了拦截器的接口， `dispatch` 方法会在拦截器的方法 `interceptContinuation` 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 `Dispatchers` 当中：\n\n```kotlin\nval Default: CoroutineDispatcher\nval Main: MainCoroutineDispatcher\nval Unconfined: CoroutineDispatcher\n```\n这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 `val IO: CoroutineDispatcher`，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。\n\n|  | Jvm | Js | Native |\n| --- | --- | --- | --- |\n| Default | 线程池 | 主线程循环 | 主线程循环 |\n| Main | UI 线程 | 与 Default 相同 | 与 Default 相同 |\n| Unconfined | 直接执行 | 直接执行 | 直接执行 |\n| IO | 线程池 | -- | -- |\n\n\n\n* IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。\n* Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。\n* Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。\n\n\n### 3.2 编写 UI 相关程序\n\nKotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：\n\n```kotlin\ngetUserBtn.setOnClickListener { \n    getUser { user ->\n        handler.post {\n            userNameView.text = user.name\n        }\n    }\n}\n```\n\n我们简单得给出 `getUser` 函数的声明：\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback){\n    ...\n}\n```\n\n由于 `getUser` 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 `handler.post` 切换到 UI 线程。上面的写法就是我们最古老的写法了。\n\n后来又有了 RxJava，那么事情开始变得有趣了起来：\n\n```kotlin\nfun getUserObservable(): Observable<User> {\n    return Observable.create<User> { emitter ->\n        getUser {\n            emitter.onNext(it)\n        }\n    }\n}\n```\n\n于是点击按钮的事件可以这么写：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    getUserObservable()\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe { user ->\n                userNameView.text = user.name\n            }\n}\n```\n\n其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！\n\n那么我们现在把这段代码过渡到协程的写法：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {\n    continuation ->\n    getUser {\n        continuation.resume(it)\n    }\n}\n```\n\n按钮点击时，我们可以：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispatchers.Main) {\n        userNameView.text = getUserCoroutine().name\n    }\n}\n```\n\n> 大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 `launch` 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。\n\n这里又有大家没见过的内容啦，`suspendCoroutine` 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 `Continuation` 实例，也就是拿到回调，方便后面我们调用它的 `resume` 或者 `resumeWithException` 来返回结果或者抛出异常。\n\n> 如果你重复调用 `resume` 或者 `resumeWithException` 会收获一枚 `IllegalStateException`，仔细想想这是为什么。\n\n对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 `Dispatchers.Main` 来确保 `launch` 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 `Dispatchers.Main` 的具体实现。\n\n在 Jvm 上，`Main` 的实现也比较有意思：\n\n```kotlin\ninternal object MainDispatcherLoader {\n    @JvmField\n    val dispatcher: MainCoroutineDispatcher = loadMainDispatcher()\n\n    private fun loadMainDispatcher(): MainCoroutineDispatcher {\n        return try {\n            val factories = MainDispatcherFactory::class.java.let { clz ->\n                ServiceLoader.load(clz, clz.classLoader).toList()\n            }\n            factories.maxBy { it.loadPriority }?.tryCreateDispatcher(factories)\n                ?: MissingMainCoroutineDispatcher(null)\n        } catch (e: Throwable) {\n            MissingMainCoroutineDispatcher(e)\n        }\n    }\n}\n```\n\n在 Android 当中，协程框架通过注册 `AndroidDispatcherFactory` 使得 `Main` 最终被赋值为 `HandlerDispatcher` 的实例，有兴趣的可以去看下  kotlinx-coroutines-android 的源码实现。\n\n> 注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。\n\n### 3.3 绑定到任意线程的调度器\n\n调度器的目的就是切线程，你不要想着我在 `dispatch` 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：\n\n```kotlin\nsuspend fun main() {\n    val myDispatcher= Executors.newSingleThreadExecutor{ r -> Thread(r, \"MyThread\") }.asCoroutineDispatcher()\n    GlobalScope.launch(myDispatcher) {\n        log(1)\n    }.join()\n    log(2)\n}\n```\n\n输出的信息就表明协程运行在我们自己的线程上。\n\n```kotlin\n16:10:57:130 [MyThread] 1\n16:10:57:136 [MyThread] 2\n```\n\n不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg)\n\n我们可以通过主动关闭线程池或者调用：\n\n```kotlin\nmyDispatcher.close()\n```\n来结束它的生命周期，再次运行程序就会正常退出了。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg)\n\n当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。\n\nKotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？\n\n**废弃的两个基于线程池创建调度器的 API**\n\n```kotlin\nfun newSingleThreadContext(name: String): ExecutorCoroutineDispatcher\nfun newFixedThreadPoolContext(nThreads: Int, name: String): ExecutorCoroutineDispatcher\n```\n这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。\n\n其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：\n\n```kotlin\nExecutors.newFixedThreadPool(10)\n        .asCoroutineDispatcher().use { dispatcher ->\n            GlobalScope.launch(dispatcher) {\n                log(1)\n                val job = async {\n                    log(2)\n                    delay(1000)\n                    log(3)\n                    \"Hello\"\n                }\n                log(4)\n                val result = job.await()\n                log(\"5. $result\")\n            }.join()\n            log(6)\n        }\n```\n\n这里面除了 `delay` 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（`Continuation.resume`）都会切线程：\n\n```\n16:28:04:771 [pool-1-thread-1] 1\n16:28:04:779 [pool-1-thread-1] 4\n16:28:04:779 [pool-1-thread-2] 2\n16:28:05:790 [pool-1-thread-3] 3\n16:28:05:793 [pool-1-thread-4] 5. Hello\n16:28:05:794 [pool-1-thread-4] 6\n```\n\n如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：\n\n```\n16:40:14:685 [pool-1-thread-1] 1\n16:40:14:706 [pool-1-thread-1] 4\n16:40:14:710 [pool-1-thread-1] 2\n16:40:15:723 [pool-1-thread-1] 3\n16:40:15:725 [pool-1-thread-1] 5. Hello\n16:40:15:725 [pool-1-thread-1] 6\n```\n\n对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 `delay` 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：\n\n| 线程数 | 10 | 1 |\n| --- | --- | --- |\n| 耗时ms | 1006.00 | 1004.97 |\n\n> 注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。\n\n也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。\n\n实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。\n\n\n### 3.4 线程安全问题\n\nJs 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。\n\n好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。\n\n如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。\n\n以下是一个错误的例子，大家很容易就能想明白：\n\n```kotlin\nsuspend fun main(){\n    var i = 0\n    Executors.newFixedThreadPool(10)\n            .asCoroutineDispatcher().use { dispatcher ->\n                List(1000000) {\n                    GlobalScope.launch(dispatcher) {\n                        i++\n                    }\n                }.forEach {\n                    it.join()\n                }\n            }\n    log(i)\n}\n```\n\n输出的结果：\n\n```\n16:59:28:080 [main] 999593\n```\n\n## 4. suspend main 函数如何调度？\n\n上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？\n\n我们先给出一个例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    GlobalScope.launch {\n        log(2)\n    }.join()\n    log(3)\n}\n```\n\n它等价于下面的写法：\n\n```kotlin\nfun main() {\n    runSuspend {\n        log(1)\n        GlobalScope.launch {\n            log(2)\n        }.join()\n        log(3)\n    }\n}\n```\n\n那你说这个 `runSuspend` 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。\n\n```kotlin\ninternal fun runSuspend(block: suspend () -> Unit) {\n    val run = RunSuspend()\n    block.startCoroutine(run)\n    run.await()\n}\n```\n\n而这里面的 `RunSuspend` 则是 `Continuation` 的实现：\n\n```kotlin\nprivate class RunSuspend : Continuation<Unit> {\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    var result: Result<Unit>? = null\n\n    override fun resumeWith(result: Result<Unit>) = synchronized(this) {\n        this.result = result\n        (this as Object).notifyAll()\n    }\n\n    fun await() = synchronized(this) {\n        while (true) {\n            when (val result = this.result) {\n                null -> (this as Object).wait()\n                else -> {\n                    result.getOrThrow() // throw up failure\n                    return\n                }\n            }\n        }\n    }\n}\n```\n\n它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。\n\n通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。\n\n> 上述代码在标准库当中被修饰为 `internal`，因此我们无法直接使用它们。不过你可以把 **RunSuspend.kt** 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 `var result: Result<Unit>? = null` 可能会报错，没关系，改成 `private var result: Result<Unit>? = null` 就可以了。\n\n## 5. 小结\n\n在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~\n\n\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-dispatchers.md","raw":"---\ntitle:  破解 Kotlin 协程(3) - 协程调度篇  \nkeywords: Kotlin 异步编程 协程 \ndate: 2019/04/11\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 上一篇我们知道了协程启动的几种模式，也通过示例认识了 `launch` 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。 \n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg)\n\n## 1. 协程上下文\n\n调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。\n\n前面我们提到 `launch` 函数有三个参数，第一个参数叫 **上下文**，它的接口类型是 `CoroutineContext`，通常我们见到的上下文的类型是 `CombinedContext` 或者 `EmptyCoroutineContext`，一个表示上下文的组合，另一个表示什么都没有。我们来看下 `CoroutineContext` 的接口方法：\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    public operator fun <E : Element> get(key: Key<E>): E?\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n    public operator fun plus(context: CoroutineContext): CoroutineContext = ...\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    public interface Key<E : Element>\n\n    public interface Element : CoroutineContext {\n        public val key: Key<*>\n        ...\n    }\n}\n```\n\n不知道大家有没有发现，它简直就是一个以 `Key` 为索引的 `List`：\n\n| CoroutineContext | List |\n| --- | --- | \n| get(Key) | get(Int) |\n| plus(CoroutineContext) | plus(List) |\n| minusKey(Key) | removeAt(Int) |\n\n> 表中的 `List.plus(List)` 实际上指的是扩展方法 `Collection<T>.plus(elements: Iterable<T>): List<T>` \n\n`CoroutineContext` 作为一个集合，它的元素就是源码中看到的 `Element`，每一个 `Element` 都有一个 `key`，因此它可以作为元素出现，同时它也是 `CoroutineContext` 的子接口，因此也可以作为集合出现。\n\n讲到这里，大家就会明白，`CoroutineContext` 原来是个数据结构啊。如果大家对于 `List` 的递归定义比较熟悉的话，那么对于 `CombinedContext` 和 `EmptyCoroutineContext` 也就很容易理解了，例如 scala 的 `List`是这么定义的：\n\n```scala\nsealed abstract class List[+A] extends ... {\n    ...\n    def head: A\n    def tail: List[A]\n    ...\n}\n```\n\n在模式匹配的时候，`List(1,2,3,4)` 是可以匹配 `x::y` 的，`x` 就是 1，`y` 则是 `List(2,3,4)`。\n\n`CombinedContext` 的定义也非常类似：\n\n```kotlin\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n    ...\n}\n```\n只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 `coroutineContext` 大多是这个 `CombinedContext` 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 `Key` 来查找，例如：\n\n```kotlin\nsuspend fun main(){\n    GlobalScope.launch {\n        println(coroutineContext[Job]) // \"coroutine#1\":StandaloneCoroutine{Active}@1ff62014\n    }\n    println(coroutineContext[Job]) // null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例\n}\n```\n\n这里的 `Job` 实际上是对它的 `companion object` 的引用\n\n```kotlin\npublic interface Job : CoroutineContext.Element {\n    /**\n     * Key for [Job] instance in the coroutine context.\n     */\n    public companion object Key : CoroutineContext.Key<Job> { ... }\n    ...\n}\n```\n\n> 所以我们也可以仿照 `Thread.currentThread()` 来一个获取当前 `Job` 的方法：\n>\n> ```kotlin\n> suspend inline fun Job.Key.currentJob() = coroutineContext[Job]\n>\n> suspend fun coroutineJob(){\n>     GlobalScope.launch {\n>         log(Job.currentJob())\n>     }\n>     log(Job.currentJob())\n> }\n> ```\n\n我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：\n\n```kotlin\nGlobalScope.launch(CoroutineName(\"Hello\")) {\n    ...\n}\n```\n\n如果有多个上下文需要添加，直接用 `+` 就可以了：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main + CoroutineName(\"Hello\")) {\n    ...\n}\n```\n\n> `Dispatchers.Main` 是调度器的一个实现，不用担心，我们很快就会认识它了。\n\n## 2. 协程拦截器\n\n费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。\n\n```kotlin\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n    \n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n    ...\n}\n```\n\n拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。\n\n它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 `Continuation` 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。\n\n我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。\n\n```kotlin\nclass MyContinuationInterceptor: ContinuationInterceptor{\n    override val key = ContinuationInterceptor\n    override fun <T> interceptContinuation(continuation: Continuation<T>) = MyContinuation(continuation)\n}\n\nclass MyContinuation<T>(val continuation: Continuation<T>): Continuation<T> {\n    override val context = continuation.context\n    override fun resumeWith(result: Result<T>) {\n        log(\"<MyContinuation> $result\" )\n        continuation.resumeWith(result)\n    }\n}\n```\n\n我们只是在回调处打了一行日志。接下来我们把用例拿出来：\n\n```kotlin\nsuspend fun main() {\n    GlobalScope.launch(MyContinuationInterceptor()) {\n        log(1)\n        val job = async {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello\"\n        }\n        log(4)\n        val result = job.await()\n        log(\"5. $result\")\n    }.join()\n    log(6)\n}\n```\n\n这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 `launch` 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 `async` 启动了一个协程，`async` 与 `launch` 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 `async` 启动的 `Job` 也就是实际上的 `Deferred` 可以有返回结果，可以通过 `await` 方法获取。\n\n可想而知，`result` 的值就是 Hello。那么这段程序运行的结果如何呢？\n\n```\n15:31:55:989 [main] <MyContinuation> Success(kotlin.Unit)  // ①\n15:31:55:992 [main] 1\n15:31:56:000 [main] <MyContinuation> Success(kotlin.Unit) // ②\n15:31:56:000 [main] 2\n15:31:56:031 [main] 4\n15:31:57:029 [kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit) // ③\n15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello) // ④\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello\n15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6\n```\n\n> “// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。\n\n大家可能就要奇怪了，你不是说 `Continuation` 是回调么，这里面回调调用也就一次啊（`await` 那里），怎么日志打印了四次呢？\n\n别慌，我们按顺序给大家介绍。\n\n首先，所有协程启动的时候，都会有一次 `Continuation.resumeWith`  的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。\n\n其次，`delay` 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。\n\n最后，④ 处的日志就很容易理解了，正是我们的返回结果。\n\n可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 `delay`，在 JVM 上 `delay` 实际上是在一个 `ScheduledExcecutor` 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，`delay` 就不会切线程了，毕竟人家是单线程的。\n\n如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。\n\n> 思考：拦截器可以有多个吗？\n\n## 3. 调度器\n\n### 3.1 概述\n\n有了前面的基础，我们对于调度器的介绍就变得水到渠成了。\n\n```kotlin\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    ...\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n    ...\n}\n```\n\n它本身是协程上下文的子类，同时实现了拦截器的接口， `dispatch` 方法会在拦截器的方法 `interceptContinuation` 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 `Dispatchers` 当中：\n\n```kotlin\nval Default: CoroutineDispatcher\nval Main: MainCoroutineDispatcher\nval Unconfined: CoroutineDispatcher\n```\n这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 `val IO: CoroutineDispatcher`，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。\n\n|  | Jvm | Js | Native |\n| --- | --- | --- | --- |\n| Default | 线程池 | 主线程循环 | 主线程循环 |\n| Main | UI 线程 | 与 Default 相同 | 与 Default 相同 |\n| Unconfined | 直接执行 | 直接执行 | 直接执行 |\n| IO | 线程池 | -- | -- |\n\n\n\n* IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。\n* Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。\n* Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。\n\n\n### 3.2 编写 UI 相关程序\n\nKotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：\n\n```kotlin\ngetUserBtn.setOnClickListener { \n    getUser { user ->\n        handler.post {\n            userNameView.text = user.name\n        }\n    }\n}\n```\n\n我们简单得给出 `getUser` 函数的声明：\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback){\n    ...\n}\n```\n\n由于 `getUser` 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 `handler.post` 切换到 UI 线程。上面的写法就是我们最古老的写法了。\n\n后来又有了 RxJava，那么事情开始变得有趣了起来：\n\n```kotlin\nfun getUserObservable(): Observable<User> {\n    return Observable.create<User> { emitter ->\n        getUser {\n            emitter.onNext(it)\n        }\n    }\n}\n```\n\n于是点击按钮的事件可以这么写：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    getUserObservable()\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe { user ->\n                userNameView.text = user.name\n            }\n}\n```\n\n其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！\n\n那么我们现在把这段代码过渡到协程的写法：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {\n    continuation ->\n    getUser {\n        continuation.resume(it)\n    }\n}\n```\n\n按钮点击时，我们可以：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispatchers.Main) {\n        userNameView.text = getUserCoroutine().name\n    }\n}\n```\n\n> 大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 `launch` 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。\n\n这里又有大家没见过的内容啦，`suspendCoroutine` 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 `Continuation` 实例，也就是拿到回调，方便后面我们调用它的 `resume` 或者 `resumeWithException` 来返回结果或者抛出异常。\n\n> 如果你重复调用 `resume` 或者 `resumeWithException` 会收获一枚 `IllegalStateException`，仔细想想这是为什么。\n\n对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 `Dispatchers.Main` 来确保 `launch` 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 `Dispatchers.Main` 的具体实现。\n\n在 Jvm 上，`Main` 的实现也比较有意思：\n\n```kotlin\ninternal object MainDispatcherLoader {\n    @JvmField\n    val dispatcher: MainCoroutineDispatcher = loadMainDispatcher()\n\n    private fun loadMainDispatcher(): MainCoroutineDispatcher {\n        return try {\n            val factories = MainDispatcherFactory::class.java.let { clz ->\n                ServiceLoader.load(clz, clz.classLoader).toList()\n            }\n            factories.maxBy { it.loadPriority }?.tryCreateDispatcher(factories)\n                ?: MissingMainCoroutineDispatcher(null)\n        } catch (e: Throwable) {\n            MissingMainCoroutineDispatcher(e)\n        }\n    }\n}\n```\n\n在 Android 当中，协程框架通过注册 `AndroidDispatcherFactory` 使得 `Main` 最终被赋值为 `HandlerDispatcher` 的实例，有兴趣的可以去看下  kotlinx-coroutines-android 的源码实现。\n\n> 注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。\n\n### 3.3 绑定到任意线程的调度器\n\n调度器的目的就是切线程，你不要想着我在 `dispatch` 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：\n\n```kotlin\nsuspend fun main() {\n    val myDispatcher= Executors.newSingleThreadExecutor{ r -> Thread(r, \"MyThread\") }.asCoroutineDispatcher()\n    GlobalScope.launch(myDispatcher) {\n        log(1)\n    }.join()\n    log(2)\n}\n```\n\n输出的信息就表明协程运行在我们自己的线程上。\n\n```kotlin\n16:10:57:130 [MyThread] 1\n16:10:57:136 [MyThread] 2\n```\n\n不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg)\n\n我们可以通过主动关闭线程池或者调用：\n\n```kotlin\nmyDispatcher.close()\n```\n来结束它的生命周期，再次运行程序就会正常退出了。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg)\n\n当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。\n\nKotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？\n\n**废弃的两个基于线程池创建调度器的 API**\n\n```kotlin\nfun newSingleThreadContext(name: String): ExecutorCoroutineDispatcher\nfun newFixedThreadPoolContext(nThreads: Int, name: String): ExecutorCoroutineDispatcher\n```\n这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。\n\n其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：\n\n```kotlin\nExecutors.newFixedThreadPool(10)\n        .asCoroutineDispatcher().use { dispatcher ->\n            GlobalScope.launch(dispatcher) {\n                log(1)\n                val job = async {\n                    log(2)\n                    delay(1000)\n                    log(3)\n                    \"Hello\"\n                }\n                log(4)\n                val result = job.await()\n                log(\"5. $result\")\n            }.join()\n            log(6)\n        }\n```\n\n这里面除了 `delay` 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（`Continuation.resume`）都会切线程：\n\n```\n16:28:04:771 [pool-1-thread-1] 1\n16:28:04:779 [pool-1-thread-1] 4\n16:28:04:779 [pool-1-thread-2] 2\n16:28:05:790 [pool-1-thread-3] 3\n16:28:05:793 [pool-1-thread-4] 5. Hello\n16:28:05:794 [pool-1-thread-4] 6\n```\n\n如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：\n\n```\n16:40:14:685 [pool-1-thread-1] 1\n16:40:14:706 [pool-1-thread-1] 4\n16:40:14:710 [pool-1-thread-1] 2\n16:40:15:723 [pool-1-thread-1] 3\n16:40:15:725 [pool-1-thread-1] 5. Hello\n16:40:15:725 [pool-1-thread-1] 6\n```\n\n对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 `delay` 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：\n\n| 线程数 | 10 | 1 |\n| --- | --- | --- |\n| 耗时ms | 1006.00 | 1004.97 |\n\n> 注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。\n\n也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。\n\n实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。\n\n\n### 3.4 线程安全问题\n\nJs 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。\n\n好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。\n\n如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。\n\n以下是一个错误的例子，大家很容易就能想明白：\n\n```kotlin\nsuspend fun main(){\n    var i = 0\n    Executors.newFixedThreadPool(10)\n            .asCoroutineDispatcher().use { dispatcher ->\n                List(1000000) {\n                    GlobalScope.launch(dispatcher) {\n                        i++\n                    }\n                }.forEach {\n                    it.join()\n                }\n            }\n    log(i)\n}\n```\n\n输出的结果：\n\n```\n16:59:28:080 [main] 999593\n```\n\n## 4. suspend main 函数如何调度？\n\n上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？\n\n我们先给出一个例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    GlobalScope.launch {\n        log(2)\n    }.join()\n    log(3)\n}\n```\n\n它等价于下面的写法：\n\n```kotlin\nfun main() {\n    runSuspend {\n        log(1)\n        GlobalScope.launch {\n            log(2)\n        }.join()\n        log(3)\n    }\n}\n```\n\n那你说这个 `runSuspend` 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。\n\n```kotlin\ninternal fun runSuspend(block: suspend () -> Unit) {\n    val run = RunSuspend()\n    block.startCoroutine(run)\n    run.await()\n}\n```\n\n而这里面的 `RunSuspend` 则是 `Continuation` 的实现：\n\n```kotlin\nprivate class RunSuspend : Continuation<Unit> {\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    var result: Result<Unit>? = null\n\n    override fun resumeWith(result: Result<Unit>) = synchronized(this) {\n        this.result = result\n        (this as Object).notifyAll()\n    }\n\n    fun await() = synchronized(this) {\n        while (true) {\n            when (val result = this.result) {\n                null -> (this as Object).wait()\n                else -> {\n                    result.getOrThrow() // throw up failure\n                    return\n                }\n            }\n        }\n    }\n}\n```\n\n它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。\n\n通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。\n\n> 上述代码在标准库当中被修饰为 `internal`，因此我们无法直接使用它们。不过你可以把 **RunSuspend.kt** 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 `var result: Result<Unit>? = null` 可能会报错，没关系，改成 `private var result: Result<Unit>? = null` 就可以了。\n\n## 5. 小结\n\n在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~\n\n\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-dispatchers","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0033000nlduzf6h687ga","content":"<blockquote>\n<p>上一篇我们知道了协程启动的几种模式，也通过示例认识了 <code>launch</code> 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg\"></p>\n<h2 id=\"1-协程上下文\"><a href=\"#1-协程上下文\" class=\"headerlink\" title=\"1. 协程上下文\"></a>1. 协程上下文</h2><p>调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。</p>\n<p>前面我们提到 <code>launch</code> 函数有三个参数，第一个参数叫 <strong>上下文</strong>，它的接口类型是 <code>CoroutineContext</code>，通常我们见到的上下文的类型是 <code>CombinedContext</code> 或者 <code>EmptyCoroutineContext</code>，一个表示上下文的组合，另一个表示什么都没有。我们来看下 <code>CoroutineContext</code> 的接口方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.3&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CoroutineContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E : Element&gt;</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">Key</span>&lt;<span class=\"type\">E</span>&gt;)</span></span>: E?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> <span class=\"title\">fold</span><span class=\"params\">(initial: <span class=\"type\">R</span>, operation: (<span class=\"type\">R</span>, <span class=\"type\">Element</span>) -&gt; <span class=\"type\">R</span>)</span></span>: R</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">plus</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>)</span></span>: CoroutineContext = ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">minusKey</span><span class=\"params\">(key: <span class=\"type\">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Key</span>&lt;<span class=\"type\">E : Element</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Element</span> : <span class=\"type\">CoroutineContext &#123;</span></span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> key: Key&lt;*&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不知道大家有没有发现，它简直就是一个以 <code>Key</code> 为索引的 <code>List</code>：</p>\n<table>\n<thead>\n<tr>\n<th>CoroutineContext</th>\n<th>List</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>get(Key)</td>\n<td>get(Int)</td>\n</tr>\n<tr>\n<td>plus(CoroutineContext)</td>\n<td>plus(List)</td>\n</tr>\n<tr>\n<td>minusKey(Key)</td>\n<td>removeAt(Int)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>表中的 <code>List.plus(List)</code> 实际上指的是扩展方法 <code>Collection&lt;T&gt;.plus(elements: Iterable&lt;T&gt;): List&lt;T&gt;</code> </p>\n</blockquote>\n<p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code>，每一个 <code>Element</code> 都有一个 <code>key</code>，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code> 的子接口，因此也可以作为集合出现。</p>\n<p>讲到这里，大家就会明白，<code>CoroutineContext</code> 原来是个数据结构啊。如果大家对于 <code>List</code> 的递归定义比较熟悉的话，那么对于 <code>CombinedContext</code> 和 <code>EmptyCoroutineContext</code> 也就很容易理解了，例如 scala 的 <code>List</code>是这么定义的：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>[+<span class=\"type\">A</span>] <span class=\"keyword\">extends</span> ... </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">head</span></span>: <span class=\"type\">A</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tail</span></span>: <span class=\"type\">List</span>[<span class=\"type\">A</span>]</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在模式匹配的时候，<code>List(1,2,3,4)</code> 是可以匹配 <code>x::y</code> 的，<code>x</code> 就是 1，<code>y</code> 则是 <code>List(2,3,4)</code>。</p>\n<p><code>CombinedContext</code> 的定义也非常类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CombinedContext</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> left: CoroutineContext,</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> element: Element</span><br><span class=\"line\">) : CoroutineContext, Serializable &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 <code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 <code>Key</code> 来查找，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        println(coroutineContext[Job]) <span class=\"comment\">// &quot;coroutine#1&quot;:StandaloneCoroutine&#123;Active&#125;@1ff62014</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(coroutineContext[Job]) <span class=\"comment\">// null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Job</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Key for [Job] instance in the coroutine context.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所以我们也可以仿照 <code>Thread.currentThread()</code> 来一个获取当前 <code>Job</code> 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> Job.Key.<span class=\"title\">currentJob</span><span class=\"params\">()</span></span> = coroutineContext[Job]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineJob</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(Job.currentJob())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(Job.currentJob())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(CoroutineName(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个上下文需要添加，直接用 <code>+</code> 就可以了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main + CoroutineName(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Dispatchers.Main</code> 是调度器的一个实现，不用担心，我们很快就会认识它了。</p>\n</blockquote>\n<h2 id=\"2-协程拦截器\"><a href=\"#2-协程拦截器\" class=\"headerlink\" title=\"2. 协程拦截器\"></a>2. 协程拦截器</h2><p>费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ContinuationInterceptor</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">interceptContinuation</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。</p>\n<p>它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 <code>Continuation</code> 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。</p>\n<p>我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContinuationInterceptor</span>: <span class=\"type\">ContinuationInterceptor&#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> key = ContinuationInterceptor</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">interceptContinuation</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContinuation</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context = continuation.context</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;&lt;MyContinuation&gt; <span class=\"variable\">$result</span>&quot;</span> )</span><br><span class=\"line\">        continuation.resumeWith(result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只是在回调处打了一行日志。接下来我们把用例拿出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> job = async &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = job.await()</span><br><span class=\"line\">        log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">6</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 <code>launch</code> 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 <code>async</code> 启动了一个协程，<code>async</code> 与 <code>launch</code> 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果，可以通过 <code>await</code> 方法获取。</p>\n<p>可想而知，<code>result</code> 的值就是 Hello。那么这段程序运行的结果如何呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15:31:55:989 [main] &lt;MyContinuation&gt; Success(kotlin.Unit)  &#x2F;&#x2F; ①</span><br><span class=\"line\">15:31:55:992 [main] 1</span><br><span class=\"line\">15:31:56:000 [main] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ②</span><br><span class=\"line\">15:31:56:000 [main] 2</span><br><span class=\"line\">15:31:56:031 [main] 4</span><br><span class=\"line\">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ③</span><br><span class=\"line\">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello) &#x2F;&#x2F; ④</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>“// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。</p>\n</blockquote>\n<p>大家可能就要奇怪了，你不是说 <code>Continuation</code> 是回调么，这里面回调调用也就一次啊（<code>await</code> 那里），怎么日志打印了四次呢？</p>\n<p>别慌，我们按顺序给大家介绍。</p>\n<p>首先，所有协程启动的时候，都会有一次 <code>Continuation.resumeWith</code>  的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。</p>\n<p>其次，<code>delay</code> 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。</p>\n<p>最后，④ 处的日志就很容易理解了，正是我们的返回结果。</p>\n<p>可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 <code>delay</code>，在 JVM 上 <code>delay</code> 实际上是在一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，<code>delay</code> 就不会切线程了，毕竟人家是单线程的。</p>\n<p>如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。</p>\n<blockquote>\n<p>思考：拦截器可以有多个吗？</p>\n</blockquote>\n<h2 id=\"3-调度器\"><a href=\"#3-调度器\" class=\"headerlink\" title=\"3. 调度器\"></a>3. 调度器</h2><h3 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1 概述\"></a>3.1 概述</h3><p>有了前面的基础，我们对于调度器的介绍就变得水到渠成了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineDispatcher</span> :<span class=\"type\"></span></span></span><br><span class=\"line\">    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatch</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>, block: <span class=\"type\">Runnable</span>)</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它本身是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 <code>Dispatchers</code> 当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> Default: CoroutineDispatcher</span><br><span class=\"line\"><span class=\"keyword\">val</span> Main: MainCoroutineDispatcher</span><br><span class=\"line\"><span class=\"keyword\">val</span> Unconfined: CoroutineDispatcher</span><br></pre></td></tr></table></figure>\n<p>这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 <code>val IO: CoroutineDispatcher</code>，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Jvm</th>\n<th>Js</th>\n<th>Native</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Default</td>\n<td>线程池</td>\n<td>主线程循环</td>\n<td>主线程循环</td>\n</tr>\n<tr>\n<td>Main</td>\n<td>UI 线程</td>\n<td>与 Default 相同</td>\n<td>与 Default 相同</td>\n</tr>\n<tr>\n<td>Unconfined</td>\n<td>直接执行</td>\n<td>直接执行</td>\n<td>直接执行</td>\n</tr>\n<tr>\n<td>IO</td>\n<td>线程池</td>\n<td>–</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<ul>\n<li>IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。</li>\n<li>Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。</li>\n<li>Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。</li>\n</ul>\n<h3 id=\"3-2-编写-UI-相关程序\"><a href=\"#3-2-编写-UI-相关程序\" class=\"headerlink\" title=\"3.2 编写 UI 相关程序\"></a>3.2 编写 UI 相关程序</h3><p>Kotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123; </span><br><span class=\"line\">    getUser &#123; user -&gt;</span><br><span class=\"line\">        handler.post &#123;</span><br><span class=\"line\">            userNameView.text = user.name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们简单得给出 <code>getUser</code> 函数的声明：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Callback = (User) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 <code>getUser</code> 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 <code>handler.post</code> 切换到 UI 线程。上面的写法就是我们最古老的写法了。</p>\n<p>后来又有了 RxJava，那么事情开始变得有趣了起来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserObservable</span><span class=\"params\">()</span></span>: Observable&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Observable.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class=\"line\">        getUser &#123;</span><br><span class=\"line\">            emitter.onNext(it)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是点击按钮的事件可以这么写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    getUserObservable()</span><br><span class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">            .subscribe &#123; user -&gt;</span><br><span class=\"line\">                userNameView.text = user.name</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！</p>\n<p>那么我们现在把这段代码过渡到协程的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    getUser &#123;</span><br><span class=\"line\">        continuation.resume(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按钮点击时，我们可以：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 <code>launch</code> 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。</p>\n</blockquote>\n<p>这里又有大家没见过的内容啦，<code>suspendCoroutine</code> 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方便后面我们调用它的 <code>resume</code> 或者 <code>resumeWithException</code> 来返回结果或者抛出异常。</p>\n<blockquote>\n<p>如果你重复调用 <code>resume</code> 或者 <code>resumeWithException</code> 会收获一枚 <code>IllegalStateException</code>，仔细想想这是为什么。</p>\n</blockquote>\n<p>对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 <code>Dispatchers.Main</code> 来确保 <code>launch</code> 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 <code>Dispatchers.Main</code> 的具体实现。</p>\n<p>在 Jvm 上，<code>Main</code> 的实现也比较有意思：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">object</span> MainDispatcherLoader &#123;</span><br><span class=\"line\">    <span class=\"meta\">@JvmField</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadMainDispatcher</span><span class=\"params\">()</span></span>: MainCoroutineDispatcher &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> factories = MainDispatcherFactory::<span class=\"keyword\">class</span>.java.let &#123; clz -&gt;</span><br><span class=\"line\">                ServiceLoader.load(clz, clz.classLoader).toList()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)</span><br><span class=\"line\">                ?: MissingMainCoroutineDispatcher(<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">            MissingMainCoroutineDispatcher(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 使得 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例，有兴趣的可以去看下  kotlinx-coroutines-android 的源码实现。</p>\n<blockquote>\n<p>注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。</p>\n</blockquote>\n<h3 id=\"3-3-绑定到任意线程的调度器\"><a href=\"#3-3-绑定到任意线程的调度器\" class=\"headerlink\" title=\"3.3 绑定到任意线程的调度器\"></a>3.3 绑定到任意线程的调度器</h3><p>调度器的目的就是切线程，你不要想着我在 <code>dispatch</code> 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class=\"string\">&quot;MyThread&quot;</span>) &#125;.asCoroutineDispatcher()</span><br><span class=\"line\">    GlobalScope.launch(myDispatcher) &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出的信息就表明协程运行在我们自己的线程上。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">10</span>:<span class=\"number\">57</span>:<span class=\"number\">130</span> [MyThread] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">10</span>:<span class=\"number\">57</span>:<span class=\"number\">136</span> [MyThread] <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg\"></p>\n<p>我们可以通过主动关闭线程池或者调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDispatcher.close()</span><br></pre></td></tr></table></figure>\n<p>来结束它的生命周期，再次运行程序就会正常退出了。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg\"></p>\n<p>当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。</p>\n<p>Kotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？</p>\n<p><strong>废弃的两个基于线程池创建调度器的 API</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">newSingleThreadContext</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">newFixedThreadPoolContext</span><span class=\"params\">(nThreads: <span class=\"type\">Int</span>, name: <span class=\"type\">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br></pre></td></tr></table></figure>\n<p>这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。</p>\n<p>其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newFixedThreadPool(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class=\"line\">            GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">                log(<span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> job = async &#123;</span><br><span class=\"line\">                    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">                    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">                    <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log(<span class=\"number\">4</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> result = job.await()</span><br><span class=\"line\">                log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">            &#125;.join()</span><br><span class=\"line\">            log(<span class=\"number\">6</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面除了 <code>delay</code> 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（<code>Continuation.resume</code>）都会切线程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:28:04:771 [pool-1-thread-1] 1</span><br><span class=\"line\">16:28:04:779 [pool-1-thread-1] 4</span><br><span class=\"line\">16:28:04:779 [pool-1-thread-2] 2</span><br><span class=\"line\">16:28:05:790 [pool-1-thread-3] 3</span><br><span class=\"line\">16:28:05:793 [pool-1-thread-4] 5. Hello</span><br><span class=\"line\">16:28:05:794 [pool-1-thread-4] 6</span><br></pre></td></tr></table></figure>\n\n<p>如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:40:14:685 [pool-1-thread-1] 1</span><br><span class=\"line\">16:40:14:706 [pool-1-thread-1] 4</span><br><span class=\"line\">16:40:14:710 [pool-1-thread-1] 2</span><br><span class=\"line\">16:40:15:723 [pool-1-thread-1] 3</span><br><span class=\"line\">16:40:15:725 [pool-1-thread-1] 5. Hello</span><br><span class=\"line\">16:40:15:725 [pool-1-thread-1] 6</span><br></pre></td></tr></table></figure>\n\n<p>对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 <code>delay</code> 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：</p>\n<table>\n<thead>\n<tr>\n<th>线程数</th>\n<th>10</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>耗时ms</td>\n<td>1006.00</td>\n<td>1004.97</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。</p>\n</blockquote>\n<p>也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。</p>\n<p>实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。</p>\n<h3 id=\"3-4-线程安全问题\"><a href=\"#3-4-线程安全问题\" class=\"headerlink\" title=\"3.4 线程安全问题\"></a>3.4 线程安全问题</h3><p>Js 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。</p>\n<p>好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。</p>\n<p>如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。</p>\n<p>以下是一个错误的例子，大家很容易就能想明白：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    Executors.newFixedThreadPool(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class=\"line\">                List(<span class=\"number\">1000000</span>) &#123;</span><br><span class=\"line\">                    GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">                        i++</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;.forEach &#123;</span><br><span class=\"line\">                    it.join()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    log(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:59:28:080 [main] 999593</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-suspend-main-函数如何调度？\"><a href=\"#4-suspend-main-函数如何调度？\" class=\"headerlink\" title=\"4. suspend main 函数如何调度？\"></a>4. suspend main 函数如何调度？</h2><p>上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？</p>\n<p>我们先给出一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它等价于下面的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runSuspend &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        GlobalScope.launch &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;.join()</span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那你说这个 <code>runSuspend</code> 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runSuspend</span><span class=\"params\">(block: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> run = RunSuspend()</span><br><span class=\"line\">    block.startCoroutine(run)</span><br><span class=\"line\">    run.await()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这里面的 <code>RunSuspend</code> 则是 <code>Continuation</code> 的实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunSuspend</span> : <span class=\"type\">Continuation</span>&lt;<span class=\"type\">Unit</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = EmptyCoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: Result&lt;<span class=\"built_in\">Unit</span>&gt;? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">Unit</span>&gt;)</span></span> = synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result</span><br><span class=\"line\">        (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Object).notifyAll()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">()</span></span> = synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (<span class=\"keyword\">val</span> result = <span class=\"keyword\">this</span>.result) &#123;</span><br><span class=\"line\">                <span class=\"literal\">null</span> -&gt; (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Object).wait()</span><br><span class=\"line\">                <span class=\"keyword\">else</span> -&gt; &#123;</span><br><span class=\"line\">                    result.getOrThrow() <span class=\"comment\">// throw up failure</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。</p>\n<p>通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。</p>\n<blockquote>\n<p>上述代码在标准库当中被修饰为 <code>internal</code>，因此我们无法直接使用它们。不过你可以把 <strong>RunSuspend.kt</strong> 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 <code>var result: Result&lt;Unit&gt;? = null</code> 可能会报错，没关系，改成 <code>private var result: Result&lt;Unit&gt;? = null</code> 就可以了。</p>\n</blockquote>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#102;&#64;&#105;&#109;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#111;&#x6d;\">&#107;&#102;&#64;&#105;&#109;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上一篇我们知道了协程启动的几种模式，也通过示例认识了 <code>launch</code> 启动协程的使用方法，本文将延续这些内容从调度的角度来进一步为大家揭示协程的奥义。 </p>\n</blockquote>","more":"<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15550227714805.jpg\"></p>\n<h2 id=\"1-协程上下文\"><a href=\"#1-协程上下文\" class=\"headerlink\" title=\"1. 协程上下文\"></a>1. 协程上下文</h2><p>调度器本质上就是一个协程上下文的实现，我们先来介绍下上下文。</p>\n<p>前面我们提到 <code>launch</code> 函数有三个参数，第一个参数叫 <strong>上下文</strong>，它的接口类型是 <code>CoroutineContext</code>，通常我们见到的上下文的类型是 <code>CombinedContext</code> 或者 <code>EmptyCoroutineContext</code>，一个表示上下文的组合，另一个表示什么都没有。我们来看下 <code>CoroutineContext</code> 的接口方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.3&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CoroutineContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E : Element&gt;</span> <span class=\"title\">get</span><span class=\"params\">(key: <span class=\"type\">Key</span>&lt;<span class=\"type\">E</span>&gt;)</span></span>: E?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> <span class=\"title\">fold</span><span class=\"params\">(initial: <span class=\"type\">R</span>, operation: (<span class=\"type\">R</span>, <span class=\"type\">Element</span>) -&gt; <span class=\"type\">R</span>)</span></span>: R</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">plus</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>)</span></span>: CoroutineContext = ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">minusKey</span><span class=\"params\">(key: <span class=\"type\">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Key</span>&lt;<span class=\"type\">E : Element</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Element</span> : <span class=\"type\">CoroutineContext &#123;</span></span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">val</span> key: Key&lt;*&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不知道大家有没有发现，它简直就是一个以 <code>Key</code> 为索引的 <code>List</code>：</p>\n<table>\n<thead>\n<tr>\n<th>CoroutineContext</th>\n<th>List</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>get(Key)</td>\n<td>get(Int)</td>\n</tr>\n<tr>\n<td>plus(CoroutineContext)</td>\n<td>plus(List)</td>\n</tr>\n<tr>\n<td>minusKey(Key)</td>\n<td>removeAt(Int)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>表中的 <code>List.plus(List)</code> 实际上指的是扩展方法 <code>Collection&lt;T&gt;.plus(elements: Iterable&lt;T&gt;): List&lt;T&gt;</code> </p>\n</blockquote>\n<p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code>，每一个 <code>Element</code> 都有一个 <code>key</code>，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code> 的子接口，因此也可以作为集合出现。</p>\n<p>讲到这里，大家就会明白，<code>CoroutineContext</code> 原来是个数据结构啊。如果大家对于 <code>List</code> 的递归定义比较熟悉的话，那么对于 <code>CombinedContext</code> 和 <code>EmptyCoroutineContext</code> 也就很容易理解了，例如 scala 的 <code>List</code>是这么定义的：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>[+<span class=\"type\">A</span>] <span class=\"keyword\">extends</span> ... </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">head</span></span>: <span class=\"type\">A</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tail</span></span>: <span class=\"type\">List</span>[<span class=\"type\">A</span>]</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在模式匹配的时候，<code>List(1,2,3,4)</code> 是可以匹配 <code>x::y</code> 的，<code>x</code> 就是 1，<code>y</code> 则是 <code>List(2,3,4)</code>。</p>\n<p><code>CombinedContext</code> 的定义也非常类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CombinedContext</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> left: CoroutineContext,</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> element: Element</span><br><span class=\"line\">) : CoroutineContext, Serializable &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只不过它是反过来的，前面是集合，后面是单独的一个元素。我们在协程体里面访问到的 <code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有很多具体的上下文实现的集合，我们如果想要找到某一个特别的上下文实现，就需要用对应的 <code>Key</code> 来查找，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        println(coroutineContext[Job]) <span class=\"comment\">// &quot;coroutine#1&quot;:StandaloneCoroutine&#123;Active&#125;@1ff62014</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(coroutineContext[Job]) <span class=\"comment\">// null，suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Job</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Key for [Job] instance in the coroutine context.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所以我们也可以仿照 <code>Thread.currentThread()</code> 来一个获取当前 <code>Job</code> 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> Job.Key.<span class=\"title\">currentJob</span><span class=\"params\">()</span></span> = coroutineContext[Job]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">coroutineJob</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(Job.currentJob())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(Job.currentJob())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>我们可以通过指定上下文为协程添加一些特性，一个很好的例子就是为协程添加名称，方便调试：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(CoroutineName(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个上下文需要添加，直接用 <code>+</code> 就可以了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main + CoroutineName(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Dispatchers.Main</code> 是调度器的一个实现，不用担心，我们很快就会认识它了。</p>\n</blockquote>\n<h2 id=\"2-协程拦截器\"><a href=\"#2-协程拦截器\" class=\"headerlink\" title=\"2. 协程拦截器\"></a>2. 协程拦截器</h2><p>费了好大劲儿说完上下文，这里就要说一个比较特殊的存在了——拦截器。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ContinuationInterceptor</span> : <span class=\"type\">CoroutineContext.Element &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">interceptContinuation</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拦截器也是一个上下文的实现方向，拦截器可以左右你的协程的执行，同时为了保证它的功能的正确性，协程上下文集合永远将它放在最后面，这真可谓是天选之子了。</p>\n<p>它拦截协程的方法也很简单，因为协程的本质就是回调 + “黑魔法”，而这个回调就是被拦截的 <code>Continuation</code> 了。用过 OkHttp 的小伙伴一下就兴奋了，拦截器我常用的啊，OkHttp 用拦截器做缓存，打日志，还可以模拟请求，协程拦截器也是一样的道理。调度器就是基于拦截器实现的，换句话说调度器就是拦截器的一种。</p>\n<p>我们可以自己定义一个拦截器放到我们的协程上下文中，看看会发生什么。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContinuationInterceptor</span>: <span class=\"type\">ContinuationInterceptor&#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> key = ContinuationInterceptor</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">interceptContinuation</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> = MyContinuation(continuation)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContinuation</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context = continuation.context</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;&lt;MyContinuation&gt; <span class=\"variable\">$result</span>&quot;</span> )</span><br><span class=\"line\">        continuation.resumeWith(result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只是在回调处打了一行日志。接下来我们把用例拿出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    GlobalScope.launch(MyContinuationInterceptor()) &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> job = async &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"number\">4</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = job.await()</span><br><span class=\"line\">        log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">6</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这可能是迄今而止我们给出的最复杂的例子了，不过请大家不要被它吓到，它依然很简单。我们通过 <code>launch</code> 启动了一个协程，为它指定了我们自己的拦截器作为上下文，紧接着在其中用 <code>async</code> 启动了一个协程，<code>async</code> 与 <code>launch</code> 从功能上是同等类型的函数，它们都被称作协程的 Builder 函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果，可以通过 <code>await</code> 方法获取。</p>\n<p>可想而知，<code>result</code> 的值就是 Hello。那么这段程序运行的结果如何呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15:31:55:989 [main] &lt;MyContinuation&gt; Success(kotlin.Unit)  &#x2F;&#x2F; ①</span><br><span class=\"line\">15:31:55:992 [main] 1</span><br><span class=\"line\">15:31:56:000 [main] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ②</span><br><span class=\"line\">15:31:56:000 [main] 2</span><br><span class=\"line\">15:31:56:031 [main] 4</span><br><span class=\"line\">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit) &#x2F;&#x2F; ③</span><br><span class=\"line\">15:31:57:029 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello) &#x2F;&#x2F; ④</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 5. Hello</span><br><span class=\"line\">15:31:57:031 [kotlinx.coroutines.DefaultExecutor] 6</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>“// ①” 不是程序输出的内容，仅为后续讲解方便而做的标注。</p>\n</blockquote>\n<p>大家可能就要奇怪了，你不是说 <code>Continuation</code> 是回调么，这里面回调调用也就一次啊（<code>await</code> 那里），怎么日志打印了四次呢？</p>\n<p>别慌，我们按顺序给大家介绍。</p>\n<p>首先，所有协程启动的时候，都会有一次 <code>Continuation.resumeWith</code>  的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于此。 ①、② 两处都是这种情况。</p>\n<p>其次，<code>delay</code> 是挂起点，1000ms 之后需要继续调度执行该协程，因此就有了 ③ 处的日志。</p>\n<p>最后，④ 处的日志就很容易理解了，正是我们的返回结果。</p>\n<p>可能有朋友还会有疑问，我并没有在拦截器当中切换线程，为什么从 ③ 处开始有了线程切换的操作？这个切换线程的逻辑源自于 <code>delay</code>，在 JVM 上 <code>delay</code> 实际上是在一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换；而在 JavaScript 环境中则是基于 setTimeout，如果运行在 Nodejs 上，<code>delay</code> 就不会切线程了，毕竟人家是单线程的。</p>\n<p>如果我们在拦截器当中自己处理了线程切换，那么就实现了自己的一个简单的调度器，大家有兴趣可以自己去尝试。</p>\n<blockquote>\n<p>思考：拦截器可以有多个吗？</p>\n</blockquote>\n<h2 id=\"3-调度器\"><a href=\"#3-调度器\" class=\"headerlink\" title=\"3. 调度器\"></a>3. 调度器</h2><h3 id=\"3-1-概述\"><a href=\"#3-1-概述\" class=\"headerlink\" title=\"3.1 概述\"></a>3.1 概述</h3><p>有了前面的基础，我们对于调度器的介绍就变得水到渠成了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineDispatcher</span> :<span class=\"type\"></span></span></span><br><span class=\"line\">    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatch</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>, block: <span class=\"type\">Runnable</span>)</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它本身是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调度。所以如果我们想要实现自己的调度器，继承这个类就可以了，不过通常我们都用现成的，它们定义在 <code>Dispatchers</code> 当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> Default: CoroutineDispatcher</span><br><span class=\"line\"><span class=\"keyword\">val</span> Main: MainCoroutineDispatcher</span><br><span class=\"line\"><span class=\"keyword\">val</span> Unconfined: CoroutineDispatcher</span><br></pre></td></tr></table></figure>\n<p>这个类的定义涉及到了 Kotlin MPP 的支持，因此你在 Jvm 版本当中还会看到 <code>val IO: CoroutineDispatcher</code>，在 js 和 native 当中就只有前面提到的这三个了（对 Jvm 好偏心呐）。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Jvm</th>\n<th>Js</th>\n<th>Native</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Default</td>\n<td>线程池</td>\n<td>主线程循环</td>\n<td>主线程循环</td>\n</tr>\n<tr>\n<td>Main</td>\n<td>UI 线程</td>\n<td>与 Default 相同</td>\n<td>与 Default 相同</td>\n</tr>\n<tr>\n<td>Unconfined</td>\n<td>直接执行</td>\n<td>直接执行</td>\n<td>直接执行</td>\n</tr>\n<tr>\n<td>IO</td>\n<td>线程池</td>\n<td>–</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<ul>\n<li>IO 仅在 Jvm 上有定义，它基于 Default 调度器背后的线程池，并实现了独立的队列和限制，因此协程调度器从 Default 切换到 IO 并不会触发线程切换。</li>\n<li>Main 主要用于 UI 相关程序，在 Jvm 上包括 Swing、JavaFx、Android，可将协程调度到各自的 UI 线程上。</li>\n<li>Js 本身就是单线程的事件循环，与 Jvm 上的 UI 程序比较类似。</li>\n</ul>\n<h3 id=\"3-2-编写-UI-相关程序\"><a href=\"#3-2-编写-UI-相关程序\" class=\"headerlink\" title=\"3.2 编写 UI 相关程序\"></a>3.2 编写 UI 相关程序</h3><p>Kotlin 的用户绝大多数都是 Android 开发者，大家对 UI 的开发需求还是比较大的。我们举一个很常见的场景，点击一个按钮做点儿异步的操作再回调刷新 UI：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123; </span><br><span class=\"line\">    getUser &#123; user -&gt;</span><br><span class=\"line\">        handler.post &#123;</span><br><span class=\"line\">            userNameView.text = user.name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们简单得给出 <code>getUser</code> 函数的声明：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Callback = (User) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 <code>getUser</code> 函数需要切到其他线程执行，因此回调通常也会在这个非 UI 的线程中调用，所以为了确保 UI 正确被刷新，我们需要用 <code>handler.post</code> 切换到 UI 线程。上面的写法就是我们最古老的写法了。</p>\n<p>后来又有了 RxJava，那么事情开始变得有趣了起来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserObservable</span><span class=\"params\">()</span></span>: Observable&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Observable.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class=\"line\">        getUser &#123;</span><br><span class=\"line\">            emitter.onNext(it)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是点击按钮的事件可以这么写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    getUserObservable()</span><br><span class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">            .subscribe &#123; user -&gt;</span><br><span class=\"line\">                userNameView.text = user.name</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 RxJava 在线程切换上的表现是非常优秀的，也正是如此，很多人甚至用它只是为了切线程方便！</p>\n<p>那么我们现在把这段代码过渡到协程的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    getUser &#123;</span><br><span class=\"line\">        continuation.resume(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按钮点击时，我们可以：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大家也可以用 anko-coroutines 当中的 View.onClick 扩展，这样我们就无需自己在这里用 <code>launch</code> 启动协程了。有关 Anko 对协程的支持，我们后面专门安排一篇文章介绍。</p>\n</blockquote>\n<p>这里又有大家没见过的内容啦，<code>suspendCoroutine</code> 这个方法并不是帮我们启动协程的，它运行在协程当中并且帮我们获取到当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方便后面我们调用它的 <code>resume</code> 或者 <code>resumeWithException</code> 来返回结果或者抛出异常。</p>\n<blockquote>\n<p>如果你重复调用 <code>resume</code> 或者 <code>resumeWithException</code> 会收获一枚 <code>IllegalStateException</code>，仔细想想这是为什么。</p>\n</blockquote>\n<p>对比前面的 RxJava 的做法，你会发现这段代码其实很容易理解，你甚至会发现协程的使用场景与 RxJava 竟是如此的相似。这里我们用到了 <code>Dispatchers.Main</code> 来确保 <code>launch</code> 启动的协程在调度时始终调度到 UI 线程，那么下面我们来看看 <code>Dispatchers.Main</code> 的具体实现。</p>\n<p>在 Jvm 上，<code>Main</code> 的实现也比较有意思：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">object</span> MainDispatcherLoader &#123;</span><br><span class=\"line\">    <span class=\"meta\">@JvmField</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadMainDispatcher</span><span class=\"params\">()</span></span>: MainCoroutineDispatcher &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> factories = MainDispatcherFactory::<span class=\"keyword\">class</span>.java.let &#123; clz -&gt;</span><br><span class=\"line\">                ServiceLoader.load(clz, clz.classLoader).toList()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)</span><br><span class=\"line\">                ?: MissingMainCoroutineDispatcher(<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">            MissingMainCoroutineDispatcher(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 使得 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例，有兴趣的可以去看下  kotlinx-coroutines-android 的源码实现。</p>\n<blockquote>\n<p>注意前面对于 RxJava 和协程的实现，我们都没有考虑异常和取消的问题。有关异常和取消的话题，我们会在后面的文章中详细介绍。</p>\n</blockquote>\n<h3 id=\"3-3-绑定到任意线程的调度器\"><a href=\"#3-3-绑定到任意线程的调度器\" class=\"headerlink\" title=\"3.3 绑定到任意线程的调度器\"></a>3.3 绑定到任意线程的调度器</h3><p>调度器的目的就是切线程，你不要想着我在 <code>dispatch</code> 的时候根据自己的心情来随机调用，那你是在害你自己（不怕各位笑话，这样的代码我还真写过，仅供娱乐）。那么问题就简单了，我们只要提供线程，调度器就应该很方便的创建出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class=\"string\">&quot;MyThread&quot;</span>) &#125;.asCoroutineDispatcher()</span><br><span class=\"line\">    GlobalScope.launch(myDispatcher) &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出的信息就表明协程运行在我们自己的线程上。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">10</span>:<span class=\"number\">57</span>:<span class=\"number\">130</span> [MyThread] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">16</span>:<span class=\"number\">10</span>:<span class=\"number\">57</span>:<span class=\"number\">136</span> [MyThread] <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>不过请大家注意，由于这个线程池是我们自己创建的，因此我们需要在合适的时候关闭它，不然的话：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546248040111.jpg\"></p>\n<p>我们可以通过主动关闭线程池或者调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDispatcher.close()</span><br></pre></td></tr></table></figure>\n<p>来结束它的生命周期，再次运行程序就会正常退出了。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15546249279403.jpg\"></p>\n<p>当然有人会说你创建的线程池的线程不是 daemon 的，所以主线程结束时 Jvm 不会停止运行。说的没错，但该释放的还是要及时释放，如果你只是在程序的整个生命周期当中短暂的用了一下这个调度器，那么一直不关闭它对应的线程池岂不是会有线程泄露吗？这就很尴尬了。</p>\n<p>Kotlin 协程设计者也特别害怕大家注意不到这一点，还特地废弃了两个 API 并且开了一个 issue 说我们要重做这套 API，这两个可怜的家伙是谁呢？</p>\n<p><strong>废弃的两个基于线程池创建调度器的 API</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">newSingleThreadContext</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">newFixedThreadPoolContext</span><span class=\"params\">(nThreads: <span class=\"type\">Int</span>, name: <span class=\"type\">String</span>)</span></span>: ExecutorCoroutineDispatcher</span><br></pre></td></tr></table></figure>\n<p>这二者可以很方便的创建绑定到特定线程的调度器，但过于简洁的 API 似乎会让人忘记它的风险。Kotlin 一向不爱做这种不清不楚的事儿，所以您呢，还是像我们这一节例子当中那样自己去构造线程池吧，这样好歹自己忘了关闭也怨不着别人（哈哈哈）。</p>\n<p>其实在多个线程上运行协程，线程总是这样切来切去其实并不会显得很轻量级，例如下面的例子就是比较可怕的了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newFixedThreadPool(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class=\"line\">            GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">                log(<span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> job = async &#123;</span><br><span class=\"line\">                    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">                    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">                    <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log(<span class=\"number\">4</span>)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> result = job.await()</span><br><span class=\"line\">                log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">            &#125;.join()</span><br><span class=\"line\">            log(<span class=\"number\">6</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面除了 <code>delay</code> 那里有一次不可避免的线程切换外，其他几处协程挂起点的继续操作（<code>Continuation.resume</code>）都会切线程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:28:04:771 [pool-1-thread-1] 1</span><br><span class=\"line\">16:28:04:779 [pool-1-thread-1] 4</span><br><span class=\"line\">16:28:04:779 [pool-1-thread-2] 2</span><br><span class=\"line\">16:28:05:790 [pool-1-thread-3] 3</span><br><span class=\"line\">16:28:05:793 [pool-1-thread-4] 5. Hello</span><br><span class=\"line\">16:28:05:794 [pool-1-thread-4] 6</span><br></pre></td></tr></table></figure>\n\n<p>如果我们的线程池只开 1 个线程，那么这里所有的输出都将在这唯一的线程中打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:40:14:685 [pool-1-thread-1] 1</span><br><span class=\"line\">16:40:14:706 [pool-1-thread-1] 4</span><br><span class=\"line\">16:40:14:710 [pool-1-thread-1] 2</span><br><span class=\"line\">16:40:15:723 [pool-1-thread-1] 3</span><br><span class=\"line\">16:40:15:725 [pool-1-thread-1] 5. Hello</span><br><span class=\"line\">16:40:15:725 [pool-1-thread-1] 6</span><br></pre></td></tr></table></figure>\n\n<p>对比这二者，10个线程的情况线程切换次数最少 3次，而 1 个线程的情况则只要 <code>delay</code> 1000ms 之后恢复执行的时候那一次。只是多两次线程切换，到底会有多大影响呢？我在我自己的 2015 款 mbp 上对于两种不同的情况分别循环运行 100 次，得到的平均时间如下：</p>\n<table>\n<thead>\n<tr>\n<th>线程数</th>\n<th>10</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>耗时ms</td>\n<td>1006.00</td>\n<td>1004.97</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意，为了测试的公平性，在运行 100 次循环之前已经做好了预热，确保所有类都已经加载。测试结果仅供参考。</p>\n</blockquote>\n<p>也就是说多两次线程切换平均能多出 1ms 的耗时。生产环境当中的代码当然会更复杂，如果这样用线程池去调度，结果可想而知。</p>\n<p>实际上通常我们只需要在一个线程当中处理自己的业务逻辑，只有一些耗时的 IO 才需要切换到 IO 线程中处理，所以好的做法可以参考 UI 对应的调度器，自己通过线程池定义调度器的做法本身没什么问题，但最好只用一个线程，因为多线程除了前面说的线程切换的开销外，还有线程安全的问题。</p>\n<h3 id=\"3-4-线程安全问题\"><a href=\"#3-4-线程安全问题\" class=\"headerlink\" title=\"3.4 线程安全问题\"></a>3.4 线程安全问题</h3><p>Js 和 Native 的并发模型与 Jvm 不同，Jvm 暴露了线程 API 给用户，这也使得协程的调度可以由用户更灵活的选择。越多的自由，意味着越多的代价，我们在 Jvm 上面编写协程代码时需要明白一点的是，线程安全问题在调度器不同的协程之间仍然存在。</p>\n<p>好的做法，就像我们前面一节提到的，尽量把自己的逻辑控制在一个线程之内，这样一方面节省了线程切换的开销，另一方面还可以避免线程安全问题，两全其美。</p>\n<p>如果大家在协程代码中使用锁之类的并发工具就反而增加了代码的复杂度，对此我的建议是大家在编写协程代码时尽量避免对外部作用域的可变变量进行引用，尽量使用参数传递而非对全局变量进行引用。</p>\n<p>以下是一个错误的例子，大家很容易就能想明白：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    Executors.newFixedThreadPool(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .asCoroutineDispatcher().use &#123; dispatcher -&gt;</span><br><span class=\"line\">                List(<span class=\"number\">1000000</span>) &#123;</span><br><span class=\"line\">                    GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">                        i++</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;.forEach &#123;</span><br><span class=\"line\">                    it.join()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    log(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16:59:28:080 [main] 999593</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-suspend-main-函数如何调度？\"><a href=\"#4-suspend-main-函数如何调度？\" class=\"headerlink\" title=\"4. suspend main 函数如何调度？\"></a>4. suspend main 函数如何调度？</h2><p>上一篇文章我们提到了 suspend main 会启动一个协程，我们示例中的协程都是它的子协程，可是这个最外层的协程到底是怎么来的呢？</p>\n<p>我们先给出一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它等价于下面的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runSuspend &#123;</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">        GlobalScope.launch &#123;</span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;.join()</span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那你说这个 <code>runSuspend</code> 又是何妨神圣？它是 Kotlin 标准库的一个方法，注意它不是 kotlinx.coroutines 当中的，它实际上属于更底层的 API 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runSuspend</span><span class=\"params\">(block: <span class=\"type\">suspend</span> () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> run = RunSuspend()</span><br><span class=\"line\">    block.startCoroutine(run)</span><br><span class=\"line\">    run.await()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这里面的 <code>RunSuspend</code> 则是 <code>Continuation</code> 的实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunSuspend</span> : <span class=\"type\">Continuation</span>&lt;<span class=\"type\">Unit</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context: CoroutineContext</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = EmptyCoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: Result&lt;<span class=\"built_in\">Unit</span>&gt;? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">Unit</span>&gt;)</span></span> = synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result</span><br><span class=\"line\">        (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Object).notifyAll()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">()</span></span> = synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">when</span> (<span class=\"keyword\">val</span> result = <span class=\"keyword\">this</span>.result) &#123;</span><br><span class=\"line\">                <span class=\"literal\">null</span> -&gt; (<span class=\"keyword\">this</span> <span class=\"keyword\">as</span> Object).wait()</span><br><span class=\"line\">                <span class=\"keyword\">else</span> -&gt; &#123;</span><br><span class=\"line\">                    result.getOrThrow() <span class=\"comment\">// throw up failure</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的上下文是空的，因此 suspend main 启动的协程并不会有任何调度行为。</p>\n<p>通过这个例子我们可以知道，实际上启动一个协程只需要有一个 lambda 表达式就可以了，想当年 Kotlin 1.1 刚发布的时候，我写了一系列的教程都是以标准库 API 为基础的，后来发现标准库的 API 也许真的不是给我们用的，所以看看就好。</p>\n<blockquote>\n<p>上述代码在标准库当中被修饰为 <code>internal</code>，因此我们无法直接使用它们。不过你可以把 <strong>RunSuspend.kt</strong> 当中的内容复制到你的工程当中，这样你就可以直接使用啦，其中的 <code>var result: Result&lt;Unit&gt;? = null</code> 可能会报错，没关系，改成 <code>private var result: Result&lt;Unit&gt;? = null</code> 就可以了。</p>\n</blockquote>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>在这篇文章当中，我们介绍了协程上下文，介绍了拦截器，进而最终引出了我们的调度器，截止目前，我们还有异常处理、协程取消、Anko 对协程的支持等话题没有讲到，如果大家有协程相关想了解的话题，可以留言哈~</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#102;&#64;&#105;&#109;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#111;&#x6d;\">&#107;&#102;&#64;&#105;&#109;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(4) - 异常处理篇","keywords":"Kotlin 协程 异常处理","date":"2019-04-22T16:00:00.000Z","description":null,"_content":"\n> 异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。 \n\n<!-- more -->\n\n\n\n\n## 1. 引子\n\n我们在前面一篇文章当中提到了这样一个例子：\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback){\n    ...\n}\n```\n\n我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {\n    continuation ->\n    getUser {\n        continuation.resume(it)\n    }\n}\n```\n\n并最终交给按钮点击事件或者其他事件去触发这个异步请求：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispatchers.Main) {\n        userNameView.text = getUserCoroutine().name\n    }\n}\n```\n\n那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。\n\n## 2. 添加异常处理逻辑\n\n首先我们加上异常回调接口函数：\n\n```kotlin\ninterface Callback<T> {\n    fun onSuccess(value: T)\n\n    fun onError(t: Throwable)\n}\n```\n\n接下来我们在改造一下我们的 `getUserCoroutine`：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> { continuation ->\n    getUser(object : Callback<User> {\n        override fun onSuccess(value: User) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n```\n\n大家可以看到，我们似乎就是完全把 `Callback` 转换成了一个 `Continuation`，在调用的时候我们只需要：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch (e: Exception) {\n        userNameView.text = \"Get User Error: $e\"\n    }\n}\n```\n\n是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 `try ... catch ... ` 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。\n\n如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：\n\n```kotlin\nfun getUserObservable(): Single<User> {\n    return Single.create<User> { emitter ->\n        getUser(object : Callback<User> {\n            override fun onSuccess(value: User) {\n                emitter.onSuccess(value)\n            }\n\n            override fun onError(t: Throwable) {\n                emitter.onError(t)\n            }\n        })\n    }\n}\n```\n\n调用时大概是这样的：\n\n```kotlin\ngetUserObservable()\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe ({ user ->\n            userNameView.text = user.name\n        }, {\n            userNameView.text = \"Get User Error: $it\"\n        })\n```\n\n其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。\n\n> 也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。\n\n## 3. 全局异常处理\n\n线程也好、RxJava 也好，都有全局处理异常的方式，例如：\n\n```kotlin\nfun main() {\n    Thread.setDefaultUncaughtExceptionHandler {t: Thread, e: Throwable ->\n        //handle exception here\n        println(\"Thread '${t.name}' throws an exception with message '${e.message}'\")\n    }\n\n    throw ArithmeticException(\"Hey!\")\n}\n```\n\n我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：\n\n```kotlin\nRxJavaPlugins.setErrorHandler(e -> {\n        //handle exception here\n        println(\"Throws an exception with message '${e.message}'\")\n});\n```\n\n协程显然也可以做到这一点。类似于通过 `Thread.setUncaughtExceptionHandler` 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 `CoroutineExceptionHandler`，这样协程内部未捕获的异常就可以通过它来捕获：\n\n```kotlin\nprivate suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\n        log(\"Throws an exception with message: ${throwable.message}\")\n    }\n\n    log(1)\n    GlobalScope.launch(exceptionHandler) {\n        throw ArithmeticException(\"Hey!\")\n    }.join()\n    log(2)\n}\n```\n\n运行结果：\n\n```\n19:06:35:087 [main] 1\n19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!\n19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2\n```\n\n`CoroutineExceptionHandler` 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。\n\n当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：\n\n```kotlin\nclass GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key<*> = CoroutineExceptionHandler\n\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        println(\"Coroutine exception: $exception\")\n    }\n}\n```\n\n然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 `CoroutineExceptionHandler` 的全类名，文件内容就写我们的实现类的全类名：\n\n```\ncom.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler\n```\n\n这样协程中没有被捕获的异常就会最终交给它处理。\n\n> Jvm 上全局 `CoroutineExceptionHandler` 的配置，本质上是对 `ServiceLoader` 的应用，之前我们在讲 `Dispatchers.Main` 的时候提到过，Jvm 上它的实现也是通过 `ServiceLoader` 来加载的。\n\n需要明确的一点是，通过 `async` 启动的协程出现未捕获的异常时会忽略 `CoroutineExceptionHandler`，这与 `launch` 的设计思路是不同的。\n\n## 4. 异常传播\n\n异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 `GlobalScope`，意味着这是一个独立的顶级协程作用域，此外还有 `coroutineScope { ... }` 以及 `supervisorScope { ... }`。\n\n* 通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。\n* coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。\n* supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。\n\n这么说还是比较抽象，因此我们拿一些例子来分析一下：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    try {\n        coroutineScope { //①\n            log(2)\n            launch { // ②\n                log(3)\n                launch { // ③ \n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hey!!\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch { // ④\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                 job.join()\n                log(\"9\")\n            } catch (e: Exception) {\n                log(\"10. $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12. $e\")\n    }\n    log(13)\n}\n```\n\n这例子稍微有点儿复杂，但也不难理解，我们在一个 `coroutineScope` 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：\n\n```\n11:37:36:208 [main] 1\n11:37:36:255 [main] 2\n11:37:36:325 [DefaultDispatcher-worker-1] 3\n11:37:36:325 [DefaultDispatcher-worker-1] 5\n11:37:36:326 [DefaultDispatcher-worker-3] 4\n11:37:36:331 [main] 6\n11:37:36:336 [DefaultDispatcher-worker-1] 7\n11:37:36:336 [main] 8\n11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@2bc92d2f\n11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!\n11:37:36:445 [DefaultDispatcher-worker-1] 13\n```\n\n注意两个位置，一个是 10，我们调用 `join`，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 `CancellationException`，这类似于线程中对 `InterruptException` 的响应，遇到这种情况表示 `join` 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？\n\n原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 `job.join` 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，`coroutineScope` 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 `delay`进行捕获，一样会收获一枚取消异常。\n\n还有一个位置就是 12，这个是我们对 `coroutineScope` 整体的一个捕获，如果 `coroutineScope` 内部以为异常而结束，那么我们是可以对它直接 `try ... catch ...` 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。 \n\n那么如果我们把 `coroutineScope` 换成 `supervisorScope`，其他不变，运行结果会是怎样呢？\n\n```\n11:52:48:632 [main] 1\n11:52:48:694 [main] 2\n11:52:48:875 [main] 6\n11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3\n11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5\n11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4\n11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7\n11:52:48:907 [main] 8\nException in thread \"DefaultDispatcher-worker-3 @coroutine#3\" java.lang.ArithmeticException: Hey!!\n\tat com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13\n```\n\n我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 `supervisorScope`，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。\n\n这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 `CoroutineExceptionHandler`，就可以证明我们前面提到的另外一个结论：\n\n首先我们定义一个 `CoroutineExceptionHandler`，我们通过上下文获取一下异常对应的协程的名字：\n\n```kotlin\nval exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\n    log(\"${coroutineContext[CoroutineName]} $throwable\")\n}\n```\n\n接着，基于前面的例子我们为 ② 和 ③ 添加 `CoroutineExceptionHandler` 和名字：\n\n```kotlin\n...\nsupervisorScope { //①\n    log(2)\n    launch(exceptionHandler + CoroutineName(\"②\")) { // ②\n        log(3)\n        launch(exceptionHandler + CoroutineName(\"③\")) { // ③\n            log(4)\n...\n```\n\n再运行这段程序，结果就比较有意思了：\n\n```\n...\n07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!\n...\n```\n\n我们发现触发的 `CoroutineExceptionHandler` 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 `supervisorScope` 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 `coroutineScope` 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。\n\n究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：\n\n* 对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope\n* 对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动\n* 对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope \n* 对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。\n\n当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。\n\n### 5. join 和 await\n\n前面我们举例子一直用的是 `launch`，启动协程其实常用的还有 `async`、`actor` 和 `produce`，其中 `actor` 和 `launch` 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 `async` 和 `produce`  则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。\n\n> `actor` 和 `produce` 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。\n\n那么消费结果指的是什么呢？对于 `async` 来讲，就是 `await`，例如：\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> { \n        throw ArithmeticException()\n    }\n    try {\n        val value = deferred.await()\n        log(\"1. $value\")\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n这个从逻辑上很好理解，我们调用 `await` 时，期望 `deferred` 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。\n\n```\n13:25:14:693 [main] 2. java.lang.ArithmeticException\n```\n\n我们自己实现的 `getUserCoroutine` 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，`join` 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 `join`：\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> {\n        throw ArithmeticException()\n    }\n    try {\n        deferred.join()\n        log(1)\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n我们就会发现，异常被吞掉了！\n\n```\n13:26:15:034 [main] 1\n```\n\n如果例子当中我们用 `launch` 替换 `async`，`join` 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， `launch` 中未捕获的异常与 `async` 的处理方式不同，`launch` 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 `supervisorScope` 中父协程不响应，那么就交给上下文中指定的 `CoroutineExceptionHandler`处理，如果没有指定，那传给全局的 `CoroutineExceptionHandler` 等等，而 `async` 则要等 `await` 来消费。\n\n> 不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 `async` 来说就算不调用 `await` 来获取这个异常，它也会在 `coroutineScope` 当中触发父协程的取消逻辑，这一点请大家注意。\n\n### 6. 小结\n\n这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：\n\n1. **协程内部异常处理流程**：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。\n2. **异常在作用域内的传播**：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。\n3.  **join 和 await 的不同**：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。\n\n如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。\n\n### 附加说明\n\njoin 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：[No CancellationException thrown when join on a crashed Job](https://github.com/Kotlin/kotlinx.coroutines/issues/1123)。\n\n当然，这个 bug 对于生成环境的影响很小，大家也不要担心。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-exceptions.md","raw":"---\ntitle:  破解 Kotlin 协程(4) - 异常处理篇  \nkeywords: Kotlin 协程 异常处理 \ndate: 2019/04/23\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。 \n\n<!-- more -->\n\n\n\n\n## 1. 引子\n\n我们在前面一篇文章当中提到了这样一个例子：\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback){\n    ...\n}\n```\n\n我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {\n    continuation ->\n    getUser {\n        continuation.resume(it)\n    }\n}\n```\n\n并最终交给按钮点击事件或者其他事件去触发这个异步请求：\n\n```kotlin\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispatchers.Main) {\n        userNameView.text = getUserCoroutine().name\n    }\n}\n```\n\n那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。\n\n## 2. 添加异常处理逻辑\n\n首先我们加上异常回调接口函数：\n\n```kotlin\ninterface Callback<T> {\n    fun onSuccess(value: T)\n\n    fun onError(t: Throwable)\n}\n```\n\n接下来我们在改造一下我们的 `getUserCoroutine`：\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> { continuation ->\n    getUser(object : Callback<User> {\n        override fun onSuccess(value: User) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n```\n\n大家可以看到，我们似乎就是完全把 `Callback` 转换成了一个 `Continuation`，在调用的时候我们只需要：\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch (e: Exception) {\n        userNameView.text = \"Get User Error: $e\"\n    }\n}\n```\n\n是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 `try ... catch ... ` 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。\n\n如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：\n\n```kotlin\nfun getUserObservable(): Single<User> {\n    return Single.create<User> { emitter ->\n        getUser(object : Callback<User> {\n            override fun onSuccess(value: User) {\n                emitter.onSuccess(value)\n            }\n\n            override fun onError(t: Throwable) {\n                emitter.onError(t)\n            }\n        })\n    }\n}\n```\n\n调用时大概是这样的：\n\n```kotlin\ngetUserObservable()\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe ({ user ->\n            userNameView.text = user.name\n        }, {\n            userNameView.text = \"Get User Error: $it\"\n        })\n```\n\n其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。\n\n> 也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。\n\n## 3. 全局异常处理\n\n线程也好、RxJava 也好，都有全局处理异常的方式，例如：\n\n```kotlin\nfun main() {\n    Thread.setDefaultUncaughtExceptionHandler {t: Thread, e: Throwable ->\n        //handle exception here\n        println(\"Thread '${t.name}' throws an exception with message '${e.message}'\")\n    }\n\n    throw ArithmeticException(\"Hey!\")\n}\n```\n\n我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：\n\n```kotlin\nRxJavaPlugins.setErrorHandler(e -> {\n        //handle exception here\n        println(\"Throws an exception with message '${e.message}'\")\n});\n```\n\n协程显然也可以做到这一点。类似于通过 `Thread.setUncaughtExceptionHandler` 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 `CoroutineExceptionHandler`，这样协程内部未捕获的异常就可以通过它来捕获：\n\n```kotlin\nprivate suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\n        log(\"Throws an exception with message: ${throwable.message}\")\n    }\n\n    log(1)\n    GlobalScope.launch(exceptionHandler) {\n        throw ArithmeticException(\"Hey!\")\n    }.join()\n    log(2)\n}\n```\n\n运行结果：\n\n```\n19:06:35:087 [main] 1\n19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!\n19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2\n```\n\n`CoroutineExceptionHandler` 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。\n\n当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：\n\n```kotlin\nclass GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key<*> = CoroutineExceptionHandler\n\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        println(\"Coroutine exception: $exception\")\n    }\n}\n```\n\n然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 `CoroutineExceptionHandler` 的全类名，文件内容就写我们的实现类的全类名：\n\n```\ncom.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler\n```\n\n这样协程中没有被捕获的异常就会最终交给它处理。\n\n> Jvm 上全局 `CoroutineExceptionHandler` 的配置，本质上是对 `ServiceLoader` 的应用，之前我们在讲 `Dispatchers.Main` 的时候提到过，Jvm 上它的实现也是通过 `ServiceLoader` 来加载的。\n\n需要明确的一点是，通过 `async` 启动的协程出现未捕获的异常时会忽略 `CoroutineExceptionHandler`，这与 `launch` 的设计思路是不同的。\n\n## 4. 异常传播\n\n异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 `GlobalScope`，意味着这是一个独立的顶级协程作用域，此外还有 `coroutineScope { ... }` 以及 `supervisorScope { ... }`。\n\n* 通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。\n* coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。\n* supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。\n\n这么说还是比较抽象，因此我们拿一些例子来分析一下：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    try {\n        coroutineScope { //①\n            log(2)\n            launch { // ②\n                log(3)\n                launch { // ③ \n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hey!!\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch { // ④\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                 job.join()\n                log(\"9\")\n            } catch (e: Exception) {\n                log(\"10. $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12. $e\")\n    }\n    log(13)\n}\n```\n\n这例子稍微有点儿复杂，但也不难理解，我们在一个 `coroutineScope` 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：\n\n```\n11:37:36:208 [main] 1\n11:37:36:255 [main] 2\n11:37:36:325 [DefaultDispatcher-worker-1] 3\n11:37:36:325 [DefaultDispatcher-worker-1] 5\n11:37:36:326 [DefaultDispatcher-worker-3] 4\n11:37:36:331 [main] 6\n11:37:36:336 [DefaultDispatcher-worker-1] 7\n11:37:36:336 [main] 8\n11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@2bc92d2f\n11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!\n11:37:36:445 [DefaultDispatcher-worker-1] 13\n```\n\n注意两个位置，一个是 10，我们调用 `join`，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 `CancellationException`，这类似于线程中对 `InterruptException` 的响应，遇到这种情况表示 `join` 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？\n\n原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 `job.join` 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，`coroutineScope` 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 `delay`进行捕获，一样会收获一枚取消异常。\n\n还有一个位置就是 12，这个是我们对 `coroutineScope` 整体的一个捕获，如果 `coroutineScope` 内部以为异常而结束，那么我们是可以对它直接 `try ... catch ...` 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。 \n\n那么如果我们把 `coroutineScope` 换成 `supervisorScope`，其他不变，运行结果会是怎样呢？\n\n```\n11:52:48:632 [main] 1\n11:52:48:694 [main] 2\n11:52:48:875 [main] 6\n11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3\n11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5\n11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4\n11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7\n11:52:48:907 [main] 8\nException in thread \"DefaultDispatcher-worker-3 @coroutine#3\" java.lang.ArithmeticException: Hey!!\n\tat com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11\n11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13\n```\n\n我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 `supervisorScope`，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。\n\n这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 `CoroutineExceptionHandler`，就可以证明我们前面提到的另外一个结论：\n\n首先我们定义一个 `CoroutineExceptionHandler`，我们通过上下文获取一下异常对应的协程的名字：\n\n```kotlin\nval exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\n    log(\"${coroutineContext[CoroutineName]} $throwable\")\n}\n```\n\n接着，基于前面的例子我们为 ② 和 ③ 添加 `CoroutineExceptionHandler` 和名字：\n\n```kotlin\n...\nsupervisorScope { //①\n    log(2)\n    launch(exceptionHandler + CoroutineName(\"②\")) { // ②\n        log(3)\n        launch(exceptionHandler + CoroutineName(\"③\")) { // ③\n            log(4)\n...\n```\n\n再运行这段程序，结果就比较有意思了：\n\n```\n...\n07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!\n...\n```\n\n我们发现触发的 `CoroutineExceptionHandler` 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 `supervisorScope` 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 `coroutineScope` 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。\n\n究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：\n\n* 对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope\n* 对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动\n* 对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope \n* 对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。\n\n当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。\n\n### 5. join 和 await\n\n前面我们举例子一直用的是 `launch`，启动协程其实常用的还有 `async`、`actor` 和 `produce`，其中 `actor` 和 `launch` 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 `async` 和 `produce`  则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。\n\n> `actor` 和 `produce` 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。\n\n那么消费结果指的是什么呢？对于 `async` 来讲，就是 `await`，例如：\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> { \n        throw ArithmeticException()\n    }\n    try {\n        val value = deferred.await()\n        log(\"1. $value\")\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n这个从逻辑上很好理解，我们调用 `await` 时，期望 `deferred` 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。\n\n```\n13:25:14:693 [main] 2. java.lang.ArithmeticException\n```\n\n我们自己实现的 `getUserCoroutine` 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，`join` 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 `join`：\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> {\n        throw ArithmeticException()\n    }\n    try {\n        deferred.join()\n        log(1)\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n我们就会发现，异常被吞掉了！\n\n```\n13:26:15:034 [main] 1\n```\n\n如果例子当中我们用 `launch` 替换 `async`，`join` 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， `launch` 中未捕获的异常与 `async` 的处理方式不同，`launch` 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 `supervisorScope` 中父协程不响应，那么就交给上下文中指定的 `CoroutineExceptionHandler`处理，如果没有指定，那传给全局的 `CoroutineExceptionHandler` 等等，而 `async` 则要等 `await` 来消费。\n\n> 不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 `async` 来说就算不调用 `await` 来获取这个异常，它也会在 `coroutineScope` 当中触发父协程的取消逻辑，这一点请大家注意。\n\n### 6. 小结\n\n这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：\n\n1. **协程内部异常处理流程**：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。\n2. **异常在作用域内的传播**：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。\n3.  **join 和 await 的不同**：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。\n\n如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。\n\n### 附加说明\n\njoin 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：[No CancellationException thrown when join on a crashed Job](https://github.com/Kotlin/kotlinx.coroutines/issues/1123)。\n\n当然，这个 bug 对于生成环境的影响很小，大家也不要担心。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-exceptions","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0034000olduzgavghcti","content":"<blockquote>\n<p>异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-引子\"><a href=\"#1-引子\" class=\"headerlink\" title=\"1. 引子\"></a>1. 引子</h2><p>我们在前面一篇文章当中提到了这样一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Callback = (User) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    getUser &#123;</span><br><span class=\"line\">        continuation.resume(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并最终交给按钮点击事件或者其他事件去触发这个异步请求：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。</p>\n<h2 id=\"2-添加异常处理逻辑\"><a href=\"#2-添加异常处理逻辑\" class=\"headerlink\" title=\"2. 添加异常处理逻辑\"></a>2. 添加异常处理逻辑</h2><p>首先我们加上异常回调接口函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们在改造一下我们的 <code>getUserCoroutine</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resume(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resumeWithException(t)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家可以看到，我们似乎就是完全把 <code>Callback</code> 转换成了一个 <code>Continuation</code>，在调用的时候我们只需要：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        userNameView.text = <span class=\"string\">&quot;Get User Error: <span class=\"variable\">$e</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 <code>try ... catch ... </code> 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。</p>\n<p>如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserObservable</span><span class=\"params\">()</span></span>: Single&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Single.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class=\"line\">        getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">                emitter.onSuccess(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                emitter.onError(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时大概是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserObservable()</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">        .subscribe (&#123; user -&gt;</span><br><span class=\"line\">            userNameView.text = user.name</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            userNameView.text = <span class=\"string\">&quot;Get User Error: <span class=\"variable\">$it</span>&quot;</span></span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。</p>\n<blockquote>\n<p>也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。</p>\n</blockquote>\n<h2 id=\"3-全局异常处理\"><a href=\"#3-全局异常处理\" class=\"headerlink\" title=\"3. 全局异常处理\"></a>3. 全局异常处理</h2><p>线程也好、RxJava 也好，都有全局处理异常的方式，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Thread.setDefaultUncaughtExceptionHandler &#123;t: Thread, e: Throwable -&gt;</span><br><span class=\"line\">        <span class=\"comment\">//handle exception here</span></span><br><span class=\"line\">        println(<span class=\"string\">&quot;Thread &#x27;<span class=\"subst\">$&#123;t.name&#125;</span>&#x27; throws an exception with message &#x27;<span class=\"subst\">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//handle exception here</span></span><br><span class=\"line\">        println(<span class=\"string\">&quot;Throws an exception with message &#x27;<span class=\"subst\">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>协程显然也可以做到这一点。类似于通过 <code>Thread.setUncaughtExceptionHandler</code> 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code>，这样协程内部未捕获的异常就可以通过它来捕获：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;Throws an exception with message: <span class=\"subst\">$&#123;throwable.message&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!&quot;</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19:06:35:087 [main] 1</span><br><span class=\"line\">19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!</span><br><span class=\"line\">19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></pre></td></tr></table></figure>\n\n<p><code>CoroutineExceptionHandler</code> 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。</p>\n<p>当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlobalCoroutineExceptionHandler</span>: <span class=\"type\">CoroutineExceptionHandler &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleException</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>, exception: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Coroutine exception: <span class=\"variable\">$exception</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 <code>CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全类名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure>\n\n<p>这样协程中没有被捕获的异常就会最终交给它处理。</p>\n<blockquote>\n<p>Jvm 上全局 <code>CoroutineExceptionHandler</code> 的配置，本质上是对 <code>ServiceLoader</code> 的应用，之前我们在讲 <code>Dispatchers.Main</code> 的时候提到过，Jvm 上它的实现也是通过 <code>ServiceLoader</code> 来加载的。</p>\n</blockquote>\n<p>需要明确的一点是，通过 <code>async</code> 启动的协程出现未捕获的异常时会忽略 <code>CoroutineExceptionHandler</code>，这与 <code>launch</code> 的设计思路是不同的。</p>\n<h2 id=\"4-异常传播\"><a href=\"#4-异常传播\" class=\"headerlink\" title=\"4. 异常传播\"></a>4. 异常传播</h2><p>异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 <code>GlobalScope</code>，意味着这是一个独立的顶级协程作用域，此外还有 <code>coroutineScope &#123; ... &#125;</code> 以及 <code>supervisorScope &#123; ... &#125;</code>。</p>\n<ul>\n<li>通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。</li>\n<li>coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。</li>\n<li>supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。</li>\n</ul>\n<p>这么说还是比较抽象，因此我们拿一些例子来分析一下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        coroutineScope &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            launch &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">                log(<span class=\"number\">3</span>)</span><br><span class=\"line\">                launch &#123; <span class=\"comment\">// ③ </span></span><br><span class=\"line\">                    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">                    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!!&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log(<span class=\"number\">5</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log(<span class=\"number\">6</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> job = launch &#123; <span class=\"comment\">// ④</span></span><br><span class=\"line\">                log(<span class=\"number\">7</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log(<span class=\"number\">8</span>)</span><br><span class=\"line\">                 job.join()</span><br><span class=\"line\">                log(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                log(<span class=\"string\">&quot;10. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"number\">11</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;12. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">13</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这例子稍微有点儿复杂，但也不难理解，我们在一个 <code>coroutineScope</code> 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:37:36:208 [main] 1</span><br><span class=\"line\">11:37:36:255 [main] 2</span><br><span class=\"line\">11:37:36:325 [DefaultDispatcher-worker-1] 3</span><br><span class=\"line\">11:37:36:325 [DefaultDispatcher-worker-1] 5</span><br><span class=\"line\">11:37:36:326 [DefaultDispatcher-worker-3] 4</span><br><span class=\"line\">11:37:36:331 [main] 6</span><br><span class=\"line\">11:37:36:336 [DefaultDispatcher-worker-1] 7</span><br><span class=\"line\">11:37:36:336 [main] 8</span><br><span class=\"line\">11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job&#x3D;ScopeCoroutine&#123;Cancelling&#125;@2bc92d2f</span><br><span class=\"line\">11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">11:37:36:445 [DefaultDispatcher-worker-1] 13</span><br></pre></td></tr></table></figure>\n\n<p>注意两个位置，一个是 10，我们调用 <code>join</code>，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 <code>CancellationException</code>，这类似于线程中对 <code>InterruptException</code> 的响应，遇到这种情况表示 <code>join</code> 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？</p>\n<p>原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 <code>job.join</code> 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，<code>coroutineScope</code> 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 <code>delay</code>进行捕获，一样会收获一枚取消异常。</p>\n<p>还有一个位置就是 12，这个是我们对 <code>coroutineScope</code> 整体的一个捕获，如果 <code>coroutineScope</code> 内部以为异常而结束，那么我们是可以对它直接 <code>try ... catch ...</code> 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。 </p>\n<p>那么如果我们把 <code>coroutineScope</code> 换成 <code>supervisorScope</code>，其他不变，运行结果会是怎样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:52:48:632 [main] 1</span><br><span class=\"line\">11:52:48:694 [main] 2</span><br><span class=\"line\">11:52:48:875 [main] 6</span><br><span class=\"line\">11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class=\"line\">11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br><span class=\"line\">11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4</span><br><span class=\"line\">11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7</span><br><span class=\"line\">11:52:48:907 [main] 8</span><br><span class=\"line\">Exception in thread &quot;DefaultDispatcher-worker-3 @coroutine#3&quot; java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">\tat com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)</span><br><span class=\"line\">\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class=\"line\">\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 <code>supervisorScope</code>，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。</p>\n<p>这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 <code>CoroutineExceptionHandler</code>，就可以证明我们前面提到的另外一个结论：</p>\n<p>首先我们定义一个 <code>CoroutineExceptionHandler</code>，我们通过上下文获取一下异常对应的协程的名字：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;<span class=\"subst\">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class=\"variable\">$throwable</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，基于前面的例子我们为 ② 和 ③ 添加 <code>CoroutineExceptionHandler</code> 和名字：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">supervisorScope &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    launch(exceptionHandler + CoroutineName(<span class=\"string\">&quot;②&quot;</span>)) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">        launch(exceptionHandler + CoroutineName(<span class=\"string\">&quot;③&quot;</span>)) &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">            log(<span class=\"number\">4</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>再运行这段程序，结果就比较有意思了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我们发现触发的 <code>CoroutineExceptionHandler</code> 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 <code>supervisorScope</code> 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 <code>coroutineScope</code> 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。</p>\n<p>究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：</p>\n<ul>\n<li>对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope</li>\n<li>对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动</li>\n<li>对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope </li>\n<li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。</li>\n</ul>\n<p>当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。</p>\n<h3 id=\"5-join-和-await\"><a href=\"#5-join-和-await\" class=\"headerlink\" title=\"5. join 和 await\"></a>5. join 和 await</h3><p>前面我们举例子一直用的是 <code>launch</code>，启动协程其实常用的还有 <code>async</code>、<code>actor</code> 和 <code>produce</code>，其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 <code>async</code> 和 <code>produce</code>  则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。</p>\n<blockquote>\n<p><code>actor</code> 和 <code>produce</code> 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。</p>\n</blockquote>\n<p>那么消费结果指的是什么呢？对于 <code>async</code> 来讲，就是 <code>await</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = GlobalScope.async&lt;<span class=\"built_in\">Int</span>&gt; &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> value = deferred.await()</span><br><span class=\"line\">        log(<span class=\"string\">&quot;1. <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;2. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个从逻辑上很好理解，我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:25:14:693 [main] 2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>\n\n<p>我们自己实现的 <code>getUserCoroutine</code> 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，<code>join</code> 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 <code>join</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = GlobalScope.async&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        deferred.join()</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;2. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们就会发现，异常被吞掉了！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:26:15:034 [main] 1</span><br></pre></td></tr></table></figure>\n\n<p>如果例子当中我们用 <code>launch</code> 替换 <code>async</code>，<code>join</code> 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， <code>launch</code> 中未捕获的异常与 <code>async</code> 的处理方式不同，<code>launch</code> 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 <code>supervisorScope</code> 中父协程不响应，那么就交给上下文中指定的 <code>CoroutineExceptionHandler</code>处理，如果没有指定，那传给全局的 <code>CoroutineExceptionHandler</code> 等等，而 <code>async</code> 则要等 <code>await</code> 来消费。</p>\n<blockquote>\n<p>不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 <code>async</code> 来说就算不调用 <code>await</code> 来获取这个异常，它也会在 <code>coroutineScope</code> 当中触发父协程的取消逻辑，这一点请大家注意。</p>\n</blockquote>\n<h3 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h3><p>这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：</p>\n<ol>\n<li><strong>协程内部异常处理流程</strong>：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。</li>\n<li><strong>异常在作用域内的传播</strong>：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。</li>\n<li> <strong>join 和 await 的不同</strong>：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。</li>\n</ol>\n<p>如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。</p>\n<h3 id=\"附加说明\"><a href=\"#附加说明\" class=\"headerlink\" title=\"附加说明\"></a>附加说明</h3><p>join 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：<a href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/1123\">No CancellationException thrown when join on a crashed Job</a>。</p>\n<p>当然，这个 bug 对于生成环境的影响很小，大家也不要担心。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#x66;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#x63;&#111;&#109;\">&#107;&#x66;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#x63;&#111;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。 </p>\n</blockquote>","more":"<h2 id=\"1-引子\"><a href=\"#1-引子\" class=\"headerlink\" title=\"1. 引子\"></a>1. 引子</h2><p>我们在前面一篇文章当中提到了这样一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> Callback = (User) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUser</span><span class=\"params\">(callback: <span class=\"type\">Callback</span>)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    getUser &#123;</span><br><span class=\"line\">        continuation.resume(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并最终交给按钮点击事件或者其他事件去触发这个异步请求：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserBtn.setOnClickListener &#123;</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。</p>\n<h2 id=\"2-添加异常处理逻辑\"><a href=\"#2-添加异常处理逻辑\" class=\"headerlink\" title=\"2. 添加异常处理逻辑\"></a>2. 添加异常处理逻辑</h2><p>首先我们加上异常回调接口函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们在改造一下我们的 <code>getUserCoroutine</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserCoroutine</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;User&gt; &#123; continuation -&gt;</span><br><span class=\"line\">    getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resume(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">            continuation.resumeWithException(t)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家可以看到，我们似乎就是完全把 <code>Callback</code> 转换成了一个 <code>Continuation</code>，在调用的时候我们只需要：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        userNameView.text = getUserCoroutine().name</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        userNameView.text = <span class=\"string\">&quot;Get User Error: <span class=\"variable\">$e</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 <code>try ... catch ... </code> 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。</p>\n<p>如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getUserObservable</span><span class=\"params\">()</span></span>: Single&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Single.create&lt;User&gt; &#123; emitter -&gt;</span><br><span class=\"line\">        getUser(<span class=\"keyword\">object</span> : Callback&lt;User&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(value: <span class=\"type\">User</span>)</span></span> &#123;</span><br><span class=\"line\">                emitter.onSuccess(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(t: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">                emitter.onError(t)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时大概是这样的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserObservable()</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">        .subscribe (&#123; user -&gt;</span><br><span class=\"line\">            userNameView.text = user.name</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            userNameView.text = <span class=\"string\">&quot;Get User Error: <span class=\"variable\">$it</span>&quot;</span></span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。</p>\n<blockquote>\n<p>也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。</p>\n</blockquote>\n<h2 id=\"3-全局异常处理\"><a href=\"#3-全局异常处理\" class=\"headerlink\" title=\"3. 全局异常处理\"></a>3. 全局异常处理</h2><p>线程也好、RxJava 也好，都有全局处理异常的方式，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    Thread.setDefaultUncaughtExceptionHandler &#123;t: Thread, e: Throwable -&gt;</span><br><span class=\"line\">        <span class=\"comment\">//handle exception here</span></span><br><span class=\"line\">        println(<span class=\"string\">&quot;Thread &#x27;<span class=\"subst\">$&#123;t.name&#125;</span>&#x27; throws an exception with message &#x27;<span class=\"subst\">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RxJavaPlugins.setErrorHandler(e -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//handle exception here</span></span><br><span class=\"line\">        println(<span class=\"string\">&quot;Throws an exception with message &#x27;<span class=\"subst\">$&#123;e.message&#125;</span>&#x27;&quot;</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>协程显然也可以做到这一点。类似于通过 <code>Thread.setUncaughtExceptionHandler</code> 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code>，这样协程内部未捕获的异常就可以通过它来捕获：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;Throws an exception with message: <span class=\"subst\">$&#123;throwable.message&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch(exceptionHandler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!&quot;</span>)</span><br><span class=\"line\">    &#125;.join()</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19:06:35:087 [main] 1</span><br><span class=\"line\">19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!</span><br><span class=\"line\">19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></pre></td></tr></table></figure>\n\n<p><code>CoroutineExceptionHandler</code> 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。</p>\n<p>当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlobalCoroutineExceptionHandler</span>: <span class=\"type\">CoroutineExceptionHandler &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleException</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span>, exception: <span class=\"type\">Throwable</span>)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Coroutine exception: <span class=\"variable\">$exception</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 <code>CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全类名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler</span><br></pre></td></tr></table></figure>\n\n<p>这样协程中没有被捕获的异常就会最终交给它处理。</p>\n<blockquote>\n<p>Jvm 上全局 <code>CoroutineExceptionHandler</code> 的配置，本质上是对 <code>ServiceLoader</code> 的应用，之前我们在讲 <code>Dispatchers.Main</code> 的时候提到过，Jvm 上它的实现也是通过 <code>ServiceLoader</code> 来加载的。</p>\n</blockquote>\n<p>需要明确的一点是，通过 <code>async</code> 启动的协程出现未捕获的异常时会忽略 <code>CoroutineExceptionHandler</code>，这与 <code>launch</code> 的设计思路是不同的。</p>\n<h2 id=\"4-异常传播\"><a href=\"#4-异常传播\" class=\"headerlink\" title=\"4. 异常传播\"></a>4. 异常传播</h2><p>异常传播还涉及到协程作用域的概念，例如我们启动协程的时候一直都是用的 <code>GlobalScope</code>，意味着这是一个独立的顶级协程作用域，此外还有 <code>coroutineScope &#123; ... &#125;</code> 以及 <code>supervisorScope &#123; ... &#125;</code>。</p>\n<ul>\n<li>通过 GlobeScope 启动的协程单独启动一个协程作用域，内部的子协程遵从默认的作用域规则。通过 GlobeScope 启动的协程“自成一派”。</li>\n<li>coroutineScope 是继承外部 Job 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程。它更适合一系列对等的协程并发的完成一项工作，任何一个子协程异常退出，那么整体都将退出，简单来说就是”一损俱损“。这也是协程内部再启动子协程的默认作用域。</li>\n<li>supervisorScope 同样继承外部作用域的上下文，但其内部的取消操作是单向传播的，父协程向子协程传播，反过来则不然，这意味着子协程出了异常并不会影响父协程以及其他兄弟协程。它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，简单来说就是”自作自受“，例如 UI，我点击一个按钮出了异常，其实并不会影响手机状态栏的刷新。需要注意的是，supervisorScope 内部启动的子协程内部再启动子协程，如无明确指出，则遵守默认作用域规则，也即 supervisorScope 只作用域其直接子协程。</li>\n</ul>\n<p>这么说还是比较抽象，因此我们拿一些例子来分析一下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        coroutineScope &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">            log(<span class=\"number\">2</span>)</span><br><span class=\"line\">            launch &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">                log(<span class=\"number\">3</span>)</span><br><span class=\"line\">                launch &#123; <span class=\"comment\">// ③ </span></span><br><span class=\"line\">                    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">                    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Hey!!&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log(<span class=\"number\">5</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log(<span class=\"number\">6</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> job = launch &#123; <span class=\"comment\">// ④</span></span><br><span class=\"line\">                log(<span class=\"number\">7</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log(<span class=\"number\">8</span>)</span><br><span class=\"line\">                 job.join()</span><br><span class=\"line\">                log(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">                log(<span class=\"string\">&quot;10. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"number\">11</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;12. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">13</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这例子稍微有点儿复杂，但也不难理解，我们在一个 <code>coroutineScope</code> 当中启动了两个协程 ②④，在 ② 当中启动了一个子协程 ③，作用域直接创建的协程记为①。那么 ③ 当中抛异常会发生什么呢？我们先来看下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:37:36:208 [main] 1</span><br><span class=\"line\">11:37:36:255 [main] 2</span><br><span class=\"line\">11:37:36:325 [DefaultDispatcher-worker-1] 3</span><br><span class=\"line\">11:37:36:325 [DefaultDispatcher-worker-1] 5</span><br><span class=\"line\">11:37:36:326 [DefaultDispatcher-worker-3] 4</span><br><span class=\"line\">11:37:36:331 [main] 6</span><br><span class=\"line\">11:37:36:336 [DefaultDispatcher-worker-1] 7</span><br><span class=\"line\">11:37:36:336 [main] 8</span><br><span class=\"line\">11:37:36:441 [DefaultDispatcher-worker-1] 10. kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job&#x3D;ScopeCoroutine&#123;Cancelling&#125;@2bc92d2f</span><br><span class=\"line\">11:37:36:445 [DefaultDispatcher-worker-1] 12. java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">11:37:36:445 [DefaultDispatcher-worker-1] 13</span><br></pre></td></tr></table></figure>\n\n<p>注意两个位置，一个是 10，我们调用 <code>join</code>，收到了一个取消异常，在协程当中支持取消的操作的suspend方法在取消时会抛出一个 <code>CancellationException</code>，这类似于线程中对 <code>InterruptException</code> 的响应，遇到这种情况表示 <code>join</code> 调用所在的协程已经被取消了，那么这个取消究竟是怎么回事呢？</p>\n<p>原来协程 ③ 抛出了未捕获的异常，进入了异常完成的状态，它与父协程 ② 之间遵循默认的作用域规则，因此 ③ 会通知它的父协程也就是 ② 取消，② 根据作用域规则通知父协程 ① 也就是整个作用域取消，这是一个自下而上的一次传播，这样身处 ① 当中的 <code>job.join</code> 调用就会抛异常，也就是 10 处的结果了。如果不是很理解这个操作，想一下我们说到的，<code>coroutineScope</code> 内部启动的协程就是“一损俱损”。实际上由于父协程 ① 被取消，协程④ 也不能幸免，如果大家有兴趣的话，也可以对 ④ 当中的 <code>delay</code>进行捕获，一样会收获一枚取消异常。</p>\n<p>还有一个位置就是 12，这个是我们对 <code>coroutineScope</code> 整体的一个捕获，如果 <code>coroutineScope</code> 内部以为异常而结束，那么我们是可以对它直接 <code>try ... catch ...</code> 来捕获这个异常的，这再一次表明协程把异步的异常处理到同步代码逻辑当中。 </p>\n<p>那么如果我们把 <code>coroutineScope</code> 换成 <code>supervisorScope</code>，其他不变，运行结果会是怎样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:52:48:632 [main] 1</span><br><span class=\"line\">11:52:48:694 [main] 2</span><br><span class=\"line\">11:52:48:875 [main] 6</span><br><span class=\"line\">11:52:48:892 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class=\"line\">11:52:48:895 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br><span class=\"line\">11:52:48:900 [DefaultDispatcher-worker-3 @coroutine#3] 4</span><br><span class=\"line\">11:52:48:905 [DefaultDispatcher-worker-2 @coroutine#2] 7</span><br><span class=\"line\">11:52:48:907 [main] 8</span><br><span class=\"line\">Exception in thread &quot;DefaultDispatcher-worker-3 @coroutine#3&quot; java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">\tat com.bennyhuo.coroutines.sample2.exceptions.ScopesKt$main$2$1$1.invokeSuspend(Scopes.kt:17)</span><br><span class=\"line\">\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class=\"line\">\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:238)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)</span><br><span class=\"line\">\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 9</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 11</span><br><span class=\"line\">11:52:49:915 [DefaultDispatcher-worker-3 @coroutine#2] 13</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，1-8 的输出其实没有本质区别，顺序上的差异是线程调度的前后造成的，并不会影响协程的语义。差别主要在于 9 与 10、11与12的区别，如果把 scope 换成 <code>supervisorScope</code>，我们发现 ③ 的异常并没有影响作用域以及作用域内的其他子协程的执行，也就是我们所说的“自作自受”。</p>\n<p>这个例子其实我们再稍做一些改动，为 ② 和 ③ 增加一个 <code>CoroutineExceptionHandler</code>，就可以证明我们前面提到的另外一个结论：</p>\n<p>首先我们定义一个 <code>CoroutineExceptionHandler</code>，我们通过上下文获取一下异常对应的协程的名字：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;<span class=\"subst\">$&#123;coroutineContext[CoroutineName]&#125;</span> <span class=\"variable\">$throwable</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，基于前面的例子我们为 ② 和 ③ 添加 <code>CoroutineExceptionHandler</code> 和名字：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">supervisorScope &#123; <span class=\"comment\">//①</span></span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    launch(exceptionHandler + CoroutineName(<span class=\"string\">&quot;②&quot;</span>)) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">        launch(exceptionHandler + CoroutineName(<span class=\"string\">&quot;③&quot;</span>)) &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">            log(<span class=\"number\">4</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>再运行这段程序，结果就比较有意思了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">07:30:11:519 [DefaultDispatcher-worker-1] CoroutineName(②) java.lang.ArithmeticException: Hey!!</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我们发现触发的 <code>CoroutineExceptionHandler</code> 竟然是协程 ② 的，意外吗？不意外，因为我们前面已经提到，对于 <code>supervisorScope</code> 的子协程 （例如 ②）的子协程（例如 ③），如果没有明确指出，它是遵循默认的作用于规则的，也就是 <code>coroutineScope</code> 的规则了，出现未捕获的异常会尝试传递给父协程并尝试取消父协程。</p>\n<p>究竟使用什么 Scope，大家自己根据实际情况来确定，我给出一些建议：</p>\n<ul>\n<li>对于没有协程作用域，但需要启动协程的时候，适合用 GlobalScope</li>\n<li>对于已经有协程作用域的情况（例如通过 GlobalScope 启动的协程体内），直接用协程启动器启动</li>\n<li>对于明确要求子协程之间相互独立不干扰时，使用 supervisorScope </li>\n<li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 Job、作用域等概念的支撑，例如我们前面提到过 suspend main 就是这种情况，对于这种情况优先考虑通过 coroutineScope 创建作用域；更进一步，大家尽量不要直接使用标准库 API，除非你对 Kotlin 的协程机制非常熟悉。</li>\n</ul>\n<p>当然，对于可能出异常的情况，请大家尽量做好异常处理，不要将问题复杂化。</p>\n<h3 id=\"5-join-和-await\"><a href=\"#5-join-和-await\" class=\"headerlink\" title=\"5. join 和 await\"></a>5. join 和 await</h3><p>前面我们举例子一直用的是 <code>launch</code>，启动协程其实常用的还有 <code>async</code>、<code>actor</code> 和 <code>produce</code>，其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获的异常出现以后，会被当做为处理的异常抛出，就像前面的例子那样。而 <code>async</code> 和 <code>produce</code>  则主要是用来输出结果的，他们内部的异常只在外部消费他们的结果时抛出。这两组协程的启动器，你也可以认为分别是“消费者”和“生产者”，消费者异常立即抛出，生产者只有结果消费时抛出异常。</p>\n<blockquote>\n<p><code>actor</code> 和 <code>produce</code> 这两个 API 目前处于比较微妙的境地，可能会被废弃或者后续提供替代方案，不建议大家使用，我们在这里就不展开细讲了。</p>\n</blockquote>\n<p>那么消费结果指的是什么呢？对于 <code>async</code> 来讲，就是 <code>await</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = GlobalScope.async&lt;<span class=\"built_in\">Int</span>&gt; &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> value = deferred.await()</span><br><span class=\"line\">        log(<span class=\"string\">&quot;1. <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;2. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个从逻辑上很好理解，我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们提供一个合适的结果，但它因为出异常，没有办法做到这一点，因此只好给我们丢出一个异常了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:25:14:693 [main] 2. java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>\n\n<p>我们自己实现的 <code>getUserCoroutine</code> 也属于类似的情况，在获取结果时，如果请求出了异常，我们就只能拿到一个异常，而不是正常的结果。相比之下，<code>join</code> 就有趣的多了，它只关注是否执行完，至于是因为什么完成，它不关心，因此如果我们在这里替换成 <code>join</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferred = GlobalScope.async&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ArithmeticException()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        deferred.join()</span><br><span class=\"line\">        log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;2. <span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们就会发现，异常被吞掉了！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:26:15:034 [main] 1</span><br></pre></td></tr></table></figure>\n\n<p>如果例子当中我们用 <code>launch</code> 替换 <code>async</code>，<code>join</code> 处仍然不会有任何异常抛出，还是那句话，它只关心有没有完成，至于怎么完成的它不关心。不同之处在于， <code>launch</code> 中未捕获的异常与 <code>async</code> 的处理方式不同，<code>launch</code> 会直接抛出给父协程，如果没有父协程（顶级作用域中）或者处于 <code>supervisorScope</code> 中父协程不响应，那么就交给上下文中指定的 <code>CoroutineExceptionHandler</code>处理，如果没有指定，那传给全局的 <code>CoroutineExceptionHandler</code> 等等，而 <code>async</code> 则要等 <code>await</code> 来消费。</p>\n<blockquote>\n<p>不管是哪个启动器，在应用了作用域之后，都会按照作用域的语义进行异常扩散，进而触发相应的取消操作，对于 <code>async</code> 来说就算不调用 <code>await</code> 来获取这个异常，它也会在 <code>coroutineScope</code> 当中触发父协程的取消逻辑，这一点请大家注意。</p>\n</blockquote>\n<h3 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h3><p>这一篇我们讲了协程的异常处理。这一块儿稍微显得有点儿复杂，但仔细理一下主要有三条线：</p>\n<ol>\n<li><strong>协程内部异常处理流程</strong>：launch 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看作用域的定义，如果取消成功，那么异常传递给父协程，否则传递给启动时上下文中配置的 CoroutineExceptionHandler 中，如果没有配置，会查找全局（JVM上）的 CoroutineExceptionHandler 进行处理，如果仍然没有，那么就将异常交给当前线程的 UncaughtExceptionHandler 处理；而 async 则在未捕获的异常出现时同样会尝试取消父协程，但不管是否能够取消成功都不会后其他后续的异常处理，直到用户主动调用 await 时将异常抛出。</li>\n<li><strong>异常在作用域内的传播</strong>：当协程出现异常时，会根据当前作用域触发异常传递，GlobalScope 会创建一个独立的作用域，所谓“自成一派”，而 在 coroutineScope 当中协程异常会触发父协程的取消，进而将整个协程作用域取消掉，如果对 coroutineScope 整体进行捕获，也可以捕获到该异常，所谓“一损俱损”；如果是 supervisorScope，那么子协程的异常不会向上传递，所谓“自作自受”。</li>\n<li> <strong>join 和 await 的不同</strong>：join 只关心协程是否执行完，await 则关心运行的结果，因此 join 在协程出现异常时也不会抛出该异常，而 await 则会；考虑到作用域的问题，如果协程抛异常，可能会导致父协程的取消，因此调用 join 时尽管不会对协程本身的异常进行抛出，但如果 join 调用所在的协程被取消，那么它会抛出取消异常，这一点需要留意。</li>\n</ol>\n<p>如果大家能把这三点理解清楚了，那么协程的异常处理可以说就非常清晰了。文中因为异常传播的原因，我们提到了取消，但没有展开详细讨论，后面我们将会专门针对取消输出一篇文章，帮助大家加深理解。</p>\n<h3 id=\"附加说明\"><a href=\"#附加说明\" class=\"headerlink\" title=\"附加说明\"></a>附加说明</h3><p>join 在父协程被取消时有一个 bug 会导致不抛出取消异常，我在准备本文时发现该问题，目前已经提交到官方并得到了修复，预计合入到 1.2.1 发版，大家有兴趣可以查看这个 issue：<a href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/1123\">No CancellationException thrown when join on a crashed Job</a>。</p>\n<p>当然，这个 bug 对于生成环境的影响很小，大家也不要担心。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#x66;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#x63;&#111;&#109;\">&#107;&#x66;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#x63;&#111;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(11) - Flow 篇","keywords":"Kotlin 协程 Flow 响应式编程 RxJava","date":"2020-03-13T16:00:00.000Z","description":null,"_content":"\n> `Flow` 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 \n\n\n\n<!-- more -->\n\n\n\n\n*本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。*\n\n## 认识 Flow\n\n介绍 `Flow` 之前，我们先来回顾下序列生成器：\n\n**代码清单1： 序列生成器**\n\n```kotlin\nval ints = sequence {\n  (1..3).forEach { \n    yield(it)\n  }  \n}\n```\n\n每次访问 `ints` 的下一个元素的时候它就执行内部的逻辑直到遇到 `yield`，如果我希望在元素之间加个延时呢？\n\n**代码清单2：序列生成器中不能调用其他挂起函数**\n\n```kotlin\nval ints = sequence {\n  (1..3).forEach { \n    yield(it)\n    delay(1000) // ERROR!\n  }  \n}\n```\n\n受 `RestrictsSuspension` 注解的约束，`delay` 不能在 `SequenceScope` 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。\n\n假设序列生成器不受这个限制，调用 `delay` 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 `ints` 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。\n\n既然序列生成器有这么多限制，那我们是时候需要认识一下 `Flow` 了。它的 API 与序列生成器极为相似：\n\n**代码清单3：创建 Flow**\n\n```kotlin\nval intFlow = flow {\n  (1..3).forEach { \n    emit(it)\n    delay(100)\n  }\n}\n```\n\n新元素通过 `emit` 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。\n\nFlow 也可以设定它运行时所使用的调度器：\n\n```kotlin\nintFlow.flowOn(Dispatchers.IO)\n```\n\n通过 `flowOn` 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 `IO` 调度器上执行。\n\n最终消费 `intFlow` 需要调用 `collect` 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 `intFlow`：\n\n**代码清单4： 消费 Flow**\n\n```kotlin\nGlobalScope.launch(myDispatcher) {\n  intFlow.flowOn(Dispatchers.IO)\n    .collect { println(it) }\n}.join()\n```\n\n为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 `MyThread` 的线程上，结果如下：\n\n```kotlin\n[MyThread] 1\n[MyThread] 2\n[MyThread] 3\n```\n\n## 对比 RxJava 的线程切换\n\nRxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 `subscribeOn` 和 `observeOn`：\n\n**代码清单5：RxJava 的调度器切换**\n\n```kotlin\nObservable.create<Int> {\n  (1..3).forEach { e ->\n    it.onNext(e)\n  }\n  it.onComplete()\n}.subscribeOn(Schedulers.io())\n.observeOn(Schedulers.from(myExecutor))\n.subscribe {\n  println(it)\n}\n```\n\n其中 `subscribeOn` 指定的调度器影响前面的逻辑，`observeOn` 影响的是后面的逻辑，因此 `it.onNext(e)` 执行在它的 `io` 这个调度器上，而最后的 `println(it)` 执行在通过 `myExecutor` 创建出来的调度器上。\n\nFlow 的调度器 API 中看似只有 `flowOn` 与 `subscribeOn` 对应，其实不然， `collect` 所在协程的调度器则与 `observeOn` 指定的调度器对应。\n\n在 RxJava 的学习和使用过程中， `subscribeOn` 和 `observeOn` 经常容易被混淆；而在 Flow 当中 `collect` 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。\n\n## 冷数据流\n\n一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。\n\n**代码清单6：Flow 可以被重复消费**\n\n```kotlin\nGlobalScope.launch(dispatcher) {\n  intFlow.collect { println(it) }\n  intFlow.collect { println(it) }\n}.join()\n```\n\n`intFlow` 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。\n\n这一点其实类似于我们前面提到的 `sequence` 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 `Observable` 也是如此，每次调用它的 `subscribe` 都会重新消费一次。\n\n所谓**冷**数据流，就是只有消费时才会生产的数据流，这一点与 `Channel` 正对应：`Channel` 的发送端并不依赖于接收端。\n\n> **说明** RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。\n\n## 异常处理\n\nFlow 的异常处理也比较直接，直接调用 `catch` 函数即可：\n\n**代码清单7：捕获 Flow 的异常**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n}\n```\n\n我们在 Flow 的参数中抛了一个异常，在 `catch` 函数中就可以直接捕获到这个异常。如果没有调用 `catch` 函数，未捕获异常会在消费时抛出。请注意，`catch` 函数只能捕获它的上游的异常。\n\n如果我们想要在流完成时执行逻辑，可以使用 `onCompletion`：\n\n**代码清单8：订阅流的完成**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n}.onCompletion { t: Throwable? ->\n  println(\"finally.\")\n}\n```\n\n`onCompletion` 用起来比较类似于 `try ... catch ... finally` 中的 `finally`，无论前面是否存在异常，它都会被调用，参数 `t` 则是前面未捕获的异常。\n\nFlow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：\n\n**代码清单9：命令式的异常处理（不推荐）**\n\n```kotlin\nflow { \n  try {\n    emit(1)\n    throw ArithmeticException(\"Div 0\")\n  } catch (t: Throwable){\n    println(\"caught error: $t\")\n  } finally {\n    println(\"finally.\")\n  }\n}\n```\n\n在流操作内部使用 `try ... catch ... finally` 这样的写法后续可能被禁用。\n\n在 RxJava 当中还有 `onErrorReturn` 类似的操作：\n\n**代码清单10：RxJava 从异常中恢复**\n\n```kotlin\nval observable = Observable.create<Int> {\n  ...\n}.onErrorReturn {\n  println(t)\n  10\n}\n```\n\n捕获异常后，返回 10 作为下一个值。\n\n我们在 Flow 当中也可以模拟这样的操作：\n\n**代码清单11：Flow 从异常中恢复**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n  emit(10)\n}\n```\n\n这里我们可以使用 `emit` 重新生产新元素出来。细心的读者一定会发现，`emit` 定义在 `FlowCollector` 当中，因此只要遇到 Receiver 为 `FlowCollector` 的函数，我们就可以生产新元素。\n\n> **说明** onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：[Breaking change: Experimental Flow.onCompletion contract for cause #1732](https://github.com/Kotlin/kotlinx.coroutines/pull/1732)。\n\n## 末端操作符\n\n前面的例子当中，我们用 `collect` 消费 Flow 的数据。`collect` 是最基本的**末端操作符**，功能与 RxJava 的 `subscribe` 类似。除了 `collect` 之外，还有其他常见的末端操作符，大体分为两类：\n\n1. 集合类型转换操作，包括 `toList`、`toSet` 等。\n2. 聚合操作，包括将 Flow 规约到单值的 `reduce`、`fold` 等操作，以及获得单个元素的操作包括 `single`、`singleOrNull`、`first` 等。\n\n实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。\n\n## 分离 flow 的消费和触发\n\n我们除了可以在 `collect` 处消费 Flow 的元素以外，还可以通过 `onEach` 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，`collect` 函数可以放到其他任意位置调用，例如：\n\n**代码清单12：分离 Flow 的消费和触发**\n\n```kotlin\nfun createFlow() = flow<Int> {\n    (1..3).forEach {\n      emit(it)\n      delay(100)\n    }\n  }.onEach { println(it) }\n\nfun main(){\n  GlobalScope.launch {\n    createFlow().collect()\n  }\n}\n```\n\n由此，我们又可以衍生出一种新的消费 Flow 的写法：\n\n**代码清单13：使用协程作用域直接触发 Flow**\n\n```kotlin\nfun main(){\n  createFlow().launchIn(GlobalScope)\n}\n```\n\n其中 `launchIn` 函数只接收一个 `CoroutineScope` 类型的参数。\n\n## Flow 的取消\n\nFlow 没有提供取消操作，原因很简单：不需要。\n\n我们前面已经介绍了 Flow 的消费依赖于 `collect` 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。\n\n**代码清单14：Flow 的取消**\n\n```kotlin\nval job = GlobalScope.launch {\n  val intFlow = flow {\n    (1..3).forEach {\n      delay(1000)\n      emit(it)\n    }\n  }\n\n  intFlow.collect { println(it) }\n}\n\ndelay(2500)\njob.cancelAndJoin()\n```\n\n每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：\n\n```kotlin\n1\n▶ 1000ms later\n2\n```\n\n如此看来，想要取消 Flow 只需要取消它所在的协程即可。\n\n## 其他 Flow 的创建方式\n\n我们已经知道了 `flow { ... }` 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 `emit` 函数不是线程安全的：\n\n**代码清单15：不能在 Flow 中直接切换调度器**\n\n```kotlin\nflow { // BAD!!\n  emit(1)\n  withContext(Dispatchers.IO){\n    emit(2)\n  }\n}\n```\n\n想要在生成元素时切换调度器，就必须使用 `channelFlow` 函数来创建 Flow：\n\n```kotlin\nchannelFlow {\n  send(1)\n  withContext(Dispatchers.IO) {\n    send(2)\n  }\n}\n```\n\n此外，我们也可以通过集合框架来创建 Flow：\n\n```kotlin\nlistOf(1, 2, 3, 4).asFlow()\nsetOf(1, 2, 3, 4).asFlow()\nflowOf(1, 2, 3, 4)\n```\n\n## Flow 的背压\n\n只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。\n\n背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：\n\n**代码清单16：为 Flow 添加缓冲**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.buffer()\n```\n\n我们也可以为 `buffer` 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。\n\n问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。\n\n第一种是 `conflate`。与 `Channel` 的 `Conflate` 模式一致，新数据会覆盖老数据，例如：\n\n**代码清单17：使用 conflate 解决背压问题**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.conflate()\n.collect { value ->\n  println(\"Collecting $value\")\n  delay(100) \n  println(\"$value collected\")\n}\n```\n\n我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：\n\n```kotlin\nCollecting 1\n1 collected\nCollecting 99\n99 collected\n```\n\n第二种是 `collectLatest`。顾名思义，只处理最新的数据，这看上去似乎与 `conflate` 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。\n\n还是前面的例子，我们稍作修改：\n\n**代码清单18：使用 collectLatest 解决背压问题**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.collectLatest { value ->\n  println(\"Collecting $value\")\n  delay(100)\n  println(\"$value collected\")\n}\n```\n\n运行结果如下：\n\n```\nCollecting 0\nCollecting 1\n...\nCollecting 97\nCollecting 98\nCollecting 99\n▶ 100ms later\n99 collected\n```\n\n前面的 `Collecting` 输出了 0 ~ 99 的所有结果，而 `collected` 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意`delay(100)`）。\n\n除 `collectLatest` 之外还有 `mapLatest`、`flatMapLatest` 等等，都是这个作用。\n\n## Flow 的变换\n\n我们已经对集合框架的变换非常熟悉了，`Flow` 看上去极其类似于这样的数据结构，这一点与 RxJava 的 `Observable` 的表现也基本一致。\n\n例如我们可以使用 `map` 来变换 `Flow` 的数据：\n\n**代码清单19：Flow 的元素变换**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map { \n  it * 2\n}\n```\n\n也可以映射成其他 Flow：\n\n**代码清单20：Flow 的嵌套**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map {\n  flow { List(it) { emit(it) } }\n}\n```\n\n这实际上得到的是一个数据类型为 `Flow` 的 `Flow`，如果希望将它们拼接起来，可以使用 `flattenConcat`：\n\n**代码清单21：拼接 Flow**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map {\n  flow { List(it) { emit(it) } }\n}.flattenConcat()\n  .collect { println(it) }\n```\n\n拼接的操作中 `flattenConcat` 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 `flattenMerge`，它会并发拼接，因此结果不会保证顺序。\n\n## 使用 Flow 实现多路复用\n\n多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。\n\n上一篇文章[破解 Kotlin 协程(10) - Select 篇](https://www.bennyhuo.com/2020/02/03/coroutine-select/)中对 await 的复用我们可以用 Flow 实现如下：\n\n**代码清单22：使用 Flow 实现对 await 的多路复用**\n\n```kotlin\ncoroutineScope {\n  val login = \"...\"\n  listOf(::getUserFromApi, ::getUserFromLocal) ... ①\n    .map { function ->\n      function.call(login) ... ②\n    }\n    .map { deferred ->\n      flow { emit(deferred.await()) } ... ③\n    }\n    .merge() ... ④\n    .onEach { user ->\n      println(\"Result: $user\")\n    }.launchIn(this)\n}\n```\n\n这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png)\n\n**图1：使用 merge 合并 Flow**\n\n同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照[破解 Kotlin 协程(10) - Select 篇](https://www.bennyhuo.com/2020/02/03/coroutine-select/)，我们给出 Flow 的实现版本：\n\n**代码清单23：使用 Flow 实现对 Channel 的复用**\n\n```kotlin\nval channels = List(10) { Channel<Int>() }\n...\nval result = channels.map {\n    it.consumeAsFlow()\n  }\n  .merge()\n  .first()\n```\n\n这比 `select` 的版本看上去要更简洁明了，每个 Channel 都通过 `consumeAsFlow` 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。\n\n## 小结\n\n`Flow` 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-flow.md","raw":"---\ntitle:  破解 Kotlin 协程(11) - Flow 篇 \nkeywords: Kotlin 协程 Flow 响应式编程 RxJava \ndate: 2020/03/14\ndescription: \ntags: \n    - kotlin\n    - flow\n    - rxjava \n---\n\n> `Flow` 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 \n\n\n\n<!-- more -->\n\n\n\n\n*本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。*\n\n## 认识 Flow\n\n介绍 `Flow` 之前，我们先来回顾下序列生成器：\n\n**代码清单1： 序列生成器**\n\n```kotlin\nval ints = sequence {\n  (1..3).forEach { \n    yield(it)\n  }  \n}\n```\n\n每次访问 `ints` 的下一个元素的时候它就执行内部的逻辑直到遇到 `yield`，如果我希望在元素之间加个延时呢？\n\n**代码清单2：序列生成器中不能调用其他挂起函数**\n\n```kotlin\nval ints = sequence {\n  (1..3).forEach { \n    yield(it)\n    delay(1000) // ERROR!\n  }  \n}\n```\n\n受 `RestrictsSuspension` 注解的约束，`delay` 不能在 `SequenceScope` 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。\n\n假设序列生成器不受这个限制，调用 `delay` 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 `ints` 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。\n\n既然序列生成器有这么多限制，那我们是时候需要认识一下 `Flow` 了。它的 API 与序列生成器极为相似：\n\n**代码清单3：创建 Flow**\n\n```kotlin\nval intFlow = flow {\n  (1..3).forEach { \n    emit(it)\n    delay(100)\n  }\n}\n```\n\n新元素通过 `emit` 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。\n\nFlow 也可以设定它运行时所使用的调度器：\n\n```kotlin\nintFlow.flowOn(Dispatchers.IO)\n```\n\n通过 `flowOn` 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 `IO` 调度器上执行。\n\n最终消费 `intFlow` 需要调用 `collect` 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 `intFlow`：\n\n**代码清单4： 消费 Flow**\n\n```kotlin\nGlobalScope.launch(myDispatcher) {\n  intFlow.flowOn(Dispatchers.IO)\n    .collect { println(it) }\n}.join()\n```\n\n为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 `MyThread` 的线程上，结果如下：\n\n```kotlin\n[MyThread] 1\n[MyThread] 2\n[MyThread] 3\n```\n\n## 对比 RxJava 的线程切换\n\nRxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 `subscribeOn` 和 `observeOn`：\n\n**代码清单5：RxJava 的调度器切换**\n\n```kotlin\nObservable.create<Int> {\n  (1..3).forEach { e ->\n    it.onNext(e)\n  }\n  it.onComplete()\n}.subscribeOn(Schedulers.io())\n.observeOn(Schedulers.from(myExecutor))\n.subscribe {\n  println(it)\n}\n```\n\n其中 `subscribeOn` 指定的调度器影响前面的逻辑，`observeOn` 影响的是后面的逻辑，因此 `it.onNext(e)` 执行在它的 `io` 这个调度器上，而最后的 `println(it)` 执行在通过 `myExecutor` 创建出来的调度器上。\n\nFlow 的调度器 API 中看似只有 `flowOn` 与 `subscribeOn` 对应，其实不然， `collect` 所在协程的调度器则与 `observeOn` 指定的调度器对应。\n\n在 RxJava 的学习和使用过程中， `subscribeOn` 和 `observeOn` 经常容易被混淆；而在 Flow 当中 `collect` 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。\n\n## 冷数据流\n\n一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。\n\n**代码清单6：Flow 可以被重复消费**\n\n```kotlin\nGlobalScope.launch(dispatcher) {\n  intFlow.collect { println(it) }\n  intFlow.collect { println(it) }\n}.join()\n```\n\n`intFlow` 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。\n\n这一点其实类似于我们前面提到的 `sequence` 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 `Observable` 也是如此，每次调用它的 `subscribe` 都会重新消费一次。\n\n所谓**冷**数据流，就是只有消费时才会生产的数据流，这一点与 `Channel` 正对应：`Channel` 的发送端并不依赖于接收端。\n\n> **说明** RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。\n\n## 异常处理\n\nFlow 的异常处理也比较直接，直接调用 `catch` 函数即可：\n\n**代码清单7：捕获 Flow 的异常**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n}\n```\n\n我们在 Flow 的参数中抛了一个异常，在 `catch` 函数中就可以直接捕获到这个异常。如果没有调用 `catch` 函数，未捕获异常会在消费时抛出。请注意，`catch` 函数只能捕获它的上游的异常。\n\n如果我们想要在流完成时执行逻辑，可以使用 `onCompletion`：\n\n**代码清单8：订阅流的完成**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n}.onCompletion { t: Throwable? ->\n  println(\"finally.\")\n}\n```\n\n`onCompletion` 用起来比较类似于 `try ... catch ... finally` 中的 `finally`，无论前面是否存在异常，它都会被调用，参数 `t` 则是前面未捕获的异常。\n\nFlow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：\n\n**代码清单9：命令式的异常处理（不推荐）**\n\n```kotlin\nflow { \n  try {\n    emit(1)\n    throw ArithmeticException(\"Div 0\")\n  } catch (t: Throwable){\n    println(\"caught error: $t\")\n  } finally {\n    println(\"finally.\")\n  }\n}\n```\n\n在流操作内部使用 `try ... catch ... finally` 这样的写法后续可能被禁用。\n\n在 RxJava 当中还有 `onErrorReturn` 类似的操作：\n\n**代码清单10：RxJava 从异常中恢复**\n\n```kotlin\nval observable = Observable.create<Int> {\n  ...\n}.onErrorReturn {\n  println(t)\n  10\n}\n```\n\n捕获异常后，返回 10 作为下一个值。\n\n我们在 Flow 当中也可以模拟这样的操作：\n\n**代码清单11：Flow 从异常中恢复**\n\n```kotlin\nflow {\n  emit(1)\n  throw ArithmeticException(\"Div 0\")\n}.catch { t: Throwable ->\n  println(\"caught error: $t\")\n  emit(10)\n}\n```\n\n这里我们可以使用 `emit` 重新生产新元素出来。细心的读者一定会发现，`emit` 定义在 `FlowCollector` 当中，因此只要遇到 Receiver 为 `FlowCollector` 的函数，我们就可以生产新元素。\n\n> **说明** onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：[Breaking change: Experimental Flow.onCompletion contract for cause #1732](https://github.com/Kotlin/kotlinx.coroutines/pull/1732)。\n\n## 末端操作符\n\n前面的例子当中，我们用 `collect` 消费 Flow 的数据。`collect` 是最基本的**末端操作符**，功能与 RxJava 的 `subscribe` 类似。除了 `collect` 之外，还有其他常见的末端操作符，大体分为两类：\n\n1. 集合类型转换操作，包括 `toList`、`toSet` 等。\n2. 聚合操作，包括将 Flow 规约到单值的 `reduce`、`fold` 等操作，以及获得单个元素的操作包括 `single`、`singleOrNull`、`first` 等。\n\n实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。\n\n## 分离 flow 的消费和触发\n\n我们除了可以在 `collect` 处消费 Flow 的元素以外，还可以通过 `onEach` 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，`collect` 函数可以放到其他任意位置调用，例如：\n\n**代码清单12：分离 Flow 的消费和触发**\n\n```kotlin\nfun createFlow() = flow<Int> {\n    (1..3).forEach {\n      emit(it)\n      delay(100)\n    }\n  }.onEach { println(it) }\n\nfun main(){\n  GlobalScope.launch {\n    createFlow().collect()\n  }\n}\n```\n\n由此，我们又可以衍生出一种新的消费 Flow 的写法：\n\n**代码清单13：使用协程作用域直接触发 Flow**\n\n```kotlin\nfun main(){\n  createFlow().launchIn(GlobalScope)\n}\n```\n\n其中 `launchIn` 函数只接收一个 `CoroutineScope` 类型的参数。\n\n## Flow 的取消\n\nFlow 没有提供取消操作，原因很简单：不需要。\n\n我们前面已经介绍了 Flow 的消费依赖于 `collect` 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。\n\n**代码清单14：Flow 的取消**\n\n```kotlin\nval job = GlobalScope.launch {\n  val intFlow = flow {\n    (1..3).forEach {\n      delay(1000)\n      emit(it)\n    }\n  }\n\n  intFlow.collect { println(it) }\n}\n\ndelay(2500)\njob.cancelAndJoin()\n```\n\n每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：\n\n```kotlin\n1\n▶ 1000ms later\n2\n```\n\n如此看来，想要取消 Flow 只需要取消它所在的协程即可。\n\n## 其他 Flow 的创建方式\n\n我们已经知道了 `flow { ... }` 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 `emit` 函数不是线程安全的：\n\n**代码清单15：不能在 Flow 中直接切换调度器**\n\n```kotlin\nflow { // BAD!!\n  emit(1)\n  withContext(Dispatchers.IO){\n    emit(2)\n  }\n}\n```\n\n想要在生成元素时切换调度器，就必须使用 `channelFlow` 函数来创建 Flow：\n\n```kotlin\nchannelFlow {\n  send(1)\n  withContext(Dispatchers.IO) {\n    send(2)\n  }\n}\n```\n\n此外，我们也可以通过集合框架来创建 Flow：\n\n```kotlin\nlistOf(1, 2, 3, 4).asFlow()\nsetOf(1, 2, 3, 4).asFlow()\nflowOf(1, 2, 3, 4)\n```\n\n## Flow 的背压\n\n只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。\n\n背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：\n\n**代码清单16：为 Flow 添加缓冲**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.buffer()\n```\n\n我们也可以为 `buffer` 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。\n\n问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。\n\n第一种是 `conflate`。与 `Channel` 的 `Conflate` 模式一致，新数据会覆盖老数据，例如：\n\n**代码清单17：使用 conflate 解决背压问题**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.conflate()\n.collect { value ->\n  println(\"Collecting $value\")\n  delay(100) \n  println(\"$value collected\")\n}\n```\n\n我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：\n\n```kotlin\nCollecting 1\n1 collected\nCollecting 99\n99 collected\n```\n\n第二种是 `collectLatest`。顾名思义，只处理最新的数据，这看上去似乎与 `conflate` 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。\n\n还是前面的例子，我们稍作修改：\n\n**代码清单18：使用 collectLatest 解决背压问题**\n\n```kotlin\nflow {\n  List(100) {\n    emit(it)\n  }\n}.collectLatest { value ->\n  println(\"Collecting $value\")\n  delay(100)\n  println(\"$value collected\")\n}\n```\n\n运行结果如下：\n\n```\nCollecting 0\nCollecting 1\n...\nCollecting 97\nCollecting 98\nCollecting 99\n▶ 100ms later\n99 collected\n```\n\n前面的 `Collecting` 输出了 0 ~ 99 的所有结果，而 `collected` 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意`delay(100)`）。\n\n除 `collectLatest` 之外还有 `mapLatest`、`flatMapLatest` 等等，都是这个作用。\n\n## Flow 的变换\n\n我们已经对集合框架的变换非常熟悉了，`Flow` 看上去极其类似于这样的数据结构，这一点与 RxJava 的 `Observable` 的表现也基本一致。\n\n例如我们可以使用 `map` 来变换 `Flow` 的数据：\n\n**代码清单19：Flow 的元素变换**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map { \n  it * 2\n}\n```\n\n也可以映射成其他 Flow：\n\n**代码清单20：Flow 的嵌套**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map {\n  flow { List(it) { emit(it) } }\n}\n```\n\n这实际上得到的是一个数据类型为 `Flow` 的 `Flow`，如果希望将它们拼接起来，可以使用 `flattenConcat`：\n\n**代码清单21：拼接 Flow**\n\n```kotlin\nflow {\n  List(5){ emit(it) } \n}.map {\n  flow { List(it) { emit(it) } }\n}.flattenConcat()\n  .collect { println(it) }\n```\n\n拼接的操作中 `flattenConcat` 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 `flattenMerge`，它会并发拼接，因此结果不会保证顺序。\n\n## 使用 Flow 实现多路复用\n\n多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。\n\n上一篇文章[破解 Kotlin 协程(10) - Select 篇](https://www.bennyhuo.com/2020/02/03/coroutine-select/)中对 await 的复用我们可以用 Flow 实现如下：\n\n**代码清单22：使用 Flow 实现对 await 的多路复用**\n\n```kotlin\ncoroutineScope {\n  val login = \"...\"\n  listOf(::getUserFromApi, ::getUserFromLocal) ... ①\n    .map { function ->\n      function.call(login) ... ②\n    }\n    .map { deferred ->\n      flow { emit(deferred.await()) } ... ③\n    }\n    .merge() ... ④\n    .onEach { user ->\n      println(\"Result: $user\")\n    }.launchIn(this)\n}\n```\n\n这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png)\n\n**图1：使用 merge 合并 Flow**\n\n同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照[破解 Kotlin 协程(10) - Select 篇](https://www.bennyhuo.com/2020/02/03/coroutine-select/)，我们给出 Flow 的实现版本：\n\n**代码清单23：使用 Flow 实现对 Channel 的复用**\n\n```kotlin\nval channels = List(10) { Channel<Int>() }\n...\nval result = channels.map {\n    it.consumeAsFlow()\n  }\n  .merge()\n  .first()\n```\n\n这比 `select` 的版本看上去要更简洁明了，每个 Channel 都通过 `consumeAsFlow` 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。\n\n## 小结\n\n`Flow` 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-flow","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0035000rlduzejso90o8","content":"<blockquote>\n<p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p>\n<h2 id=\"认识-Flow\"><a href=\"#认识-Flow\" class=\"headerlink\" title=\"认识 Flow\"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p>\n<p><strong>代码清单1： 序列生成器</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ints = sequence &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    yield(it)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p>\n<p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ints = sequence &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    yield(it)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// ERROR!</span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p>\n<p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p>\n<p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p>\n<p><strong>代码清单3：创建 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> intFlow = flow &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p>\n<p>Flow 也可以设定它运行时所使用的调度器：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p>\n<p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p>\n<p><strong>代码清单4： 消费 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(myDispatcher) &#123;</span><br><span class=\"line\">  intFlow.flowOn(Dispatchers.IO)</span><br><span class=\"line\">    .collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[MyThread] <span class=\"number\">1</span></span><br><span class=\"line\">[MyThread] <span class=\"number\">2</span></span><br><span class=\"line\">[MyThread] <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对比-RxJava-的线程切换\"><a href=\"#对比-RxJava-的线程切换\" class=\"headerlink\" title=\"对比 RxJava 的线程切换\"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p>\n<p><strong>代码清单5：RxJava 的调度器切换</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.create&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; e -&gt;</span><br><span class=\"line\">    it.onNext(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  it.onComplete()</span><br><span class=\"line\">&#125;.subscribeOn(Schedulers.io())</span><br><span class=\"line\">.observeOn(Schedulers.from(myExecutor))</span><br><span class=\"line\">.subscribe &#123;</span><br><span class=\"line\">  println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p>\n<p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p>\n<p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p>\n<h2 id=\"冷数据流\"><a href=\"#冷数据流\" class=\"headerlink\" title=\"冷数据流\"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p>\n<p><strong>代码清单6：Flow 可以被重复消费</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p>\n<p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p>\n<p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p>\n<blockquote>\n<p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p>\n</blockquote>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p>\n<p><strong>代码清单7：捕获 Flow 的异常</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p>\n<p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p>\n<p><strong>代码清单8：订阅流的完成</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;finally.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p>\n<p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p>\n<p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (t: Throwable)&#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;finally.&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p>\n<p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p>\n<p><strong>代码清单10：RxJava 从异常中恢复</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> observable = Observable.create&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;.onErrorReturn &#123;</span><br><span class=\"line\">  println(t)</span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>捕获异常后，返回 10 作为下一个值。</p>\n<p>我们在 Flow 当中也可以模拟这样的操作：</p>\n<p><strong>代码清单11：Flow 从异常中恢复</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">  emit(<span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p>\n<blockquote>\n<p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href=\"https://github.com/Kotlin/kotlinx.coroutines/pull/1732\">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p>\n</blockquote>\n<h2 id=\"末端操作符\"><a href=\"#末端操作符\" class=\"headerlink\" title=\"末端操作符\"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p>\n<ol>\n<li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li>\n<li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li>\n</ol>\n<p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p>\n<h2 id=\"分离-flow-的消费和触发\"><a href=\"#分离-flow-的消费和触发\" class=\"headerlink\" title=\"分离 flow 的消费和触发\"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p>\n<p><strong>代码清单12：分离 Flow 的消费和触发</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createFlow</span><span class=\"params\">()</span></span> = flow&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">    (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123;</span><br><span class=\"line\">      emit(it)</span><br><span class=\"line\">      delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;.onEach &#123; println(it) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  GlobalScope.launch &#123;</span><br><span class=\"line\">    createFlow().collect()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p>\n<p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  createFlow().launchIn(GlobalScope)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p>\n<h2 id=\"Flow-的取消\"><a href=\"#Flow-的取消\" class=\"headerlink\" title=\"Flow 的取消\"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p>\n<p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p>\n<p><strong>代码清单14：Flow 的取消</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> intFlow = flow &#123;</span><br><span class=\"line\">    (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123;</span><br><span class=\"line\">      delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">      emit(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2500</span>)</span><br><span class=\"line\">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>\n\n<p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">▶ 1000ms later</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p>\n<h2 id=\"其他-Flow-的创建方式\"><a href=\"#其他-Flow-的创建方式\" class=\"headerlink\" title=\"其他 Flow 的创建方式\"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow &#123; ... &#125;</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p>\n<p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123; <span class=\"comment\">// BAD!!</span></span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">    emit(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channelFlow &#123;</span><br><span class=\"line\">  send(<span class=\"number\">1</span>)</span><br><span class=\"line\">  withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    send(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，我们也可以通过集合框架来创建 Flow：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).asFlow()</span><br><span class=\"line\">setOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).asFlow()</span><br><span class=\"line\">flowOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flow-的背压\"><a href=\"#Flow-的背压\" class=\"headerlink\" title=\"Flow 的背压\"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p>\n<p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p>\n<p><strong>代码清单16：为 Flow 添加缓冲</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.buffer()</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p>\n<p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p>\n<p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p>\n<p><strong>代码清单17：使用 conflate 解决背压问题</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.conflate()</span><br><span class=\"line\">.collect &#123; value -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;Collecting <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">  delay(<span class=\"number\">100</span>) </span><br><span class=\"line\">  println(<span class=\"string\">&quot;<span class=\"variable\">$value</span> collected&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> collected</span><br><span class=\"line\">Collecting <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"number\">99</span> collected</span><br></pre></td></tr></table></figure>\n\n<p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p>\n<p>还是前面的例子，我们稍作修改：</p>\n<p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.collectLatest &#123; value -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;Collecting <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">  delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">  println(<span class=\"string\">&quot;<span class=\"variable\">$value</span> collected&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting 0</span><br><span class=\"line\">Collecting 1</span><br><span class=\"line\">...</span><br><span class=\"line\">Collecting 97</span><br><span class=\"line\">Collecting 98</span><br><span class=\"line\">Collecting 99</span><br><span class=\"line\">▶ 100ms later</span><br><span class=\"line\">99 collected</span><br></pre></td></tr></table></figure>\n\n<p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p>\n<p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p>\n<h2 id=\"Flow-的变换\"><a href=\"#Flow-的变换\" class=\"headerlink\" title=\"Flow 的变换\"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p>\n<p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p>\n<p><strong>代码清单19：Flow 的元素变换</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123; </span><br><span class=\"line\">  it * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以映射成其他 Flow：</p>\n<p><strong>代码清单20：Flow 的嵌套</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123;</span><br><span class=\"line\">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p>\n<p><strong>代码清单21：拼接 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123;</span><br><span class=\"line\">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class=\"line\">&#125;.flattenConcat()</span><br><span class=\"line\">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p>\n<h2 id=\"使用-Flow-实现多路复用\"><a href=\"#使用-Flow-实现多路复用\" class=\"headerlink\" title=\"使用 Flow 实现多路复用\"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p>\n<p>上一篇文章<a href=\"https://www.bennyhuo.com/2020/02/03/coroutine-select/\">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p>\n<p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coroutineScope &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> login = <span class=\"string\">&quot;...&quot;</span></span><br><span class=\"line\">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class=\"line\">    .map &#123; function -&gt;</span><br><span class=\"line\">      function.call(login) ... ②</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; deferred -&gt;</span><br><span class=\"line\">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .merge() ... ④</span><br><span class=\"line\">    .onEach &#123; user -&gt;</span><br><span class=\"line\">      println(<span class=\"string\">&quot;Result: <span class=\"variable\">$user</span>&quot;</span>)</span><br><span class=\"line\">    &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png\"></p>\n<p><strong>图1：使用 merge 合并 Flow</strong></p>\n<p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href=\"https://www.bennyhuo.com/2020/02/03/coroutine-select/\">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p>\n<p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channels = List(<span class=\"number\">10</span>) &#123; Channel&lt;<span class=\"built_in\">Int</span>&gt;() &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = channels.map &#123;</span><br><span class=\"line\">    it.consumeAsFlow()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .merge()</span><br><span class=\"line\">  .first()</span><br></pre></td></tr></table></figure>\n\n<p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 </p>\n</blockquote>","more":"<p><em>本文基于 Kotlinx.coroutines 1.3.3，由于部分功能尚处于实验阶段，后续也可能会发生细微的调整。</em></p>\n<h2 id=\"认识-Flow\"><a href=\"#认识-Flow\" class=\"headerlink\" title=\"认识 Flow\"></a>认识 Flow</h2><p>介绍 <code>Flow</code> 之前，我们先来回顾下序列生成器：</p>\n<p><strong>代码清单1： 序列生成器</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ints = sequence &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    yield(it)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次访问 <code>ints</code> 的下一个元素的时候它就执行内部的逻辑直到遇到 <code>yield</code>，如果我希望在元素之间加个延时呢？</p>\n<p><strong>代码清单2：序列生成器中不能调用其他挂起函数</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> ints = sequence &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    yield(it)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// ERROR!</span></span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>受 <code>RestrictsSuspension</code> 注解的约束，<code>delay</code> 不能在 <code>SequenceScope</code> 的扩展成员当中被调用，因而不能在序列生成器的协程体内调用了。</p>\n<p>假设序列生成器不受这个限制，调用 <code>delay</code> 会导致后续的执行流程的线程发生变化，外部的调用者发现在访问 <code>ints</code> 的下一个元素的时候居然还会有切换线程的副作用，这个是不是算一个“惊喜”呢？不仅如此，我想通过指定调度器来限定序列创建所在的线程，同样是不可以的，我们甚至没有办法为它设置协程上下文。</p>\n<p>既然序列生成器有这么多限制，那我们是时候需要认识一下 <code>Flow</code> 了。它的 API 与序列生成器极为相似：</p>\n<p><strong>代码清单3：创建 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> intFlow = flow &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; </span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新元素通过 <code>emit</code> 函数提供，Flow 的执行体内部也可以调用其他挂起函数，这样我们就可以在每次提供一个新元素后再延时 100ms 了。</p>\n<p>Flow 也可以设定它运行时所使用的调度器：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intFlow.flowOn(Dispatchers.IO)</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>flowOn</code> 设置的调度器只对它之前的操作有影响，因此这里意味着 intFlow 的构造逻辑会在 <code>IO</code> 调度器上执行。</p>\n<p>最终消费 <code>intFlow</code> 需要调用 <code>collect</code> 函数，这个函数也是一个挂起函数，我们启动一个协程来消费 <code>intFlow</code>：</p>\n<p><strong>代码清单4： 消费 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(myDispatcher) &#123;</span><br><span class=\"line\">  intFlow.flowOn(Dispatchers.IO)</span><br><span class=\"line\">    .collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p>为了区分调度器，我们为协程设置了一个自定义的调度器，它会将协程调度到名叫 <code>MyThread</code> 的线程上，结果如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[MyThread] <span class=\"number\">1</span></span><br><span class=\"line\">[MyThread] <span class=\"number\">2</span></span><br><span class=\"line\">[MyThread] <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对比-RxJava-的线程切换\"><a href=\"#对比-RxJava-的线程切换\" class=\"headerlink\" title=\"对比 RxJava 的线程切换\"></a>对比 RxJava 的线程切换</h2><p>RxJava 也是一个基于响应式编程模型的异步框架，它提供了两个切换调度器的 API 分别是 <code>subscribeOn</code> 和 <code>observeOn</code>：</p>\n<p><strong>代码清单5：RxJava 的调度器切换</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.create&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">  (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123; e -&gt;</span><br><span class=\"line\">    it.onNext(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  it.onComplete()</span><br><span class=\"line\">&#125;.subscribeOn(Schedulers.io())</span><br><span class=\"line\">.observeOn(Schedulers.from(myExecutor))</span><br><span class=\"line\">.subscribe &#123;</span><br><span class=\"line\">  println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>subscribeOn</code> 指定的调度器影响前面的逻辑，<code>observeOn</code> 影响的是后面的逻辑，因此 <code>it.onNext(e)</code> 执行在它的 <code>io</code> 这个调度器上，而最后的 <code>println(it)</code> 执行在通过 <code>myExecutor</code> 创建出来的调度器上。</p>\n<p>Flow 的调度器 API 中看似只有 <code>flowOn</code> 与 <code>subscribeOn</code> 对应，其实不然， <code>collect</code> 所在协程的调度器则与 <code>observeOn</code> 指定的调度器对应。</p>\n<p>在 RxJava 的学习和使用过程中， <code>subscribeOn</code> 和 <code>observeOn</code> 经常容易被混淆；而在 Flow 当中 <code>collect</code> 所在的协程自然就是观察者，它想运行在什么调度器上它自己指定即可，非常容易区分。</p>\n<h2 id=\"冷数据流\"><a href=\"#冷数据流\" class=\"headerlink\" title=\"冷数据流\"></a>冷数据流</h2><p>一个 Flow 创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p>\n<p><strong>代码清单6：Flow 可以被重复消费</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch(dispatcher) &#123;</span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p><code>intFlow</code> 就是本节最开始我们创建的 Flow，消费它会输出 1,2,3，重复消费它会重复输出 1,2,3。</p>\n<p>这一点其实类似于我们前面提到的 <code>sequence</code> 和 RxJava 例子，它们也都有自己的消费端。我们创建一个序列然后去迭代它，每次迭代都会创建一个新的迭代器从头开始迭代；RxJava 的 <code>Observable</code> 也是如此，每次调用它的 <code>subscribe</code> 都会重新消费一次。</p>\n<p>所谓<strong>冷</strong>数据流，就是只有消费时才会生产的数据流，这一点与 <code>Channel</code> 正对应：<code>Channel</code> 的发送端并不依赖于接收端。</p>\n<blockquote>\n<p><strong>说明</strong> RxJava 也存在热数据流，可以通过一定的手段实现冷热数据流的转化。不过相比之下，冷数据流的应用场景更为丰富。</p>\n</blockquote>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>Flow 的异常处理也比较直接，直接调用 <code>catch</code> 函数即可：</p>\n<p><strong>代码清单7：捕获 Flow 的异常</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 Flow 的参数中抛了一个异常，在 <code>catch</code> 函数中就可以直接捕获到这个异常。如果没有调用 <code>catch</code> 函数，未捕获异常会在消费时抛出。请注意，<code>catch</code> 函数只能捕获它的上游的异常。</p>\n<p>如果我们想要在流完成时执行逻辑，可以使用 <code>onCompletion</code>：</p>\n<p><strong>代码清单8：订阅流的完成</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">&#125;.onCompletion &#123; t: Throwable? -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;finally.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>onCompletion</code> 用起来比较类似于 <code>try ... catch ... finally</code> 中的 <code>finally</code>，无论前面是否存在异常，它都会被调用，参数 <code>t</code> 则是前面未捕获的异常。</p>\n<p>Flow 的设计初衷是希望确保流操作中异常透明。因此，以下写法是违反 Flow 的设计原则的：</p>\n<p><strong>代码清单9：命令式的异常处理（不推荐）</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (t: Throwable)&#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;finally.&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在流操作内部使用 <code>try ... catch ... finally</code> 这样的写法后续可能被禁用。</p>\n<p>在 RxJava 当中还有 <code>onErrorReturn</code> 类似的操作：</p>\n<p><strong>代码清单10：RxJava 从异常中恢复</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> observable = Observable.create&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;.onErrorReturn &#123;</span><br><span class=\"line\">  println(t)</span><br><span class=\"line\">  <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>捕获异常后，返回 10 作为下一个值。</p>\n<p>我们在 Flow 当中也可以模拟这样的操作：</p>\n<p><strong>代码清单11：Flow 从异常中恢复</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> ArithmeticException(<span class=\"string\">&quot;Div 0&quot;</span>)</span><br><span class=\"line\">&#125;.<span class=\"keyword\">catch</span> &#123; t: Throwable -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;caught error: <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">  emit(<span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以使用 <code>emit</code> 重新生产新元素出来。细心的读者一定会发现，<code>emit</code> 定义在 <code>FlowCollector</code> 当中，因此只要遇到 Receiver 为 <code>FlowCollector</code> 的函数，我们就可以生产新元素。</p>\n<blockquote>\n<p><strong>说明</strong> onCompletion 预计在协程框架的 1.4 版本中会被重新设计，之后它的作用类似于 RxJava 中 Subscriber 的 onComplete，即作为整个 Flow 的完成回调使用，回调的参数也将包含整个 Flow 的未捕获异常，参见 GitHub Issue：<a href=\"https://github.com/Kotlin/kotlinx.coroutines/pull/1732\">Breaking change: Experimental Flow.onCompletion contract for cause #1732</a>。</p>\n</blockquote>\n<h2 id=\"末端操作符\"><a href=\"#末端操作符\" class=\"headerlink\" title=\"末端操作符\"></a>末端操作符</h2><p>前面的例子当中，我们用 <code>collect</code> 消费 Flow 的数据。<code>collect</code> 是最基本的<strong>末端操作符</strong>，功能与 RxJava 的 <code>subscribe</code> 类似。除了 <code>collect</code> 之外，还有其他常见的末端操作符，大体分为两类：</p>\n<ol>\n<li>集合类型转换操作，包括 <code>toList</code>、<code>toSet</code> 等。</li>\n<li>聚合操作，包括将 Flow 规约到单值的 <code>reduce</code>、<code>fold</code> 等操作，以及获得单个元素的操作包括 <code>single</code>、<code>singleOrNull</code>、<code>first</code> 等。</li>\n</ol>\n<p>实际上，识别是否为末端操作符，还有一个简单方法，由于 Flow 的消费端一定需要运行在协程当中，因此末端操作符都是挂起函数。</p>\n<h2 id=\"分离-flow-的消费和触发\"><a href=\"#分离-flow-的消费和触发\" class=\"headerlink\" title=\"分离 flow 的消费和触发\"></a>分离 flow 的消费和触发</h2><p>我们除了可以在 <code>collect</code> 处消费 Flow 的元素以外，还可以通过 <code>onEach</code> 来做到这一点。这样消费的具体操作就不需要与末端操作符放到一起，<code>collect</code> 函数可以放到其他任意位置调用，例如：</p>\n<p><strong>代码清单12：分离 Flow 的消费和触发</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">createFlow</span><span class=\"params\">()</span></span> = flow&lt;<span class=\"built_in\">Int</span>&gt; &#123;</span><br><span class=\"line\">    (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123;</span><br><span class=\"line\">      emit(it)</span><br><span class=\"line\">      delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;.onEach &#123; println(it) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  GlobalScope.launch &#123;</span><br><span class=\"line\">    createFlow().collect()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此，我们又可以衍生出一种新的消费 Flow 的写法：</p>\n<p><strong>代码清单13：使用协程作用域直接触发 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  createFlow().launchIn(GlobalScope)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>launchIn</code> 函数只接收一个 <code>CoroutineScope</code> 类型的参数。</p>\n<h2 id=\"Flow-的取消\"><a href=\"#Flow-的取消\" class=\"headerlink\" title=\"Flow 的取消\"></a>Flow 的取消</h2><p>Flow 没有提供取消操作，原因很简单：不需要。</p>\n<p>我们前面已经介绍了 Flow 的消费依赖于 <code>collect</code> 这样的末端操作符，而它们又必须在协程当中调用，因此 Flow 的取消主要依赖于末端操作符所在的协程的状态。</p>\n<p><strong>代码清单14：Flow 的取消</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> intFlow = flow &#123;</span><br><span class=\"line\">    (<span class=\"number\">1.</span><span class=\"number\">.3</span>).forEach &#123;</span><br><span class=\"line\">      delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">      emit(it)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  intFlow.collect &#123; println(it) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2500</span>)</span><br><span class=\"line\">job.cancelAndJoin()</span><br></pre></td></tr></table></figure>\n\n<p>每隔 1000ms 生产一个元素，2500ms 以后协程被取消，因此最后一个元素生产前 Flow 就已经被取消，输出为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">▶ 1000ms later</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>如此看来，想要取消 Flow 只需要取消它所在的协程即可。</p>\n<h2 id=\"其他-Flow-的创建方式\"><a href=\"#其他-Flow-的创建方式\" class=\"headerlink\" title=\"其他 Flow 的创建方式\"></a>其他 Flow 的创建方式</h2><p>我们已经知道了 <code>flow &#123; ... &#125;</code> 这种形式的创建方式，不过在这当中无法随意切换调度器，这是因为 <code>emit</code> 函数不是线程安全的：</p>\n<p><strong>代码清单15：不能在 Flow 中直接切换调度器</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123; <span class=\"comment\">// BAD!!</span></span><br><span class=\"line\">  emit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  withContext(Dispatchers.IO)&#123;</span><br><span class=\"line\">    emit(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>想要在生成元素时切换调度器，就必须使用 <code>channelFlow</code> 函数来创建 Flow：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channelFlow &#123;</span><br><span class=\"line\">  send(<span class=\"number\">1</span>)</span><br><span class=\"line\">  withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    send(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，我们也可以通过集合框架来创建 Flow：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).asFlow()</span><br><span class=\"line\">setOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).asFlow()</span><br><span class=\"line\">flowOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flow-的背压\"><a href=\"#Flow-的背压\" class=\"headerlink\" title=\"Flow 的背压\"></a>Flow 的背压</h2><p>只要是响应式编程，就一定会有背压问题，我们先来看看背压究竟是什么。</p>\n<p>背压问题在生产者的生产速率高于消费者的处理速率的情况下出现。为了保证数据不丢失，我们也会考虑添加缓存来缓解问题：</p>\n<p><strong>代码清单16：为 Flow 添加缓冲</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.buffer()</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以为 <code>buffer</code> 指定一个容量。不过，如果我们只是单纯地添加缓存，而不是从根本上解决问题就始终会造成数据积压。</p>\n<p>问题产生的根本原因是生产和消费速率的不匹配，除直接优化消费者的性能以外，我们也可以采取一些取舍的手段。</p>\n<p>第一种是 <code>conflate</code>。与 <code>Channel</code> 的 <code>Conflate</code> 模式一致，新数据会覆盖老数据，例如：</p>\n<p><strong>代码清单17：使用 conflate 解决背压问题</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.conflate()</span><br><span class=\"line\">.collect &#123; value -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;Collecting <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">  delay(<span class=\"number\">100</span>) </span><br><span class=\"line\">  println(<span class=\"string\">&quot;<span class=\"variable\">$value</span> collected&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们快速地发送了 100 个元素，最后接收到的只有两个，当然这个结果每次都不一定一样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> collected</span><br><span class=\"line\">Collecting <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"number\">99</span> collected</span><br></pre></td></tr></table></figure>\n\n<p>第二种是 <code>collectLatest</code>。顾名思义，只处理最新的数据，这看上去似乎与 <code>conflate</code> 没有区别，其实区别大了：它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p>\n<p>还是前面的例子，我们稍作修改：</p>\n<p><strong>代码清单18：使用 collectLatest 解决背压问题</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    emit(it)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;.collectLatest &#123; value -&gt;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;Collecting <span class=\"variable\">$value</span>&quot;</span>)</span><br><span class=\"line\">  delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">  println(<span class=\"string\">&quot;<span class=\"variable\">$value</span> collected&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting 0</span><br><span class=\"line\">Collecting 1</span><br><span class=\"line\">...</span><br><span class=\"line\">Collecting 97</span><br><span class=\"line\">Collecting 98</span><br><span class=\"line\">Collecting 99</span><br><span class=\"line\">▶ 100ms later</span><br><span class=\"line\">99 collected</span><br></pre></td></tr></table></figure>\n\n<p>前面的 <code>Collecting</code> 输出了 0 ~ 99 的所有结果，而 <code>collected</code> 却只有 99，因为后面的数据到达时，处理上一个数据的操作正好被挂起了（请注意<code>delay(100)</code>）。</p>\n<p>除 <code>collectLatest</code> 之外还有 <code>mapLatest</code>、<code>flatMapLatest</code> 等等，都是这个作用。</p>\n<h2 id=\"Flow-的变换\"><a href=\"#Flow-的变换\" class=\"headerlink\" title=\"Flow 的变换\"></a>Flow 的变换</h2><p>我们已经对集合框架的变换非常熟悉了，<code>Flow</code> 看上去极其类似于这样的数据结构，这一点与 RxJava 的 <code>Observable</code> 的表现也基本一致。</p>\n<p>例如我们可以使用 <code>map</code> 来变换 <code>Flow</code> 的数据：</p>\n<p><strong>代码清单19：Flow 的元素变换</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123; </span><br><span class=\"line\">  it * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以映射成其他 Flow：</p>\n<p><strong>代码清单20：Flow 的嵌套</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123;</span><br><span class=\"line\">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上得到的是一个数据类型为 <code>Flow</code> 的 <code>Flow</code>，如果希望将它们拼接起来，可以使用 <code>flattenConcat</code>：</p>\n<p><strong>代码清单21：拼接 Flow</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flow &#123;</span><br><span class=\"line\">  List(<span class=\"number\">5</span>)&#123; emit(it) &#125; </span><br><span class=\"line\">&#125;.map &#123;</span><br><span class=\"line\">  flow &#123; List(it) &#123; emit(it) &#125; &#125;</span><br><span class=\"line\">&#125;.flattenConcat()</span><br><span class=\"line\">  .collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>拼接的操作中 <code>flattenConcat</code> 是按顺序拼接的，结果的顺序仍然是生产时的顺序；还有一个是 <code>flattenMerge</code>，它会并发拼接，因此结果不会保证顺序。</p>\n<h2 id=\"使用-Flow-实现多路复用\"><a href=\"#使用-Flow-实现多路复用\" class=\"headerlink\" title=\"使用 Flow 实现多路复用\"></a>使用 Flow 实现多路复用</h2><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p>\n<p>上一篇文章<a href=\"https://www.bennyhuo.com/2020/02/03/coroutine-select/\">破解 Kotlin 协程(10) - Select 篇</a>中对 await 的复用我们可以用 Flow 实现如下：</p>\n<p><strong>代码清单22：使用 Flow 实现对 await 的多路复用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coroutineScope &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> login = <span class=\"string\">&quot;...&quot;</span></span><br><span class=\"line\">  listOf(::getUserFromApi, ::getUserFromLocal) ... ①</span><br><span class=\"line\">    .map &#123; function -&gt;</span><br><span class=\"line\">      function.call(login) ... ②</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .map &#123; deferred -&gt;</span><br><span class=\"line\">      flow &#123; emit(deferred.await()) &#125; ... ③</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .merge() ... ④</span><br><span class=\"line\">    .onEach &#123; user -&gt;</span><br><span class=\"line\">      println(<span class=\"string\">&quot;Result: <span class=\"variable\">$user</span>&quot;</span>)</span><br><span class=\"line\">    &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这其中，① 处用创建了两个函数引用组成的 List；② 处调用它们得到 deferred；③ 处比较关键，对于每一个 deferred 我们创建一个单独的 Flow，并在 Flow 内部发送 deferred.await() 返回的结果，即返回的 User 对象；现在我们有了两个 Flow 实例，我们需要将它们整合成一个 Flow 进行处理，调用 merge 函数即可。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png\"></p>\n<p><strong>图1：使用 merge 合并 Flow</strong></p>\n<p>同样的，对 Channel 的读取复用的场景也可以使用 Flow 来完成。对照<a href=\"https://www.bennyhuo.com/2020/02/03/coroutine-select/\">破解 Kotlin 协程(10) - Select 篇</a>，我们给出 Flow 的实现版本：</p>\n<p><strong>代码清单23：使用 Flow 实现对 Channel 的复用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channels = List(<span class=\"number\">10</span>) &#123; Channel&lt;<span class=\"built_in\">Int</span>&gt;() &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = channels.map &#123;</span><br><span class=\"line\">    it.consumeAsFlow()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .merge()</span><br><span class=\"line\">  .first()</span><br></pre></td></tr></table></figure>\n\n<p>这比 <code>select</code> 的版本看上去要更简洁明了，每个 Channel 都通过 <code>consumeAsFlow</code> 函数被映射成 Flow，再 merge 成一个 Flow，取第一个元素。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>Flow</code> 是协程当中比较重要的异步工具，它的用法与其他类似的响应式编程框架非常相近，大家可以采取类比的学习方式去了解它的功能。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"破解 Kotlin 协程(11) - Flow 篇","path":"2020/03/14/coroutine-flow/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/9ff28c5395881742a6878225807e2dd75c150d63.png","excerpt":"<blockquote>\n<p><code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 RxJava 非常像，二者之间也有相互转换的 API，使用起来非常方便。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-03-13T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-03-13T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","flow","rxjava"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现","keywords":"协程 分类","date":"2019-11-30T16:00:00.000Z","description":null,"_content":"\n> 所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 \n\n<!-- more -->\n\n\n\n\n前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。\n\n## 1. 协程的分类\n\n协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。\n\n### 1.1 按调用栈分类\n\n由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：\n\n* 有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。\n* 无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。\n\n有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。\n\n当然也有反例。\n\nGo 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。\n\nKotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 `suspend` 函数，而这又恰恰是有栈协程最重要的特性之一：\n\n```kotlin\nsuspend fun level_0() {\n    println(\"I'm in level 0!\")\n    level_1() // ............ ①\n}\n\nsuspend fun level_1() {\n    println(\"I'm in level 1!\")\n    suspendNow() // ............ ②\n}\n\nsuspend fun suspendNow() \n        = suspendCoroutine<Unit> {\n    ... \n}\n```\n\n示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 `suspend` 函数嵌套调用的方式可以实现任意函数调用层次的挂起。\n\n当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。\n\n### 1.2 按调度方式分类\n\n调度过程中，根据协程转移调度权的目标又将协程分为**对称协程**和**非对称协程**：\n\n* 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。\n* 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。\n\n对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 `yield` 总是会将调度权转移给 `resume` 它的协程；还有就是我们在前面提到的 `async`/`await`，`await` 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 `await` 的位置。\n\n从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 [coro](https://luapower.com/coro)，以及 Kotlin 协程框架中基于 [Channel](https://kotlinlang.org/docs/reference/coroutines/channels.html) 的通信等。\n\n## 2. 协程的实现举例\n\n我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照**栈**的有无和**调度权**转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。\n\n### 2.1 Python 的 Generator\n\nPython 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 `yield` 来实现当前函数调用的挂起，`yield` 的参数作为对下一次 `next(num_generator)`调用的返回值：\n\n```python\nimport time\n\ndef numbers():\n    i = 0\n    while True:\n        yield(i) # ..................... ①\n        i += 1\n        time.sleep(1)\n\nnum_generator = numbers()\n\nprint(f\"[0] {next(num_generator)}\") # ... ②\nprint(f\"[1] {next(num_generator)}\") # ... ③\n\nfor i in num_generator: # ............... ④\n    print(f\"[Loop] {i}\")\n```\n\n所以运行这段程序时，首先会在 ① 处 `yield`，并将 `0` 传出，在 ② 处输出：\n\n```\n[0] 0\n```\n\n接着自 ③ 处调用 `next`，将调度权从主流程转移到 `numbers` 函数当中，从上一次挂起的位置 ① 处继续执行，`i` 的值修改为 `1`，1s 后，再次通过 `yield(1)` 挂起，③ 处输出：\n\n```\n[1] 1\n```\n\n后续就以同样的逻辑在 `for` 循环中一直输出 `[Loop] n`，直到程序被终止。\n\n我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 `yield` 来挂起当前 Generator 函数的执行，通过 `next` 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。\n\n当然，如果在 `numbers` 函数中嵌套调用 `yield`，就无法对 `numbers` 的调用进行中断了：\n\n```python\ndef numbers():\n    i = 0\n    while True:\n        yield_here(i) # ................. ①\n        i += 1\n        time.sleep(1)\n\ndef yield_here(i):\n    yield(i)\n```\n\n这时候我们再调用 `numbers` 函数，就会陷入死循环而无法返回，因为这次 `yield_here` 的返回值才是 Generator。\n\n> **说明** Python 的 Generator 属于**非对称无栈协程**的一种实现。从 Python 3.5 开始也支持 `async`/`await`，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。\n\n### 2.2 Lua 标准库的协程实现\n\nLua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：\n\n* `coroutine.create`：创建协程，参数为函数，作为协程的执行体，返回协程实例。\n* `coroutine.yield`：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 `resume` 来继续当前协程时的返回值，而它的返回值则又是外部下一次 `resume` 调用时传入的参数。\n* `coroutine.resume`：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 `yield` 时的返回值，返回值则为协程内部下一次 `yield` 时传出的参数；如果是第一次对该协程实例执行 `resume`，参数会作为协程函数的参数传入。\n\nLua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 `yield` 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。\n\n\n```lua\nfunction producer() \n    for i = 0, 3 do\n        print(\"send \"..i)\n        coroutine.yield(i) -- ④\n    end\n    print(\"End Producer\")\nend            \n\nfunction consumer(value)\n    repeat\n        print(\"receive \"..value)\n        value = coroutine.yield() -- ⑤\n    until(not value)\n    print(\"End Consumer\")\nend\n\nproducerCoroutine = coroutine.create(producer) -- ①\nconsumerCoroutine = coroutine.create(consumer) -- ②\n\nrepeat\n    status, product = coroutine.resume(producerCoroutine) -- ③\n    coroutine.resume(consumerCoroutine, product) -- ⑥\nuntil(not status)\nprint(\"End Main\")\n```\n\n这段代码在 ①、②两处创建协程，③处开始执行，`producer` 在 ④ 处 `yield(0)`，意味着 ③ 的返回值 `product` 就是 `0`，我们把 `0` 作为参数又传给 `consumer`，第一次 `resume` 参数 `0` 会作为 `consumer` 的参数 `value` 传入，因此会打印出：\n\n```\nsend 0\nreceive 0\n```\n\n接下来 `consumer` 通过 ⑤ 处的 `yield` 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，`status` 的值在对应的协程结束后会返回 `false`，这时候 `producer` 尚未结束，因此是 `true`，于是循环继续执行，后续流程类似，输出结果：\n\n```\nsend 1\nreceive 1\nsend 2\nreceive 2\nsend 3\nreceive 3\nEnd Producer\nEnd Consumer\nEnd Main\n```\n\n通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：\n\n* 协程的执行体，主要是指启动协程时对应的函数\n* 协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转\n* 协程的状态，在调用流程转移前后，协程的状态会发生相应的变化\n\n> **说明** Lua 标准库的协程属于**非对称有栈协程**，不过第三方提供了基于标准库的**对称协程**的实现，有兴趣的话可以参考： [coro](https://luapower.com/coro)。有趣的是，这也恰恰是**对称协程**的实现可以基于**非对称协程**来实现的很好的例证。\n\n\n### 2.3 Go 语言中的 go routine\n\ngo routine 的调度没有 Lua 那么明显，没有类似 `yield` 和 `resume` 的函数。\n\n\n```go\nchannel := make(chan int) // .......... ①\nvar readChannel <-chan int = channel\nvar writeChannel chan<- int = channel\n\n// reader\ngo func() { // ........................ ②\n    fmt.Println(\"wait for read\")\n    for i := range readChannel { // ... ③\n        fmt.Println(\"read\", i)\n    }\n    fmt.Println(\"read end\")\n}()  // ............................... ④\n\n\n// writer\ngo func() {\n    for i := 0; i < 3; i++{\n        fmt.Println(\"write\", i)\n        writeChannel <- i // .......... ⑤\n        time.Sleep(time.Second)\n    }\n    close(writeChannel)\n}()\n```\n\n我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 `go` 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。\n\n① 处创建了一个双向的 `channel`，可读可写，接着创建的 `readChannel` 声明为只读类型，`writeChannel` 声明为只写类型，这二者实际上是同一个 `channel`，并且由于这个 `channel` 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。\n\n在 reader 中，③ 处的 `for` 循环会对 `readChannel` 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 `writeChannel` 中写入 `i`，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：\n\n```\nwait for read\nwrite 0\nread 0\nwrite 1\nread 1\nwrite 2\nread 2\nread end\n```\n\n如果我们有多个 go routine 对 `channel` 进行读写，或者有多个 `channel` 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是**对称**的协程实现。\n\n这个示例看上去对于 `channel` 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 `writeChannel` 写入数据之后的 `Sleep` 操作去掉：\n\n```go\ngo func() {\n    fmt.Println(windows.GetCurrentThreadId(), \"wait for read\")\n    for i := range readChannel {\n        fmt.Println(windows.GetCurrentThreadId(), \"read\", i)\n    }\n    fmt.Println(windows.GetCurrentThreadId(), \"read end\")\n}()\ngo func() {\n    for i := 0; i < 3; i++{\n        fmt.Println(windows.GetCurrentThreadId(), \"write\", i)\n        writeChannel <- i\n    }\n    close(writeChannel)\n}()\n```\n\n修改后的运行结果可以看到程序在输出时所在的线程 id：\n\n```\n181808 write 0\n183984 wait for read\n181808 read 0\n181808 write 1\n181808 write 2\n181808 read 1\n181808 read 2\n181808 read end\n```\n\n两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。\n\n> **获取线程 id** 本例在 windows 上调试，通过 [sys](https://github.com/golang/sys) 库的 windows 包下提供的 `GetCurrentThreadId` 函数来获取线程 id。Linux 系统可以通过 `syscall.Gettid` 来获取。\n\n> **说明** 我们虽然一直在用 go routine 做例子，并把它称作为**对称有栈协程**的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。\n\n## 3. 小结\n\n本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 `async`/`await`，Channel 等。\n\n相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 `async`/`await` 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 `suspend` 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 `async`/`await`、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-implementations.md","raw":"---\ntitle:  破解 Kotlin 协程 番外篇(2) - 协程的几类常见的实现 \nkeywords: 协程 分类 \ndate: 2019/12/01\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 \n\n<!-- more -->\n\n\n\n\n前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。\n\n## 1. 协程的分类\n\n协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。\n\n### 1.1 按调用栈分类\n\n由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：\n\n* 有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。\n* 无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。\n\n有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。\n\n当然也有反例。\n\nGo 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。\n\nKotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 `suspend` 函数，而这又恰恰是有栈协程最重要的特性之一：\n\n```kotlin\nsuspend fun level_0() {\n    println(\"I'm in level 0!\")\n    level_1() // ............ ①\n}\n\nsuspend fun level_1() {\n    println(\"I'm in level 1!\")\n    suspendNow() // ............ ②\n}\n\nsuspend fun suspendNow() \n        = suspendCoroutine<Unit> {\n    ... \n}\n```\n\n示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 `suspend` 函数嵌套调用的方式可以实现任意函数调用层次的挂起。\n\n当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。\n\n### 1.2 按调度方式分类\n\n调度过程中，根据协程转移调度权的目标又将协程分为**对称协程**和**非对称协程**：\n\n* 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。\n* 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。\n\n对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 `yield` 总是会将调度权转移给 `resume` 它的协程；还有就是我们在前面提到的 `async`/`await`，`await` 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 `await` 的位置。\n\n从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 [coro](https://luapower.com/coro)，以及 Kotlin 协程框架中基于 [Channel](https://kotlinlang.org/docs/reference/coroutines/channels.html) 的通信等。\n\n## 2. 协程的实现举例\n\n我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照**栈**的有无和**调度权**转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。\n\n### 2.1 Python 的 Generator\n\nPython 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 `yield` 来实现当前函数调用的挂起，`yield` 的参数作为对下一次 `next(num_generator)`调用的返回值：\n\n```python\nimport time\n\ndef numbers():\n    i = 0\n    while True:\n        yield(i) # ..................... ①\n        i += 1\n        time.sleep(1)\n\nnum_generator = numbers()\n\nprint(f\"[0] {next(num_generator)}\") # ... ②\nprint(f\"[1] {next(num_generator)}\") # ... ③\n\nfor i in num_generator: # ............... ④\n    print(f\"[Loop] {i}\")\n```\n\n所以运行这段程序时，首先会在 ① 处 `yield`，并将 `0` 传出，在 ② 处输出：\n\n```\n[0] 0\n```\n\n接着自 ③ 处调用 `next`，将调度权从主流程转移到 `numbers` 函数当中，从上一次挂起的位置 ① 处继续执行，`i` 的值修改为 `1`，1s 后，再次通过 `yield(1)` 挂起，③ 处输出：\n\n```\n[1] 1\n```\n\n后续就以同样的逻辑在 `for` 循环中一直输出 `[Loop] n`，直到程序被终止。\n\n我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 `yield` 来挂起当前 Generator 函数的执行，通过 `next` 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。\n\n当然，如果在 `numbers` 函数中嵌套调用 `yield`，就无法对 `numbers` 的调用进行中断了：\n\n```python\ndef numbers():\n    i = 0\n    while True:\n        yield_here(i) # ................. ①\n        i += 1\n        time.sleep(1)\n\ndef yield_here(i):\n    yield(i)\n```\n\n这时候我们再调用 `numbers` 函数，就会陷入死循环而无法返回，因为这次 `yield_here` 的返回值才是 Generator。\n\n> **说明** Python 的 Generator 属于**非对称无栈协程**的一种实现。从 Python 3.5 开始也支持 `async`/`await`，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。\n\n### 2.2 Lua 标准库的协程实现\n\nLua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：\n\n* `coroutine.create`：创建协程，参数为函数，作为协程的执行体，返回协程实例。\n* `coroutine.yield`：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 `resume` 来继续当前协程时的返回值，而它的返回值则又是外部下一次 `resume` 调用时传入的参数。\n* `coroutine.resume`：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 `yield` 时的返回值，返回值则为协程内部下一次 `yield` 时传出的参数；如果是第一次对该协程实例执行 `resume`，参数会作为协程函数的参数传入。\n\nLua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 `yield` 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。\n\n\n```lua\nfunction producer() \n    for i = 0, 3 do\n        print(\"send \"..i)\n        coroutine.yield(i) -- ④\n    end\n    print(\"End Producer\")\nend            \n\nfunction consumer(value)\n    repeat\n        print(\"receive \"..value)\n        value = coroutine.yield() -- ⑤\n    until(not value)\n    print(\"End Consumer\")\nend\n\nproducerCoroutine = coroutine.create(producer) -- ①\nconsumerCoroutine = coroutine.create(consumer) -- ②\n\nrepeat\n    status, product = coroutine.resume(producerCoroutine) -- ③\n    coroutine.resume(consumerCoroutine, product) -- ⑥\nuntil(not status)\nprint(\"End Main\")\n```\n\n这段代码在 ①、②两处创建协程，③处开始执行，`producer` 在 ④ 处 `yield(0)`，意味着 ③ 的返回值 `product` 就是 `0`，我们把 `0` 作为参数又传给 `consumer`，第一次 `resume` 参数 `0` 会作为 `consumer` 的参数 `value` 传入，因此会打印出：\n\n```\nsend 0\nreceive 0\n```\n\n接下来 `consumer` 通过 ⑤ 处的 `yield` 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，`status` 的值在对应的协程结束后会返回 `false`，这时候 `producer` 尚未结束，因此是 `true`，于是循环继续执行，后续流程类似，输出结果：\n\n```\nsend 1\nreceive 1\nsend 2\nreceive 2\nsend 3\nreceive 3\nEnd Producer\nEnd Consumer\nEnd Main\n```\n\n通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：\n\n* 协程的执行体，主要是指启动协程时对应的函数\n* 协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转\n* 协程的状态，在调用流程转移前后，协程的状态会发生相应的变化\n\n> **说明** Lua 标准库的协程属于**非对称有栈协程**，不过第三方提供了基于标准库的**对称协程**的实现，有兴趣的话可以参考： [coro](https://luapower.com/coro)。有趣的是，这也恰恰是**对称协程**的实现可以基于**非对称协程**来实现的很好的例证。\n\n\n### 2.3 Go 语言中的 go routine\n\ngo routine 的调度没有 Lua 那么明显，没有类似 `yield` 和 `resume` 的函数。\n\n\n```go\nchannel := make(chan int) // .......... ①\nvar readChannel <-chan int = channel\nvar writeChannel chan<- int = channel\n\n// reader\ngo func() { // ........................ ②\n    fmt.Println(\"wait for read\")\n    for i := range readChannel { // ... ③\n        fmt.Println(\"read\", i)\n    }\n    fmt.Println(\"read end\")\n}()  // ............................... ④\n\n\n// writer\ngo func() {\n    for i := 0; i < 3; i++{\n        fmt.Println(\"write\", i)\n        writeChannel <- i // .......... ⑤\n        time.Sleep(time.Second)\n    }\n    close(writeChannel)\n}()\n```\n\n我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 `go` 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。\n\n① 处创建了一个双向的 `channel`，可读可写，接着创建的 `readChannel` 声明为只读类型，`writeChannel` 声明为只写类型，这二者实际上是同一个 `channel`，并且由于这个 `channel` 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。\n\n在 reader 中，③ 处的 `for` 循环会对 `readChannel` 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 `writeChannel` 中写入 `i`，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：\n\n```\nwait for read\nwrite 0\nread 0\nwrite 1\nread 1\nwrite 2\nread 2\nread end\n```\n\n如果我们有多个 go routine 对 `channel` 进行读写，或者有多个 `channel` 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是**对称**的协程实现。\n\n这个示例看上去对于 `channel` 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 `writeChannel` 写入数据之后的 `Sleep` 操作去掉：\n\n```go\ngo func() {\n    fmt.Println(windows.GetCurrentThreadId(), \"wait for read\")\n    for i := range readChannel {\n        fmt.Println(windows.GetCurrentThreadId(), \"read\", i)\n    }\n    fmt.Println(windows.GetCurrentThreadId(), \"read end\")\n}()\ngo func() {\n    for i := 0; i < 3; i++{\n        fmt.Println(windows.GetCurrentThreadId(), \"write\", i)\n        writeChannel <- i\n    }\n    close(writeChannel)\n}()\n```\n\n修改后的运行结果可以看到程序在输出时所在的线程 id：\n\n```\n181808 write 0\n183984 wait for read\n181808 read 0\n181808 write 1\n181808 write 2\n181808 read 1\n181808 read 2\n181808 read end\n```\n\n两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。\n\n> **获取线程 id** 本例在 windows 上调试，通过 [sys](https://github.com/golang/sys) 库的 windows 包下提供的 `GetCurrentThreadId` 函数来获取线程 id。Linux 系统可以通过 `syscall.Gettid` 来获取。\n\n> **说明** 我们虽然一直在用 go routine 做例子，并把它称作为**对称有栈协程**的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。\n\n## 3. 小结\n\n本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 `async`/`await`，Channel 等。\n\n相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 `async`/`await` 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 `suspend` 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 `async`/`await`、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-implementations","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0036000tlduzfunw7yyk","content":"<blockquote>\n<p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p>\n<h2 id=\"1-协程的分类\"><a href=\"#1-协程的分类\" class=\"headerlink\" title=\"1. 协程的分类\"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p>\n<h3 id=\"1-1-按调用栈分类\"><a href=\"#1-1-按调用栈分类\" class=\"headerlink\" title=\"1.1 按调用栈分类\"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p>\n<ul>\n<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>\n<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li>\n</ul>\n<p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p>\n<p>当然也有反例。</p>\n<p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p>\n<p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">level_0</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;I&#x27;m in level 0!&quot;</span>)</span><br><span class=\"line\">    level_1() <span class=\"comment\">// ............ ①</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">level_1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;I&#x27;m in level 1!&quot;</span>)</span><br><span class=\"line\">    suspendNow() <span class=\"comment\">// ............ ②</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">suspendNow</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">        = suspendCoroutine&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p>\n<p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p>\n<h3 id=\"1-2-按调度方式分类\"><a href=\"#1-2-按调度方式分类\" class=\"headerlink\" title=\"1.2 按调度方式分类\"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p>\n<ul>\n<li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li>\n<li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li>\n</ul>\n<p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p>\n<p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href=\"https://luapower.com/coro\">coro</a>，以及 Kotlin 协程框架中基于 <a href=\"https://kotlinlang.org/docs/reference/coroutines/channels.html\">Channel</a> 的通信等。</p>\n<h2 id=\"2-协程的实现举例\"><a href=\"#2-协程的实现举例\" class=\"headerlink\" title=\"2. 协程的实现举例\"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p>\n<h3 id=\"2-1-Python-的-Generator\"><a href=\"#2-1-Python-的-Generator\" class=\"headerlink\" title=\"2.1 Python 的 Generator\"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numbers</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span>(i) <span class=\"comment\"># ..................... ①</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">num_generator = numbers()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[0] <span class=\"subst\">&#123;<span class=\"built_in\">next</span>(num_generator)&#125;</span>&quot;</span>) <span class=\"comment\"># ... ②</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[1] <span class=\"subst\">&#123;<span class=\"built_in\">next</span>(num_generator)&#125;</span>&quot;</span>) <span class=\"comment\"># ... ③</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> num_generator: <span class=\"comment\"># ............... ④</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[Loop] <span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0] 0</span><br></pre></td></tr></table></figure>\n\n<p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1] 1</span><br></pre></td></tr></table></figure>\n\n<p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p>\n<p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p>\n<p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numbers</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        yield_here(i) <span class=\"comment\"># ................. ①</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yield_here</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p>\n<blockquote>\n<p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p>\n</blockquote>\n<h3 id=\"2-2-Lua-标准库的协程实现\"><a href=\"#2-2-Lua-标准库的协程实现\" class=\"headerlink\" title=\"2.2 Lua 标准库的协程实现\"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p>\n<ul>\n<li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li>\n<li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li>\n<li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li>\n</ul>\n<p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">producer</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i = <span class=\"number\">0</span>, <span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;send &quot;</span>..i)</span><br><span class=\"line\">        <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>(i) <span class=\"comment\">-- ④</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Producer&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span>            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">consumer</span><span class=\"params\">(value)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">repeat</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;receive &quot;</span>..value)</span><br><span class=\"line\">        value = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>() <span class=\"comment\">-- ⑤</span></span><br><span class=\"line\">    <span class=\"keyword\">until</span>(<span class=\"keyword\">not</span> value)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Consumer&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">producerCoroutine = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(producer) <span class=\"comment\">-- ①</span></span><br><span class=\"line\">consumerCoroutine = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(consumer) <span class=\"comment\">-- ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repeat</span></span><br><span class=\"line\">    <span class=\"built_in\">status</span>, product = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(producerCoroutine) <span class=\"comment\">-- ③</span></span><br><span class=\"line\">    <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(consumerCoroutine, product) <span class=\"comment\">-- ⑥</span></span><br><span class=\"line\"><span class=\"keyword\">until</span>(<span class=\"keyword\">not</span> <span class=\"built_in\">status</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Main&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">send 0</span><br><span class=\"line\">receive 0</span><br></pre></td></tr></table></figure>\n\n<p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">send 1</span><br><span class=\"line\">receive 1</span><br><span class=\"line\">send 2</span><br><span class=\"line\">receive 2</span><br><span class=\"line\">send 3</span><br><span class=\"line\">receive 3</span><br><span class=\"line\">End Producer</span><br><span class=\"line\">End Consumer</span><br><span class=\"line\">End Main</span><br></pre></td></tr></table></figure>\n\n<p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p>\n<ul>\n<li>协程的执行体，主要是指启动协程时对应的函数</li>\n<li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li>\n<li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li>\n</ul>\n<blockquote>\n<p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href=\"https://luapower.com/coro\">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p>\n</blockquote>\n<h3 id=\"2-3-Go-语言中的-go-routine\"><a href=\"#2-3-Go-语言中的-go-routine\" class=\"headerlink\" title=\"2.3 Go 语言中的 go routine\"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// .......... ①</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> readChannel &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = channel</span><br><span class=\"line\"><span class=\"keyword\">var</span> writeChannel <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span> = channel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reader</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// ........................ ②</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;wait for read&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> readChannel &#123; <span class=\"comment\">// ... ③</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;read&quot;</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;read end&quot;</span>)</span><br><span class=\"line\">&#125;()  <span class=\"comment\">// ............................... ④</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writer</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;write&quot;</span>, i)</span><br><span class=\"line\">        writeChannel &lt;- i <span class=\"comment\">// .......... ⑤</span></span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(writeChannel)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p>\n<p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p>\n<p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait for read</span><br><span class=\"line\">write 0</span><br><span class=\"line\">read 0</span><br><span class=\"line\">write 1</span><br><span class=\"line\">read 1</span><br><span class=\"line\">write 2</span><br><span class=\"line\">read 2</span><br><span class=\"line\">read end</span><br></pre></td></tr></table></figure>\n\n<p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p>\n<p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;wait for read&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> readChannel &#123;</span><br><span class=\"line\">        fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;read&quot;</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;read end&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">        fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;write&quot;</span>, i)</span><br><span class=\"line\">        writeChannel &lt;- i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(writeChannel)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">181808 write 0</span><br><span class=\"line\">183984 wait for read</span><br><span class=\"line\">181808 read 0</span><br><span class=\"line\">181808 write 1</span><br><span class=\"line\">181808 write 2</span><br><span class=\"line\">181808 read 1</span><br><span class=\"line\">181808 read 2</span><br><span class=\"line\">181808 read end</span><br></pre></td></tr></table></figure>\n\n<p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p>\n<blockquote>\n<p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href=\"https://github.com/golang/sys\">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p>\n</blockquote>\n<blockquote>\n<p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p>\n</blockquote>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p>\n<p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#105;&#x6d;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;\">&#x6b;&#x66;&#64;&#105;&#x6d;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>所谓知己知彼，百战不殆。为了搞清楚 Kotlin 协程是怎么回事，我们也来看看其他语言的协程是怎么实现的。 </p>\n</blockquote>","more":"<p>前面一篇文章我们大概讨论了协程是怎么一回事，也举了一些例子，不过整体上覆盖的细节比较少。这篇文章我们按照协程的经典论文 “Revisiting Coroutines” 的思路展开，详细的讨论下协程究竟是怎样的存在。当然由于涉及语言较多，个人水平有限，如有不恰当之处，欢迎大家指正。</p>\n<h2 id=\"1-协程的分类\"><a href=\"#1-协程的分类\" class=\"headerlink\" title=\"1. 协程的分类\"></a>1. 协程的分类</h2><p>协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。</p>\n<h3 id=\"1-1-按调用栈分类\"><a href=\"#1-1-按调用栈分类\" class=\"headerlink\" title=\"1.1 按调用栈分类\"></a>1.1 按调用栈分类</h3><p>由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：</p>\n<ul>\n<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>\n<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。</li>\n</ul>\n<p>有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。</p>\n<p>当然也有反例。</p>\n<p>Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，因而它在内存方面的表现也相对轻量。</p>\n<p>Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，可以在其中任意嵌套 <code>suspend</code> 函数，而这又恰恰是有栈协程最重要的特性之一：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">level_0</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;I&#x27;m in level 0!&quot;</span>)</span><br><span class=\"line\">    level_1() <span class=\"comment\">// ............ ①</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">level_1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;I&#x27;m in level 1!&quot;</span>)</span><br><span class=\"line\">    suspendNow() <span class=\"comment\">// ............ ②</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">suspendNow</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">        = suspendCoroutine&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例中 ① 处并没有真正直接挂起，② 处的调用才会真正挂起，Kotlin 通过 <code>suspend</code> 函数嵌套调用的方式可以实现任意函数调用层次的挂起。</p>\n<p>当然，想要在任意位置挂起，那就需要调用栈了，与开发者通过调用 API 显式地挂起协程相比，任意位置的挂起主要用于运行时对协程执行的干预，这种挂起方式对于开发者不可见，因而是一种隐式的挂起操作。Go 语言的 go routine 可以通过对 channel 的读写来实现挂起和恢复，除了这种显式地切换调度权之外，Go 运行时还会对长期占用调度权的 go routine 进行隐式挂起，并将调度权转移给其他 go routine，这实际上就是我们熟悉的线程的抢占式调度了。</p>\n<h3 id=\"1-2-按调度方式分类\"><a href=\"#1-2-按调度方式分类\" class=\"headerlink\" title=\"1.2 按调度方式分类\"></a>1.2 按调度方式分类</h3><p>调度过程中，根据协程转移调度权的目标又将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>：</p>\n<ul>\n<li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li>\n<li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li>\n</ul>\n<p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给 <code>resume</code> 它的协程；还有就是我们在前面提到的 <code>async</code>/<code>await</code>，<code>await</code> 时将调度权转移到异步调用中，异步调用返回结果或抛出异常时总是将调度权转移回 <code>await</code> 的位置。</p>\n<p>从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，例如 Lua 的第三方库 <a href=\"https://luapower.com/coro\">coro</a>，以及 Kotlin 协程框架中基于 <a href=\"https://kotlinlang.org/docs/reference/coroutines/channels.html\">Channel</a> 的通信等。</p>\n<h2 id=\"2-协程的实现举例\"><a href=\"#2-协程的实现举例\" class=\"headerlink\" title=\"2. 协程的实现举例\"></a>2. 协程的实现举例</h2><p>我们已经介绍了非常多的协程相关的理论知识，简单来说协程需要关注的就是程序自己处理挂起和恢复，只不过在分类的时候又根据解决挂起和恢复时具体实现细节的不同又区分了按照<strong>栈</strong>的有无和<strong>调度权</strong>转移的对称性的分类。不管怎样，协程的关注点就是程序自己处理挂起和恢复，以下我们给出一些实现，请大家留意它们是如何做到这一点的。</p>\n<h3 id=\"2-1-Python-的-Generator\"><a href=\"#2-1-Python-的-Generator\" class=\"headerlink\" title=\"2.1 Python 的 Generator\"></a>2.1 Python 的 Generator</h3><p>Python 的 Generator 也是协程，是一个典型的无栈协程的实现，我们可以在任意 Python 函数中调用 <code>yield</code> 来实现当前函数调用的挂起，<code>yield</code> 的参数作为对下一次 <code>next(num_generator)</code>调用的返回值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numbers</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span>(i) <span class=\"comment\"># ..................... ①</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">num_generator = numbers()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[0] <span class=\"subst\">&#123;<span class=\"built_in\">next</span>(num_generator)&#125;</span>&quot;</span>) <span class=\"comment\"># ... ②</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[1] <span class=\"subst\">&#123;<span class=\"built_in\">next</span>(num_generator)&#125;</span>&quot;</span>) <span class=\"comment\"># ... ③</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> num_generator: <span class=\"comment\"># ............... ④</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[Loop] <span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所以运行这段程序时，首先会在 ① 处 <code>yield</code>，并将 <code>0</code> 传出，在 ② 处输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0] 0</span><br></pre></td></tr></table></figure>\n\n<p>接着自 ③ 处调用 <code>next</code>，将调度权从主流程转移到 <code>numbers</code> 函数当中，从上一次挂起的位置 ① 处继续执行，<code>i</code> 的值修改为 <code>1</code>，1s 后，再次通过 <code>yield(1)</code> 挂起，③ 处输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1] 1</span><br></pre></td></tr></table></figure>\n\n<p>后续就以同样的逻辑在 <code>for</code> 循环中一直输出 <code>[Loop] n</code>，直到程序被终止。</p>\n<p>我们看到，之所以称 Python 的 Generator 为协程，就是因为它具备了通过 <code>yield</code> 来挂起当前 Generator 函数的执行，通过 <code>next</code> 来恢复参数对应的 Generator 执行来实现挂起、恢复的协程调度权控制转移的。</p>\n<p>当然，如果在 <code>numbers</code> 函数中嵌套调用 <code>yield</code>，就无法对 <code>numbers</code> 的调用进行中断了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numbers</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        yield_here(i) <span class=\"comment\"># ................. ①</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">yield_here</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们再调用 <code>numbers</code> 函数，就会陷入死循环而无法返回，因为这次 <code>yield_here</code> 的返回值才是 Generator。</p>\n<blockquote>\n<p><strong>说明</strong> Python 的 Generator 属于<strong>非对称无栈协程</strong>的一种实现。从 Python 3.5 开始也支持 <code>async</code>/<code>await</code>，原理与 JavaScript 的实现类似，与 Generator 的不同之处在于我们可以通过这一组关键字实现在函数嵌套调用挂起。</p>\n</blockquote>\n<h3 id=\"2-2-Lua-标准库的协程实现\"><a href=\"#2-2-Lua-标准库的协程实现\" class=\"headerlink\" title=\"2.2 Lua 标准库的协程实现\"></a>2.2 Lua 标准库的协程实现</h3><p>Lua 的协程实现可以认为是一个教科书式的案例了，它提供了几个 API 允许开发者灵活控制协程的执行：</p>\n<ul>\n<li><code>coroutine.create</code>：创建协程，参数为函数，作为协程的执行体，返回协程实例。</li>\n<li><code>coroutine.yield</code>：挂起协程，第一个参数为被挂起的协程实例，后面的参数则作为外部调用 <code>resume</code> 来继续当前协程时的返回值，而它的返回值则又是外部下一次 <code>resume</code> 调用时传入的参数。</li>\n<li><code>coroutine.resume</code>：继续协程，第一个参数为被继续的协程实例，后面的参数则作为协程内部 <code>yield</code> 时的返回值，返回值则为协程内部下一次 <code>yield</code> 时传出的参数；如果是第一次对该协程实例执行 <code>resume</code>，参数会作为协程函数的参数传入。</li>\n</ul>\n<p>Lua 的协程也有几个状态，挂起（suspended）、运行（running）、结束（dead）。其中，调用 <code>yield</code> 之后的协程处于挂起态，获得执行权而正在运行的协程则是处于运行态，协程对应的函数运行结束后，则处于结束态。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">producer</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i = <span class=\"number\">0</span>, <span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;send &quot;</span>..i)</span><br><span class=\"line\">        <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>(i) <span class=\"comment\">-- ④</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Producer&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span>            </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">consumer</span><span class=\"params\">(value)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">repeat</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;receive &quot;</span>..value)</span><br><span class=\"line\">        value = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>() <span class=\"comment\">-- ⑤</span></span><br><span class=\"line\">    <span class=\"keyword\">until</span>(<span class=\"keyword\">not</span> value)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Consumer&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">producerCoroutine = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(producer) <span class=\"comment\">-- ①</span></span><br><span class=\"line\">consumerCoroutine = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(consumer) <span class=\"comment\">-- ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repeat</span></span><br><span class=\"line\">    <span class=\"built_in\">status</span>, product = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(producerCoroutine) <span class=\"comment\">-- ③</span></span><br><span class=\"line\">    <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(consumerCoroutine, product) <span class=\"comment\">-- ⑥</span></span><br><span class=\"line\"><span class=\"keyword\">until</span>(<span class=\"keyword\">not</span> <span class=\"built_in\">status</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Main&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在 ①、②两处创建协程，③处开始执行，<code>producer</code> 在 ④ 处 <code>yield(0)</code>，意味着 ③ 的返回值 <code>product</code> 就是 <code>0</code>，我们把 <code>0</code> 作为参数又传给 <code>consumer</code>，第一次 <code>resume</code> 参数 <code>0</code> 会作为 <code>consumer</code> 的参数 <code>value</code> 传入，因此会打印出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">send 0</span><br><span class=\"line\">receive 0</span><br></pre></td></tr></table></figure>\n\n<p>接下来 <code>consumer</code> 通过 ⑤ 处的 <code>yield</code> 挂起，它的参数会作为 ⑥ 处的返回值，不过我们没有传任何参数。这时控制权又回到主流程，<code>status</code> 的值在对应的协程结束后会返回 <code>false</code>，这时候 <code>producer</code> 尚未结束，因此是 <code>true</code>，于是循环继续执行，后续流程类似，输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">send 1</span><br><span class=\"line\">receive 1</span><br><span class=\"line\">send 2</span><br><span class=\"line\">receive 2</span><br><span class=\"line\">send 3</span><br><span class=\"line\">receive 3</span><br><span class=\"line\">End Producer</span><br><span class=\"line\">End Consumer</span><br><span class=\"line\">End Main</span><br></pre></td></tr></table></figure>\n\n<p>通过这个例子，希望大家能够对协程有一个更加具体的认识，我们看到对于协程来讲，它包括：</p>\n<ul>\n<li>协程的执行体，主要是指启动协程时对应的函数</li>\n<li>协程的控制实例，我们可以通过协程创建时返回的实例控制协程的调用流转</li>\n<li>协程的状态，在调用流程转移前后，协程的状态会发生相应的变化</li>\n</ul>\n<blockquote>\n<p><strong>说明</strong> Lua 标准库的协程属于<strong>非对称有栈协程</strong>，不过第三方提供了基于标准库的<strong>对称协程</strong>的实现，有兴趣的话可以参考： <a href=\"https://luapower.com/coro\">coro</a>。有趣的是，这也恰恰是<strong>对称协程</strong>的实现可以基于<strong>非对称协程</strong>来实现的很好的例证。</p>\n</blockquote>\n<h3 id=\"2-3-Go-语言中的-go-routine\"><a href=\"#2-3-Go-语言中的-go-routine\" class=\"headerlink\" title=\"2.3 Go 语言中的 go routine\"></a>2.3 Go 语言中的 go routine</h3><p>go routine 的调度没有 Lua 那么明显，没有类似 <code>yield</code> 和 <code>resume</code> 的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// .......... ①</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> readChannel &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = channel</span><br><span class=\"line\"><span class=\"keyword\">var</span> writeChannel <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span> = channel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reader</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// ........................ ②</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;wait for read&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> readChannel &#123; <span class=\"comment\">// ... ③</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;read&quot;</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;read end&quot;</span>)</span><br><span class=\"line\">&#125;()  <span class=\"comment\">// ............................... ④</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writer</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;write&quot;</span>, i)</span><br><span class=\"line\">        writeChannel &lt;- i <span class=\"comment\">// .......... ⑤</span></span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(writeChannel)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<p>我们先来简单介绍下 go routine 的启动方式。在任意函数调用前面加关键字 <code>go</code> 即可启动一个 go routine，并在该 go routine 中调用这个函数，例如 ② 处实际上是创建了一个匿名函数，并在后面 ④ 处立即调用了该函数。我们把这两个 go routine 依次称为 “reader” 和 “writer”。</p>\n<p>① 处创建了一个双向的 <code>channel</code>，可读可写，接着创建的 <code>readChannel</code> 声明为只读类型，<code>writeChannel</code> 声明为只写类型，这二者实际上是同一个 <code>channel</code>，并且由于这个 <code>channel</code> 没有缓冲区，因此写操作会一直挂起直到读操作执行，反过来也是如此。</p>\n<p>在 reader 中，③ 处的 <code>for</code> 循环会对 <code>readChannel</code> 进行读操作，如果此时还没有对饮的写操作，就会挂起，直到有数据写入；在 writer 中，⑤ 处表示向 <code>writeChannel</code> 中写入 <code>i</code>，同样，如果写入时尚未有对应的读操作，就会挂起，直到有数据读取。整段程序的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait for read</span><br><span class=\"line\">write 0</span><br><span class=\"line\">read 0</span><br><span class=\"line\">write 1</span><br><span class=\"line\">read 1</span><br><span class=\"line\">write 2</span><br><span class=\"line\">read 2</span><br><span class=\"line\">read end</span><br></pre></td></tr></table></figure>\n\n<p>如果我们有多个 go routine 对 <code>channel</code> 进行读写，或者有多个 <code>channel</code> 供多个 go routine 读写，那么这时的读写操作实际上就是在 go routine 之间平等的转移调度权，因此可以认为 go routine 是<strong>对称</strong>的协程实现。</p>\n<p>这个示例看上去对于 <code>channel</code> 的读写操作有点儿类似两个线程中的阻塞式 IO 操作，不过 go routine 相对操作系统的内核线程来说要轻量得都，切换的成本也很低，因此在读写过程中挂起的成本也远比我们熟悉的线程阻塞的调用切换成本。实际上这两个 go routine 在切换时，很大概率不会有线程的切换，为了让示例更加能说明问题，我们为输出添加了当前的线程 id，同时将每次向 <code>writeChannel</code> 写入数据之后的 <code>Sleep</code> 操作去掉：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;wait for read&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> readChannel &#123;</span><br><span class=\"line\">        fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;read&quot;</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;read end&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">        fmt.Println(windows.GetCurrentThreadId(), <span class=\"string\">&quot;write&quot;</span>, i)</span><br><span class=\"line\">        writeChannel &lt;- i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(writeChannel)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<p>修改后的运行结果可以看到程序在输出时所在的线程 id：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">181808 write 0</span><br><span class=\"line\">183984 wait for read</span><br><span class=\"line\">181808 read 0</span><br><span class=\"line\">181808 write 1</span><br><span class=\"line\">181808 write 2</span><br><span class=\"line\">181808 read 1</span><br><span class=\"line\">181808 read 2</span><br><span class=\"line\">181808 read end</span><br></pre></td></tr></table></figure>\n\n<p>两个 go routine 除了开始运行时占用了两个线程，后续都在一个线程中转移调度权（不同场景的实际运行结果可能有细微差异，这取决于 Go 运行时的调度器）。</p>\n<blockquote>\n<p><strong>获取线程 id</strong> 本例在 windows 上调试，通过 <a href=\"https://github.com/golang/sys\">sys</a> 库的 windows 包下提供的 <code>GetCurrentThreadId</code> 函数来获取线程 id。Linux 系统可以通过 <code>syscall.Gettid</code> 来获取。</p>\n</blockquote>\n<blockquote>\n<p><strong>说明</strong> 我们虽然一直在用 go routine 做例子，并把它称作为<strong>对称有栈协程</strong>的一种实现，但考虑到 Go 运行时本身做了足够多超出其他语言的能力，例如栈优化，调度优化等，特别是的调度器还支持特定场景下的抢占式调度，某种意义上已经超越了协程概念的讨论范围，因此也有很多人认为 go routine 不能简单的认为就是协程。</p>\n</blockquote>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本文整体上对协程的分类做了较为详细的探讨。不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何通过相互出让运行调度权来完成执行，基于这一对基本的控制转移操作进而衍生出各种异步模型，并发模型例如 <code>async</code>/<code>await</code>，Channel 等。</p>\n<p>相比之下，有朋友抱怨 Kotlin 的协程没有其他语言的 <code>async</code>/<code>await</code> 那么容易上手，也没有 go routine 那么容易使用，原因也很简单，Kotlin 的协程用一个最基本的 <code>suspend</code> 关键字来支持了最基本的挂起恢复逻辑，进而在上层封装，衍生出了以上提到的几乎所有的模型，让我们在 Kotlin 当中可以有机会使用 <code>async</code>/<code>await</code>、Channel，以及最新出的 Flow API，将来还会有更多（也许包括在 issue 中被提到想要重做的 Actor），它想做的事儿太多了，也确实在一步一步地做到。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#105;&#x6d;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;\">&#x6b;&#x66;&#64;&#105;&#x6d;&#111;&#x6f;&#x63;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(10) - Select 篇","keywords":"Kotlin 协程 Select 多路复用","date":"2020-02-02T16:00:00.000Z","description":null,"_content":"\n> Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 \n\n\n\n<!-- more -->\n\n\n\n\n我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：\n\n```kotlin\nfun CoroutineScope.getUserFromApi(login: String) = async(Dispatchers.IO){\n    gitHubServiceApi.getUserSuspend(login)\n}\n\nfun CoroutineScope.getUserFromLocal(login:String) = async(Dispatchers.IO){\n    File(localDir, login).takeIf { it.exists() }?.readText()?.let { gson.fromJson(it, User::class.java) }\n}\n```\n\n不管先调用哪个 API 返回的 `Deferred` 的 `await`，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 `await`，这样反而将问题复杂化了。\n\n接下来我们用 `select` 来解决这个问题：\n\n```kotlin\nGlobalScope.launch {\n    val localDeferred = getUserFromLocal(login)\n    val remoteDeferred = getUserFromApi(login)\n\n    val userResponse = select<Response<User?>> {\n        localDeferred.onAwait { Response(it, true) }\n        remoteDeferred.onAwait { Response(it, false) }\n    }\n    ...\n}.join()\n```\n\n大家可以看到，我们没有直接调用 `await`，而是调用了 `onAwait` 在 `select` 当中注册了个回调，不管哪个先回调，`select` 立即返回对应回调中的结果。假设 `localDeferred.onAwait` 先返回，那么 `userResponse` 的值就是 `Response(it, true)`，当然由于我们的本地缓存可能不存在，因此 `select` 的结果类型是 `Response<User?>`。\n\n对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：\n\n```kotlin\nGlobalScope.launch {\n    ...\n    userResponse.value?.let { log(it) }\n    userResponse.isLocal.takeIf { it }?.let {\n        val userFromApi = remoteDeferred.await()\n        cacheUser(login, userFromApi)\n        log(userFromApi)\n    }\n}.join()\n```\n\n## 复用多个 Channel\n\n对于多个 `Channel` 的情况，也比较类似：\n\n```kotlin\nval channels = List(10) { Channel<Int>() }\n\nselect<Int?> {\n    channels.forEach { channel ->\n        channel.onReceive { it }\n        // OR\n        channel.onReceiveOrNull { it }\n    }\n}\n```\n\n对于 `onReceive`，如果 `Channel` 被关闭，`select` 会直接抛出异常；而对于 `onReceiveOrNull` 如果遇到 `Channel` 被关闭的情况，`it` 的值就是 `null`。\n\n## SelectClause\n\n我们怎么知道哪些事件可以被 `select` 呢？其实所有能够被 `select` 的事件都是 `SelectClauseN` 类型，包括：\n\n* `SelectClause0`：对应事件没有返回值，例如 `join` 没有返回值，对应的 `onJoin` 就是这个类型，使用时 `onJoin` 的参数是一个无参函数：\n\n    ```kotlin\n    select<Unit> {\n        job.onJoin { log(\"Join resumed!\") }\n    }\n    ```\n* `SelectClause1`：对应事件有返回值，前面的 `onAwait` 和 `onReceive` 都是此类情况。\n* `SelectClause2`：对应事件有返回值，此外还需要额外的一个参数，例如 `Channel.onSend` 有两个参数，第一个就是一个 `Channel` 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：\n\n    ```kotlin\n    List(100) { element ->\n        select<Unit> {\n            channels.forEach { channel ->\n                channel.onSend(element) { sentChannel -> log(\"sent on $sentChannel\") }\n            }\n        }\n    }\n    ```\n    在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，`onSend` 的第二个参数的参数是数据成功发送到的 `Channel` 对象。\n\n因此如果大家想要确认挂起函数是否支持 `select`，只需要查看其是否存在对应的 `SelectClauseN` 即可。\n\n## 小结\n\n在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。\n\n而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-select.md","raw":"---\ntitle:  破解 Kotlin 协程(10) - Select 篇  \nkeywords: Kotlin 协程 Select 多路复用 \ndate: 2020/02/03\ndescription: \ntags: \n    - kotlin\n    - coroutines\n    - select \n---\n\n> Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 \n\n\n\n<!-- more -->\n\n\n\n\n我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：\n\n```kotlin\nfun CoroutineScope.getUserFromApi(login: String) = async(Dispatchers.IO){\n    gitHubServiceApi.getUserSuspend(login)\n}\n\nfun CoroutineScope.getUserFromLocal(login:String) = async(Dispatchers.IO){\n    File(localDir, login).takeIf { it.exists() }?.readText()?.let { gson.fromJson(it, User::class.java) }\n}\n```\n\n不管先调用哪个 API 返回的 `Deferred` 的 `await`，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 `await`，这样反而将问题复杂化了。\n\n接下来我们用 `select` 来解决这个问题：\n\n```kotlin\nGlobalScope.launch {\n    val localDeferred = getUserFromLocal(login)\n    val remoteDeferred = getUserFromApi(login)\n\n    val userResponse = select<Response<User?>> {\n        localDeferred.onAwait { Response(it, true) }\n        remoteDeferred.onAwait { Response(it, false) }\n    }\n    ...\n}.join()\n```\n\n大家可以看到，我们没有直接调用 `await`，而是调用了 `onAwait` 在 `select` 当中注册了个回调，不管哪个先回调，`select` 立即返回对应回调中的结果。假设 `localDeferred.onAwait` 先返回，那么 `userResponse` 的值就是 `Response(it, true)`，当然由于我们的本地缓存可能不存在，因此 `select` 的结果类型是 `Response<User?>`。\n\n对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：\n\n```kotlin\nGlobalScope.launch {\n    ...\n    userResponse.value?.let { log(it) }\n    userResponse.isLocal.takeIf { it }?.let {\n        val userFromApi = remoteDeferred.await()\n        cacheUser(login, userFromApi)\n        log(userFromApi)\n    }\n}.join()\n```\n\n## 复用多个 Channel\n\n对于多个 `Channel` 的情况，也比较类似：\n\n```kotlin\nval channels = List(10) { Channel<Int>() }\n\nselect<Int?> {\n    channels.forEach { channel ->\n        channel.onReceive { it }\n        // OR\n        channel.onReceiveOrNull { it }\n    }\n}\n```\n\n对于 `onReceive`，如果 `Channel` 被关闭，`select` 会直接抛出异常；而对于 `onReceiveOrNull` 如果遇到 `Channel` 被关闭的情况，`it` 的值就是 `null`。\n\n## SelectClause\n\n我们怎么知道哪些事件可以被 `select` 呢？其实所有能够被 `select` 的事件都是 `SelectClauseN` 类型，包括：\n\n* `SelectClause0`：对应事件没有返回值，例如 `join` 没有返回值，对应的 `onJoin` 就是这个类型，使用时 `onJoin` 的参数是一个无参函数：\n\n    ```kotlin\n    select<Unit> {\n        job.onJoin { log(\"Join resumed!\") }\n    }\n    ```\n* `SelectClause1`：对应事件有返回值，前面的 `onAwait` 和 `onReceive` 都是此类情况。\n* `SelectClause2`：对应事件有返回值，此外还需要额外的一个参数，例如 `Channel.onSend` 有两个参数，第一个就是一个 `Channel` 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：\n\n    ```kotlin\n    List(100) { element ->\n        select<Unit> {\n            channels.forEach { channel ->\n                channel.onSend(element) { sentChannel -> log(\"sent on $sentChannel\") }\n            }\n        }\n    }\n    ```\n    在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，`onSend` 的第二个参数的参数是数据成功发送到的 `Channel` 对象。\n\n因此如果大家想要确认挂起函数是否支持 `select`，只需要查看其是否存在对应的 `SelectClauseN` 即可。\n\n## 小结\n\n在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。\n\n而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-select","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0036000wlduza9ro113g","content":"<blockquote>\n<p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">getUserFromApi</span><span class=\"params\">(login: <span class=\"type\">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class=\"line\">    gitHubServiceApi.getUserSuspend(login)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">getUserFromLocal</span><span class=\"params\">(login:<span class=\"type\">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class=\"line\">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class=\"keyword\">class</span>.java) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p>\n<p>接下来我们用 <code>select</code> 来解决这个问题：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> localDeferred = getUserFromLocal(login)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class=\"line\">        localDeferred.onAwait &#123; Response(it, <span class=\"literal\">true</span>) &#125;</span><br><span class=\"line\">        remoteDeferred.onAwait &#123; Response(it, <span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p>\n<p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class=\"line\">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> userFromApi = remoteDeferred.await()</span><br><span class=\"line\">        cacheUser(login, userFromApi)</span><br><span class=\"line\">        log(userFromApi)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"复用多个-Channel\"><a href=\"#复用多个-Channel\" class=\"headerlink\" title=\"复用多个 Channel\"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channels = List(<span class=\"number\">10</span>) &#123; Channel&lt;<span class=\"built_in\">Int</span>&gt;() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">select&lt;<span class=\"built_in\">Int</span>?&gt; &#123;</span><br><span class=\"line\">    channels.forEach &#123; channel -&gt;</span><br><span class=\"line\">        channel.onReceive &#123; it &#125;</span><br><span class=\"line\">        <span class=\"comment\">// OR</span></span><br><span class=\"line\">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p>\n<h2 id=\"SelectClause\"><a href=\"#SelectClause\" class=\"headerlink\" title=\"SelectClause\"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p>\n<ul>\n<li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    job.onJoin &#123; log(<span class=\"string\">&quot;Join resumed!&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p>\n</li>\n<li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List(<span class=\"number\">100</span>) &#123; element -&gt;</span><br><span class=\"line\">    select&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">        channels.forEach &#123; channel -&gt;</span><br><span class=\"line\">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class=\"string\">&quot;sent on <span class=\"variable\">$sentChannel</span>&quot;</span>) &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p>\n</li>\n</ul>\n<p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p>\n<p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 </p>\n</blockquote>","more":"<p>我们前面已经接触了很多挂起函数，那么如果我有这样一个场景，两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">getUserFromApi</span><span class=\"params\">(login: <span class=\"type\">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class=\"line\">    gitHubServiceApi.getUserSuspend(login)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">getUserFromLocal</span><span class=\"params\">(login:<span class=\"type\">String</span>)</span></span> = async(Dispatchers.IO)&#123;</span><br><span class=\"line\">    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class=\"keyword\">class</span>.java) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管先调用哪个 API 返回的 <code>Deferred</code> 的 <code>await</code>，都会被挂起，如果想要实现这一需求就要启动两个协程来调用 <code>await</code>，这样反而将问题复杂化了。</p>\n<p>接下来我们用 <code>select</code> 来解决这个问题：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> localDeferred = getUserFromLocal(login)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> remoteDeferred = getUserFromApi(login)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;</span><br><span class=\"line\">        localDeferred.onAwait &#123; Response(it, <span class=\"literal\">true</span>) &#125;</span><br><span class=\"line\">        remoteDeferred.onAwait &#123; Response(it, <span class=\"literal\">false</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<p>大家可以看到，我们没有直接调用 <code>await</code>，而是调用了 <code>onAwait</code> 在 <code>select</code> 当中注册了个回调，不管哪个先回调，<code>select</code> 立即返回对应回调中的结果。假设 <code>localDeferred.onAwait</code> 先返回，那么 <code>userResponse</code> 的值就是 <code>Response(it, true)</code>，当然由于我们的本地缓存可能不存在，因此 <code>select</code> 的结果类型是 <code>Response&lt;User?&gt;</code>。</p>\n<p>对于这个案例本身，如果先返回的是本地缓存，那么我们还需要获取网络结果来展示最新结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    userResponse.value?.let &#123; log(it) &#125;</span><br><span class=\"line\">    userResponse.isLocal.takeIf &#123; it &#125;?.let &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> userFromApi = remoteDeferred.await()</span><br><span class=\"line\">        cacheUser(login, userFromApi)</span><br><span class=\"line\">        log(userFromApi)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.join()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"复用多个-Channel\"><a href=\"#复用多个-Channel\" class=\"headerlink\" title=\"复用多个 Channel\"></a>复用多个 Channel</h2><p>对于多个 <code>Channel</code> 的情况，也比较类似：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> channels = List(<span class=\"number\">10</span>) &#123; Channel&lt;<span class=\"built_in\">Int</span>&gt;() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">select&lt;<span class=\"built_in\">Int</span>?&gt; &#123;</span><br><span class=\"line\">    channels.forEach &#123; channel -&gt;</span><br><span class=\"line\">        channel.onReceive &#123; it &#125;</span><br><span class=\"line\">        <span class=\"comment\">// OR</span></span><br><span class=\"line\">        channel.onReceiveOrNull &#123; it &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于 <code>onReceive</code>，如果 <code>Channel</code> 被关闭，<code>select</code> 会直接抛出异常；而对于 <code>onReceiveOrNull</code> 如果遇到 <code>Channel</code> 被关闭的情况，<code>it</code> 的值就是 <code>null</code>。</p>\n<h2 id=\"SelectClause\"><a href=\"#SelectClause\" class=\"headerlink\" title=\"SelectClause\"></a>SelectClause</h2><p>我们怎么知道哪些事件可以被 <code>select</code> 呢？其实所有能够被 <code>select</code> 的事件都是 <code>SelectClauseN</code> 类型，包括：</p>\n<ul>\n<li><p><code>SelectClause0</code>：对应事件没有返回值，例如 <code>join</code> 没有返回值，对应的 <code>onJoin</code> 就是这个类型，使用时 <code>onJoin</code> 的参数是一个无参函数：</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    job.onJoin &#123; log(<span class=\"string\">&quot;Join resumed!&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SelectClause1</code>：对应事件有返回值，前面的 <code>onAwait</code> 和 <code>onReceive</code> 都是此类情况。</p>\n</li>\n<li><p><code>SelectClause2</code>：对应事件有返回值，此外还需要额外的一个参数，例如 <code>Channel.onSend</code> 有两个参数，第一个就是一个 <code>Channel</code> 数据类型的值，表示即将发送的值，第二个是发送成功时的回调：</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List(<span class=\"number\">100</span>) &#123; element -&gt;</span><br><span class=\"line\">    select&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">        channels.forEach &#123; channel -&gt;</span><br><span class=\"line\">            channel.onSend(element) &#123; sentChannel -&gt; log(<span class=\"string\">&quot;sent on <span class=\"variable\">$sentChannel</span>&quot;</span>) &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  在消费者的消费效率较低时，数据能发给哪个就发给哪个进行处理，<code>onSend</code> 的第二个参数的参数是数据成功发送到的 <code>Channel</code> 对象。</p>\n</li>\n</ul>\n<p>因此如果大家想要确认挂起函数是否支持 <code>select</code>，只需要查看其是否存在对应的 <code>SelectClauseN</code> 即可。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在协程当中，Select 的语义与 Java NIO 或者 Unix 的 IO 多路复用类似，它的存在使得我们可以轻松实现 1 拖 N，实现哪个先来就处理哪个。尽管 Select 和 Channel 比起标准库的协程 API 已经更接近业务开发了，不过个人认为它们仍属于相对底层的 API 封装，在实践当中多数情况下也可以使用 Flow API 来解决。</p>\n<p>而这个 Flow API，完全就是响应式编程的协程版 API，我们简直可以照着 RxJava 来学习它，所以我们下一篇再见吧~~~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"破解 Kotlin 协程(10) - Select 篇","path":"2020/02/03/coroutine-select/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>Select 并不是什么新鲜概念，我们在 IO 多路复用的时候就见过它，在 Java NIO 里面也见过它。接下来给各位介绍的是 Kotlin 协程的 Select。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-02-02T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-02-02T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","coroutines","select"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"破解 Kotlin 协程(7) - 序列生成器篇","keywords":"Kotlin 协程 序列 Sequence","date":"2019-05-25T16:00:00.000Z","description":null,"_content":"\n> 说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。 \n\n<!-- more -->\n\n\n\n\n## 1. 认识 Sequence\n\n在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。\n\n下面我们给出一个斐波那契数列生成的例子：\n\n```kotlin\n val fibonacci = sequence {\n    yield(1L) // first Fibonacci number\n    var cur = 1L\n    var next = 1L\n    while (true) {\n        yield(next) // next Fibonacci number\n        val tmp = cur + next\n        cur = next\n        next = tmp\n    }\n}\n\nfibonacci.take(5).forEach(::log)\n```\n\n这个 `sequence` 实际上也是启动了一个协程，`yield` 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 `COROUTINE_SUSPENDED`，这样协程就不再继续执行，而是等待下一次 `resume` 或者 `resumeWithException` 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 `next()` 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 `yield` 调用。\n\n程序运行输出的结果如下：\n\n```\n10:44:34:071 [main] 1\n10:44:34:071 [main] 1\n10:44:34:071 [main] 2\n10:44:34:071 [main] 3\n10:44:34:071 [main] 5\n```\n\n除了使用 `yield(T)` 生成序列的下一个元素以外，我们还可以用 `yieldAll()` 来生成多个元素：\n\n```kotlin\nval seq = sequence {\n    log(\"yield 1,2,3\")\n    yieldAll(listOf(1, 2, 3))\n    log(\"yield 4,5,6\")\n    yieldAll(listOf(4, 5, 6))\n    log(\"yield 7,8,9\")\n    yieldAll(listOf(7, 8, 9))\n}\n\nseq.take(5).forEach(::log)\n```\n\n从运行结果我们可以看到，在读取 4 的时候才会去执行到 `yieldAll(listOf(4, 5, 6))`，而由于 7 以后都没有被访问到，`yieldAll(listOf(7, 8, 9))` 并不会被执行，这就是所谓的“懒”。\n\n```\n10:44:34:029 [main] yield 1,2,3\n10:44:34:060 [main] 1\n10:44:34:060 [main] 2\n10:44:34:060 [main] 3\n10:44:34:061 [main] yield 4,5,6\n10:44:34:061 [main] 4\n10:44:34:066 [main] 5\n```\n\n## 2. 深入序列生成器\n\n前面我们已经不止一次提到 `COROUTINE_SUSPENDED` 了，我们也很容易就知道 `yield` 和 `yieldAll` 都是 suspend 函数，既然能做到”懒“，那么必然在 `yield` 和 `yieldAll` 处是挂起的，因此它们的返回值一定是  `COROUTINE_SUSPENDED`，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：\n\n```kotlin\noverride suspend fun yield(value: T) {\n    nextValue = value\n    state = State_Ready\n    return suspendCoroutineUninterceptedOrReturn { c ->\n        nextStep = c\n        COROUTINE_SUSPENDED\n    }\n}\n```\n\n这是 `yield` 的实现，我们看到了老朋友 `suspendCoroutineUninterceptedOrReturn`，还看到了 `COROUTINE_SUSPENDED`，那么挂起的问题就很好理解了。而 `yieldAll` 是如出一辙：\n\n```kotlin\noverride suspend fun yieldAll(iterator: Iterator<T>) {\n    if (!iterator.hasNext()) return\n    nextIterator = iterator\n    state = State_ManyReady\n    return suspendCoroutineUninterceptedOrReturn { c ->\n        nextStep = c\n        COROUTINE_SUSPENDED\n    }\n}\n```\n\n唯一的不同在于 `state` 的值，一个流转到了 `State_Ready`，一个是 `State_ManyReady`，也倒是很好理解嘛。\n\n那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 `resume` ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 `next()` 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 `yield` 就是它的方法，我们来看看 `next` 方法的实现：\n\n```kotlin\noverride fun next(): T {\n    when (state) {\n        State_NotReady, State_ManyNotReady -> return nextNotReady() // ①\n        State_ManyReady -> { // ②\n            state = State_ManyNotReady\n            return nextIterator!!.next()\n        }\n        State_Ready -> { // ③\n            state = State_NotReady\n            val result = nextValue as T\n            nextValue = null\n            return result\n        }\n        else -> throw exceptionalState()\n    }\n}\n```\n\n我们来依次看下这三个条件：\n\n* ① 是下一个元素还没有准备好的情况，调用 `nextNotReady` 会首先调用 `hasNext` 检查是否有下一个元素，检查的过程其实就是调用 `Continuation.resume`，如果有元素，就会再次调用 `next`，否则就抛异常\n* ② 表示我们调用了 `yieldAll`，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代\n* ③ 表示我们调用了一次 `yield`，而这个元素的值就存在 `nextValue` 当中\n\n`hasNext` 的实现也不是很复杂：\n\n```kotlin\noverride fun hasNext(): Boolean {\n    while (true) {\n        when (state) {\n            State_NotReady -> {} // ①\n            State_ManyNotReady -> // ②\n                if (nextIterator!!.hasNext()) {\n                    state = State_ManyReady\n                    return true\n                } else {\n                    nextIterator = null\n                }\n            State_Done -> return false // ③\n            State_Ready, State_ManyReady -> return true // ④\n            else -> throw exceptionalState()\n        }\n\n        state = State_Failed\n        val step = nextStep!!\n        nextStep = null\n        step.resume(Unit)\n    }\n}\n```\n\n我们在通过 `next` 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 `State_NotReady`，下一次取元素的时候就会在 `next` 中触发到 `hasNext` 的调用，① 处什么都没有干，因此会直接落到后面的 `step.resume()`，这样就会继续执行我们序列生成器的代码，直到遇到 `yield` 或者 `yieldAll`。\n\n## 3. 小结\n\n序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。\n\n协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-sequence.md","raw":"---\ntitle:  破解 Kotlin 协程(7) - 序列生成器篇  \nkeywords: Kotlin 协程 序列 Sequence \ndate: 2019/05/26\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。 \n\n<!-- more -->\n\n\n\n\n## 1. 认识 Sequence\n\n在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。\n\n下面我们给出一个斐波那契数列生成的例子：\n\n```kotlin\n val fibonacci = sequence {\n    yield(1L) // first Fibonacci number\n    var cur = 1L\n    var next = 1L\n    while (true) {\n        yield(next) // next Fibonacci number\n        val tmp = cur + next\n        cur = next\n        next = tmp\n    }\n}\n\nfibonacci.take(5).forEach(::log)\n```\n\n这个 `sequence` 实际上也是启动了一个协程，`yield` 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 `COROUTINE_SUSPENDED`，这样协程就不再继续执行，而是等待下一次 `resume` 或者 `resumeWithException` 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 `next()` 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 `yield` 调用。\n\n程序运行输出的结果如下：\n\n```\n10:44:34:071 [main] 1\n10:44:34:071 [main] 1\n10:44:34:071 [main] 2\n10:44:34:071 [main] 3\n10:44:34:071 [main] 5\n```\n\n除了使用 `yield(T)` 生成序列的下一个元素以外，我们还可以用 `yieldAll()` 来生成多个元素：\n\n```kotlin\nval seq = sequence {\n    log(\"yield 1,2,3\")\n    yieldAll(listOf(1, 2, 3))\n    log(\"yield 4,5,6\")\n    yieldAll(listOf(4, 5, 6))\n    log(\"yield 7,8,9\")\n    yieldAll(listOf(7, 8, 9))\n}\n\nseq.take(5).forEach(::log)\n```\n\n从运行结果我们可以看到，在读取 4 的时候才会去执行到 `yieldAll(listOf(4, 5, 6))`，而由于 7 以后都没有被访问到，`yieldAll(listOf(7, 8, 9))` 并不会被执行，这就是所谓的“懒”。\n\n```\n10:44:34:029 [main] yield 1,2,3\n10:44:34:060 [main] 1\n10:44:34:060 [main] 2\n10:44:34:060 [main] 3\n10:44:34:061 [main] yield 4,5,6\n10:44:34:061 [main] 4\n10:44:34:066 [main] 5\n```\n\n## 2. 深入序列生成器\n\n前面我们已经不止一次提到 `COROUTINE_SUSPENDED` 了，我们也很容易就知道 `yield` 和 `yieldAll` 都是 suspend 函数，既然能做到”懒“，那么必然在 `yield` 和 `yieldAll` 处是挂起的，因此它们的返回值一定是  `COROUTINE_SUSPENDED`，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：\n\n```kotlin\noverride suspend fun yield(value: T) {\n    nextValue = value\n    state = State_Ready\n    return suspendCoroutineUninterceptedOrReturn { c ->\n        nextStep = c\n        COROUTINE_SUSPENDED\n    }\n}\n```\n\n这是 `yield` 的实现，我们看到了老朋友 `suspendCoroutineUninterceptedOrReturn`，还看到了 `COROUTINE_SUSPENDED`，那么挂起的问题就很好理解了。而 `yieldAll` 是如出一辙：\n\n```kotlin\noverride suspend fun yieldAll(iterator: Iterator<T>) {\n    if (!iterator.hasNext()) return\n    nextIterator = iterator\n    state = State_ManyReady\n    return suspendCoroutineUninterceptedOrReturn { c ->\n        nextStep = c\n        COROUTINE_SUSPENDED\n    }\n}\n```\n\n唯一的不同在于 `state` 的值，一个流转到了 `State_Ready`，一个是 `State_ManyReady`，也倒是很好理解嘛。\n\n那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 `resume` ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 `next()` 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 `yield` 就是它的方法，我们来看看 `next` 方法的实现：\n\n```kotlin\noverride fun next(): T {\n    when (state) {\n        State_NotReady, State_ManyNotReady -> return nextNotReady() // ①\n        State_ManyReady -> { // ②\n            state = State_ManyNotReady\n            return nextIterator!!.next()\n        }\n        State_Ready -> { // ③\n            state = State_NotReady\n            val result = nextValue as T\n            nextValue = null\n            return result\n        }\n        else -> throw exceptionalState()\n    }\n}\n```\n\n我们来依次看下这三个条件：\n\n* ① 是下一个元素还没有准备好的情况，调用 `nextNotReady` 会首先调用 `hasNext` 检查是否有下一个元素，检查的过程其实就是调用 `Continuation.resume`，如果有元素，就会再次调用 `next`，否则就抛异常\n* ② 表示我们调用了 `yieldAll`，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代\n* ③ 表示我们调用了一次 `yield`，而这个元素的值就存在 `nextValue` 当中\n\n`hasNext` 的实现也不是很复杂：\n\n```kotlin\noverride fun hasNext(): Boolean {\n    while (true) {\n        when (state) {\n            State_NotReady -> {} // ①\n            State_ManyNotReady -> // ②\n                if (nextIterator!!.hasNext()) {\n                    state = State_ManyReady\n                    return true\n                } else {\n                    nextIterator = null\n                }\n            State_Done -> return false // ③\n            State_Ready, State_ManyReady -> return true // ④\n            else -> throw exceptionalState()\n        }\n\n        state = State_Failed\n        val step = nextStep!!\n        nextStep = null\n        step.resume(Unit)\n    }\n}\n```\n\n我们在通过 `next` 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 `State_NotReady`，下一次取元素的时候就会在 `next` 中触发到 `hasNext` 的调用，① 处什么都没有干，因此会直接落到后面的 `step.resume()`，这样就会继续执行我们序列生成器的代码，直到遇到 `yield` 或者 `yieldAll`。\n\n## 3. 小结\n\n序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。\n\n协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-sequence","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0037000xlduzfht0b73q","content":"<blockquote>\n<p>说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-认识-Sequence\"><a href=\"#1-认识-Sequence\" class=\"headerlink\" title=\"1. 认识 Sequence\"></a>1. 认识 Sequence</h2><p>在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。</p>\n<p>下面我们给出一个斐波那契数列生成的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">val</span> fibonacci = sequence &#123;</span><br><span class=\"line\">    yield(<span class=\"number\">1L</span>) <span class=\"comment\">// first Fibonacci number</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = <span class=\"number\">1L</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> next = <span class=\"number\">1L</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        yield(next) <span class=\"comment\">// next Fibonacci number</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> tmp = cur + next</span><br><span class=\"line\">        cur = next</span><br><span class=\"line\">        next = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fibonacci.take(<span class=\"number\">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>sequence</code> 实际上也是启动了一个协程，<code>yield</code> 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 <code>COROUTINE_SUSPENDED</code>，这样协程就不再继续执行，而是等待下一次 <code>resume</code> 或者 <code>resumeWithException</code> 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 <code>next()</code> 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 <code>yield</code> 调用。</p>\n<p>程序运行输出的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:44:34:071 [main] 1</span><br><span class=\"line\">10:44:34:071 [main] 1</span><br><span class=\"line\">10:44:34:071 [main] 2</span><br><span class=\"line\">10:44:34:071 [main] 3</span><br><span class=\"line\">10:44:34:071 [main] 5</span><br></pre></td></tr></table></figure>\n\n<p>除了使用 <code>yield(T)</code> 生成序列的下一个元素以外，我们还可以用 <code>yieldAll()</code> 来生成多个元素：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> seq = sequence &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 1,2,3&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 4,5,6&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 7,8,9&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">seq.take(<span class=\"number\">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>\n\n<p>从运行结果我们可以看到，在读取 4 的时候才会去执行到 <code>yieldAll(listOf(4, 5, 6))</code>，而由于 7 以后都没有被访问到，<code>yieldAll(listOf(7, 8, 9))</code> 并不会被执行，这就是所谓的“懒”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:44:34:029 [main] yield 1,2,3</span><br><span class=\"line\">10:44:34:060 [main] 1</span><br><span class=\"line\">10:44:34:060 [main] 2</span><br><span class=\"line\">10:44:34:060 [main] 3</span><br><span class=\"line\">10:44:34:061 [main] yield 4,5,6</span><br><span class=\"line\">10:44:34:061 [main] 4</span><br><span class=\"line\">10:44:34:066 [main] 5</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-深入序列生成器\"><a href=\"#2-深入序列生成器\" class=\"headerlink\" title=\"2. 深入序列生成器\"></a>2. 深入序列生成器</h2><p>前面我们已经不止一次提到 <code>COROUTINE_SUSPENDED</code> 了，我们也很容易就知道 <code>yield</code> 和 <code>yieldAll</code> 都是 suspend 函数，既然能做到”懒“，那么必然在 <code>yield</code> 和 <code>yieldAll</code> 处是挂起的，因此它们的返回值一定是  <code>COROUTINE_SUSPENDED</code>，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">yield</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">    nextValue = value</span><br><span class=\"line\">    state = State_Ready</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class=\"line\">        nextStep = c</span><br><span class=\"line\">        COROUTINE_SUSPENDED</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是 <code>yield</code> 的实现，我们看到了老朋友 <code>suspendCoroutineUninterceptedOrReturn</code>，还看到了 <code>COROUTINE_SUSPENDED</code>，那么挂起的问题就很好理解了。而 <code>yieldAll</code> 是如出一辙：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">yieldAll</span><span class=\"params\">(iterator: <span class=\"type\">Iterator</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!iterator.hasNext()) <span class=\"keyword\">return</span></span><br><span class=\"line\">    nextIterator = iterator</span><br><span class=\"line\">    state = State_ManyReady</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class=\"line\">        nextStep = c</span><br><span class=\"line\">        COROUTINE_SUSPENDED</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>唯一的不同在于 <code>state</code> 的值，一个流转到了 <code>State_Ready</code>，一个是 <code>State_ManyReady</code>，也倒是很好理解嘛。</p>\n<p>那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 <code>resume</code> ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 <code>next()</code> 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 <code>yield</code> 就是它的方法，我们来看看 <code>next</code> 方法的实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (state) &#123;</span><br><span class=\"line\">        State_NotReady, State_ManyNotReady -&gt; <span class=\"keyword\">return</span> nextNotReady() <span class=\"comment\">// ①</span></span><br><span class=\"line\">        State_ManyReady -&gt; &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">            state = State_ManyNotReady</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nextIterator!!.next()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        State_Ready -&gt; &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">            state = State_NotReady</span><br><span class=\"line\">            <span class=\"keyword\">val</span> result = nextValue <span class=\"keyword\">as</span> T</span><br><span class=\"line\">            nextValue = <span class=\"literal\">null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> exceptionalState()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来依次看下这三个条件：</p>\n<ul>\n<li>① 是下一个元素还没有准备好的情况，调用 <code>nextNotReady</code> 会首先调用 <code>hasNext</code> 检查是否有下一个元素，检查的过程其实就是调用 <code>Continuation.resume</code>，如果有元素，就会再次调用 <code>next</code>，否则就抛异常</li>\n<li>② 表示我们调用了 <code>yieldAll</code>，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代</li>\n<li>③ 表示我们调用了一次 <code>yield</code>，而这个元素的值就存在 <code>nextValue</code> 当中</li>\n</ul>\n<p><code>hasNext</code> 的实现也不是很复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (state) &#123;</span><br><span class=\"line\">            State_NotReady -&gt; &#123;&#125; <span class=\"comment\">// ①</span></span><br><span class=\"line\">            State_ManyNotReady -&gt; <span class=\"comment\">// ②</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextIterator!!.hasNext()) &#123;</span><br><span class=\"line\">                    state = State_ManyReady</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    nextIterator = <span class=\"literal\">null</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            State_Done -&gt; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// ③</span></span><br><span class=\"line\">            State_Ready, State_ManyReady -&gt; <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">// ④</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> exceptionalState()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        state = State_Failed</span><br><span class=\"line\">        <span class=\"keyword\">val</span> step = nextStep!!</span><br><span class=\"line\">        nextStep = <span class=\"literal\">null</span></span><br><span class=\"line\">        step.resume(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在通过 <code>next</code> 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 <code>State_NotReady</code>，下一次取元素的时候就会在 <code>next</code> 中触发到 <code>hasNext</code> 的调用，① 处什么都没有干，因此会直接落到后面的 <code>step.resume()</code>，这样就会继续执行我们序列生成器的代码，直到遇到 <code>yield</code> 或者 <code>yieldAll</code>。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。</p>\n<p>协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#x6f;&#x6d;\">&#x6b;&#x66;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>说出来你可能不信，Kotlin 1.1 协程还在吃奶的时候，Sequence 就已经正式推出了，然而，Sequence 生成器的实现居然有协程的功劳。 </p>\n</blockquote>","more":"<h2 id=\"1-认识-Sequence\"><a href=\"#1-认识-Sequence\" class=\"headerlink\" title=\"1. 认识 Sequence\"></a>1. 认识 Sequence</h2><p>在 Kotlin 当中，Sequence 这个概念确切的说是“懒序列”，产生懒序列的方式可以有多种，下面我们介绍一种由基于协程实现的序列生成器。需要注意的是，这个功能内置于 Kotlin 标准库当中，不需要额外添加依赖。</p>\n<p>下面我们给出一个斐波那契数列生成的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">val</span> fibonacci = sequence &#123;</span><br><span class=\"line\">    yield(<span class=\"number\">1L</span>) <span class=\"comment\">// first Fibonacci number</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = <span class=\"number\">1L</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> next = <span class=\"number\">1L</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        yield(next) <span class=\"comment\">// next Fibonacci number</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> tmp = cur + next</span><br><span class=\"line\">        cur = next</span><br><span class=\"line\">        next = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fibonacci.take(<span class=\"number\">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>sequence</code> 实际上也是启动了一个协程，<code>yield</code> 则是一个挂起点，每次调用时先将参数保存起来作为生成的序列迭代器的下一个值，之后返回 <code>COROUTINE_SUSPENDED</code>，这样协程就不再继续执行，而是等待下一次 <code>resume</code> 或者 <code>resumeWithException</code> 的调用，而实际上，这下一次的调用就在生成的序列的迭代器的 <code>next()</code> 调用时执行。如此一来，外部在遍历序列时，每次需要读取新值时，协程内部就会执行到下一次 <code>yield</code> 调用。</p>\n<p>程序运行输出的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:44:34:071 [main] 1</span><br><span class=\"line\">10:44:34:071 [main] 1</span><br><span class=\"line\">10:44:34:071 [main] 2</span><br><span class=\"line\">10:44:34:071 [main] 3</span><br><span class=\"line\">10:44:34:071 [main] 5</span><br></pre></td></tr></table></figure>\n\n<p>除了使用 <code>yield(T)</code> 生成序列的下一个元素以外，我们还可以用 <code>yieldAll()</code> 来生成多个元素：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> seq = sequence &#123;</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 1,2,3&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 4,5,6&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">    log(<span class=\"string\">&quot;yield 7,8,9&quot;</span>)</span><br><span class=\"line\">    yieldAll(listOf(<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">seq.take(<span class=\"number\">5</span>).forEach(::log)</span><br></pre></td></tr></table></figure>\n\n<p>从运行结果我们可以看到，在读取 4 的时候才会去执行到 <code>yieldAll(listOf(4, 5, 6))</code>，而由于 7 以后都没有被访问到，<code>yieldAll(listOf(7, 8, 9))</code> 并不会被执行，这就是所谓的“懒”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:44:34:029 [main] yield 1,2,3</span><br><span class=\"line\">10:44:34:060 [main] 1</span><br><span class=\"line\">10:44:34:060 [main] 2</span><br><span class=\"line\">10:44:34:060 [main] 3</span><br><span class=\"line\">10:44:34:061 [main] yield 4,5,6</span><br><span class=\"line\">10:44:34:061 [main] 4</span><br><span class=\"line\">10:44:34:066 [main] 5</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-深入序列生成器\"><a href=\"#2-深入序列生成器\" class=\"headerlink\" title=\"2. 深入序列生成器\"></a>2. 深入序列生成器</h2><p>前面我们已经不止一次提到 <code>COROUTINE_SUSPENDED</code> 了，我们也很容易就知道 <code>yield</code> 和 <code>yieldAll</code> 都是 suspend 函数，既然能做到”懒“，那么必然在 <code>yield</code> 和 <code>yieldAll</code> 处是挂起的，因此它们的返回值一定是  <code>COROUTINE_SUSPENDED</code>，这一点我们在本文的开头就已经提到，下面我们来见识一下庐山真面目：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">yield</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">    nextValue = value</span><br><span class=\"line\">    state = State_Ready</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class=\"line\">        nextStep = c</span><br><span class=\"line\">        COROUTINE_SUSPENDED</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是 <code>yield</code> 的实现，我们看到了老朋友 <code>suspendCoroutineUninterceptedOrReturn</code>，还看到了 <code>COROUTINE_SUSPENDED</code>，那么挂起的问题就很好理解了。而 <code>yieldAll</code> 是如出一辙：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">yieldAll</span><span class=\"params\">(iterator: <span class=\"type\">Iterator</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!iterator.hasNext()) <span class=\"keyword\">return</span></span><br><span class=\"line\">    nextIterator = iterator</span><br><span class=\"line\">    state = State_ManyReady</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; c -&gt;</span><br><span class=\"line\">        nextStep = c</span><br><span class=\"line\">        COROUTINE_SUSPENDED</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>唯一的不同在于 <code>state</code> 的值，一个流转到了 <code>State_Ready</code>，一个是 <code>State_ManyReady</code>，也倒是很好理解嘛。</p>\n<p>那么现在就剩下一个问题了，既然有了挂起，那么什么时候执行 <code>resume</code> ？这个很容易想到，我们在迭代序列的时候呗，也就是序列迭代器的 <code>next()</code> 的时候，那么这事儿就好办了，找下序列的迭代器实现即可，这个类型我们也很容易找到，显然 <code>yield</code> 就是它的方法，我们来看看 <code>next</code> 方法的实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (state) &#123;</span><br><span class=\"line\">        State_NotReady, State_ManyNotReady -&gt; <span class=\"keyword\">return</span> nextNotReady() <span class=\"comment\">// ①</span></span><br><span class=\"line\">        State_ManyReady -&gt; &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">            state = State_ManyNotReady</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nextIterator!!.next()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        State_Ready -&gt; &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">            state = State_NotReady</span><br><span class=\"line\">            <span class=\"keyword\">val</span> result = nextValue <span class=\"keyword\">as</span> T</span><br><span class=\"line\">            nextValue = <span class=\"literal\">null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> exceptionalState()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来依次看下这三个条件：</p>\n<ul>\n<li>① 是下一个元素还没有准备好的情况，调用 <code>nextNotReady</code> 会首先调用 <code>hasNext</code> 检查是否有下一个元素，检查的过程其实就是调用 <code>Continuation.resume</code>，如果有元素，就会再次调用 <code>next</code>，否则就抛异常</li>\n<li>② 表示我们调用了 <code>yieldAll</code>，一下子传入了很多元素，目前还没有读取完，因此需要继续从传入的这个元素集合当中去迭代</li>\n<li>③ 表示我们调用了一次 <code>yield</code>，而这个元素的值就存在 <code>nextValue</code> 当中</li>\n</ul>\n<p><code>hasNext</code> 的实现也不是很复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (state) &#123;</span><br><span class=\"line\">            State_NotReady -&gt; &#123;&#125; <span class=\"comment\">// ①</span></span><br><span class=\"line\">            State_ManyNotReady -&gt; <span class=\"comment\">// ②</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextIterator!!.hasNext()) &#123;</span><br><span class=\"line\">                    state = State_ManyReady</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    nextIterator = <span class=\"literal\">null</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            State_Done -&gt; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// ③</span></span><br><span class=\"line\">            State_Ready, State_ManyReady -&gt; <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">// ④</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt; <span class=\"keyword\">throw</span> exceptionalState()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        state = State_Failed</span><br><span class=\"line\">        <span class=\"keyword\">val</span> step = nextStep!!</span><br><span class=\"line\">        nextStep = <span class=\"literal\">null</span></span><br><span class=\"line\">        step.resume(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在通过 <code>next</code> 读取完一个元素之后，如果已经传入的元素已经没有剩余，状态会转为 <code>State_NotReady</code>，下一次取元素的时候就会在 <code>next</code> 中触发到 <code>hasNext</code> 的调用，① 处什么都没有干，因此会直接落到后面的 <code>step.resume()</code>，这样就会继续执行我们序列生成器的代码，直到遇到 <code>yield</code> 或者 <code>yieldAll</code>。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>序列生成器很好的利用了协程的状态机特性，将序列生成的过程从形式上整合到了一起，让程序更加紧凑，表现力更强。本节讨论的序列，某种意义上更像是生产 - 消费者模型中的生产者，而迭代序列的一方则像是消费者，其实在 kotlinx.coroutines 库中提供了更为强大的能力来实现生产 - 消费者模式，我们将在后面的文章当中展示给大家看。</p>\n<p>协程的回调特性可以让我们在实践当中很好的替代传统回调的写法，同时它的状态机特性也可以让曾经的状态机实现获得新的写法，除了序列之外，也许还会有更多有趣的适用场景等待我们去发掘~</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#x6f;&#x6d;\">&#x6b;&#x66;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(6) - 协程挂起篇","keywords":"Kotlin 协程 协程挂起 任务挂起 suspend 非阻塞","date":"2019-05-06T16:00:00.000Z","description":null,"_content":"\n> 协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！） \n\n<!-- more -->\n\n\n\n\n\n## 1. 先看看 delay\n\n我们刚刚学线程的时候，最常见的模拟各种延时用的就是 `Thread.sleep` 了，而在协程里面，对应的就是 `delay`。`sleep` 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 `delay` 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 `delay` 也可以是让协程休眠的一种很好的手段。\n\n`delay` 的源码其实很简单：\n\n```kotlin\npublic suspend fun delay(timeMillis: Long) {\n    if (timeMillis <= 0) return // don't delay\n    return suspendCancellableCoroutine sc@ { cont: CancellableContinuation<Unit> ->\n        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n    }\n}\n```\n\n`cont.context.delay.scheduleResumeAfterDelay` 这个操作，你可以类比 JavaScript 的 `setTimeout`，Android 的 `handler.postDelay`，本质上就是设置了一个延时回调，时间一到就调用 `cont` 的 resume 系列方法让协程继续执行。\n\n剩下的最关键的就是 `suspendCancellableCoroutine` 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 `delay` 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 `join`、`await` 等等。\n\n\n## 2. 再来说说 suspendCancellableCoroutine\n\n既然大家对于 `suspendCancellableCoroutine` 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：\n\n```kotlin\nprivate suspend fun joinSuspend() = suspendCancellableCoroutine<Unit> { cont ->\n    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))\n}\n```\n\n`Job.join()` 这个方法会首先检查调用者 `Job` 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 `joinSuspend` 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 `suspendCancellableCoroutine` 内部究竟做了什么呢？\n\n```kotlin\npublic suspend inline fun <T> suspendCancellableCoroutine(\n    crossinline block: (CancellableContinuation<T>) -> Unit\n): T =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n        block(cancellable)\n        cancellable.getResult() // 这里的类型是 Any?\n    }\n```\n\n`suspendCoroutineUninterceptedOrReturn` 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 `Continuation` 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：`suspendCoroutineUninterceptedOrReturn` 的返回值类型是 `T`，而传入的 lambda 的返回值类型是 `Any?`， 也就是我们看到的 `cancellable.getResult()` 的类型是 `Any?`，这是为什么？\n\n我记得在协程系列文章的开篇，我就提到过 `suspend` 函数的签名，当时是以 `await` 为例的，这个方法大致相当于：\n\n```kotlin\nfun await(continuation: Continuation<User>): Any {\n    ...\n}\n```\n\n`suspend` 一方面为这个方法添加了一个 `Continuation` 的参数，另一方面，原先的返回值类型 `User` 成了 `Continuation` 的泛型实参，而真正的返回值类型竟然是 `Any`。当然，这里因为定义的逻辑返回值类型 `User` 是不可空的，因此真实的返回值类型也用了 `Any` 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 `Any?` 了，这正与前面提到的 `cancellable.getResult()` 返回的这个 `Any?` 相对应。\n\n> 如果大家去查 `await` 的源码，你同样会看到这个 `getResult()` 的调用。\n\n简单来说就是，对于 `suspend` 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 `join` 或者 `await` 或者其他 `suspend` 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 `cancellable.getResult()` 究竟返回什么了，且看：\n\n```kotlin\ninternal fun getResult(): Any? {\n    ...\n    if (trySuspend()) return COROUTINE_SUSPENDED // ① 触发挂起逻辑\n    ...\n    if (state is CompletedExceptionally)  // ② 异常立即抛出\n        throw recoverStackTrace(state.cause, this) \n    return getSuccessfulResult(state) // ③ 正常结果立即返回\n}\n```\n\n这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？\n\n```kotlin\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n```\n这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 `Any`。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。\n\n## 3. 深入挂起操作\n\n既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。\n\n```kotlin\nsuspend fun hello() = suspendCoroutineUninterceptedOrReturn<Int>{\n    continuation ->\n    log(1)\n    thread {\n        Thread.sleep(1000)\n        log(2)\n        continuation.resume(1024)\n    }\n    log(3)\n    COROUTINE_SUSPENDED\n}\n```\n\n我写了这么一个 `suspend` 函数，在 `suspendCoroutineUninterceptedOrReturn` 当中直接返回了这个传说中的白板 `COROUTINE_SUSPENDED`，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？\n\n```java\npublic class CallCoroutine {\n    public static void main(String... args) {\n        Object value = SuspendTestKt.hello(new Continuation<Integer>() {\n            @NotNull\n            @Override\n            public CoroutineContext getContext() {\n                return EmptyCoroutineContext.INSTANCE;\n            }\n\n            @Override\n            public void resumeWith(@NotNull Object o) { // ①\n                if(o instanceof Integer){\n                    handleResult(o);\n                } else {\n                    Throwable throwable = (Throwable) o;\n                    throwable.printStackTrace();\n                }\n            }\n        });\n\n        if(value == IntrinsicsKt.getCOROUTINE_SUSPENDED()){ // ②\n            LogKt.log(\"Suspended.\");\n        } else {\n            handleResult(value);\n        }\n    }\n\n    public static void handleResult(Object o){\n        LogKt.log(\"The result is \" + o);\n    }\n}\n```\n\n这段代码看上去比较奇怪，可能会让人困惑的有两处：\n\n① 处，我们在 Kotlin 当中看到的 `resumeWith` 的参数类型是 `Result`，怎么这儿成了 `Object` 了？因为 `Result` 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 `Object` （在Kotlin 里面是 `Any?`）\n\n② 处  `IntrinsicsKt.getCOROUTINE_SUSPENDED()` 就是 Kotlin 的 `COROUTINE_SUSPENDED`\n\n剩下的其实并不难理解，运行结果自然就是如下所示了：\n\n```\n07:52:55:288 [main] 1\n07:52:55:293 [main] 3\n07:52:55:296 [main] Suspended.\n07:52:56:298 [Thread-0] 2\n07:52:56:306 [Thread-0] The result is 1024\n```\n\n其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：\n\n```kotlin\nsuspend fun main() {\n    log(hello())\n}\n```\n\n只不过我们在 Kotlin 当中还是不太容易拿到 `hello` 在挂起时的真正返回值，其他的返回结果完全相同。\n\n```\n12:44:08:290 [main] 1\n12:44:08:292 [main] 3\n12:44:09:296 [Thread-0] 2\n12:44:09:296 [Thread-0] 1024\n```\n\n很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。\n\n## 4. 深入理解协程的状态转移\n\n前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：\n\n```kotlin\nsuspend fun returnSuspended() = suspendCoroutineUninterceptedOrReturn<String>{\n    continuation ->\n    thread {\n        Thread.sleep(1000)\n        continuation.resume(\"Return suspended.\")\n    }\n    COROUTINE_SUSPENDED\n}\n\nsuspend fun returnImmediately() = suspendCoroutineUninterceptedOrReturn<String>{\n    log(1)\n    \"Return immediately.\"\n}\n```\n\n我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 `join` 或者 `await` 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    log(returnSuspended())\n    log(2)\n    delay(1000)\n    log(3)\n    log(returnImmediately())\n    log(4)\n}\n```\n\n运行结果如下：\n\n```\n08:09:37:090 [main] 1\n08:09:38:096 [Thread-0] Return suspended.\n08:09:38:096 [Thread-0] 2\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4\n```\n\n好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：\n\n> 注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。\n\n```java\npublic class ContinuationImpl implements Continuation<Object> {\n\n    private int label = 0;\n    private final Continuation<Unit> completion;\n\n    public ContinuationImpl(Continuation<Unit> completion) {\n        this.completion = completion;\n    }\n\n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object o) {\n        try {\n            Object result = o;\n            switch (label) {\n                case 0: {\n                    LogKt.log(1);\n                    result = SuspendFunctionsKt.returnSuspended( this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 1: {\n                    LogKt.log(result);\n                    LogKt.log(2);\n                    result = DelayKt.delay(1000, this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 2: {\n                    LogKt.log(3);\n                    result = SuspendFunctionsKt.returnImmediately( this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 3:{\n                    LogKt.log(result);\n                    LogKt.log(4);\n                }\n            }\n            completion.resumeWith(Unit.INSTANCE);\n        } catch (Exception e) {\n            completion.resumeWith(e);\n        }\n    }\n\n    private boolean isSuspended(Object result) {\n        return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();\n    }\n}\n```\n\n我们定义了一个 Java 类 `ContinuationImpl`，它就是一个 `Continuation` 的实现。\n\n> 实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 `ContinuationImpl` 的类，只不过，它的 `resumeWith` 最终调用到了 `invokeSuspend`，而这个 `invokeSuspend` 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 `launch`启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 `SuspendLambda` 的子类，而它又是 `ContinuationImpl` 的子类。\n\n有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 `RunSuspend` 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：\n\n```java\npublic class RunSuspend implements Continuation<Unit> {\n\n    private Object result;\n\n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object result) {\n        synchronized (this){\n            this.result = result;\n            notifyAll(); // 协程已经结束，通知下面的 wait() 方法停止阻塞\n        }\n    }\n\n    public void await() throws Throwable {\n        synchronized (this){\n            while (true){\n                Object result = this.result;\n                if(result == null) wait(); // 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回\n                else if(result instanceof Throwable){\n                    throw (Throwable) result;\n                } else return;\n            }\n        }\n    }\n}\n```\n\n这段代码的关键点在于 `await()` 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 `result` 是 `null`，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：\n\n```java\n...\n    public static void main(String... args) throws Throwable {\n        RunSuspend runSuspend = new RunSuspend();\n        ContinuationImpl table = new ContinuationImpl(runSuspend);\n        table.resumeWith(Unit.INSTANCE);\n        runSuspend.await();\n    }\n...\n```\n\n> 这写法简直就是 suspend main 的真实面貌了。\n\n我们看到，作为 completion 传入的 `RunSuspend` 实例的 `resumeWith` 实际上是在 `ContinuationImpl` 的 `resumeWtih` 的最后才会被调用，因此它的 `await()` 一旦进入阻塞态，直到 `ContinuationImpl` 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。\n\n于是这段代码的运行结果如下：\n\n```\n08:36:51:305 [main] 1\n08:36:52:315 [Thread-0] Return suspended.\n08:36:52:315 [Thread-0] 2\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4\n```\n\n我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：\n\n* 协程的挂起函数本质上就是一个回调，回调类型就是 `Continuation`\n* 协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 `label` 不断的自增来实现状态流转一样\n\n如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 `resumeWith` 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。\n\n## 5. 小结\n\n不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。\n\n当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 `Sequence` 就是基于协程实现的，它的用法很简单，几乎与普通的 `Iterable` 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-suspend.md","raw":"---\ntitle:  破解 Kotlin 协程(6) - 协程挂起篇  \nkeywords: Kotlin 协程 协程挂起 任务挂起 suspend 非阻塞 \ndate: 2019/05/07\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！） \n\n<!-- more -->\n\n\n\n\n\n## 1. 先看看 delay\n\n我们刚刚学线程的时候，最常见的模拟各种延时用的就是 `Thread.sleep` 了，而在协程里面，对应的就是 `delay`。`sleep` 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 `delay` 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 `delay` 也可以是让协程休眠的一种很好的手段。\n\n`delay` 的源码其实很简单：\n\n```kotlin\npublic suspend fun delay(timeMillis: Long) {\n    if (timeMillis <= 0) return // don't delay\n    return suspendCancellableCoroutine sc@ { cont: CancellableContinuation<Unit> ->\n        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n    }\n}\n```\n\n`cont.context.delay.scheduleResumeAfterDelay` 这个操作，你可以类比 JavaScript 的 `setTimeout`，Android 的 `handler.postDelay`，本质上就是设置了一个延时回调，时间一到就调用 `cont` 的 resume 系列方法让协程继续执行。\n\n剩下的最关键的就是 `suspendCancellableCoroutine` 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 `delay` 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 `join`、`await` 等等。\n\n\n## 2. 再来说说 suspendCancellableCoroutine\n\n既然大家对于 `suspendCancellableCoroutine` 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：\n\n```kotlin\nprivate suspend fun joinSuspend() = suspendCancellableCoroutine<Unit> { cont ->\n    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))\n}\n```\n\n`Job.join()` 这个方法会首先检查调用者 `Job` 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 `joinSuspend` 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 `suspendCancellableCoroutine` 内部究竟做了什么呢？\n\n```kotlin\npublic suspend inline fun <T> suspendCancellableCoroutine(\n    crossinline block: (CancellableContinuation<T>) -> Unit\n): T =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n        block(cancellable)\n        cancellable.getResult() // 这里的类型是 Any?\n    }\n```\n\n`suspendCoroutineUninterceptedOrReturn` 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 `Continuation` 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：`suspendCoroutineUninterceptedOrReturn` 的返回值类型是 `T`，而传入的 lambda 的返回值类型是 `Any?`， 也就是我们看到的 `cancellable.getResult()` 的类型是 `Any?`，这是为什么？\n\n我记得在协程系列文章的开篇，我就提到过 `suspend` 函数的签名，当时是以 `await` 为例的，这个方法大致相当于：\n\n```kotlin\nfun await(continuation: Continuation<User>): Any {\n    ...\n}\n```\n\n`suspend` 一方面为这个方法添加了一个 `Continuation` 的参数，另一方面，原先的返回值类型 `User` 成了 `Continuation` 的泛型实参，而真正的返回值类型竟然是 `Any`。当然，这里因为定义的逻辑返回值类型 `User` 是不可空的，因此真实的返回值类型也用了 `Any` 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 `Any?` 了，这正与前面提到的 `cancellable.getResult()` 返回的这个 `Any?` 相对应。\n\n> 如果大家去查 `await` 的源码，你同样会看到这个 `getResult()` 的调用。\n\n简单来说就是，对于 `suspend` 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 `join` 或者 `await` 或者其他 `suspend` 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 `cancellable.getResult()` 究竟返回什么了，且看：\n\n```kotlin\ninternal fun getResult(): Any? {\n    ...\n    if (trySuspend()) return COROUTINE_SUSPENDED // ① 触发挂起逻辑\n    ...\n    if (state is CompletedExceptionally)  // ② 异常立即抛出\n        throw recoverStackTrace(state.cause, this) \n    return getSuccessfulResult(state) // ③ 正常结果立即返回\n}\n```\n\n这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？\n\n```kotlin\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n```\n这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 `Any`。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。\n\n## 3. 深入挂起操作\n\n既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。\n\n```kotlin\nsuspend fun hello() = suspendCoroutineUninterceptedOrReturn<Int>{\n    continuation ->\n    log(1)\n    thread {\n        Thread.sleep(1000)\n        log(2)\n        continuation.resume(1024)\n    }\n    log(3)\n    COROUTINE_SUSPENDED\n}\n```\n\n我写了这么一个 `suspend` 函数，在 `suspendCoroutineUninterceptedOrReturn` 当中直接返回了这个传说中的白板 `COROUTINE_SUSPENDED`，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？\n\n```java\npublic class CallCoroutine {\n    public static void main(String... args) {\n        Object value = SuspendTestKt.hello(new Continuation<Integer>() {\n            @NotNull\n            @Override\n            public CoroutineContext getContext() {\n                return EmptyCoroutineContext.INSTANCE;\n            }\n\n            @Override\n            public void resumeWith(@NotNull Object o) { // ①\n                if(o instanceof Integer){\n                    handleResult(o);\n                } else {\n                    Throwable throwable = (Throwable) o;\n                    throwable.printStackTrace();\n                }\n            }\n        });\n\n        if(value == IntrinsicsKt.getCOROUTINE_SUSPENDED()){ // ②\n            LogKt.log(\"Suspended.\");\n        } else {\n            handleResult(value);\n        }\n    }\n\n    public static void handleResult(Object o){\n        LogKt.log(\"The result is \" + o);\n    }\n}\n```\n\n这段代码看上去比较奇怪，可能会让人困惑的有两处：\n\n① 处，我们在 Kotlin 当中看到的 `resumeWith` 的参数类型是 `Result`，怎么这儿成了 `Object` 了？因为 `Result` 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 `Object` （在Kotlin 里面是 `Any?`）\n\n② 处  `IntrinsicsKt.getCOROUTINE_SUSPENDED()` 就是 Kotlin 的 `COROUTINE_SUSPENDED`\n\n剩下的其实并不难理解，运行结果自然就是如下所示了：\n\n```\n07:52:55:288 [main] 1\n07:52:55:293 [main] 3\n07:52:55:296 [main] Suspended.\n07:52:56:298 [Thread-0] 2\n07:52:56:306 [Thread-0] The result is 1024\n```\n\n其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：\n\n```kotlin\nsuspend fun main() {\n    log(hello())\n}\n```\n\n只不过我们在 Kotlin 当中还是不太容易拿到 `hello` 在挂起时的真正返回值，其他的返回结果完全相同。\n\n```\n12:44:08:290 [main] 1\n12:44:08:292 [main] 3\n12:44:09:296 [Thread-0] 2\n12:44:09:296 [Thread-0] 1024\n```\n\n很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。\n\n## 4. 深入理解协程的状态转移\n\n前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：\n\n```kotlin\nsuspend fun returnSuspended() = suspendCoroutineUninterceptedOrReturn<String>{\n    continuation ->\n    thread {\n        Thread.sleep(1000)\n        continuation.resume(\"Return suspended.\")\n    }\n    COROUTINE_SUSPENDED\n}\n\nsuspend fun returnImmediately() = suspendCoroutineUninterceptedOrReturn<String>{\n    log(1)\n    \"Return immediately.\"\n}\n```\n\n我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 `join` 或者 `await` 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    log(returnSuspended())\n    log(2)\n    delay(1000)\n    log(3)\n    log(returnImmediately())\n    log(4)\n}\n```\n\n运行结果如下：\n\n```\n08:09:37:090 [main] 1\n08:09:38:096 [Thread-0] Return suspended.\n08:09:38:096 [Thread-0] 2\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.\n08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4\n```\n\n好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：\n\n> 注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。\n\n```java\npublic class ContinuationImpl implements Continuation<Object> {\n\n    private int label = 0;\n    private final Continuation<Unit> completion;\n\n    public ContinuationImpl(Continuation<Unit> completion) {\n        this.completion = completion;\n    }\n\n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object o) {\n        try {\n            Object result = o;\n            switch (label) {\n                case 0: {\n                    LogKt.log(1);\n                    result = SuspendFunctionsKt.returnSuspended( this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 1: {\n                    LogKt.log(result);\n                    LogKt.log(2);\n                    result = DelayKt.delay(1000, this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 2: {\n                    LogKt.log(3);\n                    result = SuspendFunctionsKt.returnImmediately( this);\n                    label++;\n                    if (isSuspended(result)) return;\n                }\n                case 3:{\n                    LogKt.log(result);\n                    LogKt.log(4);\n                }\n            }\n            completion.resumeWith(Unit.INSTANCE);\n        } catch (Exception e) {\n            completion.resumeWith(e);\n        }\n    }\n\n    private boolean isSuspended(Object result) {\n        return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();\n    }\n}\n```\n\n我们定义了一个 Java 类 `ContinuationImpl`，它就是一个 `Continuation` 的实现。\n\n> 实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 `ContinuationImpl` 的类，只不过，它的 `resumeWith` 最终调用到了 `invokeSuspend`，而这个 `invokeSuspend` 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 `launch`启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 `SuspendLambda` 的子类，而它又是 `ContinuationImpl` 的子类。\n\n有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 `RunSuspend` 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：\n\n```java\npublic class RunSuspend implements Continuation<Unit> {\n\n    private Object result;\n\n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object result) {\n        synchronized (this){\n            this.result = result;\n            notifyAll(); // 协程已经结束，通知下面的 wait() 方法停止阻塞\n        }\n    }\n\n    public void await() throws Throwable {\n        synchronized (this){\n            while (true){\n                Object result = this.result;\n                if(result == null) wait(); // 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回\n                else if(result instanceof Throwable){\n                    throw (Throwable) result;\n                } else return;\n            }\n        }\n    }\n}\n```\n\n这段代码的关键点在于 `await()` 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 `result` 是 `null`，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：\n\n```java\n...\n    public static void main(String... args) throws Throwable {\n        RunSuspend runSuspend = new RunSuspend();\n        ContinuationImpl table = new ContinuationImpl(runSuspend);\n        table.resumeWith(Unit.INSTANCE);\n        runSuspend.await();\n    }\n...\n```\n\n> 这写法简直就是 suspend main 的真实面貌了。\n\n我们看到，作为 completion 传入的 `RunSuspend` 实例的 `resumeWith` 实际上是在 `ContinuationImpl` 的 `resumeWtih` 的最后才会被调用，因此它的 `await()` 一旦进入阻塞态，直到 `ContinuationImpl` 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。\n\n于是这段代码的运行结果如下：\n\n```\n08:36:51:305 [main] 1\n08:36:52:315 [Thread-0] Return suspended.\n08:36:52:315 [Thread-0] 2\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.\n08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4\n```\n\n我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：\n\n* 协程的挂起函数本质上就是一个回调，回调类型就是 `Continuation`\n* 协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 `label` 不断的自增来实现状态流转一样\n\n如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 `resumeWith` 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。\n\n## 5. 小结\n\n不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。\n\n当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 `Sequence` 就是基于协程实现的，它的用法很简单，几乎与普通的 `Iterable` 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-suspend","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0037000zlduzblrk5e3m","content":"<blockquote>\n<p>协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！） </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n\n<h2 id=\"1-先看看-delay\"><a href=\"#1-先看看-delay\" class=\"headerlink\" title=\"1. 先看看 delay\"></a>1. 先看看 delay</h2><p>我们刚刚学线程的时候，最常见的模拟各种延时用的就是 <code>Thread.sleep</code> 了，而在协程里面，对应的就是 <code>delay</code>。<code>sleep</code> 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 <code>delay</code> 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 <code>delay</code> 也可以是让协程休眠的一种很好的手段。</p>\n<p><code>delay</code> 的源码其实很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeMillis &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"comment\">// don&#x27;t delay</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCancellableCoroutine <span class=\"symbol\">sc@</span> &#123; cont: CancellableContinuation&lt;<span class=\"built_in\">Unit</span>&gt; -&gt;</span><br><span class=\"line\">        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作，你可以类比 JavaScript 的 <code>setTimeout</code>，Android 的 <code>handler.postDelay</code>，本质上就是设置了一个延时回调，时间一到就调用 <code>cont</code> 的 resume 系列方法让协程继续执行。</p>\n<p>剩下的最关键的就是 <code>suspendCancellableCoroutine</code> 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 <code>delay</code> 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 <code>join</code>、<code>await</code> 等等。</p>\n<h2 id=\"2-再来说说-suspendCancellableCoroutine\"><a href=\"#2-再来说说-suspendCancellableCoroutine\" class=\"headerlink\" title=\"2. 再来说说 suspendCancellableCoroutine\"></a>2. 再来说说 suspendCancellableCoroutine</h2><p>既然大家对于 <code>suspendCancellableCoroutine</code> 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">joinSuspend</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;<span class=\"built_in\">Unit</span>&gt; &#123; cont -&gt;</span><br><span class=\"line\">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class=\"keyword\">this</span>, cont).asHandler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Job.join()</code> 这个方法会首先检查调用者 <code>Job</code> 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 <code>joinSuspend</code> 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 <code>suspendCancellableCoroutine</code> 内部究竟做了什么呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">suspendCancellableCoroutine</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">crossinline</span> block: (<span class=\"type\">CancellableContinuation</span>&lt;<span class=\"type\">T</span>&gt;) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: T =</span><br><span class=\"line\">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class=\"line\">        block(cancellable)</span><br><span class=\"line\">        cancellable.getResult() <span class=\"comment\">// 这里的类型是 Any?</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 <code>Continuation</code> 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 <code>T</code>，而传入的 lambda 的返回值类型是 <code>Any?</code>， 也就是我们看到的 <code>cancellable.getResult()</code> 的类型是 <code>Any?</code>，这是为什么？</p>\n<p>我记得在协程系列文章的开篇，我就提到过 <code>suspend</code> 函数的签名，当时是以 <code>await</code> 为例的，这个方法大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">User</span>&gt;)</span></span>: Any &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspend</code> 一方面为这个方法添加了一个 <code>Continuation</code> 的参数，另一方面，原先的返回值类型 <code>User</code> 成了 <code>Continuation</code> 的泛型实参，而真正的返回值类型竟然是 <code>Any</code>。当然，这里因为定义的逻辑返回值类型 <code>User</code> 是不可空的，因此真实的返回值类型也用了 <code>Any</code> 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 <code>Any?</code> 了，这正与前面提到的 <code>cancellable.getResult()</code> 返回的这个 <code>Any?</code> 相对应。</p>\n<blockquote>\n<p>如果大家去查 <code>await</code> 的源码，你同样会看到这个 <code>getResult()</code> 的调用。</p>\n</blockquote>\n<p>简单来说就是，对于 <code>suspend</code> 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 <code>join</code> 或者 <code>await</code> 或者其他 <code>suspend</code> 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 <code>cancellable.getResult()</code> 究竟返回什么了，且看：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getResult</span><span class=\"params\">()</span></span>: Any? &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trySuspend()) <span class=\"keyword\">return</span> COROUTINE_SUSPENDED <span class=\"comment\">// ① 触发挂起逻辑</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state <span class=\"keyword\">is</span> CompletedExceptionally)  <span class=\"comment\">// ② 异常立即抛出</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> recoverStackTrace(state.cause, <span class=\"keyword\">this</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> getSuccessfulResult(state) <span class=\"comment\">// ③ 正常结果立即返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">val</span> COROUTINE_SUSPENDED: Any <span class=\"keyword\">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineSingletons</span> </span>&#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure>\n<p>这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 <code>Any</code>。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。</p>\n<h2 id=\"3-深入挂起操作\"><a href=\"#3-深入挂起操作\" class=\"headerlink\" title=\"3. 深入挂起操作\"></a>3. 深入挂起操作</h2><p>既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class=\"built_in\">Int</span>&gt;&#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    thread &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        continuation.resume(<span class=\"number\">1024</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    COROUTINE_SUSPENDED</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我写了这么一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回了这个传说中的白板 <code>COROUTINE_SUSPENDED</code>，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallCoroutine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">        Object value = SuspendTestKt.hello(<span class=\"keyword\">new</span> Continuation&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@NotNull</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object o)</span> </span>&#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> Integer)&#123;</span><br><span class=\"line\">                    handleResult(o);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Throwable throwable = (Throwable) o;</span><br><span class=\"line\">                    throwable.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == IntrinsicsKt.getCOROUTINE_SUSPENDED())&#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">            LogKt.log(<span class=\"string\">&quot;Suspended.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handleResult(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResult</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        LogKt.log(<span class=\"string\">&quot;The result is &quot;</span> + o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码看上去比较奇怪，可能会让人困惑的有两处：</p>\n<p>① 处，我们在 Kotlin 当中看到的 <code>resumeWith</code> 的参数类型是 <code>Result</code>，怎么这儿成了 <code>Object</code> 了？因为 <code>Result</code> 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 <code>Object</code> （在Kotlin 里面是 <code>Any?</code>）</p>\n<p>② 处  <code>IntrinsicsKt.getCOROUTINE_SUSPENDED()</code> 就是 Kotlin 的 <code>COROUTINE_SUSPENDED</code></p>\n<p>剩下的其实并不难理解，运行结果自然就是如下所示了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">07:52:55:288 [main] 1</span><br><span class=\"line\">07:52:55:293 [main] 3</span><br><span class=\"line\">07:52:55:296 [main] Suspended.</span><br><span class=\"line\">07:52:56:298 [Thread-0] 2</span><br><span class=\"line\">07:52:56:306 [Thread-0] The result is 1024</span><br></pre></td></tr></table></figure>\n\n<p>其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(hello())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只不过我们在 Kotlin 当中还是不太容易拿到 <code>hello</code> 在挂起时的真正返回值，其他的返回结果完全相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:44:08:290 [main] 1</span><br><span class=\"line\">12:44:08:292 [main] 3</span><br><span class=\"line\">12:44:09:296 [Thread-0] 2</span><br><span class=\"line\">12:44:09:296 [Thread-0] 1024</span><br></pre></td></tr></table></figure>\n\n<p>很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。</p>\n<h2 id=\"4-深入理解协程的状态转移\"><a href=\"#4-深入理解协程的状态转移\" class=\"headerlink\" title=\"4. 深入理解协程的状态转移\"></a>4. 深入理解协程的状态转移</h2><p>前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnSuspended</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    thread &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        continuation.resume(<span class=\"string\">&quot;Return suspended.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    COROUTINE_SUSPENDED</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnImmediately</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;Return immediately.&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 <code>join</code> 或者 <code>await</code> 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    log(returnSuspended())</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    log(returnImmediately())</span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:09:37:090 [main] 1</span><br><span class=\"line\">08:09:38:096 [Thread-0] Return suspended.</span><br><span class=\"line\">08:09:38:096 [Thread-0] 2</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>\n\n<p>好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：</p>\n<blockquote>\n<p>注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContinuationImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Continuation</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> label = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContinuationImpl</span><span class=\"params\">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.completion = completion;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Object result = o;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (label) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    result = SuspendFunctionsKt.returnSuspended( <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(result);</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    result = DelayKt.delay(<span class=\"number\">1000</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    result = SuspendFunctionsKt.returnImmediately( <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>:&#123;</span><br><span class=\"line\">                    LogKt.log(result);</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completion.resumeWith(Unit.INSTANCE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            completion.resumeWith(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSuspended</span><span class=\"params\">(Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义了一个 Java 类 <code>ContinuationImpl</code>，它就是一个 <code>Continuation</code> 的实现。</p>\n<blockquote>\n<p>实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 <code>ContinuationImpl</code> 的类，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code>，而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 <code>launch</code>启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code> 的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p>\n</blockquote>\n<p>有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 <code>RunSuspend</code> 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunSuspend</span> <span class=\"keyword\">implements</span> <span class=\"title\">Continuation</span>&lt;<span class=\"title\">Unit</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">            notifyAll(); <span class=\"comment\">// 协程已经结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Object result = <span class=\"keyword\">this</span>.result;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result == <span class=\"keyword\">null</span>) wait(); <span class=\"comment\">// 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(result <span class=\"keyword\">instanceof</span> Throwable)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> (Throwable) result;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的关键点在于 <code>await()</code> 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 <code>result</code> 是 <code>null</code>，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        RunSuspend runSuspend = <span class=\"keyword\">new</span> RunSuspend();</span><br><span class=\"line\">        ContinuationImpl table = <span class=\"keyword\">new</span> ContinuationImpl(runSuspend);</span><br><span class=\"line\">        table.resumeWith(Unit.INSTANCE);</span><br><span class=\"line\">        runSuspend.await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这写法简直就是 suspend main 的真实面貌了。</p>\n</blockquote>\n<p>我们看到，作为 completion 传入的 <code>RunSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWtih</code> 的最后才会被调用，因此它的 <code>await()</code> 一旦进入阻塞态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。</p>\n<p>于是这段代码的运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:36:51:305 [main] 1</span><br><span class=\"line\">08:36:52:315 [Thread-0] Return suspended.</span><br><span class=\"line\">08:36:52:315 [Thread-0] 2</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：</p>\n<ul>\n<li>协程的挂起函数本质上就是一个回调，回调类型就是 <code>Continuation</code></li>\n<li>协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 <code>label</code> 不断的自增来实现状态流转一样</li>\n</ul>\n<p>如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 <code>resumeWith</code> 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。</p>\n<p>当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 <code>Sequence</code> 就是基于协程实现的，它的用法很简单，几乎与普通的 <code>Iterable</code> 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#105;&#109;&#x6f;&#x6f;&#x63;&#46;&#99;&#111;&#109;\">&#x6b;&#x66;&#64;&#105;&#109;&#x6f;&#x6f;&#x63;&#46;&#99;&#111;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>协程的挂起最初是一个很神秘的东西，因为我们总是用线程的概念去思考，所以我们只能想到阻塞。不阻塞的挂起到底是怎么回事呢？说出来你也许会笑~~（哭？。。抱歉这篇文章我实在是没办法写的更通俗易懂了，大家一定要亲手实践！） </p>\n</blockquote>","more":"<h2 id=\"1-先看看-delay\"><a href=\"#1-先看看-delay\" class=\"headerlink\" title=\"1. 先看看 delay\"></a>1. 先看看 delay</h2><p>我们刚刚学线程的时候，最常见的模拟各种延时用的就是 <code>Thread.sleep</code> 了，而在协程里面，对应的就是 <code>delay</code>。<code>sleep</code> 让线程进入休眠状态，直到指定时间之后某种信号或者条件到达，线程就尝试恢复执行，而 <code>delay</code> 会让协程挂起，这个过程并不会阻塞 CPU，甚至可以说从硬件使用效率上来讲是“什么都不耽误”，从这个意义上讲 <code>delay</code> 也可以是让协程休眠的一种很好的手段。</p>\n<p><code>delay</code> 的源码其实很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeMillis &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"comment\">// don&#x27;t delay</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCancellableCoroutine <span class=\"symbol\">sc@</span> &#123; cont: CancellableContinuation&lt;<span class=\"built_in\">Unit</span>&gt; -&gt;</span><br><span class=\"line\">        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作，你可以类比 JavaScript 的 <code>setTimeout</code>，Android 的 <code>handler.postDelay</code>，本质上就是设置了一个延时回调，时间一到就调用 <code>cont</code> 的 resume 系列方法让协程继续执行。</p>\n<p>剩下的最关键的就是 <code>suspendCancellableCoroutine</code> 了，这可是我们的老朋友了，前面我们用它实现了回调到协程的各种转换 —— 原来 <code>delay</code> 也是基于它实现的，如果我们再多看一些源码，你就会发现类似的还有 <code>join</code>、<code>await</code> 等等。</p>\n<h2 id=\"2-再来说说-suspendCancellableCoroutine\"><a href=\"#2-再来说说-suspendCancellableCoroutine\" class=\"headerlink\" title=\"2. 再来说说 suspendCancellableCoroutine\"></a>2. 再来说说 suspendCancellableCoroutine</h2><p>既然大家对于 <code>suspendCancellableCoroutine</code> 已经很熟悉了，那么我们干脆直接召唤一个老朋友给大家：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">joinSuspend</span><span class=\"params\">()</span></span> = suspendCancellableCoroutine&lt;<span class=\"built_in\">Unit</span>&gt; &#123; cont -&gt;</span><br><span class=\"line\">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(<span class=\"keyword\">this</span>, cont).asHandler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Job.join()</code> 这个方法会首先检查调用者 <code>Job</code> 的状态是否已经完成，如果是，就直接返回并继续执行后面的代码而不再挂起，否则就会走到这个 <code>joinSuspend</code> 的分支当中。我们看到这里只是注册了一个完成时的回调，那么传说中的 <code>suspendCancellableCoroutine</code> 内部究竟做了什么呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">suspendCancellableCoroutine</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">crossinline</span> block: (<span class=\"type\">CancellableContinuation</span>&lt;<span class=\"type\">T</span>&gt;) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: T =</span><br><span class=\"line\">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class=\"line\">        block(cancellable)</span><br><span class=\"line\">        cancellable.getResult() <span class=\"comment\">// 这里的类型是 Any?</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法调用的源码是看不到的，因为它根本没有源码：P 它的逻辑就是帮大家拿到 <code>Continuation</code> 实例，真的就只有这样。不过这样说起来还是很抽象，因为有一处非常的可疑：<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 <code>T</code>，而传入的 lambda 的返回值类型是 <code>Any?</code>， 也就是我们看到的 <code>cancellable.getResult()</code> 的类型是 <code>Any?</code>，这是为什么？</p>\n<p>我记得在协程系列文章的开篇，我就提到过 <code>suspend</code> 函数的签名，当时是以 <code>await</code> 为例的，这个方法大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">await</span><span class=\"params\">(continuation: <span class=\"type\">Continuation</span>&lt;<span class=\"type\">User</span>&gt;)</span></span>: Any &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>suspend</code> 一方面为这个方法添加了一个 <code>Continuation</code> 的参数，另一方面，原先的返回值类型 <code>User</code> 成了 <code>Continuation</code> 的泛型实参，而真正的返回值类型竟然是 <code>Any</code>。当然，这里因为定义的逻辑返回值类型 <code>User</code> 是不可空的，因此真实的返回值类型也用了 <code>Any</code> 来示意，如果泛型实参是个可空的类型，那么真实的返回值类型也就是 <code>Any?</code> 了，这正与前面提到的 <code>cancellable.getResult()</code> 返回的这个 <code>Any?</code> 相对应。</p>\n<blockquote>\n<p>如果大家去查 <code>await</code> 的源码，你同样会看到这个 <code>getResult()</code> 的调用。</p>\n</blockquote>\n<p>简单来说就是，对于 <code>suspend</code> 函数，不是一定要挂起的，可以在需要的时候挂起，也就是要等待的协程还没有执行完的时候，等待协程执行完再继续执行；而如果在开始 <code>join</code> 或者 <code>await</code> 或者其他 <code>suspend</code> 函数，如果目标协程已经完成，那么就没必要等了，直接拿着结果走人即可。那么这个神奇的逻辑就在于 <code>cancellable.getResult()</code> 究竟返回什么了，且看：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getResult</span><span class=\"params\">()</span></span>: Any? &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trySuspend()) <span class=\"keyword\">return</span> COROUTINE_SUSPENDED <span class=\"comment\">// ① 触发挂起逻辑</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state <span class=\"keyword\">is</span> CompletedExceptionally)  <span class=\"comment\">// ② 异常立即抛出</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> recoverStackTrace(state.cause, <span class=\"keyword\">this</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> getSuccessfulResult(state) <span class=\"comment\">// ③ 正常结果立即返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码 ① 处就是挂起逻辑了，表示这时候目标协程还没有执行完，需要等待结果，②③是协程已经执行完可以直接拿到异常和正常结果的两种情况。②③好理解，关键是 ①，它要挂起，这返回的是个什么东西？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">val</span> COROUTINE_SUSPENDED: Any <span class=\"keyword\">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineSingletons</span> </span>&#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure>\n<p>这是 1.3 的实现，1.3 以前的实现更有趣，就是一个白板 <code>Any</code>。其实是什么不重要，关键是这个东西是一个单例，任何时候协程见到它就知道自己该挂起了。</p>\n<h2 id=\"3-深入挂起操作\"><a href=\"#3-深入挂起操作\" class=\"headerlink\" title=\"3. 深入挂起操作\"></a>3. 深入挂起操作</h2><p>既然说到挂起，大家可能觉得还是一知半解，还是不知道挂起究竟怎么做到的，怎么办？说真的这个挂起是个什么操作其实一直没有拿出来给大家看，不是我们太小气了，只是太早拿出来会比较吓人。。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;<span class=\"built_in\">Int</span>&gt;&#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    thread &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        continuation.resume(<span class=\"number\">1024</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    COROUTINE_SUSPENDED</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我写了这么一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回了这个传说中的白板 <code>COROUTINE_SUSPENDED</code>，正常来说我们应该在一个协程当中调用这个方法对吧，可是我偏不，我写一段 Java 代码去调用这个方法，结果会怎样呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallCoroutine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">        Object value = SuspendTestKt.hello(<span class=\"keyword\">new</span> Continuation&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@NotNull</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object o)</span> </span>&#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(o <span class=\"keyword\">instanceof</span> Integer)&#123;</span><br><span class=\"line\">                    handleResult(o);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Throwable throwable = (Throwable) o;</span><br><span class=\"line\">                    throwable.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == IntrinsicsKt.getCOROUTINE_SUSPENDED())&#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">            LogKt.log(<span class=\"string\">&quot;Suspended.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handleResult(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResult</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        LogKt.log(<span class=\"string\">&quot;The result is &quot;</span> + o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码看上去比较奇怪，可能会让人困惑的有两处：</p>\n<p>① 处，我们在 Kotlin 当中看到的 <code>resumeWith</code> 的参数类型是 <code>Result</code>，怎么这儿成了 <code>Object</code> 了？因为 <code>Result</code> 是内联类，编译时会用它唯一的成员替换掉它，因此就替换成了 <code>Object</code> （在Kotlin 里面是 <code>Any?</code>）</p>\n<p>② 处  <code>IntrinsicsKt.getCOROUTINE_SUSPENDED()</code> 就是 Kotlin 的 <code>COROUTINE_SUSPENDED</code></p>\n<p>剩下的其实并不难理解，运行结果自然就是如下所示了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">07:52:55:288 [main] 1</span><br><span class=\"line\">07:52:55:293 [main] 3</span><br><span class=\"line\">07:52:55:296 [main] Suspended.</span><br><span class=\"line\">07:52:56:298 [Thread-0] 2</span><br><span class=\"line\">07:52:56:306 [Thread-0] The result is 1024</span><br></pre></td></tr></table></figure>\n\n<p>其实这段 Java 代码的调用方式与 Kotlin 下面的调用已经很接近了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(hello())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只不过我们在 Kotlin 当中还是不太容易拿到 <code>hello</code> 在挂起时的真正返回值，其他的返回结果完全相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:44:08:290 [main] 1</span><br><span class=\"line\">12:44:08:292 [main] 3</span><br><span class=\"line\">12:44:09:296 [Thread-0] 2</span><br><span class=\"line\">12:44:09:296 [Thread-0] 1024</span><br></pre></td></tr></table></figure>\n\n<p>很有可能你看到这里都会觉得晕头转向，没有关系，我现在已经开始尝试揭示一些协程挂起的背后逻辑了，比起简单的使用，概念的理解和接受需要有个小小的过程。</p>\n<h2 id=\"4-深入理解协程的状态转移\"><a href=\"#4-深入理解协程的状态转移\" class=\"headerlink\" title=\"4. 深入理解协程的状态转移\"></a>4. 深入理解协程的状态转移</h2><p>前面我们已经对协程的原理做了一些揭示，显然 Java 的代码让大家能够更容易理解，那么接下来我们再来看一个更复杂的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnSuspended</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class=\"line\">    continuation -&gt;</span><br><span class=\"line\">    thread &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        continuation.resume(<span class=\"string\">&quot;Return suspended.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    COROUTINE_SUSPENDED</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnImmediately</span><span class=\"params\">()</span></span> = suspendCoroutineUninterceptedOrReturn&lt;String&gt;&#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;Return immediately.&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们首先定义两个挂起函数，第一个会真正挂起，第二个则会直接返回结果，这类似于我们前面讨论 <code>join</code> 或者 <code>await</code> 的两条路径。我们再用 Kotlin 给出一个调用它们的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    log(returnSuspended())</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    log(returnImmediately())</span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:09:37:090 [main] 1</span><br><span class=\"line\">08:09:38:096 [Thread-0] Return suspended.</span><br><span class=\"line\">08:09:38:096 [Thread-0] 2</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class=\"line\">08:09:39:141 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>\n\n<p>好，现在我们要揭示这段协程代码的真实面貌，为了做到这一点，我们用 Java 来仿写一下这段逻辑：</p>\n<blockquote>\n<p>注意，下面的代码逻辑上并不能做到十分严谨，不应该出现在生产当中，仅供学习理解协程使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContinuationImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Continuation</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> label = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Continuation&lt;Unit&gt; completion;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContinuationImpl</span><span class=\"params\">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.completion = completion;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Object result = o;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (label) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    result = SuspendFunctionsKt.returnSuspended( <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(result);</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    result = DelayKt.delay(<span class=\"number\">1000</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>: &#123;</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    result = SuspendFunctionsKt.returnImmediately( <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    label++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isSuspended(result)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>:&#123;</span><br><span class=\"line\">                    LogKt.log(result);</span><br><span class=\"line\">                    LogKt.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            completion.resumeWith(Unit.INSTANCE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            completion.resumeWith(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSuspended</span><span class=\"params\">(Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义了一个 Java 类 <code>ContinuationImpl</code>，它就是一个 <code>Continuation</code> 的实现。</p>\n<blockquote>\n<p>实际上如果你愿意，你还真得可以在 Kotlin 的标准库当中找到一个名叫 <code>ContinuationImpl</code> 的类，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code>，而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是一个 Lambda 表达式 —— 我们通过 <code>launch</code>启动协程，传入的那个 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code> 的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p>\n</blockquote>\n<p>有了这个类我们还需要准备一个 completion 用来接收结果，这个类仿照标准库的 <code>RunSuspend</code> 类实现，如果你有阅读前面的文章，那么你应该知道 suspend main 的实现就是基于这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunSuspend</span> <span class=\"keyword\">implements</span> <span class=\"title\">Continuation</span>&lt;<span class=\"title\">Unit</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CoroutineContext <span class=\"title\">getContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EmptyCoroutineContext.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resumeWith</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">            notifyAll(); <span class=\"comment\">// 协程已经结束，通知下面的 wait() 方法停止阻塞</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Object result = <span class=\"keyword\">this</span>.result;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result == <span class=\"keyword\">null</span>) wait(); <span class=\"comment\">// 调用了 Object.wait()，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(result <span class=\"keyword\">instanceof</span> Throwable)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> (Throwable) result;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的关键点在于 <code>await()</code> 方法，它在其中起了一个死循环，不过大家不要害怕，这个死循环是个纸老虎，如果 <code>result</code> 是 <code>null</code>，那么当前线程会被立即阻塞，直到结果出现。具体的使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        RunSuspend runSuspend = <span class=\"keyword\">new</span> RunSuspend();</span><br><span class=\"line\">        ContinuationImpl table = <span class=\"keyword\">new</span> ContinuationImpl(runSuspend);</span><br><span class=\"line\">        table.resumeWith(Unit.INSTANCE);</span><br><span class=\"line\">        runSuspend.await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这写法简直就是 suspend main 的真实面貌了。</p>\n</blockquote>\n<p>我们看到，作为 completion 传入的 <code>RunSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWtih</code> 的最后才会被调用，因此它的 <code>await()</code> 一旦进入阻塞态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕正常退出了。</p>\n<p>于是这段代码的运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:36:51:305 [main] 1</span><br><span class=\"line\">08:36:52:315 [Thread-0] Return suspended.</span><br><span class=\"line\">08:36:52:315 [Thread-0] 2</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 3</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] Return immediately.</span><br><span class=\"line\">08:36:53:362 [kotlinx.coroutines.DefaultExecutor] 4</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这段普通的 Java 代码与前面的 Kotlin 协程调用完全一样。那么我这段 Java 代码的编写根据是什么呢？就是 Kotlin 协程编译之后产生的字节码。当然，字节码是比较抽象的，我这样写出来就是为了让大家更容易的理解协程是如何执行的，看到这里，相信大家对于协程的本质有了进一步的认识：</p>\n<ul>\n<li>协程的挂起函数本质上就是一个回调，回调类型就是 <code>Continuation</code></li>\n<li>协程体的执行就是一个状态机，每一次遇到挂起函数，都是一次状态转移，就像我们前面例子中的 <code>label</code> 不断的自增来实现状态流转一样</li>\n</ul>\n<p>如果能够把这两点认识清楚，那么相信你在学习协程其他概念的时候就都将不再是问题了。如果想要进行线程调度，就按照我们讲到的调度器的做法，在 <code>resumeWith</code> 处执行线程切换就好了，其实非常容易理解的。官方的协程框架本质上就是在做这么几件事儿，如果你去看源码，可能一时云里雾里，主要是因为框架除了实现核心逻辑外还需要考虑跨平台实现，还需要优化性能，但不管怎么样，这源码横竖看起来就是五个字：状态机回调。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>不同以往，我们从这一篇开始毫无保留的为大家尝试揭示协程背后的逻辑，也许一时间可能有些难懂，不过不要紧，你可以使用协程一段时间之后再来阅读这些内容，相信一定会豁然开朗的。</p>\n<p>当然，这一篇内容的安排更多是为后面的序列篇开路，Kotlin 的 <code>Sequence</code> 就是基于协程实现的，它的用法很简单，几乎与普通的 <code>Iterable</code> 没什么区别，因此序列篇我们会重点关注它的内部实现原理，欢迎大家关注。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#105;&#109;&#x6f;&#x6f;&#x63;&#46;&#99;&#111;&#109;\">&#x6b;&#x66;&#64;&#105;&#109;&#x6f;&#x6f;&#x63;&#46;&#99;&#111;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？","keywords":"Kotlin 协程 协程 stackful stackless","date":"2019-10-18T16:00:00.000Z","description":null,"_content":"\n> 接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。 \n\n<!-- more -->\n\n\n\n\n文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。\n\n## 1. 协程到底是啥？\n\nKotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。\n\n更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg)\n\n\n那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。\n\n那么我们再来理一理协程的概念：\n\n* 挂起恢复\n* 程序自己处理挂起恢复\n* 程序自己处理挂起恢复来实现协程的协作运行\n\n关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。\n\n> 有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。\n\n## 2. 为什么协程的概念会有混乱的感觉？\n\n我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。\n\n协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~ \n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg)\n\n协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。\n\n> Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。\n\n绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 [Quasar](http://docs.paralleluniverse.co/quasar/)，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。\n\n## 3. 协程有哪些主流的实现？\n\n我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：\n\n* 有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。\n* 无栈协程 Stackless Coroutine：协程没有自己的调用栈。\n\n栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 `StackOverflowException`，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。\n\n有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。 \n\n> goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。\n\nJavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？\n\n这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。\n\n> Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。\n\nContinuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 `suspend` 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 `suspend` 函数的调用，它都有可能会被挂起。每一个 `suspend` 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：\n\n```kotlin\nsuspend fun hello() = suspendCoroutine<Int>{ continuation ->\n    println(\"Hello\")\n    continuation.resumeWith(Result.success(10086))\n}\n``` \n\n我们定义了一个 `suspend` 函数 `hello`，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 `resumeWith` 的 `continuation` 是哪里来的？\n\n都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 `suspend` 函数，大家也会发现这些 `suspend` 函数都需要传入一个额外的 `Continuation`，就是这个意思。\n\n当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 `suspend` 函数现出原形：\n\n```kotlin\nval helloRef = ::hello\nval result = helloRef.call(object: Continuation<Int>{\n    override val context = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<Int>) {\n        println(\"resumeWith: ${result.getOrNull()}\")\n    }\n})\n```\n\n这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用  `hello()`，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 `Continuation`。\n\n再强调一下，这段代码不需要运行在协程体内，或者其他的 `suspend` 函数中。现在请大家仔细想想，为什么官方要求 `suspend` 函数一定要运行在协程体内或者其他 `suspend` 函数中呢？\n\n答案自然就是任何一个协程体或者 `suspend` 函数中都有一个隐含的 `Continuation` 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。\n\n说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg)\n\n\n## 4. Kotlin 协程真的只是一个线程框架吗？\n\n这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg)\n\nKotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。\n\n> 杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。\n\n协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。\n\n我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？\n\n说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 `Activity` 刚创建的时候想要拿到一个 `View` 的大小一般返回都是 0，因为 `Activity` 的布局是在 `onResume` 方法调用之后完成的，所以 `handler.post` 一下就好了：\n\n```kotlin\noverride fun onResume(){\n    super.onResume()\n    handler.post {\n        val width = myView.width\n        ...\n    }\n}\n```\n\n这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：\n\n```kotlin\noverride fun onResume() {\n    super.onResume()\n    GlobalScope.launch(Dispatchers.Main) {\n        val width = handler.postSuspend {\n            myView.width\n        }\n        Log.d(\"MyView\", width.toString())\n    }\n}\n\nsuspend fun <T> Handler.postSuspend(block: () -> T) = suspendCoroutine<T> {\n    post {\n        it.resume(block())\n    }\n}\n```\n\n其实我个人觉得如果 Kotlin 协程的默认的调度器是 `Main`，并且这个 `Main` 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 `Main` 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 `runBlocking` 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。\n\nKotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg)\n\n\n## 5. 协程真的比线程有优势吗？\n\n这可不是一个很容易回答的问题。\n\nKotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。\n\n想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg)\n\n线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：\n\n**协程更像一种轻量级的『线程』。**\n\n线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。\n\n欸？没有写错吗？你写的可是线程啊？\n\n对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg)\n\n\n我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。\n\n> 线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？\n\n## 6. 小结\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg)\n\n\n总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutine-why-so-called-lightweight-thread.md","raw":"---\ntitle:  破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？ \nkeywords: Kotlin 协程 协程 stackful stackless \ndate: 2019/10/19\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。 \n\n<!-- more -->\n\n\n\n\n文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。\n\n## 1. 协程到底是啥？\n\nKotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。\n\n更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg)\n\n\n那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。\n\n那么我们再来理一理协程的概念：\n\n* 挂起恢复\n* 程序自己处理挂起恢复\n* 程序自己处理挂起恢复来实现协程的协作运行\n\n关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。\n\n> 有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。\n\n## 2. 为什么协程的概念会有混乱的感觉？\n\n我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。\n\n协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~ \n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg)\n\n协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。\n\n> Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。\n\n绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 [Quasar](http://docs.paralleluniverse.co/quasar/)，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。\n\n## 3. 协程有哪些主流的实现？\n\n我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：\n\n* 有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。\n* 无栈协程 Stackless Coroutine：协程没有自己的调用栈。\n\n栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 `StackOverflowException`，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。\n\n有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。 \n\n> goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。\n\nJavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？\n\n这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。\n\n> Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。\n\nContinuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 `suspend` 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 `suspend` 函数的调用，它都有可能会被挂起。每一个 `suspend` 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：\n\n```kotlin\nsuspend fun hello() = suspendCoroutine<Int>{ continuation ->\n    println(\"Hello\")\n    continuation.resumeWith(Result.success(10086))\n}\n``` \n\n我们定义了一个 `suspend` 函数 `hello`，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 `resumeWith` 的 `continuation` 是哪里来的？\n\n都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 `suspend` 函数，大家也会发现这些 `suspend` 函数都需要传入一个额外的 `Continuation`，就是这个意思。\n\n当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 `suspend` 函数现出原形：\n\n```kotlin\nval helloRef = ::hello\nval result = helloRef.call(object: Continuation<Int>{\n    override val context = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<Int>) {\n        println(\"resumeWith: ${result.getOrNull()}\")\n    }\n})\n```\n\n这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用  `hello()`，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 `Continuation`。\n\n再强调一下，这段代码不需要运行在协程体内，或者其他的 `suspend` 函数中。现在请大家仔细想想，为什么官方要求 `suspend` 函数一定要运行在协程体内或者其他 `suspend` 函数中呢？\n\n答案自然就是任何一个协程体或者 `suspend` 函数中都有一个隐含的 `Continuation` 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。\n\n说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg)\n\n\n## 4. Kotlin 协程真的只是一个线程框架吗？\n\n这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg)\n\nKotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。\n\n> 杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。\n\n协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。\n\n我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？\n\n说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 `Activity` 刚创建的时候想要拿到一个 `View` 的大小一般返回都是 0，因为 `Activity` 的布局是在 `onResume` 方法调用之后完成的，所以 `handler.post` 一下就好了：\n\n```kotlin\noverride fun onResume(){\n    super.onResume()\n    handler.post {\n        val width = myView.width\n        ...\n    }\n}\n```\n\n这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：\n\n```kotlin\noverride fun onResume() {\n    super.onResume()\n    GlobalScope.launch(Dispatchers.Main) {\n        val width = handler.postSuspend {\n            myView.width\n        }\n        Log.d(\"MyView\", width.toString())\n    }\n}\n\nsuspend fun <T> Handler.postSuspend(block: () -> T) = suspendCoroutine<T> {\n    post {\n        it.resume(block())\n    }\n}\n```\n\n其实我个人觉得如果 Kotlin 协程的默认的调度器是 `Main`，并且这个 `Main` 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 `Main` 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 `runBlocking` 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。\n\nKotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg)\n\n\n## 5. 协程真的比线程有优势吗？\n\n这可不是一个很容易回答的问题。\n\nKotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。\n\n想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg)\n\n线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：\n\n**协程更像一种轻量级的『线程』。**\n\n线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。\n\n欸？没有写错吗？你写的可是线程啊？\n\n对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg)\n\n\n我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。\n\n> 线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？\n\n## 6. 小结\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg)\n\n\n总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutine-why-so-called-lightweight-thread","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi00370010lduz3kk1e7wg","content":"<blockquote>\n<p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p>\n<h2 id=\"1-协程到底是啥？\"><a href=\"#1-协程到底是啥？\" class=\"headerlink\" title=\"1. 协程到底是啥？\"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p>\n<p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg\"></p>\n<p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p>\n<p>那么我们再来理一理协程的概念：</p>\n<ul>\n<li>挂起恢复</li>\n<li>程序自己处理挂起恢复</li>\n<li>程序自己处理挂起恢复来实现协程的协作运行</li>\n</ul>\n<p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p>\n<blockquote>\n<p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p>\n</blockquote>\n<h2 id=\"2-为什么协程的概念会有混乱的感觉？\"><a href=\"#2-为什么协程的概念会有混乱的感觉？\" class=\"headerlink\" title=\"2. 为什么协程的概念会有混乱的感觉？\"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p>\n<p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~ </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg\"></p>\n<p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p>\n<blockquote>\n<p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p>\n</blockquote>\n<p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href=\"http://docs.paralleluniverse.co/quasar/\">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p>\n<h2 id=\"3-协程有哪些主流的实现？\"><a href=\"#3-协程有哪些主流的实现？\" class=\"headerlink\" title=\"3. 协程有哪些主流的实现？\"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p>\n<ul>\n<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>\n<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li>\n</ul>\n<p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p>\n<p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。 </p>\n<blockquote>\n<p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p>\n</blockquote>\n<p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p>\n<p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p>\n<blockquote>\n<p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p>\n</blockquote>\n<p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;<span class=\"built_in\">Int</span>&gt;&#123; continuation -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">    continuation.resumeWith(Result.success(<span class=\"number\">10086</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义了一个 <code>suspend</code> 函数 <code>hello</code>，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 <code>resumeWith</code> 的 <code>continuation</code> 是哪里来的？</p>\n<p>都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 <code>suspend</code> 函数，大家也会发现这些 <code>suspend</code> 函数都需要传入一个额外的 <code>Continuation</code>，就是这个意思。</p>\n<p>当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 <code>suspend</code> 函数现出原形：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> helloRef = ::hello</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = helloRef.call(<span class=\"keyword\">object</span>: Continuation&lt;<span class=\"built_in\">Int</span>&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context = EmptyCoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">Int</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;resumeWith: <span class=\"subst\">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用  <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p>\n<p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p>\n<p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p>\n<p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg\"></p>\n<h2 id=\"4-Kotlin-协程真的只是一个线程框架吗？\"><a href=\"#4-Kotlin-协程真的只是一个线程框架吗？\" class=\"headerlink\" title=\"4. Kotlin 协程真的只是一个线程框架吗？\"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg\"></p>\n<p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p>\n<blockquote>\n<p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p>\n</blockquote>\n<p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p>\n<p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p>\n<p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume()</span><br><span class=\"line\">    handler.post &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = myView.width</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume()</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = handler.postSuspend &#123;</span><br><span class=\"line\">            myView.width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;MyView&quot;</span>, width.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Handler.<span class=\"title\">postSuspend</span><span class=\"params\">(block: () -&gt; <span class=\"type\">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class=\"line\">    post &#123;</span><br><span class=\"line\">        it.resume(block())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p>\n<p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg\"></p>\n<h2 id=\"5-协程真的比线程有优势吗？\"><a href=\"#5-协程真的比线程有优势吗？\" class=\"headerlink\" title=\"5. 协程真的比线程有优势吗？\"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p>\n<p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p>\n<p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg\"></p>\n<p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p>\n<p><strong>协程更像一种轻量级的『线程』。</strong></p>\n<p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p>\n<p>欸？没有写错吗？你写的可是线程啊？</p>\n<p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg\"></p>\n<p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p>\n<blockquote>\n<p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p>\n</blockquote>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h2><p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg\"></p>\n<p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#x69;&#109;&#x6f;&#111;&#x63;&#46;&#x63;&#111;&#x6d;\">&#x6b;&#x66;&#64;&#x69;&#109;&#x6f;&#111;&#x63;&#46;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>接触新概念，最好的办法就是先整体看个大概，再回过头来细细品味。 </p>\n</blockquote>","more":"<p>文中如果没有特别说明，协程指编程语言级别的协程，线程则特指操作系统内核线程。</p>\n<h2 id=\"1-协程到底是啥？\"><a href=\"#1-协程到底是啥？\" class=\"headerlink\" title=\"1. 协程到底是啥？\"></a>1. 协程到底是啥？</h2><p>Kotlin 的协程从 v1.1 开始公测(Experimental) 到现在，已经算是非常成熟了，但大家对它的看法却一直存在各种疑问，为什么呢？因为即便我们把 Kotlin 丢掉，单纯协程这个东西本身就已经长时间让大家感到疑惑了，不信的话可以单独搜一下协程或者 Coroutine，甚至连 Lua 之父在提到为什么协程鲜见于早期语言实现，就是因为这概念没有一个清晰的界定。</p>\n<p>更有意思的是，在查阅资料的过程中，你会经常会陷入一种一会儿『啊，我懂了』，一会儿『啊，我懂个屁』的循环当中，不瞒各位说，我从七八年前刚开始学 Lua 的时候面对 Lua 的协程也是这个破感觉，后来接触 goroutine 又来了一遍，接触 Kotlin 的协程又来了一遍，习惯就好。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712859864288.jpg\"></p>\n<p>那么问题的关键在于，协程的概念是不是真的混乱呢？其实不是的，协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复，挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，就没了，一句话就能说明白的事儿是不是特简单？它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p>\n<p>那么我们再来理一理协程的概念：</p>\n<ul>\n<li>挂起恢复</li>\n<li>程序自己处理挂起恢复</li>\n<li>程序自己处理挂起恢复来实现协程的协作运行</li>\n</ul>\n<p>关键核心就是协程是一个能挂起并且待会儿恢复执行的东西。任何时候自己产生疑惑的时候都回过来再想想这几句话，就算协程最终呈现给我们的样子可能『花里胡哨』，但万变不离其宗。</p>\n<blockquote>\n<p>有的朋友不理解什么叫挂起，挂起这个词其实还真是源于操作系统的叫法，直观的理解上，你就当做暂停理解吧。</p>\n</blockquote>\n<h2 id=\"2-为什么协程的概念会有混乱的感觉？\"><a href=\"#2-为什么协程的概念会有混乱的感觉？\" class=\"headerlink\" title=\"2. 为什么协程的概念会有混乱的感觉？\"></a>2. 为什么协程的概念会有混乱的感觉？</h2><p>我们前面提到，协程的概念其实并不混乱，那么混乱的是什么？是各家对它的实现。这就好像牛顿第二定律一样，看似很简单，F = ma，用起来就五花八门了，衍生的各种公式更是层出不穷。</p>\n<p>协程不就是要挂起、恢复么，请问挂起恢复具体要怎么做？没有定义呀。既然没有定义是不是就可以随便？是的，抓住老鼠就是好猫~ </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712868953541.jpg\"></p>\n<p>协程这一点儿跟线程真的是没法比啊，主流操作系统都有成熟的线程模型，应用层经常提到的线程的概念大多就是映射方式的差异，所以不同的编程语言一旦引入了线程，那么基本上就是照搬了系统线程的概念，线程本身也不是他们实现的——这很好理解，因为线程调度是操作系统做的嘛。</p>\n<blockquote>\n<p>Java 对线程做了很好的支持，这也是 Java 在高并发场景风生水起的一个关键支柱，不过如果你有兴趣去看下虚拟机底层对线程的支持，例如 Android 虚拟机，其实就是 pthread。Java 的 Object 还有一个 wait 方法，这个方法几乎支撑了各种锁的实现，它底层是 condition。</p>\n</blockquote>\n<p>绝大多数协程都是语言层面自己的实现，不同的编程语言有不同的使用场景，自然在实现上也看似有很大的差异，甚至还有的语言自己没有实现协程，但开发者通过第三方框架的方式提供了协程的能力，例如 Java 的框架 <a href=\"http://docs.paralleluniverse.co/quasar/\">Quasar</a>，加上协程实现本身在操作系统层面就有过一系列演进，因此出现了虽然理论上看起来很简单，但实现上却多样化的局面。</p>\n<h2 id=\"3-协程有哪些主流的实现？\"><a href=\"#3-协程有哪些主流的实现？\" class=\"headerlink\" title=\"3. 协程有哪些主流的实现？\"></a>3. 协程有哪些主流的实现？</h2><p>我们在前面讲各个语言的实现有差异，说的是看似有很大的差异，主要是各自的关键字、类型命名不一样，但总结下来大家对于协程的分类更倾向于按照有没有栈来分，即：</p>\n<ul>\n<li>有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。</li>\n<li>无栈协程 Stackless Coroutine：协程没有自己的调用栈。</li>\n</ul>\n<p>栈这个东西大家应该都很熟悉了，我们递归调用函数的层次太多就会导致 <code>StackOverflowException</code>，因为栈内存是有限的；我们的程序出现了异常我们总是希望看到异常点的调用关系，这样方便定位问题，这也需要栈。</p>\n<p>有栈协程有什么好处呢？因为有栈，所以在任何一个调用的地方运行时都可以选择把栈保存起来，暂停这个协程，听起来就跟线程一样了，只不过挂起和恢复执行的权限在程序自己，而不是操作系统。缺点也是非常明显的，每创建一个协程不管有没有在运行都要为它开辟一个栈，这也是目前无栈协程流行的原因。 </p>\n<blockquote>\n<p>goroutine 看上去似乎不像协程，因为开发者自己无法决定一个协程的挂起和恢复，这个工作是 go 运行时自己处理的。为了支持 goroutine 在任意位置能挂起，goroutine 其实是一个有栈协程，go 运行时在这里做了大量的优化，它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。</p>\n</blockquote>\n<p>JavaScript、C# 还有 Python 的协程，或者干脆就说 async/await，相比之下就轻量多了，它们看起来更像是针对回调加了个语法糖的支持——它们其实就是无栈协程的实现了。无栈，顾名思义，每一个协程都不会单独开辟调用栈，那么问题来了，它的上下文是如何保存的？</p>\n<p>这就要提到传说中的 CPS 了，即 continuation-passing-style。我们来想象一下，程序被挂起，或者说中断，最关键的是什么？是保存挂起点，或者中断点，对于线程被操作系统中断，中断点就是被保存在调用栈当中的，而我们的无栈协程要保存到哪儿呢？保存到 Continuation 对象当中，这个东西可能在不同的语言当中叫法不一样，但本质上都是一个 Continuation，它就是一个普通的对象，占用内存非常小，还是很抽象是吧，想想你常见的 Callback，它其实就是一个 Continuation 的实现。</p>\n<blockquote>\n<p>Kotlin 的协程的根基就是一个叫做 Continuation 的类。我在前面的文章不止一次提到，这家伙长得横看竖看就是一个回调，resume 就是 onSuccess，resumeWithException 就是 onFailure。</p>\n</blockquote>\n<p>Continuation 携带了协程继续执行所需要的上下文，同时它自己又是挂起点，因为待会儿恢复执行的时候只需要执行它回调的函数体就可以了。对于 Kotlin 来讲，每一个 <code>suspend</code> 函数都是一个挂起点，意味着对于当前协程来说，每遇到一个 <code>suspend</code> 函数的调用，它都有可能会被挂起。每一个 <code>suspend</code> 函数都被编译器插入了一个 Continuation 类型的参数用来保存当前的调用点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> = suspendCoroutine&lt;<span class=\"built_in\">Int</span>&gt;&#123; continuation -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">    continuation.resumeWith(Result.success(<span class=\"number\">10086</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义了一个 <code>suspend</code> 函数 <code>hello</code>，它看起来没有接收任何参数，如果真是这样，请问我们在后面调用 <code>resumeWith</code> 的 <code>continuation</code> 是哪里来的？</p>\n<p>都说挂起函数必须在协程内部调用，其实也不是，我们在前面讲挂起原理的时候就用 Java 代码直接去调用 <code>suspend</code> 函数，大家也会发现这些 <code>suspend</code> 函数都需要传入一个额外的 <code>Continuation</code>，就是这个意思。</p>\n<p>当然，Java 也不是必须的，我们只需要用点儿 Kotlin 反射，一样可以直接让 <code>suspend</code> 函数现出原形：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> helloRef = ::hello</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = helloRef.call(<span class=\"keyword\">object</span>: Continuation&lt;<span class=\"built_in\">Int</span>&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">val</span> context = EmptyCoroutineContext</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">resumeWith</span><span class=\"params\">(result: <span class=\"type\">Result</span>&lt;<span class=\"type\">Int</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;resumeWith: <span class=\"subst\">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这与我们在协程挂起原理那篇的做法如出一辙，我们虽然没有办法直接调用  <code>hello()</code>，但我们可以拿到它的函数引用，用发射调用它（这个做法后续可能也会被禁掉，但 1.3.50 目前仍然是可用的），调用的时候如果你什么参数都不传，编译器就会提示你它需要一个参数，呃，你看，它这么快就投降了——需要的这个参数正是 <code>Continuation</code>。</p>\n<p>再强调一下，这段代码不需要运行在协程体内，或者其他的 <code>suspend</code> 函数中。现在请大家仔细想想，为什么官方要求 <code>suspend</code> 函数一定要运行在协程体内或者其他 <code>suspend</code> 函数中呢？</p>\n<p>答案自然就是任何一个协程体或者 <code>suspend</code> 函数中都有一个隐含的 <code>Continuation</code> 实例，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。</p>\n<p>说到这里，我们已经接近 Kotlin 协程的本质了，它是一种无栈协程实现，它的本质就是一段代码 + Continuation 实例。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712876557532.jpg\"></p>\n<h2 id=\"4-Kotlin-协程真的只是一个线程框架吗？\"><a href=\"#4-Kotlin-协程真的只是一个线程框架吗？\" class=\"headerlink\" title=\"4. Kotlin 协程真的只是一个线程框架吗？\"></a>4. Kotlin 协程真的只是一个线程框架吗？</h2><p>这个说法其实是很奇怪的。我如果问你线程其实是一个 CPU 框架吗，你肯定会觉得这俩，啥啊？？？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712877286523.jpg\"></p>\n<p>Kotlin 协程确实在实现的过程中提供了切线程的能力，这是它的能力，不是它的身份，就好比拿着学位证非说这是身份证一样，学位证描述的是这人能干啥，不能描述这人是谁。</p>\n<blockquote>\n<p>杠精们可能会说学位证有照片有名字啊。你拿着学位证去买飞机票你看人家认不认呗。</p>\n</blockquote>\n<p>协程的世界可以没有线程，如果操作系统的 CPU 调度模型是协程的话；反过来也成立——这个应该不会有人反对吧。Kotlin 协程是不是可以没有线程呢？至少从 Java 虚拟机的实现上来看，好像。。。。不太行啊。没错，是不太行，不过这不是 Kotlin 协程的问题，是 Java 虚拟机的问题，谁让 Java 虚拟机的线程用起来没有那么难用呢，在它刚出来的时候简直吊打了当时其他语言对并发的支持（就像 goroutine 出来的时候吊打它一样）。</p>\n<p>我们知道 Kotlin 除了支持 Java 虚拟机之外，还支持 JavaScript，还支持 Native。JavaScript 无论是跑在 Web 还是 Node.js 当中，都是单线程玩耍的；Kotlin Native 虽然可以调用 pthread，但官方表示我们有自己的并发模型（Worker），不建议直接使用线程。在这两个平台上跑，Kotlin 的协程其实都是单线程的，又怎么讲是个线程框架呢？</p>\n<p>说到这儿可能又有人有疑问了，单线程要协程能做什么呢？这个前端同学可能会比较有感触，谁跟你们说的异步一定要多线程。。Android 开发的同学其实可以想想你在 <code>Activity</code> 刚创建的时候想要拿到一个 <code>View</code> 的大小一般返回都是 0，因为 <code>Activity</code> 的布局是在 <code>onResume</code> 方法调用之后完成的，所以 <code>handler.post</code> 一下就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume()</span><br><span class=\"line\">    handler.post &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = myView.width</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是异步代码嘛，但这代码其实都运行在主线程的，我们当然可以用协程改写一下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume()</span><br><span class=\"line\">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> width = handler.postSuspend &#123;</span><br><span class=\"line\">            myView.width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;MyView&quot;</span>, width.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Handler.<span class=\"title\">postSuspend</span><span class=\"params\">(block: () -&gt; <span class=\"type\">T</span>)</span></span> = suspendCoroutine&lt;T&gt; &#123;</span><br><span class=\"line\">    post &#123;</span><br><span class=\"line\">        it.resume(block())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我个人觉得如果 Kotlin 协程的默认的调度器是 <code>Main</code>，并且这个 <code>Main</code> 会根据各自平台选择一个合适的事件循环，这样更能体现 Kotlin 协程在不同平台的一致性，例如对于 Android 来说 <code>Main</code> 就是 UI 线程上的事件循环，对于 Swing 同样是 Swing 的 UI 事件循环，只要是有事件循环的平台就默认基于这个循环来一个调度器，没有默认事件循环的也好办，Kotlin 协程本身就有 <code>runBlocking</code> 嘛，对于普通 Java 程序来说没有事件循环就给它构造一个就行了。</p>\n<p>Kotlin 协程的设计者没有这样做，他们当然也有他们的道理，毕竟他们不愿意强迫开发者一定要用协程，甚至立刻马上就得对原有的代码进行改造，他们希望 Kotlin 只是一门编程语言，一门提供足够安全保障和灵活语法的编程语言，剩下的交给开发者去选择。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712879342461.jpg\"></p>\n<h2 id=\"5-协程真的比线程有优势吗？\"><a href=\"#5-协程真的比线程有优势吗？\" class=\"headerlink\" title=\"5. 协程真的比线程有优势吗？\"></a>5. 协程真的比线程有优势吗？</h2><p>这可不是一个很容易回答的问题。</p>\n<p>Kotlin 协程刚出来的时候，有人就做过性能对比，觉得协程没有任何性能优势。我们完全可以认为他的测试方法是专业的，在一些场景确实用协程不会有任何性能上的优势，这就好比我们需要在一个单核 CPU 上跑一个计算密集型的程序还要开多个线程跑一样，任何特性都有适合它的场景和不适合它的领域。</p>\n<p>想必大家看各类讲解协程的文章都会提到协程比线程轻量，这个其实我们前面也解释过了，编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。如果没有直观的感受的话，就尽情想象一下你正要拿五杀的时候公司领导在微信群里发消息问你今天的活跃怎么跌了的场景。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712882561417.jpg\"></p>\n<p>线程除了包含内核线程本身执行代码能力的含义以外，通常也被赋予了逻辑任务的概念，所以协程是一种轻量级的『线程』的说法，更多描述的是它的使用场景，这句话也许这样说更贴切一些：</p>\n<p><strong>协程更像一种轻量级的『线程』。</strong></p>\n<p>线程自然可以享受到并行计算的优待，协程则只能依赖程序内部的线程来实现并行计算。协程的优势其实更多是体现在 IO 密集型程序上，这对于 Java 开发者来说可能又是一个很迷惑的事情，因为大家写 Java 这么多年，很少有人用上 NIO，绝大多数都是用 BIO 来读写 IO，因此不管开线程还是开协程，读写 IO 的时候总是要有一个线程在等待 IO，所以看上去似乎也没有什么区别。但用 NIO 就不一样了，IO 不阻塞，通过开一个或很少的几个线程来 select IO 的事件，有 IO 事件到达时再分配相应的线程去读写 IO，比起传统的 IO 就已经有了很大的提升。</p>\n<p>欸？没有写错吗？你写的可是线程啊？</p>\n<p>对啊，用了 NIO 以后，本身就可以减少线程的使用，没错的。可是协程呢？协程可以基于这个思路进一步简化代码的组织，虽然线程就能解决问题，但写起来其实是很累的，协程可以让你更轻松，特别是遇到多个任务需要访问公共资源时，如果每个任务都分配一个线程去处理，那么少不了就有线程会花费大量的时间在等待获取锁上，但如果我们用协程来承载任务，用极少量的线程来承载协程，那么锁优化就变得简单了：协程如果无法获取到锁，那么协程挂起，对应的线程就可以让出去运行其他协程了。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712887435643.jpg\"></p>\n<p>我更愿意把协程作为更贴近业务逻辑甚至人类思考层面的一种抽象，这个抽象层次其实已经比线程更高了。线程可以让我们的程序并发的跑，协程可以让并发程序跑得看起来更美好。</p>\n<blockquote>\n<p>线程本身就可以，为什么要用协程呢？这就像我们经常被人问起 Java 就可以解决问题，我为什么要用 Kotlin 呢？为什么你说呢？</p>\n</blockquote>\n<h2 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6. 小结\"></a>6. 小结</h2><p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15712891180933.jpg\"></p>\n<p>总的来说，不管是异步代码同步化，还是并发代码简洁化，协程的出现其实是为代码从计算机向人类思维的贴近提供了可能。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#x66;&#64;&#x69;&#109;&#x6f;&#111;&#x63;&#46;&#x63;&#111;&#x6d;\">&#x6b;&#x66;&#64;&#x69;&#109;&#x6f;&#111;&#x63;&#46;&#x63;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"破解 Kotlin 协程(2) - 协程启动篇","keywords":"Kotlin 协程 启动模式","date":"2019-04-07T16:00:00.000Z","description":null,"_content":"\n> 现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。 \n\n<!-- more -->\n\n\n\n\n## 1. 回想一下刚学 Thread 的时候\n\n我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：\n\n```kotlin\nval thread = object : Thread(){\n    override fun run() {\n        super.run()\n        //do what you want to do.\n    }\n}\nthread.start()\n```\n\n肯定有人忘了调用 `start`，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 `start` 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 `stop` 可以用，结果他们很快发现设计 `stop` 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。\n\n> 既然 `stop` 是错误，那么总是让初学者丢掉的 `start` 是不是也是一个错误呢？\n\n哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：\n\n```kotlin\nval myThread = thread {\n    //do what you want\n}\n```\n\n这个 `thread` 方法有个参数 `start` 默认为 `true`，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：\n\n```kotlin\nval myThread = thread(start = false) {\n    //do what you want\n}\n//later on ...\nmyThread.start()\n```\n\n这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。\n\n## 2. 再来看看协程的启动\n\n说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：\n\n```kotlin\nGlobalScope.launch {\n    //do what you want\n}\n```\n\n那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 **上下文**、**启动模式**、**协程体**，**协程体** 就好比 `Thread.run` 当中的代码，自不必说。\n\n本文将为大家详细介绍 **启动模式**。在 Kotlin 协程当中，启动模式是一个枚举：\n\n```kotlin\npublic enum class CoroutineStart {\n    DEFAULT,\n    LAZY,\n    @ExperimentalCoroutinesApi\n    ATOMIC,\n    @ExperimentalCoroutinesApi\n    UNDISPATCHED;\n}\n```\n\n| 模式 | 功能 | \n| --- | --- |\n| DEFAULT | 立即执行协程体 | \n| ATOMIC | 立即执行协程体，但在开始运行之前无法取消 | \n| UNDISPATCHED | 立即在当前线程执行协程体，直到第一个 suspend 调用 |\n| LAZY | 只有在需要的情况下运行 |\n\n### 2.1 DEFAULT\n\n四个启动模式当中我们最常用的其实是 `DEFAULT` 和 `LAZY`。\n\n`DEFAULT` 是饿汉式启动，`launch` 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    val job = GlobalScope.launch {\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n```\n\n> 说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。\n\n这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：\n\n```kotlin\n19:51:08:160 [main] 1\n19:51:08:603 [main] 3\n19:51:08:606 [DefaultDispatcher-worker-1] 2\n19:51:08:624 [main] 4\n```\n\n也可能是：\n\n```kotlin\n20:19:06:367 [main] 1\n20:19:06:541 [DefaultDispatcher-worker-1] 2\n20:19:06:550 [main] 3\n20:19:06:551 [main] 4\n```\n这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。\n\n> JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。\n> \n> 当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。\n> \n> 更多调度器的话题，我们后续还会进一步讨论。\n\n### 2.2 LAZY\n\n`LAZY` 是懒汉式启动，`launch` 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， `launch` 调用后会返回一个 `Job` 实例，对于这种情况，我们可以：\n\n* 调用 `Job.start`，主动触发协程的调度执行\n* 调用 `Job.join`，隐式的触发协程的调度执行\n\n所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 `await` 来表达对 `Deferred` 的需要。这个行为与 `Thread.join` 不一样，后者如果没有启动的话，调用 `join` 不会有任何作用。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.start()\nlog(4)\n```\n\n基于此，对于上面的示例，输出的结果可能是：\n\n```\n14:56:28:374 [main] 1\n14:56:28:493 [main] 3\n14:56:28:511 [main] 4\n14:56:28:516 [DefaultDispatcher-worker-1] 2\n```\n\n当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 `join`，\n\n```kotlin\n...\nlog(3)\njob.join()\nlog(4)\n```\n\n因为要等待协程执行完毕，因此输出的结果一定是：\n\n```\n14:47:45:963 [main] 1\n14:47:46:054 [main] 3\n14:47:46:069 [DefaultDispatcher-worker-1] 2\n14:47:46:090 [main] 4\n```\n\n### 2.3 ATOMIC\n\n`ATOMIC` 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。\n\n为了搞清楚它与 `DEFAULT` 的区别，我们来看一段例子：\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n}\njob.cancel()\nlog(3)\n```\n我们创建了协程后立即 cancel，但由于是 `ATOMIC` 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。\n\n```\n20:42:42:783 [main] 1\n20:42:42:879 [main] 3\n20:42:42:879 [DefaultDispatcher-worker-1] 2\n```\n\n对应的，如果是 `DEFAULT` 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 `DEFAULT` 模式，那么 2 有可能会输出，也可能不会。\n\n需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过`ATOMIC` 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n    delay(1000)\n    log(3)\n}\njob.cancel()\nlog(4)\njob.join()\n```\n\n我们在 2 和 3 之间加了一个 `delay`，`delay` 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 `ATOMIC` 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 `delay` 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 `delay` 是支持 cancel 的，因此后面的 3 将不会被打印。\n\n> 我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。\n\n### 2.4 UNDISPATCHED\n\n有了前面的基础，`UNDISPATCHED` 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 `ATOMIC`，不同之处在于 `UNDISPATCHED` 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n    log(2)\n    delay(100)\n    log(3)\n}\nlog(4)\njob.join()\nlog(5)\n```\n我们还是以这样一个例子来认识下 `UNDISPATCHED` 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，`delay` 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，`join` 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：\n\n```\n22:00:31:693 [main] 1\n22:00:31:782 [main @coroutine#1] 2\n22:00:31:800 [main] 4\n22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3\n22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5\n```\n\n> 方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，`join` 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。\n\n## 3. 小结\n\n本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。\n\n## 附录\n\n`log` 函数的定义：\n\n```kotlin\nval dateFormat = SimpleDateFormat(\"HH:mm:ss:SSS\")\n\nval now = {\n    dateFormat.format(Date(System.currentTimeMillis()))\n}\n\nfun log(msg: Any?) = println(\"${now()} [${Thread.currentThread().name}] $msg\")\n```\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/coroutines-start-mode.md","raw":"---\ntitle:  破解 Kotlin 协程(2) - 协程启动篇 \nkeywords: Kotlin 协程 启动模式 \ndate: 2019/04/08\ndescription: \ntags:\n  - Kotlin\n  - Coroutine\n---\n\n> 现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。 \n\n<!-- more -->\n\n\n\n\n## 1. 回想一下刚学 Thread 的时候\n\n我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：\n\n```kotlin\nval thread = object : Thread(){\n    override fun run() {\n        super.run()\n        //do what you want to do.\n    }\n}\nthread.start()\n```\n\n肯定有人忘了调用 `start`，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 `start` 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 `stop` 可以用，结果他们很快发现设计 `stop` 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。\n\n> 既然 `stop` 是错误，那么总是让初学者丢掉的 `start` 是不是也是一个错误呢？\n\n哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：\n\n```kotlin\nval myThread = thread {\n    //do what you want\n}\n```\n\n这个 `thread` 方法有个参数 `start` 默认为 `true`，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：\n\n```kotlin\nval myThread = thread(start = false) {\n    //do what you want\n}\n//later on ...\nmyThread.start()\n```\n\n这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。\n\n## 2. 再来看看协程的启动\n\n说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：\n\n```kotlin\nGlobalScope.launch {\n    //do what you want\n}\n```\n\n那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 **上下文**、**启动模式**、**协程体**，**协程体** 就好比 `Thread.run` 当中的代码，自不必说。\n\n本文将为大家详细介绍 **启动模式**。在 Kotlin 协程当中，启动模式是一个枚举：\n\n```kotlin\npublic enum class CoroutineStart {\n    DEFAULT,\n    LAZY,\n    @ExperimentalCoroutinesApi\n    ATOMIC,\n    @ExperimentalCoroutinesApi\n    UNDISPATCHED;\n}\n```\n\n| 模式 | 功能 | \n| --- | --- |\n| DEFAULT | 立即执行协程体 | \n| ATOMIC | 立即执行协程体，但在开始运行之前无法取消 | \n| UNDISPATCHED | 立即在当前线程执行协程体，直到第一个 suspend 调用 |\n| LAZY | 只有在需要的情况下运行 |\n\n### 2.1 DEFAULT\n\n四个启动模式当中我们最常用的其实是 `DEFAULT` 和 `LAZY`。\n\n`DEFAULT` 是饿汉式启动，`launch` 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：\n\n```kotlin\nsuspend fun main() {\n    log(1)\n    val job = GlobalScope.launch {\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n```\n\n> 说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。\n\n这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：\n\n```kotlin\n19:51:08:160 [main] 1\n19:51:08:603 [main] 3\n19:51:08:606 [DefaultDispatcher-worker-1] 2\n19:51:08:624 [main] 4\n```\n\n也可能是：\n\n```kotlin\n20:19:06:367 [main] 1\n20:19:06:541 [DefaultDispatcher-worker-1] 2\n20:19:06:550 [main] 3\n20:19:06:551 [main] 4\n```\n这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。\n\n> JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。\n> \n> 当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。\n> \n> 更多调度器的话题，我们后续还会进一步讨论。\n\n### 2.2 LAZY\n\n`LAZY` 是懒汉式启动，`launch` 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， `launch` 调用后会返回一个 `Job` 实例，对于这种情况，我们可以：\n\n* 调用 `Job.start`，主动触发协程的调度执行\n* 调用 `Job.join`，隐式的触发协程的调度执行\n\n所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 `await` 来表达对 `Deferred` 的需要。这个行为与 `Thread.join` 不一样，后者如果没有启动的话，调用 `join` 不会有任何作用。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.start()\nlog(4)\n```\n\n基于此，对于上面的示例，输出的结果可能是：\n\n```\n14:56:28:374 [main] 1\n14:56:28:493 [main] 3\n14:56:28:511 [main] 4\n14:56:28:516 [DefaultDispatcher-worker-1] 2\n```\n\n当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 `join`，\n\n```kotlin\n...\nlog(3)\njob.join()\nlog(4)\n```\n\n因为要等待协程执行完毕，因此输出的结果一定是：\n\n```\n14:47:45:963 [main] 1\n14:47:46:054 [main] 3\n14:47:46:069 [DefaultDispatcher-worker-1] 2\n14:47:46:090 [main] 4\n```\n\n### 2.3 ATOMIC\n\n`ATOMIC` 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。\n\n为了搞清楚它与 `DEFAULT` 的区别，我们来看一段例子：\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n}\njob.cancel()\nlog(3)\n```\n我们创建了协程后立即 cancel，但由于是 `ATOMIC` 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。\n\n```\n20:42:42:783 [main] 1\n20:42:42:879 [main] 3\n20:42:42:879 [DefaultDispatcher-worker-1] 2\n```\n\n对应的，如果是 `DEFAULT` 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 `DEFAULT` 模式，那么 2 有可能会输出，也可能不会。\n\n需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过`ATOMIC` 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n    delay(1000)\n    log(3)\n}\njob.cancel()\nlog(4)\njob.join()\n```\n\n我们在 2 和 3 之间加了一个 `delay`，`delay` 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 `ATOMIC` 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 `delay` 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 `delay` 是支持 cancel 的，因此后面的 3 将不会被打印。\n\n> 我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。\n\n### 2.4 UNDISPATCHED\n\n有了前面的基础，`UNDISPATCHED` 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 `ATOMIC`，不同之处在于 `UNDISPATCHED` 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n    log(2)\n    delay(100)\n    log(3)\n}\nlog(4)\njob.join()\nlog(5)\n```\n我们还是以这样一个例子来认识下 `UNDISPATCHED` 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，`delay` 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，`join` 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：\n\n```\n22:00:31:693 [main] 1\n22:00:31:782 [main @coroutine#1] 2\n22:00:31:800 [main] 4\n22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3\n22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5\n```\n\n> 方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，`join` 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。\n\n## 3. 小结\n\n本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。\n\n## 附录\n\n`log` 函数的定义：\n\n```kotlin\nval dateFormat = SimpleDateFormat(\"HH:mm:ss:SSS\")\n\nval now = {\n    dateFormat.format(Date(System.currentTimeMillis()))\n}\n\nfun log(msg: Any?) = println(\"${now()} [${Thread.currentThread().name}] $msg\")\n```\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"coroutines-start-mode","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi00380012lduzb6b527ri","content":"<blockquote>\n<p>现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"1-回想一下刚学-Thread-的时候\"><a href=\"#1-回想一下刚学-Thread-的时候\" class=\"headerlink\" title=\"1. 回想一下刚学 Thread 的时候\"></a>1. 回想一下刚学 Thread 的时候</h2><p>我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = <span class=\"keyword\">object</span> : Thread()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run()</span><br><span class=\"line\">        <span class=\"comment\">//do what you want to do.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.start()</span><br></pre></td></tr></table></figure>\n\n<p>肯定有人忘了调用 <code>start</code>，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 <code>start</code> 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 <code>stop</code> 可以用，结果他们很快发现设计 <code>stop</code> 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。</p>\n<blockquote>\n<p>既然 <code>stop</code> 是错误，那么总是让初学者丢掉的 <code>start</code> 是不是也是一个错误呢？</p>\n</blockquote>\n<p>哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myThread = thread &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>thread</code> 方法有个参数 <code>start</code> 默认为 <code>true</code>，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myThread = thread(start = <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//later on ...</span></span><br><span class=\"line\">myThread.start()</span><br></pre></td></tr></table></figure>\n\n<p>这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。</p>\n<h2 id=\"2-再来看看协程的启动\"><a href=\"#2-再来看看协程的启动\" class=\"headerlink\" title=\"2. 再来看看协程的启动\"></a>2. 再来看看协程的启动</h2><p>说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 <strong>上下文</strong>、<strong>启动模式</strong>、<strong>协程体</strong>，<strong>协程体</strong> 就好比 <code>Thread.run</code> 当中的代码，自不必说。</p>\n<p>本文将为大家详细介绍 <strong>启动模式</strong>。在 Kotlin 协程当中，启动模式是一个枚举：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineStart</span> </span>&#123;</span><br><span class=\"line\">    DEFAULT,</span><br><span class=\"line\">    LAZY,</span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalCoroutinesApi</span></span><br><span class=\"line\">    ATOMIC,</span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalCoroutinesApi</span></span><br><span class=\"line\">    UNDISPATCHED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFAULT</td>\n<td>立即执行协程体</td>\n</tr>\n<tr>\n<td>ATOMIC</td>\n<td>立即执行协程体，但在开始运行之前无法取消</td>\n</tr>\n<tr>\n<td>UNDISPATCHED</td>\n<td>立即在当前线程执行协程体，直到第一个 suspend 调用</td>\n</tr>\n<tr>\n<td>LAZY</td>\n<td>只有在需要的情况下运行</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-DEFAULT\"><a href=\"#2-1-DEFAULT\" class=\"headerlink\" title=\"2.1 DEFAULT\"></a>2.1 DEFAULT</h3><p>四个启动模式当中我们最常用的其实是 <code>DEFAULT</code> 和 <code>LAZY</code>。</p>\n<p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    job.join()</span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。</p>\n</blockquote>\n<p>这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">160</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">603</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">606</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">624</span> [main] <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>也可能是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">367</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">541</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">550</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">551</span> [main] <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。</p>\n<blockquote>\n<p>JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。</p>\n<p>当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。</p>\n<p>更多调度器的话题，我们后续还会进一步讨论。</p>\n</blockquote>\n<h3 id=\"2-2-LAZY\"><a href=\"#2-2-LAZY\" class=\"headerlink\" title=\"2.2 LAZY\"></a>2.2 LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， <code>launch</code> 调用后会返回一个 <code>Job</code> 实例，对于这种情况，我们可以：</p>\n<ul>\n<li>调用 <code>Job.start</code>，主动触发协程的调度执行</li>\n<li>调用 <code>Job.join</code>，隐式的触发协程的调度执行</li>\n</ul>\n<p>所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 <code>await</code> 来表达对 <code>Deferred</code> 的需要。这个行为与 <code>Thread.join</code> 不一样，后者如果没有启动的话，调用 <code>join</code> 不会有任何作用。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job.start()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>基于此，对于上面的示例，输出的结果可能是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:56:28:374 [main] 1</span><br><span class=\"line\">14:56:28:493 [main] 3</span><br><span class=\"line\">14:56:28:511 [main] 4</span><br><span class=\"line\">14:56:28:516 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>\n\n<p>当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 <code>join</code>，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job.join()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>因为要等待协程执行完毕，因此输出的结果一定是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:47:45:963 [main] 1</span><br><span class=\"line\">14:47:46:054 [main] 3</span><br><span class=\"line\">14:47:46:069 [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">14:47:46:090 [main] 4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-ATOMIC\"><a href=\"#2-3-ATOMIC\" class=\"headerlink\" title=\"2.3 ATOMIC\"></a>2.3 ATOMIC</h3><p><code>ATOMIC</code> 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。</p>\n<p>为了搞清楚它与 <code>DEFAULT</code> 的区别，我们来看一段例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">job.cancel()</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>我们创建了协程后立即 cancel，但由于是 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20:42:42:783 [main] 1</span><br><span class=\"line\">20:42:42:879 [main] 3</span><br><span class=\"line\">20:42:42:879 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>\n\n<p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 <code>DEFAULT</code> 模式，那么 2 有可能会输出，也可能不会。</p>\n<p>需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过<code>ATOMIC</code> 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">job.cancel()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br><span class=\"line\">job.join()</span><br></pre></td></tr></table></figure>\n\n<p>我们在 2 和 3 之间加了一个 <code>delay</code>，<code>delay</code> 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 <code>ATOMIC</code> 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 <code>delay</code> 是支持 cancel 的，因此后面的 3 将不会被打印。</p>\n<blockquote>\n<p>我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。</p>\n</blockquote>\n<h3 id=\"2-4-UNDISPATCHED\"><a href=\"#2-4-UNDISPATCHED\" class=\"headerlink\" title=\"2.4 UNDISPATCHED\"></a>2.4 UNDISPATCHED</h3><p>有了前面的基础，<code>UNDISPATCHED</code> 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 <code>ATOMIC</code>，不同之处在于 <code>UNDISPATCHED</code> 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br><span class=\"line\">job.join()</span><br><span class=\"line\">log(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>我们还是以这样一个例子来认识下 <code>UNDISPATCHED</code> 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，<code>delay</code> 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，<code>join</code> 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:00:31:693 [main] 1</span><br><span class=\"line\">22:00:31:782 [main @coroutine#1] 2</span><br><span class=\"line\">22:00:31:800 [main] 4</span><br><span class=\"line\">22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class=\"line\">22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，<code>join</code> 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。</p>\n</blockquote>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><code>log</code> 函数的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dateFormat = SimpleDateFormat(<span class=\"string\">&quot;HH:mm:ss:SSS&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> now = &#123;</span><br><span class=\"line\">    dateFormat.format(Date(System.currentTimeMillis()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">Any</span>?)</span></span> = println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;now()&#125;</span> [<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#102;&#64;&#x69;&#x6d;&#111;&#x6f;&#x63;&#46;&#99;&#x6f;&#109;\">&#107;&#102;&#64;&#x69;&#x6d;&#111;&#x6f;&#x63;&#46;&#99;&#x6f;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>现在你已经知道协程大概是怎么回事了，也应该想要自己尝试一把了吧。本文将为大家详细介绍协程的几种启动模式之间的不同，当然，我不打算现在就开始深入源码剖析原理，大家只需要记住这些规则就能很好的使用协程了。 </p>\n</blockquote>","more":"<h2 id=\"1-回想一下刚学-Thread-的时候\"><a href=\"#1-回想一下刚学-Thread-的时候\" class=\"headerlink\" title=\"1. 回想一下刚学 Thread 的时候\"></a>1. 回想一下刚学 Thread 的时候</h2><p>我相信现在接触 Kotlin 的开发者绝大多数都有 Java 基础，我们刚开始学习 Thread 的时候，一定都是这样干的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> thread = <span class=\"keyword\">object</span> : Thread()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run()</span><br><span class=\"line\">        <span class=\"comment\">//do what you want to do.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">thread.start()</span><br></pre></td></tr></table></figure>\n\n<p>肯定有人忘了调用 <code>start</code>，还特别纳闷为啥我开的线程不启动呢。说实话，这个线程的 <code>start</code> 的设计其实是很奇怪的，不过我理解设计者们，毕竟当年还有 <code>stop</code> 可以用，结果他们很快发现设计 <code>stop</code> 就是一个错误，因为不安全而在 JDK 1.1 就废弃，称得上是最短命的 API 了吧。</p>\n<blockquote>\n<p>既然 <code>stop</code> 是错误，那么总是让初学者丢掉的 <code>start</code> 是不是也是一个错误呢？</p>\n</blockquote>\n<p>哈，有点儿跑题了。我们今天主要说 Kotlin。Kotlin 的设计者就很有想法，他们为线程提供了一个便捷的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myThread = thread &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>thread</code> 方法有个参数 <code>start</code> 默认为 <code>true</code>，换句话说，这样创造出来的线程默认就是启动的，除非你实在不想让它马上投入工作：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> myThread = thread(start = <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//later on ...</span></span><br><span class=\"line\">myThread.start()</span><br></pre></td></tr></table></figure>\n\n<p>这样看上去自然多了。接口设计就应该让默认值满足 80% 的需求嘛。</p>\n<h2 id=\"2-再来看看协程的启动\"><a href=\"#2-再来看看协程的启动\" class=\"headerlink\" title=\"2. 再来看看协程的启动\"></a>2. 再来看看协程的启动</h2><p>说了这么多线程，原因嘛，毕竟大家对它是最熟悉的。协程的 API 设计其实也与之一脉相承，我们来看一段最简单的启动协程的方式：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GlobalScope.launch &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do what you want</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么这段代码会怎么执行呢？我们说过，启动协程需要三样东西，分别是 <strong>上下文</strong>、<strong>启动模式</strong>、<strong>协程体</strong>，<strong>协程体</strong> 就好比 <code>Thread.run</code> 当中的代码，自不必说。</p>\n<p>本文将为大家详细介绍 <strong>启动模式</strong>。在 Kotlin 协程当中，启动模式是一个枚举：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoroutineStart</span> </span>&#123;</span><br><span class=\"line\">    DEFAULT,</span><br><span class=\"line\">    LAZY,</span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalCoroutinesApi</span></span><br><span class=\"line\">    ATOMIC,</span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalCoroutinesApi</span></span><br><span class=\"line\">    UNDISPATCHED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFAULT</td>\n<td>立即执行协程体</td>\n</tr>\n<tr>\n<td>ATOMIC</td>\n<td>立即执行协程体，但在开始运行之前无法取消</td>\n</tr>\n<tr>\n<td>UNDISPATCHED</td>\n<td>立即在当前线程执行协程体，直到第一个 suspend 调用</td>\n</tr>\n<tr>\n<td>LAZY</td>\n<td>只有在需要的情况下运行</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-DEFAULT\"><a href=\"#2-1-DEFAULT\" class=\"headerlink\" title=\"2.1 DEFAULT\"></a>2.1 DEFAULT</h3><p>四个启动模式当中我们最常用的其实是 <code>DEFAULT</code> 和 <code>LAZY</code>。</p>\n<p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入待调度状态，一旦调度器 OK 就可以开始执行。我们来看个简单的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    job.join()</span><br><span class=\"line\">    log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>说明： main 函数 支持 suspend 是从 Kotlin 1.3 开始的。另外，main 函数省略参数也是 Kotlin 1.3 的特性。后面的示例没有特别说明都是直接运行在 suspend main 函数当中。</p>\n</blockquote>\n<p>这段程序采用默认的启动模式，由于我们也没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现与其他语言的实现类似，它在后台专门会有一些线程处理异步任务，所以上述程序的运行结果可能是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">160</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">603</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">606</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">19</span>:<span class=\"number\">51</span>:08:<span class=\"number\">624</span> [main] <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>也可能是：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">367</span> [main] <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">541</span> [DefaultDispatcher-worker-<span class=\"number\">1</span>] <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">550</span> [main] <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">19</span>:<span class=\"number\">06</span>:<span class=\"number\">551</span> [main] <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这取决于 CPU 对于当前线程与后台线程的调度顺序，不过不要担心，很快你就会发现这个例子当中 2 和 3 的输出顺序其实并没有那么重要。</p>\n<blockquote>\n<p>JVM 上默认调度器的实现也许你已经猜到，没错，就是开了一个线程池，但区区几个线程足以调度成千上万个协程，而且每一个协程都有自己的调用栈，这与纯粹的开线程池去执行异步任务有本质的区别。</p>\n<p>当然，我们说 Kotlin 是一门跨平台的语言，因此上述代码还可以运行在 JavaScript 环境中，例如 Nodejs。在 Nodejs 中，Kotlin 协程的默认调度器则并没有实现线程的切换，输出结果也会略有不同，这样似乎更符合 JavaScript 的执行逻辑。</p>\n<p>更多调度器的话题，我们后续还会进一步讨论。</p>\n</blockquote>\n<h3 id=\"2-2-LAZY\"><a href=\"#2-2-LAZY\" class=\"headerlink\" title=\"2.2 LAZY\"></a>2.2 LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。这其实就有点儿费解了，什么叫我们需要它执行的时候呢？就是需要它的运行结果的时候， <code>launch</code> 调用后会返回一个 <code>Job</code> 实例，对于这种情况，我们可以：</p>\n<ul>\n<li>调用 <code>Job.start</code>，主动触发协程的调度执行</li>\n<li>调用 <code>Job.join</code>，隐式的触发协程的调度执行</li>\n</ul>\n<p>所以这个所谓的”需要“，其实是一个很有趣的措辞，后面你还会看到我们也可以通过 <code>await</code> 来表达对 <code>Deferred</code> 的需要。这个行为与 <code>Thread.join</code> 不一样，后者如果没有启动的话，调用 <code>join</code> 不会有任何作用。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job.start()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>基于此，对于上面的示例，输出的结果可能是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:56:28:374 [main] 1</span><br><span class=\"line\">14:56:28:493 [main] 3</span><br><span class=\"line\">14:56:28:511 [main] 4</span><br><span class=\"line\">14:56:28:516 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>\n\n<p>当然如果你运气够好，也可能出现 2 比 4 在前面的情况。而对于 <code>join</code>，</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br><span class=\"line\">job.join()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>因为要等待协程执行完毕，因此输出的结果一定是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:47:45:963 [main] 1</span><br><span class=\"line\">14:47:46:054 [main] 3</span><br><span class=\"line\">14:47:46:069 [DefaultDispatcher-worker-1] 2</span><br><span class=\"line\">14:47:46:090 [main] 4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-ATOMIC\"><a href=\"#2-3-ATOMIC\" class=\"headerlink\" title=\"2.3 ATOMIC\"></a>2.3 ATOMIC</h3><p><code>ATOMIC</code> 只有涉及 cancel 的时候才有意义，cancel 本身也是一个值得详细讨论的话题，在这里我们就简单认为 cancel 后协程会被取消掉，也就是不再执行了。那么调用 cancel 的时机不同，结果也是有差异的，例如协程调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等。</p>\n<p>为了搞清楚它与 <code>DEFAULT</code> 的区别，我们来看一段例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">job.cancel()</span><br><span class=\"line\">log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>我们创建了协程后立即 cancel，但由于是 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1、2、3 一定都会输出，只是 2 和 3 的顺序就难说了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20:42:42:783 [main] 1</span><br><span class=\"line\">20:42:42:879 [main] 3</span><br><span class=\"line\">20:42:42:879 [DefaultDispatcher-worker-1] 2</span><br></pre></td></tr></table></figure>\n\n<p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时如果 cancel 就已经调用，那么协程就会直接被 cancel 而不会有任何调用，当然也有可能协程开始时尚未被 cancel，那么它就可以正常启动了。所以前面的例子如果改用 <code>DEFAULT</code> 模式，那么 2 有可能会输出，也可能不会。</p>\n<p>需要注意的是，cancel 调用一定会将该 job 的状态置为 cancelling，只不过<code>ATOMIC</code> 模式的协程在启动时无视了这一状态。为了证明这一点，我们可以让例子稍微复杂一些：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">job.cancel()</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br><span class=\"line\">job.join()</span><br></pre></td></tr></table></figure>\n\n<p>我们在 2 和 3 之间加了一个 <code>delay</code>，<code>delay</code> 会使得协程体的执行被挂起，1000ms 之后再次调度后面的部分，因此 3 会在 2 执行之后 1000ms 时输出。对于 <code>ATOMIC</code> 模式，我们已经讨论过它一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 suspend 函数，这时我们的协程迎来了自己的第一个挂起点，恰好 <code>delay</code> 是支持 cancel 的，因此后面的 3 将不会被打印。</p>\n<blockquote>\n<p>我们使用线程的时候，想要让线程里面的任务停止执行也会面临类似的问题，但遗憾的是线程中看上去与 cancel 相近的 stop 接口已经被废弃，因为存在一些安全的问题。不过随着我们不断地深入探讨，你就会发现协程的 cancel 某种意义上更像线程的 interrupt。</p>\n</blockquote>\n<h3 id=\"2-4-UNDISPATCHED\"><a href=\"#2-4-UNDISPATCHED\" class=\"headerlink\" title=\"2.4 UNDISPATCHED\"></a>2.4 UNDISPATCHED</h3><p>有了前面的基础，<code>UNDISPATCHED</code> 就很容易理解了。协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这听起来有点儿像前面的 <code>ATOMIC</code>，不同之处在于 <code>UNDISPATCHED</code> 不经过任何调度器即开始执行协程体。当然遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文当中的调度器了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(<span class=\"number\">4</span>)</span><br><span class=\"line\">job.join()</span><br><span class=\"line\">log(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>我们还是以这样一个例子来认识下 <code>UNDISPATCHED</code> 模式，按照我们前面的讨论，协程启动后会立即在当前线程执行，因此 1、2 会连续在同一线程中执行，<code>delay</code> 是挂起点，因此 3 会等 100ms 后再次调度，这时候 4 执行，<code>join</code> 要求等待协程执行完，因此等 3 输出后再执行 5。以下是运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:00:31:693 [main] 1</span><br><span class=\"line\">22:00:31:782 [main @coroutine#1] 2</span><br><span class=\"line\">22:00:31:800 [main] 4</span><br><span class=\"line\">22:00:31:914 [DefaultDispatcher-worker-1 @coroutine#1] 3</span><br><span class=\"line\">22:00:31:916 [DefaultDispatcher-worker-1 @coroutine#1] 5</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>方括号当中是线程名，我们发现协程执行时会修改线程名来让自己显得颇有存在感。运行结果看上去还有一个细节可能会让人困惑，<code>join</code> 之后的 5 的线程与 3 一样，这是为什么？我们在前面提到我们的示例都运行在 suspend main 函数当中，所以 suspend main 函数会帮我们直接启动一个协程，而我们示例的协程都是它的子协程，所以这里 5 的调度取决于这个最外层的协程的调度规则了。关于协程的调度，我们后面再聊。</p>\n</blockquote>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>本文通过一些例子来给大家逐步揭开协程的面纱。相信大家读完对于协程的执行机制有了一个大概的认识，同时对于协程的调度这个话题想必也非常好奇或者感到困惑，这是正常的——因为我们还没有讲嘛，放心，调度器的内容已经安排了 : )。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><code>log</code> 函数的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dateFormat = SimpleDateFormat(<span class=\"string\">&quot;HH:mm:ss:SSS&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> now = &#123;</span><br><span class=\"line\">    dateFormat.format(Date(System.currentTimeMillis()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">Any</span>?)</span></span> = println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;now()&#125;</span> [<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#107;&#102;&#64;&#x69;&#x6d;&#111;&#x6f;&#x63;&#46;&#99;&#x6f;&#109;\">&#107;&#102;&#64;&#x69;&#x6d;&#111;&#x6f;&#x63;&#46;&#99;&#x6f;&#109;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"也许你需要这个为数据类生成 DeepCopy 方法的库","date":"2018-12-01T16:00:00.000Z","_content":"\n前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。\n\n<!--more-->\n\n## 我们有什么拷贝的需求？\n\n我们知道 Kotlin 的 data class 出厂自带了一套 `copy` 方法，这个 `copy` 方法呢，就是实打实的一个浅拷贝，例如：\n\n```kotlin\ndata class GitUser(val name: String)\n```\n它的 `copy` 方法其实就相当于：\n\n```kotlin\ndata class GitUser(val name: String) {\n    fun copy(name: String = this.name) = GitUser(name)\n}\n```\n\n如果成员是 `val` 那倒也还好，可如果是另一个数据类呢？\n\n```kotlin\ndata class GitUser(val name: String)\ndata class Project(val name: String)\ndata class Owner(val gitUser: GitUser, val project: Project)\n```\n\n我们如果需要 `copy` 一下 `Owner` 的话，我们就会发现新实例与旧实例共享了 `GitUser` 和 `Project` 的实例，万一项目的名称是可以改的：\n\n```kotlin\ndata class Project(var name: String)\n```\n\n新实例的 `project` 的名称我想更改一下，结果发现老实例的也被改了。\n\n所以你需要一个 DeepCopy 的方法：\n\n```kotlin\ndata class Owner(val gitUser: GitUser, val project: Project){\n    fun deepCopy(gitUser: GitUser = this.gitUser, project: Project = this.project): Owner {\n        return Owner(gitUser.copy(), project.copy())\n    }\n}\n```\n\n你这时候想，虽然 `GitUser` 和 `Project` 这两个数据类内部的字段都是基本类型，用 `copy` 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 `deepCopy` 方法。。。\n\n## 来来来，先实现个简单的\n\n天哪。那岂不是要写死了。\n\n不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ\n\n于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 `deepCopy` 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～\n\n```kotlin\nfun <T : Any> T.deepCopy(): T {\n    //①判断是否为数据类，不是的话直接返回\n    if (!this::class.isData) {\n        return this\n    }\n    //②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型\n    return this::class.primaryConstructor!!.let { primaryConstructor ->\n        primaryConstructor.parameters\n            .map { parameter ->\n                val value =\n                    (this::class as KClass<T>).declaredMemberProperties.first { it.name == parameter.name }.get(this)\n                //③如果主构造器参数类型为数据类，递归调用\n                if ((parameter.type.classifier as? KClass<*>)?.isData == true) {\n                    parameter to value?.deepCopy()\n                } else {\n                    parameter to value\n                }\n            }\n            .toMap()\n            .let(primaryConstructor::callBy)\n    }\n}\n```\n\n看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~* \n\n其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻\n \n这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：\n\n```gradle\ncompile 'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'\n```\n\n当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——\n\n## 来我们再试试注解处理器\n\n注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。\n\n不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 `Metadata` 来获取到这些信息。\n\n读取 `Metadata` 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：\n\n``` gradle\ncompile \"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4\"\n```\n\n读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ\n\n需要提一句的是，我们通过注解处理器生成的 `deepCopy` 可以添加默认参数，这里有不少细节需要处理，也是得益于 `Metadata` 的信息。\n\n下面给大家看看例子吧：\n\n首先添加依赖，配置注解处理器：\n\n```gradle\nrepositories {\n    jcenter()\n    //kotlinx-metadata-jvm 目前部署到了这个仓库\n    maven { url \"https://kotlin.bintray.com/kotlinx/\" }\n}\n\n...\napply plugin: \"kotlin-kapt\"\n...\n\ndependencies {\n    kapt 'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'\n    compile 'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'\n}\n```\n\n接着为我们的数据类配置注解：\n\n```kotlin\n@DeepCopy\ndata class GitUser(val name: String)\n\n@DeepCopy\ndata class Project(val name: String)\n\n@DeepCopy\ndata class Owner(val gitUser: GitUser, val project: Project)\n```\n\nbuild 一下，生成了下面的扩展函数：\n\n```kotlin\nfun Owner.deepCopy(gitUser: GitUser = this.gitUser, project: Project = this.project): Owner =\n    Owner(gitUser.deepCopy(), project.deepCopy()) \n```\n\n我们看到，这已经跟出厂自带的 `copy` 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 `DeepCopy`，如果标注，就递归调用对应的 `deepCopy` 函数。\n\n其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：\n\n```kotlin\nfun Owner.deepCopy(): Owner = Owner(gitUser.deepCopy(), project.deepCopy()) \n```\n\n可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：\n\n```kotlin\n@DeepCopy\ndata class GenericParameter(val map: HashMap<String, List<String>>)\n\n@DeepCopy\ndata class GenericParameterT<K: Number, V>(val map: HashMap<K, V>)\n\n@DeepCopy\ndata class StarProjection(val map: List<Map<*, String>>)\n\n@DeepCopy\ndata class Variances1(val map: HashMap<String, out List<Number>>)\n```\n\n如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。\n\n\n## 项目详情\n\n这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：[https://github.com/enbandari/KotlinDeepCopy](https://github.com/enbandari/KotlinDeepCopy)，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。\n\n别犹豫了，Star 一波吧，千万别手软。\n\n---\n转载请注明出处：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n","source":"_posts/deepcopy.md","raw":"---\ntitle: 也许你需要这个为数据类生成 DeepCopy 方法的库\ndate: 2018/12/02\ntags:\n  - Kotlin\n  - dataclass\n---\n\n前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。\n\n<!--more-->\n\n## 我们有什么拷贝的需求？\n\n我们知道 Kotlin 的 data class 出厂自带了一套 `copy` 方法，这个 `copy` 方法呢，就是实打实的一个浅拷贝，例如：\n\n```kotlin\ndata class GitUser(val name: String)\n```\n它的 `copy` 方法其实就相当于：\n\n```kotlin\ndata class GitUser(val name: String) {\n    fun copy(name: String = this.name) = GitUser(name)\n}\n```\n\n如果成员是 `val` 那倒也还好，可如果是另一个数据类呢？\n\n```kotlin\ndata class GitUser(val name: String)\ndata class Project(val name: String)\ndata class Owner(val gitUser: GitUser, val project: Project)\n```\n\n我们如果需要 `copy` 一下 `Owner` 的话，我们就会发现新实例与旧实例共享了 `GitUser` 和 `Project` 的实例，万一项目的名称是可以改的：\n\n```kotlin\ndata class Project(var name: String)\n```\n\n新实例的 `project` 的名称我想更改一下，结果发现老实例的也被改了。\n\n所以你需要一个 DeepCopy 的方法：\n\n```kotlin\ndata class Owner(val gitUser: GitUser, val project: Project){\n    fun deepCopy(gitUser: GitUser = this.gitUser, project: Project = this.project): Owner {\n        return Owner(gitUser.copy(), project.copy())\n    }\n}\n```\n\n你这时候想，虽然 `GitUser` 和 `Project` 这两个数据类内部的字段都是基本类型，用 `copy` 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 `deepCopy` 方法。。。\n\n## 来来来，先实现个简单的\n\n天哪。那岂不是要写死了。\n\n不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ\n\n于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 `deepCopy` 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～\n\n```kotlin\nfun <T : Any> T.deepCopy(): T {\n    //①判断是否为数据类，不是的话直接返回\n    if (!this::class.isData) {\n        return this\n    }\n    //②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型\n    return this::class.primaryConstructor!!.let { primaryConstructor ->\n        primaryConstructor.parameters\n            .map { parameter ->\n                val value =\n                    (this::class as KClass<T>).declaredMemberProperties.first { it.name == parameter.name }.get(this)\n                //③如果主构造器参数类型为数据类，递归调用\n                if ((parameter.type.classifier as? KClass<*>)?.isData == true) {\n                    parameter to value?.deepCopy()\n                } else {\n                    parameter to value\n                }\n            }\n            .toMap()\n            .let(primaryConstructor::callBy)\n    }\n}\n```\n\n看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~* \n\n其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻\n \n这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：\n\n```gradle\ncompile 'com.bennyhuo.kotlin:deepcopy-reflect:1.1.0'\n```\n\n当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——\n\n## 来我们再试试注解处理器\n\n注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。\n\n不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 `Metadata` 来获取到这些信息。\n\n读取 `Metadata` 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：\n\n``` gradle\ncompile \"org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4\"\n```\n\n读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ\n\n需要提一句的是，我们通过注解处理器生成的 `deepCopy` 可以添加默认参数，这里有不少细节需要处理，也是得益于 `Metadata` 的信息。\n\n下面给大家看看例子吧：\n\n首先添加依赖，配置注解处理器：\n\n```gradle\nrepositories {\n    jcenter()\n    //kotlinx-metadata-jvm 目前部署到了这个仓库\n    maven { url \"https://kotlin.bintray.com/kotlinx/\" }\n}\n\n...\napply plugin: \"kotlin-kapt\"\n...\n\ndependencies {\n    kapt 'com.bennyhuo.kotlin:deepcopy-compiler:1.1.0'\n    compile 'com.bennyhuo.kotlin:deepcopy-annotations:1.1.0'\n}\n```\n\n接着为我们的数据类配置注解：\n\n```kotlin\n@DeepCopy\ndata class GitUser(val name: String)\n\n@DeepCopy\ndata class Project(val name: String)\n\n@DeepCopy\ndata class Owner(val gitUser: GitUser, val project: Project)\n```\n\nbuild 一下，生成了下面的扩展函数：\n\n```kotlin\nfun Owner.deepCopy(gitUser: GitUser = this.gitUser, project: Project = this.project): Owner =\n    Owner(gitUser.deepCopy(), project.deepCopy()) \n```\n\n我们看到，这已经跟出厂自带的 `copy` 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 `DeepCopy`，如果标注，就递归调用对应的 `deepCopy` 函数。\n\n其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：\n\n```kotlin\nfun Owner.deepCopy(): Owner = Owner(gitUser.deepCopy(), project.deepCopy()) \n```\n\n可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：\n\n```kotlin\n@DeepCopy\ndata class GenericParameter(val map: HashMap<String, List<String>>)\n\n@DeepCopy\ndata class GenericParameterT<K: Number, V>(val map: HashMap<K, V>)\n\n@DeepCopy\ndata class StarProjection(val map: List<Map<*, String>>)\n\n@DeepCopy\ndata class Variances1(val map: HashMap<String, out List<Number>>)\n```\n\n如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。\n\n\n## 项目详情\n\n这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：[https://github.com/enbandari/KotlinDeepCopy](https://github.com/enbandari/KotlinDeepCopy)，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。\n\n别犹豫了，Star 一波吧，千万别手软。\n\n---\n转载请注明出处：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n","slug":"deepcopy","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003a0013lduz7ojx9z9v","content":"<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"我们有什么拷贝的需求？\"><a href=\"#我们有什么拷贝的需求？\" class=\"headerlink\" title=\"我们有什么拷贝的需求？\"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br></pre></td></tr></table></figure>\n<p>它的 <code>copy</code> 方法其实就相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">copy</span><span class=\"params\">(name: <span class=\"type\">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)</span><br></pre></td></tr></table></figure>\n\n<p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">var</span> name: String)</span><br></pre></td></tr></table></figure>\n\n<p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p>\n<p>所以你需要一个 DeepCopy 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deepCopy</span><span class=\"params\">(gitUser: <span class=\"type\">GitUser</span> = this.gitUser, project: <span class=\"type\">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p>\n<h2 id=\"来来来，先实现个简单的\"><a href=\"#来来来，先实现个简单的\" class=\"headerlink\" title=\"来来来，先实现个简单的\"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p>\n<p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p>\n<p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> T.<span class=\"title\">deepCopy</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"comment\">//①判断是否为数据类，不是的话直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.isData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.primaryConstructor!!.let &#123; primaryConstructor -&gt;</span><br><span class=\"line\">        primaryConstructor.parameters</span><br><span class=\"line\">            .map &#123; parameter -&gt;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> value =</span><br><span class=\"line\">                    (<span class=\"keyword\">this</span>::<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">as</span> <span class=\"title\">KClass</span>&lt;<span class=\"type\">T</span>&gt;).<span class=\"title\">declaredMemberProperties</span>.<span class=\"title\">first</span> </span>&#123; it.name == parameter.name &#125;.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"comment\">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((parameter.type.classifier <span class=\"keyword\">as</span>? KClass&lt;*&gt;)?.isData == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    parameter to value?.deepCopy()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parameter to value</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            .toMap()</span><br><span class=\"line\">            .let(primaryConstructor::callBy)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~* </p>\n<p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p>\n<p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-reflect:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p>\n<h2 id=\"来我们再试试注解处理器\"><a href=\"#来我们再试试注解处理器\" class=\"headerlink\" title=\"来我们再试试注解处理器\"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p>\n<p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p>\n<p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&quot;org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p>\n<p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p>\n<p>下面给大家看看例子吧：</p>\n<p>首先添加依赖，配置注解处理器：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    <span class=\"comment\">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class=\"line\">    maven &#123; url <span class=\"string\">&quot;https://kotlin.bintray.com/kotlinx/&quot;</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">apply plugin: <span class=\"string\">&quot;kotlin-kapt&quot;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-compiler:1.1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-annotations:1.1.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着为我们的数据类配置注解：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)</span><br></pre></td></tr></table></figure>\n\n<p>build 一下，生成了下面的扩展函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Owner.<span class=\"title\">deepCopy</span><span class=\"params\">(gitUser: <span class=\"type\">GitUser</span> = this.gitUser, project: <span class=\"type\">Project</span> = this.project)</span></span>: Owner =</span><br><span class=\"line\">    Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p>\n<p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Owner.<span class=\"title\">deepCopy</span><span class=\"params\">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>\n\n<p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericParameter</span></span>(<span class=\"keyword\">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericParameterT</span>&lt;<span class=\"type\">K: Number, V</span>&gt;</span>(<span class=\"keyword\">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StarProjection</span></span>(<span class=\"keyword\">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Variances1</span></span>(<span class=\"keyword\">val</span> map: HashMap&lt;String, <span class=\"keyword\">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p>\n<h2 id=\"项目详情\"><a href=\"#项目详情\" class=\"headerlink\" title=\"项目详情\"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href=\"https://github.com/enbandari/KotlinDeepCopy\">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p>\n<p>别犹豫了，Star 一波吧，千万别手软。</p>\n<hr>\n<p>转载请注明出处：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>\n","site":{"data":{}},"excerpt":"<p>前不久 JetBrains 在北京搞了一次技术大会，我在演讲当中提到了一个叫 DeepCopy 的库，那么我们今天就来详细说说它。</p>","more":"<h2 id=\"我们有什么拷贝的需求？\"><a href=\"#我们有什么拷贝的需求？\" class=\"headerlink\" title=\"我们有什么拷贝的需求？\"></a>我们有什么拷贝的需求？</h2><p>我们知道 Kotlin 的 data class 出厂自带了一套 <code>copy</code> 方法，这个 <code>copy</code> 方法呢，就是实打实的一个浅拷贝，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br></pre></td></tr></table></figure>\n<p>它的 <code>copy</code> 方法其实就相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">copy</span><span class=\"params\">(name: <span class=\"type\">String</span> = this.name)</span></span> = GitUser(name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果成员是 <code>val</code> 那倒也还好，可如果是另一个数据类呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)</span><br></pre></td></tr></table></figure>\n\n<p>我们如果需要 <code>copy</code> 一下 <code>Owner</code> 的话，我们就会发现新实例与旧实例共享了 <code>GitUser</code> 和 <code>Project</code> 的实例，万一项目的名称是可以改的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">var</span> name: String)</span><br></pre></td></tr></table></figure>\n\n<p>新实例的 <code>project</code> 的名称我想更改一下，结果发现老实例的也被改了。</p>\n<p>所以你需要一个 DeepCopy 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">deepCopy</span><span class=\"params\">(gitUser: <span class=\"type\">GitUser</span> = this.gitUser, project: <span class=\"type\">Project</span> = this.project)</span></span>: Owner &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Owner(gitUser.copy(), project.copy())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你这时候想，虽然 <code>GitUser</code> 和 <code>Project</code> 这两个数据类内部的字段都是基本类型，用 <code>copy</code> 进行复制似乎也问题不大，可如果它们的成员当中也存在数据类呢？所以，你需要为每一个数据类定制一个 <code>deepCopy</code> 方法。。。</p>\n<h2 id=\"来来来，先实现个简单的\"><a href=\"#来来来，先实现个简单的\" class=\"headerlink\" title=\"来来来，先实现个简单的\"></a>来来来，先实现个简单的</h2><p>天哪。那岂不是要写死了。</p>\n<p>不过问题不大，我们总是会想办法让编译器或者运行时来帮我们搞定一切，于是我想到了要不要写个 Kotlin 的编译期插件呢，正巧 KotlinConf 也有人分享了一下这个话题，不过由于目前这套机制还没有正式开放，就算我写了你们也不敢用，更何况我还不会写呢ψ(｀∇´)ψ</p>\n<p>于是我想到了最简单的，用反射！用反射再配合 Kotlin 最优秀的特性之一的扩展方法，我们就可以为所有的类无缝提供一个 <code>deepCopy</code> 的扩展方法，当然，我们的目标是为数据类服务，所以其他类调用这个方法我们一概直接返回(～￣▽￣)～</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> T.<span class=\"title\">deepCopy</span><span class=\"params\">()</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"comment\">//①判断是否为数据类，不是的话直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.isData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//②数据类一定有主构造器，不用怕，这里放心使用 !! 来转为非空类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.primaryConstructor!!.let &#123; primaryConstructor -&gt;</span><br><span class=\"line\">        primaryConstructor.parameters</span><br><span class=\"line\">            .map &#123; parameter -&gt;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> value =</span><br><span class=\"line\">                    (<span class=\"keyword\">this</span>::<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">as</span> <span class=\"title\">KClass</span>&lt;<span class=\"type\">T</span>&gt;).<span class=\"title\">declaredMemberProperties</span>.<span class=\"title\">first</span> </span>&#123; it.name == parameter.name &#125;.<span class=\"keyword\">get</span>(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"comment\">//③如果主构造器参数类型为数据类，递归调用</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((parameter.type.classifier <span class=\"keyword\">as</span>? KClass&lt;*&gt;)?.isData == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    parameter to value?.deepCopy()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parameter to value</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            .toMap()</span><br><span class=\"line\">            .let(primaryConstructor::callBy)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上去很简单吧！正好秀一波反射的肌肉(￣▽￣)~* </p>\n<p>其实反射还真挺简单的，不会反射的小伙伴们也不要害怕，现在大家都觉得反射有性能问题而不敢用，不会就不会吧(╯°□°）╯︵┻━┻</p>\n<p>这个库我已经扔到 jcenter，因此你可以通过添加依赖来使用它：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-reflect:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，这里由于是运行时才知道类型的构造器参数列表，因此没办法添加默认参数。但注解处理器可以呀，不信你瞧——</p>\n<h2 id=\"来我们再试试注解处理器\"><a href=\"#来我们再试试注解处理器\" class=\"headerlink\" title=\"来我们再试试注解处理器\"></a>来我们再试试注解处理器</h2><p>注解处理器实现理论上是可以的。额，实际上当然也是可以的，不然这在 JetBrains 大会上讲过的东西要是不行的话，我可丢不起那人。。。</p>\n<p>不过有些细节需要注意，我们在 Java 编译期的角度是无法认知哪些是数据类的，也没有什么所谓的主构造器一说，所以我们需要通过 <code>Metadata</code> 来获取到这些信息。</p>\n<p>读取 <code>Metadata</code> 需要用到下面这个框架，其实 Kotlin 反射跟这个原理一样，不同之处在于反射在运行时读取，我们则在编译时读取：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">&quot;org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.0.4&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>读取的方法我就不细说啦，后面我会提供源码，大家有兴趣可以花两分钟详细阅读下ヽ(；´Д｀)ﾉ</p>\n<p>需要提一句的是，我们通过注解处理器生成的 <code>deepCopy</code> 可以添加默认参数，这里有不少细节需要处理，也是得益于 <code>Metadata</code> 的信息。</p>\n<p>下面给大家看看例子吧：</p>\n<p>首先添加依赖，配置注解处理器：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    <span class=\"comment\">//kotlinx-metadata-jvm 目前部署到了这个仓库</span></span><br><span class=\"line\">    maven &#123; url <span class=\"string\">&quot;https://kotlin.bintray.com/kotlinx/&quot;</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">apply plugin: <span class=\"string\">&quot;kotlin-kapt&quot;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    kapt <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-compiler:1.1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">&#x27;com.bennyhuo.kotlin:deepcopy-annotations:1.1.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着为我们的数据类配置注解：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitUser</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Project</span></span>(<span class=\"keyword\">val</span> name: String)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Owner</span></span>(<span class=\"keyword\">val</span> gitUser: GitUser, <span class=\"keyword\">val</span> project: Project)</span><br></pre></td></tr></table></figure>\n\n<p>build 一下，生成了下面的扩展函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Owner.<span class=\"title\">deepCopy</span><span class=\"params\">(gitUser: <span class=\"type\">GitUser</span> = this.gitUser, project: <span class=\"type\">Project</span> = this.project)</span></span>: Owner =</span><br><span class=\"line\">    Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>\n\n<p>我们看到，这已经跟出厂自带的 <code>copy</code> 很像了，不同之处就是我们会递归的检查哪些数据类被标注为 <code>DeepCopy</code>，如果标注，就递归调用对应的 <code>deepCopy</code> 函数。</p>\n<p>其实如果不添加默认值，这个注解处理器非常容易写的，因为它不需要处理泛型，不需要处理与 Java 的类型映射，也不需要处理别名，一气呵成，就像这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Owner.<span class=\"title\">deepCopy</span><span class=\"params\">()</span></span>: Owner = Owner(gitUser.deepCopy(), project.deepCopy()) </span><br></pre></td></tr></table></figure>\n\n<p>可是一旦加上了默认值，那就意味着我们需要为函数添加参数，那么我们就需要搞清楚参数的类型，是否协变，等等。但仍然问题不大，经过一下午的折腾（耽误了我看 KPL 季后赛了都），我们支持了参数类型有泛型实参，形参，星投影，甚至泛型参数嵌套，型变，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericParameter</span></span>(<span class=\"keyword\">val</span> map: HashMap&lt;String, List&lt;String&gt;&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericParameterT</span>&lt;<span class=\"type\">K: Number, V</span>&gt;</span>(<span class=\"keyword\">val</span> map: HashMap&lt;K, V&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StarProjection</span></span>(<span class=\"keyword\">val</span> map: List&lt;Map&lt;*, String&gt;&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@DeepCopy</span></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Variances1</span></span>(<span class=\"keyword\">val</span> map: HashMap&lt;String, <span class=\"keyword\">out</span> List&lt;Number&gt;&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>如果还有哪些情况没有覆盖到，那么尽管给我开 Issue 就好啦。</p>\n<h2 id=\"项目详情\"><a href=\"#项目详情\" class=\"headerlink\" title=\"项目详情\"></a>项目详情</h2><p>这个项目在 11月17日的 JetBrains 大会上我已经提到过了，项目在 Github 上，地址：<a href=\"https://github.com/enbandari/KotlinDeepCopy\">https://github.com/enbandari/KotlinDeepCopy</a>，我知道公众号没法点地址，因此点击阅读原文，就可以很方便的找到它。</p>\n<p>别犹豫了，Star 一波吧，千万别手软。</p>\n<hr>\n<p>转载请注明出处：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"要再见了吗，Kotlin Android Extension","keywords":"Kotlin 1.4 KAE","date":"2020-11-06T16:00:00.000Z","description":null,"_content":"\n> 伴随了我们这么多年的 KAE，就这么要离开我们了？ \n\n\n\n<!-- more -->\n\n\n\n\n前几天看到邮件说 [Kotlin 1.4.20-M2](https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2) 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？\n\n紧接着我们就可以看到一行：[Deprecate Kotlin Android Extensions compiler plugin](https://youtrack.jetbrains.com/issue/KT-42121)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png)\n\n说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。\n\n非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称**合成的属性**。\n\n## 销毁之后的空指针\n\nKAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。\n\n这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。\n\n```kotlin\n...\nimport kotlinx.android.synthetic.main.activity_main.*\n\nclass MainFragment : Fragment() {\n    ...\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n\n        textView.text = \"Crash!\"\n    }\n}\n```\n\n必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：\n\n```kotlin\nlateinit var textView: TextView\n\noverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n    textView = view.findViewById(R.id.textView)\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n\n    textView.text = \"Nothing happened.\"\n}\n```\n\n这样的代码虽然看上去不怎么高明，但它至少不会 Crash。\n\nKotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。\n\n就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 ```lifecycleScope.launchWhenResumed{ ... }``` 就能很好的解决这个问题。\n\n这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。\n\n## 张冠李戴\n\n由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。\n\n例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：\n\n```kotlin\nimport kotlinx.android.synthetic.main.fragment_main.*\n\n...\n\ntextView.text = \"MainActivity\"\n```\n\n编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。\n\n这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。\n\n## 冲突的 ID\n\n还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。\n\n为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\">\n\n  <TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n然后在 Activity 或者 Fragment 当中加载这两个 layout：\n\n```kotlin\nval tipsView = View.inflate(view.context, R.layout.view_tips, null)\nval warningView = View.inflate(view.context, R.layout.view_warning, null)\n\ntipsView.textView.text = \"Tips\"\nwarningView.textView.text = \"Warning\"\n\n... // 添加到对应的父 View 当中\n```\n\n那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：\n\n```kotlin\nkotlinx.android.synthetic.main.view_tips.view.*\nkotlinx.android.synthetic.main.view_warning.view.*\n```\n\n我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。\n\n![image-20201107095613833](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png)\n\n运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，`warningView.textView` 其实就等价于 `warningView.findViewById(R.id.textView)`：\n\n```asm\nALOAD 4\nDUP\nLDC \"warningView\"\nGETSTATIC com/bennyhuo/helloandroid/R$id.textView : I\nINVOKEVIRTUAL android/view/View.findViewById (I)Landroid/view/View;\nCHECKCAST android/widget/TextView\n```\n\n所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。\n\n另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：\n\n```kotlin\nobject ViewTipsLayout {\n\n  val View.textView: TextView\n    get() = findViewById(R.id.textView)\n\n}\n\nobject ViewWarningLayout {\n\n  val View.textView: TextView\n    get() = findViewById(R.id.textView)\n\n}\n```\n\n那么使用的时候如果产生 id 冲突，就可以这样：\n\n```kotlin\nwith(ViewTipsLayout) {\n  tipsView.textView.text = \"Tips\"\n}\n\nwith(ViewWarningLayout) {\n  warningView.textView.text = \"Warning\"\n}\n```\n\n当然，这只是我们的设想了。毕竟都要废弃了。\n\n## 不支持 Compose\n\n去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。\n\nAnko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。\n\nKotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 [skiko](https://github.com/JetBrains/skiko) 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 [compose-jb](https://github.com/JetBrains/compose-jb) 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。\n\n对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。\n\n> KAE：我这么优秀！\n>\n> Compose：你给我让开！\n\n## 使用 ViewBinding 作为替代方案\n\n那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png)\n\nKotlin 官方建议开发者使用 Android 的 [View Binding](https://developer.android.com/topic/libraries/view-binding) 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：\n\n```kotlin\nprivate var _binding: ResultProfileBinding? = null\n// This property is only valid between onCreateView and\n// onDestroyView.\nprivate val binding get() = _binding!!\n\noverride fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?\n): View? {\n    _binding = ResultProfileBinding.inflate(inflater, container, false)\n    val view = binding.root\n    return view\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n    _binding = null\n}\n```\n\n访问 View 时：\n\n```kotlin\nbinding.name.text = viewModel.name\nbinding.button.setOnClickListener { viewModel.userClicked() }\n```\n\n相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。\n\n我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。\n\n其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？\n\n```kotlin\nabstract class ViewBindingFragment<T: ViewBinding>: Fragment() {\n\n    private var _binding: T? = null\n\n    val binding: T\n        get() = _binding!!\n\n    abstract fun onCreateBinding(inflater: LayoutInflater,\n                                 container: ViewGroup?,\n                                 savedInstanceState: Bundle?): T\n    abstract fun T.onViewCreated()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return onCreateBinding(inflater, container, savedInstanceState).also {\n            _binding = it\n        }.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.onViewCreated()\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n这样用的时候直接继承这个类就好了：\n\n```kotlin\nclass MainFragment : ViewBindingFragment<FragmentMainBinding>() {\n\n    override fun onCreateBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentMainBinding {\n        return FragmentMainBinding.inflate(inflater, container, false)\n    }\n\n    override fun FragmentMainBinding.onViewCreated() {\n        textView.text = \"MainFragment\"\n        textView.setOnClickListener {\n            Toast.makeText(requireContext(), \"Clicked.\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}\n```\n\n这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。\n\n## 小结\n\nKAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。\n\n相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。\n\n不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。\n\n再见，KAE。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/deprecated-kotlin-android-extensions.md","raw":"---\ntitle:  要再见了吗，Kotlin Android Extension  \nkeywords: Kotlin 1.4 KAE \ndate: 2020/11/07\ndescription: \ntags: \n    - kotlin\n    - android\n    - news \n---\n\n> 伴随了我们这么多年的 KAE，就这么要离开我们了？ \n\n\n\n<!-- more -->\n\n\n\n\n前几天看到邮件说 [Kotlin 1.4.20-M2](https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2) 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？\n\n紧接着我们就可以看到一行：[Deprecate Kotlin Android Extensions compiler plugin](https://youtrack.jetbrains.com/issue/KT-42121)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png)\n\n说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。\n\n非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称**合成的属性**。\n\n## 销毁之后的空指针\n\nKAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。\n\n这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。\n\n```kotlin\n...\nimport kotlinx.android.synthetic.main.activity_main.*\n\nclass MainFragment : Fragment() {\n    ...\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n\n        textView.text = \"Crash!\"\n    }\n}\n```\n\n必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：\n\n```kotlin\nlateinit var textView: TextView\n\noverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n    textView = view.findViewById(R.id.textView)\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n\n    textView.text = \"Nothing happened.\"\n}\n```\n\n这样的代码虽然看上去不怎么高明，但它至少不会 Crash。\n\nKotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。\n\n就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 ```lifecycleScope.launchWhenResumed{ ... }``` 就能很好的解决这个问题。\n\n这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。\n\n## 张冠李戴\n\n由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。\n\n例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：\n\n```kotlin\nimport kotlinx.android.synthetic.main.fragment_main.*\n\n...\n\ntextView.text = \"MainActivity\"\n```\n\n编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。\n\n这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。\n\n## 冲突的 ID\n\n还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。\n\n为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\">\n\n  <TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintLeft_toLeftOf=\"parent\"\n    app:layout_constraintRight_toRightOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n然后在 Activity 或者 Fragment 当中加载这两个 layout：\n\n```kotlin\nval tipsView = View.inflate(view.context, R.layout.view_tips, null)\nval warningView = View.inflate(view.context, R.layout.view_warning, null)\n\ntipsView.textView.text = \"Tips\"\nwarningView.textView.text = \"Warning\"\n\n... // 添加到对应的父 View 当中\n```\n\n那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：\n\n```kotlin\nkotlinx.android.synthetic.main.view_tips.view.*\nkotlinx.android.synthetic.main.view_warning.view.*\n```\n\n我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。\n\n![image-20201107095613833](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png)\n\n运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，`warningView.textView` 其实就等价于 `warningView.findViewById(R.id.textView)`：\n\n```asm\nALOAD 4\nDUP\nLDC \"warningView\"\nGETSTATIC com/bennyhuo/helloandroid/R$id.textView : I\nINVOKEVIRTUAL android/view/View.findViewById (I)Landroid/view/View;\nCHECKCAST android/widget/TextView\n```\n\n所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。\n\n另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：\n\n```kotlin\nobject ViewTipsLayout {\n\n  val View.textView: TextView\n    get() = findViewById(R.id.textView)\n\n}\n\nobject ViewWarningLayout {\n\n  val View.textView: TextView\n    get() = findViewById(R.id.textView)\n\n}\n```\n\n那么使用的时候如果产生 id 冲突，就可以这样：\n\n```kotlin\nwith(ViewTipsLayout) {\n  tipsView.textView.text = \"Tips\"\n}\n\nwith(ViewWarningLayout) {\n  warningView.textView.text = \"Warning\"\n}\n```\n\n当然，这只是我们的设想了。毕竟都要废弃了。\n\n## 不支持 Compose\n\n去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。\n\nAnko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。\n\nKotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 [skiko](https://github.com/JetBrains/skiko) 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 [compose-jb](https://github.com/JetBrains/compose-jb) 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。\n\n对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。\n\n> KAE：我这么优秀！\n>\n> Compose：你给我让开！\n\n## 使用 ViewBinding 作为替代方案\n\n那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png)\n\nKotlin 官方建议开发者使用 Android 的 [View Binding](https://developer.android.com/topic/libraries/view-binding) 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：\n\n```kotlin\nprivate var _binding: ResultProfileBinding? = null\n// This property is only valid between onCreateView and\n// onDestroyView.\nprivate val binding get() = _binding!!\n\noverride fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?\n): View? {\n    _binding = ResultProfileBinding.inflate(inflater, container, false)\n    val view = binding.root\n    return view\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n    _binding = null\n}\n```\n\n访问 View 时：\n\n```kotlin\nbinding.name.text = viewModel.name\nbinding.button.setOnClickListener { viewModel.userClicked() }\n```\n\n相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。\n\n我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。\n\n其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？\n\n```kotlin\nabstract class ViewBindingFragment<T: ViewBinding>: Fragment() {\n\n    private var _binding: T? = null\n\n    val binding: T\n        get() = _binding!!\n\n    abstract fun onCreateBinding(inflater: LayoutInflater,\n                                 container: ViewGroup?,\n                                 savedInstanceState: Bundle?): T\n    abstract fun T.onViewCreated()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return onCreateBinding(inflater, container, savedInstanceState).also {\n            _binding = it\n        }.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        binding.onViewCreated()\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n这样用的时候直接继承这个类就好了：\n\n```kotlin\nclass MainFragment : ViewBindingFragment<FragmentMainBinding>() {\n\n    override fun onCreateBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentMainBinding {\n        return FragmentMainBinding.inflate(inflater, container, false)\n    }\n\n    override fun FragmentMainBinding.onViewCreated() {\n        textView.text = \"MainFragment\"\n        textView.setOnClickListener {\n            Toast.makeText(requireContext(), \"Clicked.\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}\n```\n\n这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。\n\n## 小结\n\nKAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。\n\n相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。\n\n不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。\n\n再见，KAE。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"deprecated-kotlin-android-extensions","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003a0014lduz3gb1g2kl","content":"<blockquote>\n<p>伴随了我们这么多年的 KAE，就这么要离开我们了？ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>前几天看到邮件说 <a href=\"https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2\">Kotlin 1.4.20-M2</a> 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？</p>\n<p>紧接着我们就可以看到一行：<a href=\"https://youtrack.jetbrains.com/issue/KT-42121\">Deprecate Kotlin Android Extensions compiler plugin</a>。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png\"></p>\n<p>说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。</p>\n<p>非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称<strong>合成的属性</strong>。</p>\n<h2 id=\"销毁之后的空指针\"><a href=\"#销毁之后的空指针\" class=\"headerlink\" title=\"销毁之后的空指针\"></a>销毁之后的空指针</h2><p>KAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。</p>\n<p>这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.text = <span class=\"string\">&quot;Crash!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> textView: TextView</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">    textView = view.findViewById(R.id.textView)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\"></span><br><span class=\"line\">    textView.text = <span class=\"string\">&quot;Nothing happened.&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码虽然看上去不怎么高明，但它至少不会 Crash。</p>\n<p>Kotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。</p>\n<p>就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 <code>lifecycleScope.launchWhenResumed&#123; ... &#125;</code> 就能很好的解决这个问题。</p>\n<p>这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。</p>\n<h2 id=\"张冠李戴\"><a href=\"#张冠李戴\" class=\"headerlink\" title=\"张冠李戴\"></a>张冠李戴</h2><p>由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。</p>\n<p>例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.android.synthetic.main.fragment_main.*</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">textView.text = <span class=\"string\">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。</p>\n<p>这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。</p>\n<h2 id=\"冲突的-ID\"><a href=\"#冲突的-ID\" class=\"headerlink\" title=\"冲突的 ID\"></a>冲突的 ID</h2><p>还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。</p>\n<p>为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/textView&quot;</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在 Activity 或者 Fragment 当中加载这两个 layout：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tipsView = View.inflate(view.context, R.layout.view_tips, <span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> warningView = View.inflate(view.context, R.layout.view_warning, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">tipsView.textView.text = <span class=\"string\">&quot;Tips&quot;</span></span><br><span class=\"line\">warningView.textView.text = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 添加到对应的父 View 当中</span></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinx.android.synthetic.main.view_tips.view.*</span><br><span class=\"line\">kotlinx.android.synthetic.main.view_warning.view.*</span><br></pre></td></tr></table></figure>\n\n<p>我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png\" alt=\"image-20201107095613833\"></p>\n<p>运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，<code>warningView.textView</code> 其实就等价于 <code>warningView.findViewById(R.id.textView)</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALOAD 4</span><br><span class=\"line\">DUP</span><br><span class=\"line\">LDC &quot;warningView&quot;</span><br><span class=\"line\">GETSTATIC com&#x2F;bennyhuo&#x2F;helloandroid&#x2F;R$id.textView : I</span><br><span class=\"line\">INVOKEVIRTUAL android&#x2F;view&#x2F;View.findViewById (I)Landroid&#x2F;view&#x2F;View;</span><br><span class=\"line\">CHECKCAST android&#x2F;widget&#x2F;TextView</span><br></pre></td></tr></table></figure>\n\n<p>所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。</p>\n<p>另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> ViewTipsLayout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> View.textView: TextView</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = findViewById(R.id.textView)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">object</span> ViewWarningLayout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> View.textView: TextView</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = findViewById(R.id.textView)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么使用的时候如果产生 id 冲突，就可以这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(ViewTipsLayout) &#123;</span><br><span class=\"line\">  tipsView.textView.text = <span class=\"string\">&quot;Tips&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">with(ViewWarningLayout) &#123;</span><br><span class=\"line\">  warningView.textView.text = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这只是我们的设想了。毕竟都要废弃了。</p>\n<h2 id=\"不支持-Compose\"><a href=\"#不支持-Compose\" class=\"headerlink\" title=\"不支持 Compose\"></a>不支持 Compose</h2><p>去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。</p>\n<p>Anko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。</p>\n<p>Kotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 <a href=\"https://github.com/JetBrains/skiko\">skiko</a> 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 <a href=\"https://github.com/JetBrains/compose-jb\">compose-jb</a> 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。</p>\n<p>对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。</p>\n<blockquote>\n<p>KAE：我这么优秀！</p>\n<p>Compose：你给我让开！</p>\n</blockquote>\n<h2 id=\"使用-ViewBinding-作为替代方案\"><a href=\"#使用-ViewBinding-作为替代方案\" class=\"headerlink\" title=\"使用 ViewBinding 作为替代方案\"></a>使用 ViewBinding 作为替代方案</h2><p>那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png\"></p>\n<p>Kotlin 官方建议开发者使用 Android 的 <a href=\"https://developer.android.com/topic/libraries/view-binding\">View Binding</a> 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> _binding: ResultProfileBinding? = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// This property is only valid between onCreateView and</span></span><br><span class=\"line\"><span class=\"comment\">// onDestroyView.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> binding <span class=\"keyword\">get</span>() = _binding!!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: View? &#123;</span><br><span class=\"line\">    _binding = ResultProfileBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> view = binding.root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> view</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\">    _binding = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问 View 时：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.name.text = viewModel.name</span><br><span class=\"line\">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。</p>\n<p>我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。</p>\n<p>其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewBindingFragment</span>&lt;<span class=\"type\">T: ViewBinding</span>&gt;: <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> _binding: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> binding: T</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = _binding!!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateBinding</span><span class=\"params\">(inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span>: T</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> T.<span class=\"title\">onViewCreated</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: View? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> onCreateBinding(inflater, container, savedInstanceState).also &#123;</span><br><span class=\"line\">            _binding = it</span><br><span class=\"line\">        &#125;.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.onViewCreated()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\">        _binding = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样用的时候直接继承这个类就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainFragment</span> : <span class=\"type\">ViewBindingFragment</span>&lt;<span class=\"type\">FragmentMainBinding</span>&gt;</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateBinding</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: FragmentMainBinding &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FragmentMainBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> FragmentMainBinding.<span class=\"title\">onViewCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        textView.text = <span class=\"string\">&quot;MainFragment&quot;</span></span><br><span class=\"line\">        textView.setOnClickListener &#123;</span><br><span class=\"line\">            Toast.makeText(requireContext(), <span class=\"string\">&quot;Clicked.&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>KAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。</p>\n<p>相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。</p>\n<p>不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。</p>\n<p>再见，KAE。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>伴随了我们这么多年的 KAE，就这么要离开我们了？ </p>\n</blockquote>","more":"<p>前几天看到邮件说 <a href=\"https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2\">Kotlin 1.4.20-M2</a> 发布了，于是打开看了看更新，发现有个新的用于 Parcelize 的插件。要知道这个功能一直都是集成在 KAE 当中的，那 KAE 呢？</p>\n<p>紧接着我们就可以看到一行：<a href=\"https://youtrack.jetbrains.com/issue/KT-42121\">Deprecate Kotlin Android Extensions compiler plugin</a>。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png\"></p>\n<p>说实话，直接废弃，我还是有些意外的。毕竟这个插件在早期为 Kotlin 攻城略地快速吸引 Android 开发者立下了汗马功劳，多年来虽然几乎没有功能更新，但直到现在仍然能够胜任绝大多数场景。</p>\n<p>非要说废弃的理由，确实也能罗列几个出来。为了方便，我们把以 layout 当中 View 的 id 为名而合成的属性简称<strong>合成的属性</strong>。</p>\n<h2 id=\"销毁之后的空指针\"><a href=\"#销毁之后的空指针\" class=\"headerlink\" title=\"销毁之后的空指针\"></a>销毁之后的空指针</h2><p>KAE 是通过在字节码层面添加合成属性来解决 findViewById 的问题的，对于 Activity 和 Fragment 而言，合成的属性背后其实就是一个缓存，这个缓存会在 Activity 的 onDestroy、Fragment 的 onDestroyView 的时候清空。所以每次访问合成的属性，其实只有第一次是调用 findViewById，之后就是一个查缓存的过程。</p>\n<p>这个设计很合理，不过也不免有些危险存在。主要是在 Fragment 当中，如果不小心在 onDestroyView 调用之后访问了这些合成的属性，就会抛一个空指针异常，因为此时缓存已经被清空，而 Fragment 的 View 也被置为 null 了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.text = <span class=\"string\">&quot;Crash!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>必须说明的一点是，这里抛空指针是合理的，毕竟 Fragment 的 View 的生命周期已经结束了，不过生产实践当中很多时候不是一句“合理”就能解决问题的，我们要的更多的是给老板减少损失。这里如果 textView 仍然可以访问，它不过是修改了一下文字而已，不会有其他副作用，但恰恰因为 KAE 这里严格的遵守了生命周期的变化清空了缓存，却又没有办法阻止开发者继续访问这个合成属性而导致空指针。对比而言，如果我们直接使用 findViewById，情况可能是下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> textView: TextView</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">    textView = view.findViewById(R.id.textView)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\"></span><br><span class=\"line\">    textView.text = <span class=\"string\">&quot;Nothing happened.&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码虽然看上去不怎么高明，但它至少不会 Crash。</p>\n<p>Kotlin 一向追求代码的安全性，而且希望在编译时就把代码运行时可能产生的问题尽可能地暴露出来。在很多场景下 Kotlin 确实做得很好，然而 KAE 并没有做到这一点。</p>\n<p>就这个具体的问题而言，倒也很容易解决，现在 Android 当中已经有了足够多的生命周期管理工具，我们能够很好的避免在 Fragment 或者 Activity 的生命周期结束之后还要执行一些相关的操作。例如使用 <code>lifecycleScope.launchWhenResumed&#123; ... &#125;</code> 就能很好的解决这个问题。</p>\n<p>这么看来，这一点似乎不算是 KAE 本身的缺陷。难道是我们要求太高了？不，降低标准的事儿我们是绝不会做的，Kotlin 官方这么多年都没有解决这个问题，快出来挨打 （╬￣皿￣）＝○＃（￣＃）３￣） 。</p>\n<h2 id=\"张冠李戴\"><a href=\"#张冠李戴\" class=\"headerlink\" title=\"张冠李戴\"></a>张冠李戴</h2><p>由于合成的属性只能从 Receiver 的类型上做限制，无法确定对应的 View、Activity、Fragment 当中是否真实存在这个合成的属性对应 id 的 View，因此也存在访问安全性上的隐患。</p>\n<p>例如我当前的 Activity 的 layout 是 activity_main.xml，其中并未定义 id 为 textView 的 View，然而下面的写法却不会在编译时报错：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.android.synthetic.main.fragment_main.*</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">textView.text = <span class=\"string\">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>编译时高高兴兴，运行时就要垂头丧气了，因为 findViewById 一定会返回 null，而合成的属性又不是可空类型。</p>\n<p>这个问题从现有的 KAE 的思路上来看，确实不太好解决，不过从多年的实践来看，这也许都算不上是一个问题，至少我用了快 5 年 KAE，只有偶尔几次写错 id 以外，多数情况下不会出现此类问题。这个问题确实算是一个缺陷，但它的影响实在是有限。</p>\n<h2 id=\"冲突的-ID\"><a href=\"#冲突的-ID\" class=\"headerlink\" title=\"冲突的 ID\"></a>冲突的 ID</h2><p>还有一个问题就是命名空间的问题。合成的属性从导包的形式上来看，像是以 layout 的文件名加上固定的前缀合成的包下的顶级属性，一旦这个包被导入，当前的整个文件当中都可以使用 View、Activity、Fragment 来访问这些合成的属性，这就及其容易导致命名空间冲突的问题。</p>\n<p>为了说明问题，我们创建两个完全相同的 layout，分别命名为 view_tips.xml 和 view_warning.xml，里面只是简单的包含一个 id 为 textView 的 TextView</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xmlns:app</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/textView&quot;</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在 Activity 或者 Fragment 当中加载这两个 layout：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> tipsView = View.inflate(view.context, R.layout.view_tips, <span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> warningView = View.inflate(view.context, R.layout.view_warning, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">tipsView.textView.text = <span class=\"string\">&quot;Tips&quot;</span></span><br><span class=\"line\">warningView.textView.text = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 添加到对应的父 View 当中</span></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候我们就要面临一个导包的问题，tipsView 和 warningView 访问的合成属性可能来自于以下两个包：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinx.android.synthetic.main.view_tips.view.*</span><br><span class=\"line\">kotlinx.android.synthetic.main.view_warning.view.*</span><br></pre></td></tr></table></figure>\n\n<p>我们当然可以把二者一并导入，但问题在于二者即便如此，合成的属性在编译时静态绑定也只能绑定到一个包下面的合成属性下，这样的结果就是我们在 Android Studio 当中点击 warningView.textView 可能会跳转到 view_tips 这个 layout 当中。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20201107095613833.png\" alt=\"image-20201107095613833\"></p>\n<p>运行时会不会有问题呢？那倒不至于，因为你始终记住合成属性在运行时会替换成 findViewById 就可以了，只要 findViewById 不出问题，那合成属性自然也不存在问题。从生成的字节码来看，<code>warningView.textView</code> 其实就等价于 <code>warningView.findViewById(R.id.textView)</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALOAD 4</span><br><span class=\"line\">DUP</span><br><span class=\"line\">LDC &quot;warningView&quot;</span><br><span class=\"line\">GETSTATIC com&#x2F;bennyhuo&#x2F;helloandroid&#x2F;R$id.textView : I</span><br><span class=\"line\">INVOKEVIRTUAL android&#x2F;view&#x2F;View.findViewById (I)Landroid&#x2F;view&#x2F;View;</span><br><span class=\"line\">CHECKCAST android&#x2F;widget&#x2F;TextView</span><br></pre></td></tr></table></figure>\n\n<p>所以这个问题本质上影响的是开发体验。出现冲突，一方面可能是类文件太大，包含的 UI 逻辑过多，导致引入过多的 layout，从而产生冲突；另一方面也可能是布局上拆分得太小，一个视图的逻辑类当中不得不引入大量的 layout 导致冲突。通过合理的设计 UI 相关的类，这个问题本身也可以很好的规避。</p>\n<p>另外，如果语言本身支持把包名作为命名空间，在代码访问时直接予以限定，一样可以达到目的。按照现有的语法特性，如果合成的属性是在一个 object 当中定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">object</span> ViewTipsLayout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> View.textView: TextView</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = findViewById(R.id.textView)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">object</span> ViewWarningLayout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> View.textView: TextView</span><br><span class=\"line\">    <span class=\"keyword\">get</span>() = findViewById(R.id.textView)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么使用的时候如果产生 id 冲突，就可以这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(ViewTipsLayout) &#123;</span><br><span class=\"line\">  tipsView.textView.text = <span class=\"string\">&quot;Tips&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">with(ViewWarningLayout) &#123;</span><br><span class=\"line\">  warningView.textView.text = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这只是我们的设想了。毕竟都要废弃了。</p>\n<h2 id=\"不支持-Compose\"><a href=\"#不支持-Compose\" class=\"headerlink\" title=\"不支持 Compose\"></a>不支持 Compose</h2><p>去年的时候 Anko 就被废弃了，这么想来，KAE 能苟活这么久大概是因为根本不怎么需要维护吧？在这里提 Anko 到不是为了嘲讽，Anko 虽然离开了我们，可 Anko 所倡导的 DSL 布局的精神却留了下来，也就是 Jetpack 当中仍然处于 Alpha 状态（怎么都是 Alpha，难道这么久了还不配有个 Beta 吗）的 Compose 了。</p>\n<p>Anko Layout 不算成功，主要原因还是开发成本的问题。预览要等编译，编译又要很久，这简直了，谁用谁知道。隔壁家的 SwiftUI 就做得很好，说明鱼和熊掌还是可以兼得的，所以我看好 Compose，就看 Android 还能活几年，能不能等到那个时候了（哈哈哈，开玩笑）。</p>\n<p>Kotlin 最近一直在推 KMM，大家都在猜 Kotlin 官方会不会搞一个 React Kotlin Native 或者 Klutter 出来，结果最近我们就看到 JetBrains 的 GitHub 下一个叫 <a href=\"https://github.com/JetBrains/skiko\">skiko</a> 的框架非常活跃，它是基于 Kotlin 多平台特性封装的 Skia 的 API（Flutter：喵喵喵？？）。还有一个就是 <a href=\"https://github.com/JetBrains/compose-jb\">compose-jb</a> 了，我粗略看了下，目前已经把 Compose 移植到了桌面上，支持了 Windows、Linux、macOS，也不知道 iOS 被安排了没有（真实司马昭之心啊）。所以 Compose 已经不再是 Android 的了，它是大家的。</p>\n<p>对于 Compose 而言，KAE 一点儿用都没有，因为人家根本不需要做 View 绑定好不好。</p>\n<blockquote>\n<p>KAE：我这么优秀！</p>\n<p>Compose：你给我让开！</p>\n</blockquote>\n<h2 id=\"使用-ViewBinding-作为替代方案\"><a href=\"#使用-ViewBinding-作为替代方案\" class=\"headerlink\" title=\"使用 ViewBinding 作为替代方案\"></a>使用 ViewBinding 作为替代方案</h2><p>那么问题来了，KAE 废弃之后会怎么样呢？按照链接当中的说明来看，废弃之后仍然可以使用，但会有一个警告；当然，出现问题官方也不会再修复了，更不会有新功能。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-01-08-16-09.png\"></p>\n<p>Kotlin 官方建议开发者使用 Android 的 <a href=\"https://developer.android.com/topic/libraries/view-binding\">View Binding</a> 来解决此类场景的问题。客观的讲 View Binding 确实能解决前面提到的几个 KAE 存在的问题，但 View Binding 的写法上也会略显啰嗦：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> _binding: ResultProfileBinding? = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// This property is only valid between onCreateView and</span></span><br><span class=\"line\"><span class=\"comment\">// onDestroyView.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> binding <span class=\"keyword\">get</span>() = _binding!!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: View? &#123;</span><br><span class=\"line\">    _binding = ResultProfileBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> view = binding.root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> view</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\">    _binding = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问 View 时：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding.name.text = viewModel.name</span><br><span class=\"line\">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比之下，KAE 解决了 findViewById 的类型安全和访问繁琐的问题；而 View Binding 则在此基础上又解决了空安全的问题。</p>\n<p>我看到在废弃 KAE 的讨论中，大家还是觉得废弃有些难以理解，毕竟之前你也没怎么管这个插件啊，这么多年了除了加了个 Parcelize 的功能以外，也没怎么着啊。不过历史的车轮总是在往前滚（(ノ｀Д)ノ）的嘛，Kotlin 官方这么急着废弃 KAE，也许就是要为 View Binding 让路，JetBrains 现在和 Google 穿一条裤子，谁知道他们是不是有什么对未来的美（si）好（xia）规（jiao）划（yi）呢？哈哈，玩笑啦。</p>\n<p>其实 View Binding 除了写起来多了几行代码以外，别的倒也没什么大毛病。而写法复杂这个嘛，其实说来也简单，我们稍微封装一下不就行了么？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewBindingFragment</span>&lt;<span class=\"type\">T: ViewBinding</span>&gt;: <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> _binding: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> binding: T</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = _binding!!</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateBinding</span><span class=\"params\">(inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span>: T</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> T.<span class=\"title\">onViewCreated</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateView</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: View? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> onCreateBinding(inflater, container, savedInstanceState).also &#123;</span><br><span class=\"line\">            _binding = it</span><br><span class=\"line\">        &#125;.root</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewCreated</span><span class=\"params\">(view: <span class=\"type\">View</span>, savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class=\"line\">        binding.onViewCreated()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroyView</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroyView()</span><br><span class=\"line\">        _binding = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样用的时候直接继承这个类就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainFragment</span> : <span class=\"type\">ViewBindingFragment</span>&lt;<span class=\"type\">FragmentMainBinding</span>&gt;</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreateBinding</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        inflater: <span class=\"type\">LayoutInflater</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        container: <span class=\"type\">ViewGroup</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        savedInstanceState: <span class=\"type\">Bundle</span>?</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: FragmentMainBinding &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FragmentMainBinding.inflate(inflater, container, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> FragmentMainBinding.<span class=\"title\">onViewCreated</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        textView.text = <span class=\"string\">&quot;MainFragment&quot;</span></span><br><span class=\"line\">        textView.setOnClickListener &#123;</span><br><span class=\"line\">            Toast.makeText(requireContext(), <span class=\"string\">&quot;Clicked.&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个也就是我随手那么一写，肯定算不上完美，但至少说明 View Binding 的写法一样可以做到很简洁。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>KAE 本质上就是通过编译期生成字节码的方式为 Activity、Fragment、View 提供了以 xml 布局中的 id 为名的合成属性，从而简化使用 findViewById 来实现 View 绑定的一个插件。</p>\n<p>相比之下，KAE 比 findViewById 本身提供了更简便的 View 绑定方式，也保证了 View 的类型安全，但却无法保证 View 的空安全 —— 而这些问题都在 ViewBinding 当中得到了解决。</p>\n<p>不管怎样，KAE 被废弃是没什么悬念了，它曾经一度填补了 Android 开发体验上的空缺，也曾经一度受到追捧和质疑，更曾是 Kotlin 早期吸引 Android 开发者的一把利器，现在终于完成了它自己的历史任务。</p>\n<p>再见，KAE。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"要再见了吗，Kotlin Android Extension","path":"2020/11/07/deprecated-kotlin-android-extensions/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-11-05-15-18-42.png","excerpt":"<blockquote>\n<p>伴随了我们这么多年的 KAE，就这么要离开我们了？ </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-11-06T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-11-06T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","android","news"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"如何看待 Google 将 Kotlin 作为 Android 开发首选语言？","keywords":"Android Kotlin Google Java","date":"2019-05-09T16:00:00.000Z","description":null,"_content":"\n> 如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。 \n\n<!-- more -->\n\n\n\n\n相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。\n\nKotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。\n\n我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。\n\n我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 [Android开发必备知识：为什么说Kotlin值得一试](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=404087761&idx=1&sn=d80625ee52f860a7a2ed4c238d2151b6) 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。\n\nKotlin 究竟有多香呢？\n\n讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。\n\n**解放碑 50° 么，我的天！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg)\n\n后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。\n\n那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。\n\n大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。\n\n说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。\n\n所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。\n\n共勉吧。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/google-preferred-kotlin.md","raw":"---\ntitle:  如何看待 Google 将 Kotlin 作为 Android 开发首选语言？ \nkeywords: Android Kotlin Google Java \ndate: 2019/05/10\ndescription: \ntags:\n  - Kotlin\n  - Android\n---\n\n> 如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。 \n\n<!-- more -->\n\n\n\n\n相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。\n\nKotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。\n\n我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。\n\n我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 [Android开发必备知识：为什么说Kotlin值得一试](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=404087761&idx=1&sn=d80625ee52f860a7a2ed4c238d2151b6) 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。\n\nKotlin 究竟有多香呢？\n\n讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。\n\n**解放碑 50° 么，我的天！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg)\n\n后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。\n\n那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。\n\n大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。\n\n说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。\n\n所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。\n\n共勉吧。\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"google-preferred-kotlin","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003c0017lduz9kq2g6aw","content":"<blockquote>\n<p>如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。</p>\n<p>Kotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。</p>\n<p>我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。</p>\n<p>我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 <a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=404087761&idx=1&sn=d80625ee52f860a7a2ed4c238d2151b6\">Android开发必备知识：为什么说Kotlin值得一试</a> 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。</p>\n<p>Kotlin 究竟有多香呢？</p>\n<p>讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。</p>\n<p><strong>解放碑 50° 么，我的天！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg\"></p>\n<p>后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。</p>\n<p>那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。</p>\n<p>大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。</p>\n<p>说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。</p>\n<p>所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。</p>\n<p>共勉吧。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#99;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#99;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>如果你觉得天气热不舒服，那一定是享受过凉爽之后才会有的感觉。你没有意识到 Java 的问题，那正说明你应该试试 Kotlin。 </p>\n</blockquote>","more":"<p>相比两年前第一次大范围的出现在公众面前，Kotlin 这一次其实有点儿顺其自然了，成为首选是情理之中的事儿，没什么大惊小怪的。</p>\n<p>Kotlin 从 2016.2.19 发了 1.0 以来，基本上一年一个大版本的速度在发展，短短数年时间在行业内立足，并且向全平台推进，雄心可见一斑。不过观察来观察去，以前 Java 服务端的同学也许也开始慢慢尝试，但它的使用者仍然是 Android 开发者为主，这与 Google 的大力推荐有很大的关系，用群里一个小伙伴的说法就是：都是你们这些人闹得，整这么多技术学都学不过来——虽然这话有点儿小牢骚，但至少说明大家最开始都是被逼上梁山的。</p>\n<p>我从16年就在公司项目的线上代码中各种尝试 Kotlin 的特性了，目前我自己基本上除非必须很少写 Java 代码，但这么长时间下来同组其他同学大多并没有表现出对 Kotlin 的热情，为什么？因为 Java 够用啊，能实现我的需求就可以了啊。我本也是想推动一下大家去使用的，但我偏偏又不爱干强人所难的事儿，因为如果我刻意去推大家转 Kotlin，会让 Kotlin 的切入变成是对现状的屈从、充满了来自行业的压迫感，这样会往往让大家忽略掉来自体验语言本身优秀特性的幸福感。所以我觉得没必要让语言的切换变成某种“政治”意义上的东西，它不应该是一种自上而下的做法，而应该是一种自下而上的革命。</p>\n<p>我已经从事了好几年的 Kotlin 布道，Kotlin 对于我而言已经超出了工具的范畴，我会像追星一样关注它的发展，关注 Slack 上面的聊天，关注 GitHub 仓库的提交，这一切都来自曾经的不情愿和后来的“真香”。Kotlin 第一次进入我的视野源自一次 IntelliJ Community 源码的构建，当时看到后缀为 kt 的文件，我就崩溃了，Groovy 和 Scala 我还没学明白，怎么又来一门新语言——相信大家最初的想法都跟我一样，我当年不知道是有多么喜欢 Java——然而逼着自己学了几天 Kotlin 之后，就收到了“真香”警告，网上流传很久的一篇来自 Bugly 公众号的文章 <a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=404087761&idx=1&sn=d80625ee52f860a7a2ed4c238d2151b6\">Android开发必备知识：为什么说Kotlin值得一试</a> 就是之后没过多久我在公司内部发表的一篇文章，后面又被 Bugly 公众号转载了出来。</p>\n<p>Kotlin 究竟有多香呢？</p>\n<p>讲个故事：我大学四年在重庆读书宿舍没有空调，而重庆的夏天有多热呢？据说在石头上打一颗鸡蛋都可以熟，上午下暴雨下午太阳出来半个小时就看不出任何暴雨痕迹，每年夏天总有那么几天不用上课是因为高温。。。十年前校内还是很流行的，一张全城热死的海报被疯狂转载。。。</p>\n<p><strong>解放碑 50° 么，我的天！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15574446261266.jpg\"></p>\n<p>后来毕业后，终于可以自己装空调了，发现原来夏天还可以这么爽。现在倒好，出门热一会儿我都觉得难受。</p>\n<p>那这跟 Kotlin 有什么关系呢？这就是用 Java 与用 Kotlin 的对比，也许你觉得用 Java 写代码感觉良好，那都是错觉，就好比你从小生活在炎热的天气从来不开空调，就根本不知道开空调有多舒服。</p>\n<p>大家往往在推动别人使用 Kotlin 的时候，只会提到它的开发效率，安全性之类的，其实还要一个更重要的就是，它的很多语法特性与最新的编程思维接轨，你可以只学一门语言就可以领略众多编程方法、思路，所谓窥一斑而知全豹，一门语言让你既可以面向对象，也可以面向函数，既可以线程，也可以协程，既可以 Android 又可以 iOS。开阔眼界，提升思维能力是从码农到可以秀的码农的重要一环。</p>\n<p>说到这里再引用别人的一个观点：当你掌握两门以上外语的时候才能够真正领略到外语的对你思考方式的影响。大意如此吧，说这话的人我估计是要算上英语之外要大家再掌握一门语言的，我不想过分纠结外语的问题，只是想告诉大家，编程语言也是如此。如果你只掌握了一门语言比如 Java，实际上你甚至相当于连一门语言都没有掌握，我在学习 Kotlin 的过程中与 Java 做了大量的对比，这个过程不仅没有让我的 Java 水平受任何负面影响，还实实在在的促进了对 Java 语言体系的认识和理解。</p>\n<p>所谓身在其中自然不得其全貌，多学几门语言，你才能够解锁上帝视角。如果你想要在技术这条路上走得更远，那么请多多接触，作为 Java 开发者，不只是 Kotlin，我也还建议大家认真了解下 Python、JavaScript 还有 Go（如果。。算了，要学 Haskell 的人应该不需要看这篇文章） ，他们背后的生态差异会让你打开一扇又一扇新世界的大门。</p>\n<p>共勉吧。</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#99;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#105;&#109;&#x6f;&#x6f;&#99;&#46;&#99;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"快速迁移 Gradle 脚本至 KTS","keywords":"Gradle Groovy Kotlin KTS","date":"2021-04-17T16:00:00.000Z","description":null,"_content":"\n> 接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1Kf4y1p7zq&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n大家可以在我的 GitHub 页面找到这个工程：[bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua](https://github.com/bennyhuo/Android-LuaJavax)，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。\n\n![提交记录](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png)\n\n因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。\n\n接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。\n\n## 1. 处理字符串字面量\n\n我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：\n\n```groovy\ninclude ':app',':luajava', ':luajavax'\n```\n\n显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。\n\n我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：\n\n![使用全局正则匹配替换单引号](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png)\n\n1. 匹配框输入正则表达式 `'(.*?[^\\\\])'`，替换框中填写 `\"$1\"`，这里的 `$1` 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 `$n` 来表示，其中 `$0` 表示匹配到的整个字符\n2. 过滤文件后缀，我们只对 `*.gradle` 文件做替换\n3. 在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分\n4. 在输入框后面选择 `.*`，蓝色高亮表示启用正则匹配\n\n你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。\n\n至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。\n\n点击 Replace All，替换之后所有的单引号都就变成了双引号：\n\n```groovy\ninclude \":app\",\":luajava\", \":luajavax\"\n```\n\n## 2. 给方法调用加上括号\n\n还是以 settings.gradle 当中的这句为例：\n\n```groovy\ninclude \":app\",\":luajava\", \":luajavax\"\n```\n\n它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。\n\n处理方法，这时候你们应该很自然的就能想到全局正则匹配了：\n\n![全局正则为方法调用加括号](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png)\n\n在这里，匹配框输入正则表达式 `(\\w+) (([^=\\{\\s]+)(.*))`，替换框中填写 `$1($2)`，其他配置与前面替换引号一样。\n\n你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。\n\n点击全部替换，这时候你就发现所有的方法调用都加上了括号：\n\n```groovy\ninclude(\":app\",\":luajava\", \":luajavax\")\n```\n\n实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如\n\n```groovy\ntask clean(type: Delete) {\n    delete(rootProject.buildDir)\n}\n```\n\n被替换成了：\n\n```groovy\ntask(clean(type: Delete) {)\n    delete(rootProject.buildDir)\n}\n```\n\n但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。\n\n## 3. 开始迁移\n\n### 3.1 迁移 settings.gradle\n\n迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。\n\n就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。\n\n### 3.2 迁移根工程下的 build.gradle\n\n我们先贴出来原来的 groovy 版本：\n\n```groovy\nbuildscript {\n    ext.kotlin_version = \"1.4.30\"\n    repositories {\n        maven {\n            url(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n        }\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:4.0.1\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n\n        classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n        // For(Kotlin projects, you need to add Dokka.)\n        classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n    }\n}\n\nsubprojects {\n    repositories {\n        maven {\n            url(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n        }\n    }\n    it.afterEvaluate {\n        it.with {\n            if(plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n                group = \"com.bennyhuo\"\n                version = \"1.0\"\n\n                apply(plugin: \"com.vanniktech.maven.publish\")\n\n            }\n        }\n    }\n}\n\ntask(clean(type: Delete) {\n    delete(rootProject.buildDir)\n})\n```\n\n那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：\n\n```\ne: ...\\Android-Luajavax\\build.gradle.kts:3:5: Unresolved reference: ext\n```\n\n说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 [Project 的属性都是哪里来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd)），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 `getProperties()[\"ext\"]`，所以：\n\n```groovy\next.kotlin_version = \"1.4.30\"\n```\n\n等价于\n\n```kotlin\nextra[\"kotlin_version\"] = \"1.4.30\"\n```\n\n接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：\n\n```kotlin\nval kotlin_version: String by extra\n...\nclasspath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n```\n\n有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。\n\n接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成\n\n```kotlin\nmaven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n```\n\n然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。\n\n以下是 Groovy 原版：\n\n```kotlin\nsubprojects {\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    it.afterEvaluate {\n        it.with {\n            if(plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n                group = \"com.bennyhuo\"\n                version = \"1.0\"\n\n                apply(plugin: \"com.vanniktech.maven.publish\")\n\n            }\n        }\n    }\n}\n```\n\n首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 `it.afterEvaluate` 改成 `this.afterEvaluate`；`it.with` 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。\n\n剩下的就是 `apply(plugin: \"com.vanniktech.maven.publish\")` 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：`apply(plugin = \"com.vanniktech.maven.publish\")`。\n\n最后就是创建任务的代码了，其实很好改，想想我们上节的内容（[Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd)），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：\n\n```kotlin\ntasks.register<Delete>(\"clean\") {\n    delete(rootProject.buildDir)\n}\n```\n\n我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。\n\n至此根工程下面的 build.gradle 改造完毕。\n\n不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。\n\n### 3.3 迁移 app 模块的 build.gradle\n\n我们先把完整的待改造的版本贴出来：\n\n```groovy\napply(plugin: \"com.android.application\")\napply(plugin: \"kotlin-android\")\napply(plugin: \"kotlin-android-extensions\")\n\nandroid {\n    compileSdkVersion(28)\n    buildToolsVersion(\"28.0.3\")\n    defaultConfig {\n        applicationId(\"com.bennyhuo.luajavax.sample\")\n        minSdkVersion(18)\n        targetSdkVersion(28)\n        versionCode(1)\n        versionName(\"1.0\")\n    }\n    buildTypes {\n        release {\n            minifyEnabled(true)\n            signingConfig(signingConfigs.debug)\n            proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n        }\n    }\n\n    lintOptions {\n        checkReleaseBuilds(false)\n        // Or, if(you prefer, you can continue to check for errors in release builds,)\n        // but(continue the build even when errors are found:)\n        abortOnError(false)\n    }\n}\n\ntasks.withType(JavaCompile) {\n    options.encoding = \"UTF-8\"\n}\n\ndependencies {\n    implementation(project(\":luajavax\"))\n    api(\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\")\n\n    api(\"org.slf4j:slf4j-api:1.7.21\")\n    api(\"com.github.tony19:logback-android-core:1.1.1-6\")\n    api(\"com.github.tony19:logback-android-classic:1.1.1-6\") {\n        // workaround(issue #73)\n        exclude(group: \"com.google.android\", module: \"android\")\n    }\n}\n```\n\n接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。\n\n首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：\n\n```kotlin\napply(plugin = \"com.android.application\")\napply(plugin = \"kotlin-android\")\napply(plugin = \"kotlin-android-extensions\")\n```\n\n但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 `android { ... }` 无法直接访问。具体原理可以参考前面的视频：[你的 Gradle 脚本是怎么运行起来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd)。\n\n我们需要通过 `plugins { ... }` 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。\n\n```kotlin\n//apply(plugin = \"com.android.application\")\n//apply(plugin = \"kotlin-android\")\n//apply(plugin = \"kotlin-android-extensions\")\n\nplugins {\n    id(\"com.android.application\")\n    id(\"kotlin-android\")\n    id(\"kotlin-android-extensions\")\n}\n```\n\n这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 `android { ... }` 可以访问了。\n\n接下来我们看到 Gradle 报错的是 defaultConfig 部分：\n\n```kotlin\ndefaultConfig {\n    applicationId(\"com.bennyhuo.luajavax.sample\") // error\n    minSdkVersion(18)\n    targetSdkVersion(28) \n    versionCode(1) // error\n    versionName(\"1.0\") // error\n}\n```\n\n这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：\n\n![使用代码提示查看 applicationId 的定义](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png)\n\n原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：\n\n```kotlin\napplicationId = \"com.bennyhuo.luajavax.sample\"\n```\n\n![使用代码提示查看 versionCode 的定义](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png)\n\n后面的 versionCode 和 versionName 也是如此。\n\n接下来我们看 buildTypes 这一块儿。\n\n![buildTypes 中的报错](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png)\n\n`release { ... }` 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。\n\n这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？]([Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd))里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。\n\n实际上我们在更早的时候介绍 [Project 的属性都是哪里来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd) 的时候就提到过，如果被访问的对象恰好是 **GroovyObject** 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 **invokeMethod** 来访问。所以关键的问题来了，`release { ... }` 是调用了哪个类的 **invokeMethod** 呢？\n\n是 `NamedDomainObjectContainerConfigureDelegate` 的。在 Groovy 版本的 Gradle 脚本当中，形如 `buildTypes { ... }` 这样的配置代码，实际上都是通过对应的 **ConfigureDelegate** 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。\n\n总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：\n\n**DefaultNamedDomainObjectCollection**\n\n```java\npublic DynamicInvokeResult tryInvokeMethod(String name, Object... arguments) {\n    if (isConfigureMethod(name, arguments)) {\n        return DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[0], getByName(name)));\n    }\n    return DynamicInvokeResult.notFound();\n}\n```\n\nrelease 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：\n\n**NamedDomainObjectContainerConfigureDelegate**\n\n```java\nprotected DynamicInvokeResult _configure(String name, Object[] params) {\n    if (params.length == 1 && params[0] instanceof Closure) {\n        return DynamicInvokeResult.found(_container.create(name, (Closure) params[0]));\n    }\n    return DynamicInvokeResult.notFound();\n}\n```\n\n说了这么多，大家只需要记住对于已经存在的，可以使用 **getByName** 来获取，而不存在的，要使用 **create** 来创建。\n\n因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：\n\n```kotlin\nbuildTypes {\n    val release = getByName(\"release\")\n    release.apply {\n        isMinifyEnabled = true\n        signingConfig = signingConfigs.getByName(\"debug\")\n        proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n    }\n}\n```\n\n当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：\n\n```kotlin\nval release by getting {\n    isMinifyEnabled = true\n    signingConfig = signingConfigs.getByName(\"debug\")\n    proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n}\n```\n\n如果需要创建一个叫 beta 的 BuildType，可以使用 creating：\n\n```kotlin\nval beta by creating {\n    isMinifyEnabled = false\n    signingConfig = signingConfigs.getByName(\"debug\")\n    proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n}\n```\n\n![添加新的 BuildType：beta](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png)\n\n好，关于 BuildType 我们就说这么多。\n\n接下来报错的是 lintOptions，这个比较简单，修改如下：\n\n```kotlin\nlintOptions {\n    isCheckReleaseBuilds = false\n    // Or, if(you prefer, you can continue to check for errors in release builds,)\n    // but(continue the build even when errors are found:)\n    isAbortOnError = false\n}\n```\n\n再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：\n\n![通过类型获取任务的报错信息](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png)\n\n根据 IDE 的提示，不难想到以下的改法：\n\n```kotlin\ntasks.withType(JavaCompile::class.java) {\n    options.encoding = \"UTF-8\"\n}\n```\n\n不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：\n\n```kotlin\ntasks.withType<JavaCompile> {\n    options.encoding = \"UTF-8\"\n}\n```\n\n最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：\n\n```kotlin\ndependencies {\n    implementation(project(\":luajavax\"))\n    api(\"org.jetbrains.kotlin:kotlin-stdlib:1.4.30\") // 后续给出替代方案，这里先硬编码\n\n    api(\"org.slf4j:slf4j-api:1.7.21\")\n    api(\"com.github.tony19:logback-android-core:1.1.1-6\")\n    api(\"com.github.tony19:logback-android-classic:1.1.1-6\") {\n        // workaround(issue #73)\n        exclude(group = \"com.google.android\", module = \"android\")\n    }\n}\n```\n\n至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。\n\n## 4. 依赖版本号的替代方案\n\n我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。\n\nKotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。\n\n### 4.1 Kotlin 风格的属性读写\n\n尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 `extra[...]` 的形式定义属性，还可以采用下面的方法：\n\n```kotlin\nval kotlinVersion by extra(\"1.4.30\")\nval isRelease by extra {\n    getBooleanFromFile(\"config.properties\",\"buidType\")\n}\n```\n\n这样定义之后，在当前变量所在的范围之内，还可以直接使用。\n\n当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：\n\n```kotlin\nval kotlin_version: String by extra\n```\n\n### 4.2 在 buildSrc 当中定义\n\nbuildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：\n\n```kotlin\nplugins {\n    `kotlin-dsl`\n}\n\nrepositories {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：\n\n```kotlin\nval kotlinVersion = \"1.4.30\"\nval slf4jVersion = \"1.7.21\"\n```\n\n注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。\n\n使用也很简单：\n\n```kotlin\ndependencies {\n    classpath(\"com.android.tools.build:gradle:4.0.1\")\n    classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion\")\n\t...\n}\n```\n\nbuildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。\n\n## 5. 小结\n\n迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 [bernaferrari/GradleKotlinConverter](https://github.com/bernaferrari/GradleKotlinConverter) 这个项目，其实它的原理就是正则表达式匹配和替换。\n\n本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。\n\n希望对大家有帮助。谢谢大家。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/gradle-migrate-to-kts.md","raw":"---\ntitle:  快速迁移 Gradle 脚本至 KTS \nkeywords: Gradle Groovy Kotlin KTS \ndate: 2021/04/18\ndescription: \ntags: \n    - gradle\n    - groovy\n    - kotlin\n    - kts \n---\n\n> 接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1Kf4y1p7zq&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n大家可以在我的 GitHub 页面找到这个工程：[bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua](https://github.com/bennyhuo/Android-LuaJavax)，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。\n\n![提交记录](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png)\n\n因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。\n\n接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。\n\n## 1. 处理字符串字面量\n\n我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：\n\n```groovy\ninclude ':app',':luajava', ':luajavax'\n```\n\n显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。\n\n我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：\n\n![使用全局正则匹配替换单引号](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png)\n\n1. 匹配框输入正则表达式 `'(.*?[^\\\\])'`，替换框中填写 `\"$1\"`，这里的 `$1` 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 `$n` 来表示，其中 `$0` 表示匹配到的整个字符\n2. 过滤文件后缀，我们只对 `*.gradle` 文件做替换\n3. 在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分\n4. 在输入框后面选择 `.*`，蓝色高亮表示启用正则匹配\n\n你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。\n\n至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。\n\n点击 Replace All，替换之后所有的单引号都就变成了双引号：\n\n```groovy\ninclude \":app\",\":luajava\", \":luajavax\"\n```\n\n## 2. 给方法调用加上括号\n\n还是以 settings.gradle 当中的这句为例：\n\n```groovy\ninclude \":app\",\":luajava\", \":luajavax\"\n```\n\n它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。\n\n处理方法，这时候你们应该很自然的就能想到全局正则匹配了：\n\n![全局正则为方法调用加括号](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png)\n\n在这里，匹配框输入正则表达式 `(\\w+) (([^=\\{\\s]+)(.*))`，替换框中填写 `$1($2)`，其他配置与前面替换引号一样。\n\n你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。\n\n点击全部替换，这时候你就发现所有的方法调用都加上了括号：\n\n```groovy\ninclude(\":app\",\":luajava\", \":luajavax\")\n```\n\n实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如\n\n```groovy\ntask clean(type: Delete) {\n    delete(rootProject.buildDir)\n}\n```\n\n被替换成了：\n\n```groovy\ntask(clean(type: Delete) {)\n    delete(rootProject.buildDir)\n}\n```\n\n但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。\n\n## 3. 开始迁移\n\n### 3.1 迁移 settings.gradle\n\n迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。\n\n就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。\n\n### 3.2 迁移根工程下的 build.gradle\n\n我们先贴出来原来的 groovy 版本：\n\n```groovy\nbuildscript {\n    ext.kotlin_version = \"1.4.30\"\n    repositories {\n        maven {\n            url(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n        }\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:4.0.1\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n\n        classpath(\"com.vanniktech:gradle-maven-publish-plugin:0.14.2\")\n        // For(Kotlin projects, you need to add Dokka.)\n        classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:0.10.1\")\n    }\n}\n\nsubprojects {\n    repositories {\n        maven {\n            url(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n        }\n    }\n    it.afterEvaluate {\n        it.with {\n            if(plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n                group = \"com.bennyhuo\"\n                version = \"1.0\"\n\n                apply(plugin: \"com.vanniktech.maven.publish\")\n\n            }\n        }\n    }\n}\n\ntask(clean(type: Delete) {\n    delete(rootProject.buildDir)\n})\n```\n\n那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：\n\n```\ne: ...\\Android-Luajavax\\build.gradle.kts:3:5: Unresolved reference: ext\n```\n\n说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 [Project 的属性都是哪里来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd)），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 `getProperties()[\"ext\"]`，所以：\n\n```groovy\next.kotlin_version = \"1.4.30\"\n```\n\n等价于\n\n```kotlin\nextra[\"kotlin_version\"] = \"1.4.30\"\n```\n\n接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：\n\n```kotlin\nval kotlin_version: String by extra\n...\nclasspath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\")\n```\n\n有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。\n\n接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成\n\n```kotlin\nmaven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n```\n\n然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。\n\n以下是 Groovy 原版：\n\n```kotlin\nsubprojects {\n    repositories {\n        maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n    }\n    it.afterEvaluate {\n        it.with {\n            if(plugins.hasPlugin(\"com.android.library\") || plugins.hasPlugin(\"java-library\")) {\n                group = \"com.bennyhuo\"\n                version = \"1.0\"\n\n                apply(plugin: \"com.vanniktech.maven.publish\")\n\n            }\n        }\n    }\n}\n```\n\n首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 `it.afterEvaluate` 改成 `this.afterEvaluate`；`it.with` 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。\n\n剩下的就是 `apply(plugin: \"com.vanniktech.maven.publish\")` 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：`apply(plugin = \"com.vanniktech.maven.publish\")`。\n\n最后就是创建任务的代码了，其实很好改，想想我们上节的内容（[Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd)），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：\n\n```kotlin\ntasks.register<Delete>(\"clean\") {\n    delete(rootProject.buildDir)\n}\n```\n\n我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。\n\n至此根工程下面的 build.gradle 改造完毕。\n\n不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。\n\n### 3.3 迁移 app 模块的 build.gradle\n\n我们先把完整的待改造的版本贴出来：\n\n```groovy\napply(plugin: \"com.android.application\")\napply(plugin: \"kotlin-android\")\napply(plugin: \"kotlin-android-extensions\")\n\nandroid {\n    compileSdkVersion(28)\n    buildToolsVersion(\"28.0.3\")\n    defaultConfig {\n        applicationId(\"com.bennyhuo.luajavax.sample\")\n        minSdkVersion(18)\n        targetSdkVersion(28)\n        versionCode(1)\n        versionName(\"1.0\")\n    }\n    buildTypes {\n        release {\n            minifyEnabled(true)\n            signingConfig(signingConfigs.debug)\n            proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n        }\n    }\n\n    lintOptions {\n        checkReleaseBuilds(false)\n        // Or, if(you prefer, you can continue to check for errors in release builds,)\n        // but(continue the build even when errors are found:)\n        abortOnError(false)\n    }\n}\n\ntasks.withType(JavaCompile) {\n    options.encoding = \"UTF-8\"\n}\n\ndependencies {\n    implementation(project(\":luajavax\"))\n    api(\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\")\n\n    api(\"org.slf4j:slf4j-api:1.7.21\")\n    api(\"com.github.tony19:logback-android-core:1.1.1-6\")\n    api(\"com.github.tony19:logback-android-classic:1.1.1-6\") {\n        // workaround(issue #73)\n        exclude(group: \"com.google.android\", module: \"android\")\n    }\n}\n```\n\n接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。\n\n首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：\n\n```kotlin\napply(plugin = \"com.android.application\")\napply(plugin = \"kotlin-android\")\napply(plugin = \"kotlin-android-extensions\")\n```\n\n但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 `android { ... }` 无法直接访问。具体原理可以参考前面的视频：[你的 Gradle 脚本是怎么运行起来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd)。\n\n我们需要通过 `plugins { ... }` 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。\n\n```kotlin\n//apply(plugin = \"com.android.application\")\n//apply(plugin = \"kotlin-android\")\n//apply(plugin = \"kotlin-android-extensions\")\n\nplugins {\n    id(\"com.android.application\")\n    id(\"kotlin-android\")\n    id(\"kotlin-android-extensions\")\n}\n```\n\n这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 `android { ... }` 可以访问了。\n\n接下来我们看到 Gradle 报错的是 defaultConfig 部分：\n\n```kotlin\ndefaultConfig {\n    applicationId(\"com.bennyhuo.luajavax.sample\") // error\n    minSdkVersion(18)\n    targetSdkVersion(28) \n    versionCode(1) // error\n    versionName(\"1.0\") // error\n}\n```\n\n这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：\n\n![使用代码提示查看 applicationId 的定义](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png)\n\n原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：\n\n```kotlin\napplicationId = \"com.bennyhuo.luajavax.sample\"\n```\n\n![使用代码提示查看 versionCode 的定义](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png)\n\n后面的 versionCode 和 versionName 也是如此。\n\n接下来我们看 buildTypes 这一块儿。\n\n![buildTypes 中的报错](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png)\n\n`release { ... }` 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。\n\n这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？]([Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd))里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。\n\n实际上我们在更早的时候介绍 [Project 的属性都是哪里来的？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd) 的时候就提到过，如果被访问的对象恰好是 **GroovyObject** 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 **invokeMethod** 来访问。所以关键的问题来了，`release { ... }` 是调用了哪个类的 **invokeMethod** 呢？\n\n是 `NamedDomainObjectContainerConfigureDelegate` 的。在 Groovy 版本的 Gradle 脚本当中，形如 `buildTypes { ... }` 这样的配置代码，实际上都是通过对应的 **ConfigureDelegate** 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。\n\n总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：\n\n**DefaultNamedDomainObjectCollection**\n\n```java\npublic DynamicInvokeResult tryInvokeMethod(String name, Object... arguments) {\n    if (isConfigureMethod(name, arguments)) {\n        return DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[0], getByName(name)));\n    }\n    return DynamicInvokeResult.notFound();\n}\n```\n\nrelease 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：\n\n**NamedDomainObjectContainerConfigureDelegate**\n\n```java\nprotected DynamicInvokeResult _configure(String name, Object[] params) {\n    if (params.length == 1 && params[0] instanceof Closure) {\n        return DynamicInvokeResult.found(_container.create(name, (Closure) params[0]));\n    }\n    return DynamicInvokeResult.notFound();\n}\n```\n\n说了这么多，大家只需要记住对于已经存在的，可以使用 **getByName** 来获取，而不存在的，要使用 **create** 来创建。\n\n因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：\n\n```kotlin\nbuildTypes {\n    val release = getByName(\"release\")\n    release.apply {\n        isMinifyEnabled = true\n        signingConfig = signingConfigs.getByName(\"debug\")\n        proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n    }\n}\n```\n\n当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：\n\n```kotlin\nval release by getting {\n    isMinifyEnabled = true\n    signingConfig = signingConfigs.getByName(\"debug\")\n    proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n}\n```\n\n如果需要创建一个叫 beta 的 BuildType，可以使用 creating：\n\n```kotlin\nval beta by creating {\n    isMinifyEnabled = false\n    signingConfig = signingConfigs.getByName(\"debug\")\n    proguardFiles(getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\")\n}\n```\n\n![添加新的 BuildType：beta](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png)\n\n好，关于 BuildType 我们就说这么多。\n\n接下来报错的是 lintOptions，这个比较简单，修改如下：\n\n```kotlin\nlintOptions {\n    isCheckReleaseBuilds = false\n    // Or, if(you prefer, you can continue to check for errors in release builds,)\n    // but(continue the build even when errors are found:)\n    isAbortOnError = false\n}\n```\n\n再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：\n\n![通过类型获取任务的报错信息](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png)\n\n根据 IDE 的提示，不难想到以下的改法：\n\n```kotlin\ntasks.withType(JavaCompile::class.java) {\n    options.encoding = \"UTF-8\"\n}\n```\n\n不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：\n\n```kotlin\ntasks.withType<JavaCompile> {\n    options.encoding = \"UTF-8\"\n}\n```\n\n最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：\n\n```kotlin\ndependencies {\n    implementation(project(\":luajavax\"))\n    api(\"org.jetbrains.kotlin:kotlin-stdlib:1.4.30\") // 后续给出替代方案，这里先硬编码\n\n    api(\"org.slf4j:slf4j-api:1.7.21\")\n    api(\"com.github.tony19:logback-android-core:1.1.1-6\")\n    api(\"com.github.tony19:logback-android-classic:1.1.1-6\") {\n        // workaround(issue #73)\n        exclude(group = \"com.google.android\", module = \"android\")\n    }\n}\n```\n\n至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。\n\n## 4. 依赖版本号的替代方案\n\n我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。\n\nKotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。\n\n### 4.1 Kotlin 风格的属性读写\n\n尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 `extra[...]` 的形式定义属性，还可以采用下面的方法：\n\n```kotlin\nval kotlinVersion by extra(\"1.4.30\")\nval isRelease by extra {\n    getBooleanFromFile(\"config.properties\",\"buidType\")\n}\n```\n\n这样定义之后，在当前变量所在的范围之内，还可以直接使用。\n\n当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：\n\n```kotlin\nval kotlin_version: String by extra\n```\n\n### 4.2 在 buildSrc 当中定义\n\nbuildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：\n\n```kotlin\nplugins {\n    `kotlin-dsl`\n}\n\nrepositories {\n    maven(\"https://mirrors.tencent.com/nexus/repository/maven-public/\")\n}\n```\n\n然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：\n\n```kotlin\nval kotlinVersion = \"1.4.30\"\nval slf4jVersion = \"1.7.21\"\n```\n\n注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。\n\n使用也很简单：\n\n```kotlin\ndependencies {\n    classpath(\"com.android.tools.build:gradle:4.0.1\")\n    classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion\")\n\t...\n}\n```\n\nbuildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。\n\n## 5. 小结\n\n迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 [bernaferrari/GradleKotlinConverter](https://github.com/bernaferrari/GradleKotlinConverter) 这个项目，其实它的原理就是正则表达式匹配和替换。\n\n本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。\n\n希望对大家有帮助。谢谢大家。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"gradle-migrate-to-kts","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003c0019lduz0jivddts","content":"<blockquote>\n<p>接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1Kf4y1p7zq&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<span id=\"more\"></span>\n\n\n\n\n<p>大家可以在我的 GitHub 页面找到这个工程：<a href=\"https://github.com/bennyhuo/Android-LuaJavax\">bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua</a>，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png\" alt=\"提交记录\"></p>\n<p>因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。</p>\n<p>接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。</p>\n<h2 id=\"1-处理字符串字面量\"><a href=\"#1-处理字符串字面量\" class=\"headerlink\" title=\"1. 处理字符串字面量\"></a>1. 处理字符串字面量</h2><p>我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&#x27;:app&#x27;</span>,<span class=\"string\">&#x27;:luajava&#x27;</span>, <span class=\"string\">&#x27;:luajavax&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。</p>\n<p>我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png\" alt=\"使用全局正则匹配替换单引号\"></p>\n<ol>\n<li>匹配框输入正则表达式 <code>&#39;(.*?[^\\\\])&#39;</code>，替换框中填写 <code>&quot;$1&quot;</code>，这里的 <code>$1</code> 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 <code>$n</code> 来表示，其中 <code>$0</code> 表示匹配到的整个字符</li>\n<li>过滤文件后缀，我们只对 <code>*.gradle</code> 文件做替换</li>\n<li>在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分</li>\n<li>在输入框后面选择 <code>.*</code>，蓝色高亮表示启用正则匹配</li>\n</ol>\n<p>你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。</p>\n<p>至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。</p>\n<p>点击 Replace All，替换之后所有的单引号都就变成了双引号：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-给方法调用加上括号\"><a href=\"#2-给方法调用加上括号\" class=\"headerlink\" title=\"2. 给方法调用加上括号\"></a>2. 给方法调用加上括号</h2><p>还是以 settings.gradle 当中的这句为例：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。</p>\n<p>处理方法，这时候你们应该很自然的就能想到全局正则匹配了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png\" alt=\"全局正则为方法调用加括号\"></p>\n<p>在这里，匹配框输入正则表达式 <code>(\\w+) (([^=\\&#123;\\s]+)(.*))</code>，替换框中填写 <code>$1($2)</code>，其他配置与前面替换引号一样。</p>\n<p>你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。</p>\n<p>点击全部替换，这时候你就发现所有的方法调用都加上了括号：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include(<span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task clean(<span class=\"attr\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被替换成了：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task(clean(<span class=\"attr\">type:</span> Delete) &#123;)</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。</p>\n<h2 id=\"3-开始迁移\"><a href=\"#3-开始迁移\" class=\"headerlink\" title=\"3. 开始迁移\"></a>3. 开始迁移</h2><h3 id=\"3-1-迁移-settings-gradle\"><a href=\"#3-1-迁移-settings-gradle\" class=\"headerlink\" title=\"3.1 迁移 settings.gradle\"></a>3.1 迁移 settings.gradle</h3><p>迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。</p>\n<p>就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。</p>\n<h3 id=\"3-2-迁移根工程下的-build-gradle\"><a href=\"#3-2-迁移根工程下的-build-gradle\" class=\"headerlink\" title=\"3.2 迁移根工程下的 build.gradle\"></a>3.2 迁移根工程下的 build.gradle</h3><p>我们先贴出来原来的 groovy 版本：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.kotlin_version = <span class=\"string\">&quot;1.4.30&quot;</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it.afterEvaluate &#123;</span><br><span class=\"line\">        it.with &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">                group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">                version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task(clean(<span class=\"attr\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e: ...\\Android-Luajavax\\build.gradle.kts:3:5: Unresolved reference: ext</span><br></pre></td></tr></table></figure>\n\n<p>说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd\">Project 的属性都是哪里来的？</a>），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 <code>getProperties()[&quot;ext&quot;]</code>，所以：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>等价于</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extra[<span class=\"string\">&quot;kotlin_version&quot;</span>] = <span class=\"string\">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra</span><br><span class=\"line\">...</span><br><span class=\"line\">classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。</p>\n<p>接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。</p>\n<p>以下是 Groovy 原版：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it.afterEvaluate &#123;</span><br><span class=\"line\">        it.with &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">                group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">                version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                apply(plugin: <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 <code>it.afterEvaluate</code> 改成 <code>this.afterEvaluate</code>；<code>it.with</code> 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。</p>\n<p>剩下的就是 <code>apply(plugin: &quot;com.vanniktech.maven.publish&quot;)</code> 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：<code>apply(plugin = &quot;com.vanniktech.maven.publish&quot;)</code>。</p>\n<p>最后就是创建任务的代码了，其实很好改，想想我们上节的内容（<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd\">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</a>），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。</p>\n<p>至此根工程下面的 build.gradle 改造完毕。</p>\n<p>不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。</p>\n<h3 id=\"3-3-迁移-app-模块的-build-gradle\"><a href=\"#3-3-迁移-app-模块的-build-gradle\" class=\"headerlink\" title=\"3.3 迁移 app 模块的 build.gradle\"></a>3.3 迁移 app 模块的 build.gradle</h3><p>我们先把完整的待改造的版本贴出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion(<span class=\"number\">28</span>)</span><br><span class=\"line\">    buildToolsVersion(<span class=\"string\">&quot;28.0.3&quot;</span>)</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId(<span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span>)</span><br><span class=\"line\">        minSdkVersion(<span class=\"number\">18</span>)</span><br><span class=\"line\">        targetSdkVersion(<span class=\"number\">28</span>)</span><br><span class=\"line\">        versionCode(<span class=\"number\">1</span>)</span><br><span class=\"line\">        versionName(<span class=\"string\">&quot;1.0&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            signingConfig(signingConfigs.debug)</span><br><span class=\"line\">            proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lintOptions &#123;</span><br><span class=\"line\">        checkReleaseBuilds(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class=\"line\">        <span class=\"comment\">// but(continue the build even when errors are found:)</span></span><br><span class=\"line\">        abortOnError(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.withType(JavaCompile) &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(project(<span class=\"string\">&quot;:luajavax&quot;</span>))</span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// workaround(issue #73)</span></span><br><span class=\"line\">        exclude(<span class=\"attr\">group:</span> <span class=\"string\">&quot;com.google.android&quot;</span>, <span class=\"attr\">module:</span> <span class=\"string\">&quot;android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。</p>\n<p>首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply(plugin = <span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">apply(plugin = <span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">apply(plugin = <span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 <code>android &#123; ... &#125;</code> 无法直接访问。具体原理可以参考前面的视频：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd\">你的 Gradle 脚本是怎么运行起来的？</a>。</p>\n<p>我们需要通过 <code>plugins &#123; ... &#125;</code> 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;com.android.application&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;kotlin-android&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;kotlin-android-extensions&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 <code>android &#123; ... &#125;</code> 可以访问了。</p>\n<p>接下来我们看到 Gradle 报错的是 defaultConfig 部分：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">    applicationId(<span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">    minSdkVersion(<span class=\"number\">18</span>)</span><br><span class=\"line\">    targetSdkVersion(<span class=\"number\">28</span>) </span><br><span class=\"line\">    versionCode(<span class=\"number\">1</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">    versionName(<span class=\"string\">&quot;1.0&quot;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png\" alt=\"使用代码提示查看 applicationId 的定义\"></p>\n<p>原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applicationId = <span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png\" alt=\"使用代码提示查看 versionCode 的定义\"></p>\n<p>后面的 versionCode 和 versionName 也是如此。</p>\n<p>接下来我们看 buildTypes 这一块儿。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png\" alt=\"buildTypes 中的报错\"></p>\n<p><code>release &#123; ... &#125;</code> 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。</p>\n<p>这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd\">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)</a>)里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。</p>\n<p>实际上我们在更早的时候介绍 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd\">Project 的属性都是哪里来的？</a> 的时候就提到过，如果被访问的对象恰好是 <strong>GroovyObject</strong> 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 <strong>invokeMethod</strong> 来访问。所以关键的问题来了，<code>release &#123; ... &#125;</code> 是调用了哪个类的 <strong>invokeMethod</strong> 呢？</p>\n<p>是 <code>NamedDomainObjectContainerConfigureDelegate</code> 的。在 Groovy 版本的 Gradle 脚本当中，形如 <code>buildTypes &#123; ... &#125;</code> 这样的配置代码，实际上都是通过对应的 <strong>ConfigureDelegate</strong> 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。</p>\n<p>总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：</p>\n<p><strong>DefaultNamedDomainObjectCollection</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DynamicInvokeResult <span class=\"title\">tryInvokeMethod</span><span class=\"params\">(String name, Object... arguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isConfigureMethod(name, arguments)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[<span class=\"number\">0</span>], getByName(name)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DynamicInvokeResult.notFound();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>release 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：</p>\n<p><strong>NamedDomainObjectContainerConfigureDelegate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DynamicInvokeResult <span class=\"title\">_configure</span><span class=\"params\">(String name, Object[] params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (params.length == <span class=\"number\">1</span> &amp;&amp; params[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> Closure) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicInvokeResult.found(_container.create(name, (Closure) params[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DynamicInvokeResult.notFound();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，大家只需要记住对于已经存在的，可以使用 <strong>getByName</strong> 来获取，而不存在的，要使用 <strong>create</strong> 来创建。</p>\n<p>因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> release = getByName(<span class=\"string\">&quot;release&quot;</span>)</span><br><span class=\"line\">    release.apply &#123;</span><br><span class=\"line\">        isMinifyEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">        signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">        proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> release <span class=\"keyword\">by</span> getting &#123;</span><br><span class=\"line\">    isMinifyEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">    signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">    proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要创建一个叫 beta 的 BuildType，可以使用 creating：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> beta <span class=\"keyword\">by</span> creating &#123;</span><br><span class=\"line\">    isMinifyEnabled = <span class=\"literal\">false</span></span><br><span class=\"line\">    signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">    proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png\" alt=\"添加新的 BuildType：beta\"></p>\n<p>好，关于 BuildType 我们就说这么多。</p>\n<p>接下来报错的是 lintOptions，这个比较简单，修改如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lintOptions &#123;</span><br><span class=\"line\">    isCheckReleaseBuilds = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class=\"line\">    <span class=\"comment\">// but(continue the build even when errors are found:)</span></span><br><span class=\"line\">    isAbortOnError = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png\" alt=\"通过类型获取任务的报错信息\"></p>\n<p>根据 IDE 的提示，不难想到以下的改法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.withType(JavaCompile::<span class=\"keyword\">class</span>.java) &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.withType&lt;JavaCompile&gt; &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(project(<span class=\"string\">&quot;:luajavax&quot;</span>))</span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.30&quot;</span>) <span class=\"comment\">// 后续给出替代方案，这里先硬编码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// workaround(issue #73)</span></span><br><span class=\"line\">        exclude(group = <span class=\"string\">&quot;com.google.android&quot;</span>, module = <span class=\"string\">&quot;android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。</p>\n<h2 id=\"4-依赖版本号的替代方案\"><a href=\"#4-依赖版本号的替代方案\" class=\"headerlink\" title=\"4. 依赖版本号的替代方案\"></a>4. 依赖版本号的替代方案</h2><p>我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。</p>\n<p>Kotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。</p>\n<h3 id=\"4-1-Kotlin-风格的属性读写\"><a href=\"#4-1-Kotlin-风格的属性读写\" class=\"headerlink\" title=\"4.1 Kotlin 风格的属性读写\"></a>4.1 Kotlin 风格的属性读写</h3><p>尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 <code>extra[...]</code> 的形式定义属性，还可以采用下面的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlinVersion <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> isRelease <span class=\"keyword\">by</span> extra &#123;</span><br><span class=\"line\">    getBooleanFromFile(<span class=\"string\">&quot;config.properties&quot;</span>,<span class=\"string\">&quot;buidType&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样定义之后，在当前变量所在的范围之内，还可以直接使用。</p>\n<p>当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-在-buildSrc-当中定义\"><a href=\"#4-2-在-buildSrc-当中定义\" class=\"headerlink\" title=\"4.2 在 buildSrc 当中定义\"></a>4.2 在 buildSrc 当中定义</h3><p>buildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    `kotlin-dsl`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlinVersion = <span class=\"string\">&quot;1.4.30&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> slf4jVersion = <span class=\"string\">&quot;1.7.21&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。</p>\n<p>使用也很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlinVersion</span>&quot;</span>)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 <a href=\"https://github.com/bernaferrari/GradleKotlinConverter\">bernaferrari/GradleKotlinConverter</a> 这个项目，其实它的原理就是正则表达式匹配和替换。</p>\n<p>本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。</p>\n<p>希望对大家有帮助。谢谢大家。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1Kf4y1p7zq&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","more":"<p>大家可以在我的 GitHub 页面找到这个工程：<a href=\"https://github.com/bennyhuo/Android-LuaJavax\">bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua</a>，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png\" alt=\"提交记录\"></p>\n<p>因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。</p>\n<p>接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。</p>\n<h2 id=\"1-处理字符串字面量\"><a href=\"#1-处理字符串字面量\" class=\"headerlink\" title=\"1. 处理字符串字面量\"></a>1. 处理字符串字面量</h2><p>我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&#x27;:app&#x27;</span>,<span class=\"string\">&#x27;:luajava&#x27;</span>, <span class=\"string\">&#x27;:luajavax&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。</p>\n<p>我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png\" alt=\"使用全局正则匹配替换单引号\"></p>\n<ol>\n<li>匹配框输入正则表达式 <code>&#39;(.*?[^\\\\])&#39;</code>，替换框中填写 <code>&quot;$1&quot;</code>，这里的 <code>$1</code> 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 <code>$n</code> 来表示，其中 <code>$0</code> 表示匹配到的整个字符</li>\n<li>过滤文件后缀，我们只对 <code>*.gradle</code> 文件做替换</li>\n<li>在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分</li>\n<li>在输入框后面选择 <code>.*</code>，蓝色高亮表示启用正则匹配</li>\n</ol>\n<p>你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。</p>\n<p>至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。</p>\n<p>点击 Replace All，替换之后所有的单引号都就变成了双引号：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-给方法调用加上括号\"><a href=\"#2-给方法调用加上括号\" class=\"headerlink\" title=\"2. 给方法调用加上括号\"></a>2. 给方法调用加上括号</h2><p>还是以 settings.gradle 当中的这句为例：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。</p>\n<p>处理方法，这时候你们应该很自然的就能想到全局正则匹配了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png\" alt=\"全局正则为方法调用加括号\"></p>\n<p>在这里，匹配框输入正则表达式 <code>(\\w+) (([^=\\&#123;\\s]+)(.*))</code>，替换框中填写 <code>$1($2)</code>，其他配置与前面替换引号一样。</p>\n<p>你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。</p>\n<p>点击全部替换，这时候你就发现所有的方法调用都加上了括号：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include(<span class=\"string\">&quot;:app&quot;</span>,<span class=\"string\">&quot;:luajava&quot;</span>, <span class=\"string\">&quot;:luajavax&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task clean(<span class=\"attr\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被替换成了：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task(clean(<span class=\"attr\">type:</span> Delete) &#123;)</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。</p>\n<h2 id=\"3-开始迁移\"><a href=\"#3-开始迁移\" class=\"headerlink\" title=\"3. 开始迁移\"></a>3. 开始迁移</h2><h3 id=\"3-1-迁移-settings-gradle\"><a href=\"#3-1-迁移-settings-gradle\" class=\"headerlink\" title=\"3.1 迁移 settings.gradle\"></a>3.1 迁移 settings.gradle</h3><p>迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。</p>\n<p>就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。</p>\n<h3 id=\"3-2-迁移根工程下的-build-gradle\"><a href=\"#3-2-迁移根工程下的-build-gradle\" class=\"headerlink\" title=\"3.2 迁移根工程下的 build.gradle\"></a>3.2 迁移根工程下的 build.gradle</h3><p>我们先贴出来原来的 groovy 版本：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext.kotlin_version = <span class=\"string\">&quot;1.4.30&quot;</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class=\"line\">        classpath(<span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it.afterEvaluate &#123;</span><br><span class=\"line\">        it.with &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">                group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">                version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task(clean(<span class=\"attr\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e: ...\\Android-Luajavax\\build.gradle.kts:3:5: Unresolved reference: ext</span><br></pre></td></tr></table></figure>\n\n<p>说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd\">Project 的属性都是哪里来的？</a>），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 <code>getProperties()[&quot;ext&quot;]</code>，所以：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.kotlin_version = <span class=\"string\">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>等价于</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extra[<span class=\"string\">&quot;kotlin_version&quot;</span>] = <span class=\"string\">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra</span><br><span class=\"line\">...</span><br><span class=\"line\">classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlin_version</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。</p>\n<p>接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。</p>\n<p>以下是 Groovy 原版：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    it.afterEvaluate &#123;</span><br><span class=\"line\">        it.with &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(plugins.hasPlugin(<span class=\"string\">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class=\"string\">&quot;java-library&quot;</span>)) &#123;</span><br><span class=\"line\">                group = <span class=\"string\">&quot;com.bennyhuo&quot;</span></span><br><span class=\"line\">                version = <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                apply(plugin: <span class=\"string\">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 <code>it.afterEvaluate</code> 改成 <code>this.afterEvaluate</code>；<code>it.with</code> 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。</p>\n<p>剩下的就是 <code>apply(plugin: &quot;com.vanniktech.maven.publish&quot;)</code> 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：<code>apply(plugin = &quot;com.vanniktech.maven.publish&quot;)</code>。</p>\n<p>最后就是创建任务的代码了，其实很好改，想想我们上节的内容（<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd\">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</a>），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.register&lt;Delete&gt;(<span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    delete(rootProject.buildDir)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。</p>\n<p>至此根工程下面的 build.gradle 改造完毕。</p>\n<p>不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。</p>\n<h3 id=\"3-3-迁移-app-模块的-build-gradle\"><a href=\"#3-3-迁移-app-模块的-build-gradle\" class=\"headerlink\" title=\"3.3 迁移 app 模块的 build.gradle\"></a>3.3 迁移 app 模块的 build.gradle</h3><p>我们先把完整的待改造的版本贴出来：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">apply(<span class=\"attr\">plugin:</span> <span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion(<span class=\"number\">28</span>)</span><br><span class=\"line\">    buildToolsVersion(<span class=\"string\">&quot;28.0.3&quot;</span>)</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId(<span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span>)</span><br><span class=\"line\">        minSdkVersion(<span class=\"number\">18</span>)</span><br><span class=\"line\">        targetSdkVersion(<span class=\"number\">28</span>)</span><br><span class=\"line\">        versionCode(<span class=\"number\">1</span>)</span><br><span class=\"line\">        versionName(<span class=\"string\">&quot;1.0&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            signingConfig(signingConfigs.debug)</span><br><span class=\"line\">            proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lintOptions &#123;</span><br><span class=\"line\">        checkReleaseBuilds(<span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class=\"line\">        <span class=\"comment\">// but(continue the build even when errors are found:)</span></span><br><span class=\"line\">        abortOnError(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.withType(JavaCompile) &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(project(<span class=\"string\">&quot;:luajavax&quot;</span>))</span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// workaround(issue #73)</span></span><br><span class=\"line\">        exclude(<span class=\"attr\">group:</span> <span class=\"string\">&quot;com.google.android&quot;</span>, <span class=\"attr\">module:</span> <span class=\"string\">&quot;android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。</p>\n<p>首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply(plugin = <span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">apply(plugin = <span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">apply(plugin = <span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 <code>android &#123; ... &#125;</code> 无法直接访问。具体原理可以参考前面的视频：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd\">你的 Gradle 脚本是怎么运行起来的？</a>。</p>\n<p>我们需要通过 <code>plugins &#123; ... &#125;</code> 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;com.android.application&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;kotlin-android&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//apply(plugin = &quot;kotlin-android-extensions&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 <code>android &#123; ... &#125;</code> 可以访问了。</p>\n<p>接下来我们看到 Gradle 报错的是 defaultConfig 部分：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig &#123;</span><br><span class=\"line\">    applicationId(<span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">    minSdkVersion(<span class=\"number\">18</span>)</span><br><span class=\"line\">    targetSdkVersion(<span class=\"number\">28</span>) </span><br><span class=\"line\">    versionCode(<span class=\"number\">1</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">    versionName(<span class=\"string\">&quot;1.0&quot;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png\" alt=\"使用代码提示查看 applicationId 的定义\"></p>\n<p>原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applicationId = <span class=\"string\">&quot;com.bennyhuo.luajavax.sample&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png\" alt=\"使用代码提示查看 versionCode 的定义\"></p>\n<p>后面的 versionCode 和 versionName 也是如此。</p>\n<p>接下来我们看 buildTypes 这一块儿。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png\" alt=\"buildTypes 中的报错\"></p>\n<p><code>release &#123; ... &#125;</code> 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。</p>\n<p>这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd\">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)</a>)里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。</p>\n<p>实际上我们在更早的时候介绍 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd\">Project 的属性都是哪里来的？</a> 的时候就提到过，如果被访问的对象恰好是 <strong>GroovyObject</strong> 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 <strong>invokeMethod</strong> 来访问。所以关键的问题来了，<code>release &#123; ... &#125;</code> 是调用了哪个类的 <strong>invokeMethod</strong> 呢？</p>\n<p>是 <code>NamedDomainObjectContainerConfigureDelegate</code> 的。在 Groovy 版本的 Gradle 脚本当中，形如 <code>buildTypes &#123; ... &#125;</code> 这样的配置代码，实际上都是通过对应的 <strong>ConfigureDelegate</strong> 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。</p>\n<p>总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：</p>\n<p><strong>DefaultNamedDomainObjectCollection</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DynamicInvokeResult <span class=\"title\">tryInvokeMethod</span><span class=\"params\">(String name, Object... arguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isConfigureMethod(name, arguments)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[<span class=\"number\">0</span>], getByName(name)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DynamicInvokeResult.notFound();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>release 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：</p>\n<p><strong>NamedDomainObjectContainerConfigureDelegate</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DynamicInvokeResult <span class=\"title\">_configure</span><span class=\"params\">(String name, Object[] params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (params.length == <span class=\"number\">1</span> &amp;&amp; params[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> Closure) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicInvokeResult.found(_container.create(name, (Closure) params[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DynamicInvokeResult.notFound();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，大家只需要记住对于已经存在的，可以使用 <strong>getByName</strong> 来获取，而不存在的，要使用 <strong>create</strong> 来创建。</p>\n<p>因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> release = getByName(<span class=\"string\">&quot;release&quot;</span>)</span><br><span class=\"line\">    release.apply &#123;</span><br><span class=\"line\">        isMinifyEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">        signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">        proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> release <span class=\"keyword\">by</span> getting &#123;</span><br><span class=\"line\">    isMinifyEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">    signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">    proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要创建一个叫 beta 的 BuildType，可以使用 creating：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> beta <span class=\"keyword\">by</span> creating &#123;</span><br><span class=\"line\">    isMinifyEnabled = <span class=\"literal\">false</span></span><br><span class=\"line\">    signingConfig = signingConfigs.getByName(<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\">    proguardFiles(getDefaultProguardFile(<span class=\"string\">&quot;proguard-android.txt&quot;</span>), <span class=\"string\">&quot;proguard-rules.pro&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png\" alt=\"添加新的 BuildType：beta\"></p>\n<p>好，关于 BuildType 我们就说这么多。</p>\n<p>接下来报错的是 lintOptions，这个比较简单，修改如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lintOptions &#123;</span><br><span class=\"line\">    isCheckReleaseBuilds = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class=\"line\">    <span class=\"comment\">// but(continue the build even when errors are found:)</span></span><br><span class=\"line\">    isAbortOnError = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png\" alt=\"通过类型获取任务的报错信息\"></p>\n<p>根据 IDE 的提示，不难想到以下的改法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.withType(JavaCompile::<span class=\"keyword\">class</span>.java) &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks.withType&lt;JavaCompile&gt; &#123;</span><br><span class=\"line\">    options.encoding = <span class=\"string\">&quot;UTF-8&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(project(<span class=\"string\">&quot;:luajavax&quot;</span>))</span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.30&quot;</span>) <span class=\"comment\">// 后续给出替代方案，这里先硬编码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    api(<span class=\"string\">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class=\"line\">    api(<span class=\"string\">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// workaround(issue #73)</span></span><br><span class=\"line\">        exclude(group = <span class=\"string\">&quot;com.google.android&quot;</span>, module = <span class=\"string\">&quot;android&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。</p>\n<h2 id=\"4-依赖版本号的替代方案\"><a href=\"#4-依赖版本号的替代方案\" class=\"headerlink\" title=\"4. 依赖版本号的替代方案\"></a>4. 依赖版本号的替代方案</h2><p>我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。</p>\n<p>Kotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。</p>\n<h3 id=\"4-1-Kotlin-风格的属性读写\"><a href=\"#4-1-Kotlin-风格的属性读写\" class=\"headerlink\" title=\"4.1 Kotlin 风格的属性读写\"></a>4.1 Kotlin 风格的属性读写</h3><p>尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 <code>extra[...]</code> 的形式定义属性，还可以采用下面的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlinVersion <span class=\"keyword\">by</span> extra(<span class=\"string\">&quot;1.4.30&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> isRelease <span class=\"keyword\">by</span> extra &#123;</span><br><span class=\"line\">    getBooleanFromFile(<span class=\"string\">&quot;config.properties&quot;</span>,<span class=\"string\">&quot;buidType&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样定义之后，在当前变量所在的范围之内，还可以直接使用。</p>\n<p>当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlin_version: String <span class=\"keyword\">by</span> extra</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-在-buildSrc-当中定义\"><a href=\"#4-2-在-buildSrc-当中定义\" class=\"headerlink\" title=\"4.2 在 buildSrc 当中定义\"></a>4.2 在 buildSrc 当中定义</h3><p>buildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    `kotlin-dsl`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    maven(<span class=\"string\">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> kotlinVersion = <span class=\"string\">&quot;1.4.30&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> slf4jVersion = <span class=\"string\">&quot;1.7.21&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。</p>\n<p>使用也很简单：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class=\"line\">    classpath(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class=\"variable\">$kotlinVersion</span>&quot;</span>)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。</p>\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 <a href=\"https://github.com/bernaferrari/GradleKotlinConverter\">bernaferrari/GradleKotlinConverter</a> 这个项目，其实它的原理就是正则表达式匹配和替换。</p>\n<p>本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。</p>\n<p>希望对大家有帮助。谢谢大家。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"快速迁移 Gradle 脚本至 KTS","path":"2021/04/18/gradle-migrate-to-kts/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png","excerpt":"<blockquote>\n<p>接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1Kf4y1p7zq&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","date":{"_isAMomentObject":true,"_i":"2021-04-17T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-04-17T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["gradle","groovy","kotlin","kts"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？","keywords":"Gradle Groovy","date":"2021-04-11T16:00:00.000Z","description":null,"_content":"\n> 任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1ib4y1D74X&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n```gradle\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n```\n\n它定义了一个叫做 \"clean\" 的任务，这个任务的类型是 Delete。\n\n其中 Delete 是一个类的名字，这是 Groovy 的语法，相当于 Delete.class。这个还好，至少人家语法上支持这样做。\n\n后面的 { ... } 有 Kotlin 经验的小伙伴们自然也不会觉得陌生，这肯定是接收一个 Lambda （在 Groovy 当中就是 Closure）作为参数，里面的 `delete rootProject.buildDir` 则等价于 `delete(rootProject.buildDir)`，这也是 Groovy 的语法，在 Groovy 当中只要不引起歧义，函数的调用是可以去掉括号的，类似的例子有很多：\n\n```gradle\ndependencies {\n    classpath 'com.android.tools.build:gradle:4.0.1'\n    ...\n}\n```\n\n这里的 classpath 也是如此。\n\n这都很容易理解。那么问题来了，`task clean(...){ ... }` 这是个什么语法？我们定义一个名叫 \"clean\" 的任务，这个任务名不应该是一个字符串字面量吗，但现在按照 Groovy 的语法，它应该等价于 `task(clean(...){ ... })` ，这个 clean 看上去其实是个方法名，而不是一个常量。\n\n如果大家跟我一样一开始就绞尽脑汁地去研究这个玩意究竟是什么 Groovy 语法，那你从一开始就错了。这个答案直到我们在翻阅 Gradle 源码的时候，看到有一个叫做 TaskDefinitionScriptTransformer 的类，这个类在 Gradle 脚本编译运行的第二个阶段时被调用，它和其他几个类似的 Transformer 一样，作用就是对源代码的语法树做了一些转换。\n\n大家在 Gradle 源码当中找到这个类之后就会发现，注释已经写的非常清晰了，例如：\n\n```java\nif (args.getExpression(0) instanceof MapExpression && args.getExpression(1) instanceof VariableExpression) {\n    // Matches: task <name-value-pairs>, <identifier>, <arg>?\n    // Map to: task(<name-value-pairs>, '<identifier>', <arg>?)\n    transformVariableExpression(call, 1);\n} else if (args.getExpression(0) instanceof VariableExpression) {\n    // Matches: task <identifier>, <arg>?\n    transformVariableExpression(call, 0);\n}\n```\n\n通过注释我们可以看到，task 实际上是被当做函数来调用的，我们也确实可以在 Project 当中找到它的定义：\n\n![image-20210411072516707](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png)\n\n这个映射实际上就是给 identifier 加了个引号，变成字符串字面量。注意到 `transformVariableExpression(call, 1);` 的第二个参数 1 对应的就是 `<identifier>`，第二个分支里面的位置则是 0。\n\n这个方法的实现也很显而易见：\n\n```java\nprivate void transformVariableExpression(MethodCallExpression call, int index) {\n    ArgumentListExpression args = (ArgumentListExpression) call.getArguments();\n    //拿到 identifier 对应的表达式\n    VariableExpression arg = (VariableExpression) args.getExpression(index);\n    if (!isDynamicVar(arg)) {\n        return;\n    }\n\n    // Matches: task args?, <identifier>, args? or task(args?, <identifier>, args?)\n    // Map to: task(args?, '<identifier>', args?)\n    String taskName = arg.getText(); // 表达式的内容就是任务名\n    call.setMethod(new ConstantExpression(\"task\"));\n    // 创建一个以任务名为内容的字符串字面量\n    args.getExpressions().set(index, new ConstantExpression(taskName));\n}\n```\n\n除了这个转换以外，还有很多其他的情况，现在我们的问题是文章一开始提到的 `task clean(...){ ... }`应当属于那种转换？属于嵌套方法调用的转换。前面我们已经分析到这个写法其实可以等价于 `task(clean(...){ ... })`，对应的转换在 `maybeTransformNestedMethodCall` 方法当中给出了实现，我们摘录一部分给大家了解一下：\n\n```java\nprivate boolean maybeTransformNestedMethodCall(MethodCallExpression nestedMethod, MethodCallExpression target) {\n    ...\n    // Matches: task <identifier> <arg-list> | task <string> <arg-list>\n    // Map to: task(\"<identifier>\", <arg-list>) | task(<string>, <arg-list>)\n    Expression taskName = nestedMethod.getMethod();\n    Expression mapArg = null;\n    List<Expression> extraArgs = Collections.emptyList();\n\n    if (nestedMethod.getArguments() instanceof TupleExpression) {\n        TupleExpression nestedArgs = (TupleExpression) nestedMethod.getArguments();\n        if (nestedArgs.getExpressions().size() == 2 && nestedArgs.getExpression(0) instanceof MapExpression && nestedArgs.getExpression(1) instanceof ClosureExpression) {\n            // Matches: task <identifier>(<options-map>) <closure>\n            mapArg = nestedArgs.getExpression(0);\n            extraArgs = nestedArgs.getExpressions().subList(1, nestedArgs.getExpressions().size());\n        } else {\n            ...\n        }\n    }\n\n    target.setMethod(new ConstantExpression(\"task\"));\n    ArgumentListExpression args = (ArgumentListExpression) target.getArguments();\n    args.getExpressions().clear();\n    // 如果有 map 参数，放到第一个\n    if (mapArg != null) {\n        args.addExpression(mapArg);\n    }\n    // 注意，taskName 被当做参数传入\n    args.addExpression(taskName);\n    // 剩下的参数\n    for (Expression extraArg : extraArgs) {\n        args.addExpression(extraArg);\n    }\n    return true;\n}\n```\n\nmapArg 是否为 null，对应了 task 方法的两个重载版本：\n\n```java\nTask task(String name, Closure configureClosure);\nTask task(Map<String, ?> args, String name, Closure configureClosure);\n```\n\n这么来看，文章开头提到的创建任务的写法，实际上相当于：\n\n```gradle\ntask(type: Delete, \"clean\") {\n    delete rootProject.buildDir\n}\n```\n\n其他类似的 Transformer 大家可以自行分析。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/gradle-task-syntax.md","raw":"---\ntitle:  Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ \nkeywords: Gradle Groovy \ndate: 2021/04/12\ndescription: \ntags: \n    - gradle\n    - groovy \n---\n\n> 任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1ib4y1D74X&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\n```gradle\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n```\n\n它定义了一个叫做 \"clean\" 的任务，这个任务的类型是 Delete。\n\n其中 Delete 是一个类的名字，这是 Groovy 的语法，相当于 Delete.class。这个还好，至少人家语法上支持这样做。\n\n后面的 { ... } 有 Kotlin 经验的小伙伴们自然也不会觉得陌生，这肯定是接收一个 Lambda （在 Groovy 当中就是 Closure）作为参数，里面的 `delete rootProject.buildDir` 则等价于 `delete(rootProject.buildDir)`，这也是 Groovy 的语法，在 Groovy 当中只要不引起歧义，函数的调用是可以去掉括号的，类似的例子有很多：\n\n```gradle\ndependencies {\n    classpath 'com.android.tools.build:gradle:4.0.1'\n    ...\n}\n```\n\n这里的 classpath 也是如此。\n\n这都很容易理解。那么问题来了，`task clean(...){ ... }` 这是个什么语法？我们定义一个名叫 \"clean\" 的任务，这个任务名不应该是一个字符串字面量吗，但现在按照 Groovy 的语法，它应该等价于 `task(clean(...){ ... })` ，这个 clean 看上去其实是个方法名，而不是一个常量。\n\n如果大家跟我一样一开始就绞尽脑汁地去研究这个玩意究竟是什么 Groovy 语法，那你从一开始就错了。这个答案直到我们在翻阅 Gradle 源码的时候，看到有一个叫做 TaskDefinitionScriptTransformer 的类，这个类在 Gradle 脚本编译运行的第二个阶段时被调用，它和其他几个类似的 Transformer 一样，作用就是对源代码的语法树做了一些转换。\n\n大家在 Gradle 源码当中找到这个类之后就会发现，注释已经写的非常清晰了，例如：\n\n```java\nif (args.getExpression(0) instanceof MapExpression && args.getExpression(1) instanceof VariableExpression) {\n    // Matches: task <name-value-pairs>, <identifier>, <arg>?\n    // Map to: task(<name-value-pairs>, '<identifier>', <arg>?)\n    transformVariableExpression(call, 1);\n} else if (args.getExpression(0) instanceof VariableExpression) {\n    // Matches: task <identifier>, <arg>?\n    transformVariableExpression(call, 0);\n}\n```\n\n通过注释我们可以看到，task 实际上是被当做函数来调用的，我们也确实可以在 Project 当中找到它的定义：\n\n![image-20210411072516707](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png)\n\n这个映射实际上就是给 identifier 加了个引号，变成字符串字面量。注意到 `transformVariableExpression(call, 1);` 的第二个参数 1 对应的就是 `<identifier>`，第二个分支里面的位置则是 0。\n\n这个方法的实现也很显而易见：\n\n```java\nprivate void transformVariableExpression(MethodCallExpression call, int index) {\n    ArgumentListExpression args = (ArgumentListExpression) call.getArguments();\n    //拿到 identifier 对应的表达式\n    VariableExpression arg = (VariableExpression) args.getExpression(index);\n    if (!isDynamicVar(arg)) {\n        return;\n    }\n\n    // Matches: task args?, <identifier>, args? or task(args?, <identifier>, args?)\n    // Map to: task(args?, '<identifier>', args?)\n    String taskName = arg.getText(); // 表达式的内容就是任务名\n    call.setMethod(new ConstantExpression(\"task\"));\n    // 创建一个以任务名为内容的字符串字面量\n    args.getExpressions().set(index, new ConstantExpression(taskName));\n}\n```\n\n除了这个转换以外，还有很多其他的情况，现在我们的问题是文章一开始提到的 `task clean(...){ ... }`应当属于那种转换？属于嵌套方法调用的转换。前面我们已经分析到这个写法其实可以等价于 `task(clean(...){ ... })`，对应的转换在 `maybeTransformNestedMethodCall` 方法当中给出了实现，我们摘录一部分给大家了解一下：\n\n```java\nprivate boolean maybeTransformNestedMethodCall(MethodCallExpression nestedMethod, MethodCallExpression target) {\n    ...\n    // Matches: task <identifier> <arg-list> | task <string> <arg-list>\n    // Map to: task(\"<identifier>\", <arg-list>) | task(<string>, <arg-list>)\n    Expression taskName = nestedMethod.getMethod();\n    Expression mapArg = null;\n    List<Expression> extraArgs = Collections.emptyList();\n\n    if (nestedMethod.getArguments() instanceof TupleExpression) {\n        TupleExpression nestedArgs = (TupleExpression) nestedMethod.getArguments();\n        if (nestedArgs.getExpressions().size() == 2 && nestedArgs.getExpression(0) instanceof MapExpression && nestedArgs.getExpression(1) instanceof ClosureExpression) {\n            // Matches: task <identifier>(<options-map>) <closure>\n            mapArg = nestedArgs.getExpression(0);\n            extraArgs = nestedArgs.getExpressions().subList(1, nestedArgs.getExpressions().size());\n        } else {\n            ...\n        }\n    }\n\n    target.setMethod(new ConstantExpression(\"task\"));\n    ArgumentListExpression args = (ArgumentListExpression) target.getArguments();\n    args.getExpressions().clear();\n    // 如果有 map 参数，放到第一个\n    if (mapArg != null) {\n        args.addExpression(mapArg);\n    }\n    // 注意，taskName 被当做参数传入\n    args.addExpression(taskName);\n    // 剩下的参数\n    for (Expression extraArg : extraArgs) {\n        args.addExpression(extraArg);\n    }\n    return true;\n}\n```\n\nmapArg 是否为 null，对应了 task 方法的两个重载版本：\n\n```java\nTask task(String name, Closure configureClosure);\nTask task(Map<String, ?> args, String name, Closure configureClosure);\n```\n\n这么来看，文章开头提到的创建任务的写法，实际上相当于：\n\n```gradle\ntask(type: Delete, \"clean\") {\n    delete rootProject.buildDir\n}\n```\n\n其他类似的 Transformer 大家可以自行分析。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"gradle-task-syntax","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003d001clduzd59dglg6","content":"<blockquote>\n<p>任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1ib4y1D74X&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<span id=\"more\"></span>\n\n\n\n\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">task</span> clean(type: <span class=\"keyword\">Delete</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它定义了一个叫做 “clean” 的任务，这个任务的类型是 Delete。</p>\n<p>其中 Delete 是一个类的名字，这是 Groovy 的语法，相当于 Delete.class。这个还好，至少人家语法上支持这样做。</p>\n<p>后面的 { … } 有 Kotlin 经验的小伙伴们自然也不会觉得陌生，这肯定是接收一个 Lambda （在 Groovy 当中就是 Closure）作为参数，里面的 <code>delete rootProject.buildDir</code> 则等价于 <code>delete(rootProject.buildDir)</code>，这也是 Groovy 的语法，在 Groovy 当中只要不引起歧义，函数的调用是可以去掉括号的，类似的例子有很多：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">classpath</span> <span class=\"string\">&#x27;com.android.tools.build:gradle:4.0.1&#x27;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 classpath 也是如此。</p>\n<p>这都很容易理解。那么问题来了，<code>task clean(...)&#123; ... &#125;</code> 这是个什么语法？我们定义一个名叫 “clean” 的任务，这个任务名不应该是一个字符串字面量吗，但现在按照 Groovy 的语法，它应该等价于 <code>task(clean(...)&#123; ... &#125;)</code> ，这个 clean 看上去其实是个方法名，而不是一个常量。</p>\n<p>如果大家跟我一样一开始就绞尽脑汁地去研究这个玩意究竟是什么 Groovy 语法，那你从一开始就错了。这个答案直到我们在翻阅 Gradle 源码的时候，看到有一个叫做 TaskDefinitionScriptTransformer 的类，这个类在 Gradle 脚本编译运行的第二个阶段时被调用，它和其他几个类似的 Transformer 一样，作用就是对源代码的语法树做了一些转换。</p>\n<p>大家在 Gradle 源码当中找到这个类之后就会发现，注释已经写的非常清晰了，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (args.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> MapExpression &amp;&amp; args.getExpression(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> VariableExpression) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;name-value-pairs&gt;, &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(&lt;name-value-pairs&gt;, &#x27;&lt;identifier&gt;&#x27;, &lt;arg&gt;?)</span></span><br><span class=\"line\">    transformVariableExpression(call, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (args.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> VariableExpression) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class=\"line\">    transformVariableExpression(call, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过注释我们可以看到，task 实际上是被当做函数来调用的，我们也确实可以在 Project 当中找到它的定义：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png\" alt=\"image-20210411072516707\"></p>\n<p>这个映射实际上就是给 identifier 加了个引号，变成字符串字面量。注意到 <code>transformVariableExpression(call, 1);</code> 的第二个参数 1 对应的就是 <code>&lt;identifier&gt;</code>，第二个分支里面的位置则是 0。</p>\n<p>这个方法的实现也很显而易见：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transformVariableExpression</span><span class=\"params\">(MethodCallExpression call, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    ArgumentListExpression args = (ArgumentListExpression) call.getArguments();</span><br><span class=\"line\">    <span class=\"comment\">//拿到 identifier 对应的表达式</span></span><br><span class=\"line\">    VariableExpression arg = (VariableExpression) args.getExpression(index);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDynamicVar(arg)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Matches: task args?, &lt;identifier&gt;, args? or task(args?, &lt;identifier&gt;, args?)</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(args?, &#x27;&lt;identifier&gt;&#x27;, args?)</span></span><br><span class=\"line\">    String taskName = arg.getText(); <span class=\"comment\">// 表达式的内容就是任务名</span></span><br><span class=\"line\">    call.setMethod(<span class=\"keyword\">new</span> ConstantExpression(<span class=\"string\">&quot;task&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个以任务名为内容的字符串字面量</span></span><br><span class=\"line\">    args.getExpressions().set(index, <span class=\"keyword\">new</span> ConstantExpression(taskName));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个转换以外，还有很多其他的情况，现在我们的问题是文章一开始提到的 <code>task clean(...)&#123; ... &#125;</code>应当属于那种转换？属于嵌套方法调用的转换。前面我们已经分析到这个写法其实可以等价于 <code>task(clean(...)&#123; ... &#125;)</code>，对应的转换在 <code>maybeTransformNestedMethodCall</code> 方法当中给出了实现，我们摘录一部分给大家了解一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">maybeTransformNestedMethodCall</span><span class=\"params\">(MethodCallExpression nestedMethod, MethodCallExpression target)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;identifier&gt; &lt;arg-list&gt; | task &lt;string&gt; &lt;arg-list&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(&quot;&lt;identifier&gt;&quot;, &lt;arg-list&gt;) | task(&lt;string&gt;, &lt;arg-list&gt;)</span></span><br><span class=\"line\">    Expression taskName = nestedMethod.getMethod();</span><br><span class=\"line\">    Expression mapArg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    List&lt;Expression&gt; extraArgs = Collections.emptyList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nestedMethod.getArguments() <span class=\"keyword\">instanceof</span> TupleExpression) &#123;</span><br><span class=\"line\">        TupleExpression nestedArgs = (TupleExpression) nestedMethod.getArguments();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nestedArgs.getExpressions().size() == <span class=\"number\">2</span> &amp;&amp; nestedArgs.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> MapExpression &amp;&amp; nestedArgs.getExpression(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> ClosureExpression) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Matches: task &lt;identifier&gt;(&lt;options-map&gt;) &lt;closure&gt;</span></span><br><span class=\"line\">            mapArg = nestedArgs.getExpression(<span class=\"number\">0</span>);</span><br><span class=\"line\">            extraArgs = nestedArgs.getExpressions().subList(<span class=\"number\">1</span>, nestedArgs.getExpressions().size());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    target.setMethod(<span class=\"keyword\">new</span> ConstantExpression(<span class=\"string\">&quot;task&quot;</span>));</span><br><span class=\"line\">    ArgumentListExpression args = (ArgumentListExpression) target.getArguments();</span><br><span class=\"line\">    args.getExpressions().clear();</span><br><span class=\"line\">    <span class=\"comment\">// 如果有 map 参数，放到第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapArg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        args.addExpression(mapArg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意，taskName 被当做参数传入</span></span><br><span class=\"line\">    args.addExpression(taskName);</span><br><span class=\"line\">    <span class=\"comment\">// 剩下的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression extraArg : extraArgs) &#123;</span><br><span class=\"line\">        args.addExpression(extraArg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mapArg 是否为 null，对应了 task 方法的两个重载版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(String name, Closure configureClosure)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(Map&lt;String, ?&gt; args, String name, Closure configureClosure)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这么来看，文章开头提到的创建任务的写法，实际上相当于：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">task</span>(type: <span class=\"keyword\">Delete</span>, <span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他类似的 Transformer 大家可以自行分析。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1ib4y1D74X&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","more":"<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">task</span> clean(type: <span class=\"keyword\">Delete</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它定义了一个叫做 “clean” 的任务，这个任务的类型是 Delete。</p>\n<p>其中 Delete 是一个类的名字，这是 Groovy 的语法，相当于 Delete.class。这个还好，至少人家语法上支持这样做。</p>\n<p>后面的 { … } 有 Kotlin 经验的小伙伴们自然也不会觉得陌生，这肯定是接收一个 Lambda （在 Groovy 当中就是 Closure）作为参数，里面的 <code>delete rootProject.buildDir</code> 则等价于 <code>delete(rootProject.buildDir)</code>，这也是 Groovy 的语法，在 Groovy 当中只要不引起歧义，函数的调用是可以去掉括号的，类似的例子有很多：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">classpath</span> <span class=\"string\">&#x27;com.android.tools.build:gradle:4.0.1&#x27;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 classpath 也是如此。</p>\n<p>这都很容易理解。那么问题来了，<code>task clean(...)&#123; ... &#125;</code> 这是个什么语法？我们定义一个名叫 “clean” 的任务，这个任务名不应该是一个字符串字面量吗，但现在按照 Groovy 的语法，它应该等价于 <code>task(clean(...)&#123; ... &#125;)</code> ，这个 clean 看上去其实是个方法名，而不是一个常量。</p>\n<p>如果大家跟我一样一开始就绞尽脑汁地去研究这个玩意究竟是什么 Groovy 语法，那你从一开始就错了。这个答案直到我们在翻阅 Gradle 源码的时候，看到有一个叫做 TaskDefinitionScriptTransformer 的类，这个类在 Gradle 脚本编译运行的第二个阶段时被调用，它和其他几个类似的 Transformer 一样，作用就是对源代码的语法树做了一些转换。</p>\n<p>大家在 Gradle 源码当中找到这个类之后就会发现，注释已经写的非常清晰了，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (args.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> MapExpression &amp;&amp; args.getExpression(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> VariableExpression) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;name-value-pairs&gt;, &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(&lt;name-value-pairs&gt;, &#x27;&lt;identifier&gt;&#x27;, &lt;arg&gt;?)</span></span><br><span class=\"line\">    transformVariableExpression(call, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (args.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> VariableExpression) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;identifier&gt;, &lt;arg&gt;?</span></span><br><span class=\"line\">    transformVariableExpression(call, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过注释我们可以看到，task 实际上是被当做函数来调用的，我们也确实可以在 Project 当中找到它的定义：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png\" alt=\"image-20210411072516707\"></p>\n<p>这个映射实际上就是给 identifier 加了个引号，变成字符串字面量。注意到 <code>transformVariableExpression(call, 1);</code> 的第二个参数 1 对应的就是 <code>&lt;identifier&gt;</code>，第二个分支里面的位置则是 0。</p>\n<p>这个方法的实现也很显而易见：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transformVariableExpression</span><span class=\"params\">(MethodCallExpression call, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    ArgumentListExpression args = (ArgumentListExpression) call.getArguments();</span><br><span class=\"line\">    <span class=\"comment\">//拿到 identifier 对应的表达式</span></span><br><span class=\"line\">    VariableExpression arg = (VariableExpression) args.getExpression(index);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDynamicVar(arg)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Matches: task args?, &lt;identifier&gt;, args? or task(args?, &lt;identifier&gt;, args?)</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(args?, &#x27;&lt;identifier&gt;&#x27;, args?)</span></span><br><span class=\"line\">    String taskName = arg.getText(); <span class=\"comment\">// 表达式的内容就是任务名</span></span><br><span class=\"line\">    call.setMethod(<span class=\"keyword\">new</span> ConstantExpression(<span class=\"string\">&quot;task&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个以任务名为内容的字符串字面量</span></span><br><span class=\"line\">    args.getExpressions().set(index, <span class=\"keyword\">new</span> ConstantExpression(taskName));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个转换以外，还有很多其他的情况，现在我们的问题是文章一开始提到的 <code>task clean(...)&#123; ... &#125;</code>应当属于那种转换？属于嵌套方法调用的转换。前面我们已经分析到这个写法其实可以等价于 <code>task(clean(...)&#123; ... &#125;)</code>，对应的转换在 <code>maybeTransformNestedMethodCall</code> 方法当中给出了实现，我们摘录一部分给大家了解一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">maybeTransformNestedMethodCall</span><span class=\"params\">(MethodCallExpression nestedMethod, MethodCallExpression target)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Matches: task &lt;identifier&gt; &lt;arg-list&gt; | task &lt;string&gt; &lt;arg-list&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// Map to: task(&quot;&lt;identifier&gt;&quot;, &lt;arg-list&gt;) | task(&lt;string&gt;, &lt;arg-list&gt;)</span></span><br><span class=\"line\">    Expression taskName = nestedMethod.getMethod();</span><br><span class=\"line\">    Expression mapArg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    List&lt;Expression&gt; extraArgs = Collections.emptyList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nestedMethod.getArguments() <span class=\"keyword\">instanceof</span> TupleExpression) &#123;</span><br><span class=\"line\">        TupleExpression nestedArgs = (TupleExpression) nestedMethod.getArguments();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nestedArgs.getExpressions().size() == <span class=\"number\">2</span> &amp;&amp; nestedArgs.getExpression(<span class=\"number\">0</span>) <span class=\"keyword\">instanceof</span> MapExpression &amp;&amp; nestedArgs.getExpression(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> ClosureExpression) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Matches: task &lt;identifier&gt;(&lt;options-map&gt;) &lt;closure&gt;</span></span><br><span class=\"line\">            mapArg = nestedArgs.getExpression(<span class=\"number\">0</span>);</span><br><span class=\"line\">            extraArgs = nestedArgs.getExpressions().subList(<span class=\"number\">1</span>, nestedArgs.getExpressions().size());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    target.setMethod(<span class=\"keyword\">new</span> ConstantExpression(<span class=\"string\">&quot;task&quot;</span>));</span><br><span class=\"line\">    ArgumentListExpression args = (ArgumentListExpression) target.getArguments();</span><br><span class=\"line\">    args.getExpressions().clear();</span><br><span class=\"line\">    <span class=\"comment\">// 如果有 map 参数，放到第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapArg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        args.addExpression(mapArg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意，taskName 被当做参数传入</span></span><br><span class=\"line\">    args.addExpression(taskName);</span><br><span class=\"line\">    <span class=\"comment\">// 剩下的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression extraArg : extraArgs) &#123;</span><br><span class=\"line\">        args.addExpression(extraArg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mapArg 是否为 null，对应了 task 方法的两个重载版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(String name, Closure configureClosure)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Task <span class=\"title\">task</span><span class=\"params\">(Map&lt;String, ?&gt; args, String name, Closure configureClosure)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这么来看，文章开头提到的创建任务的写法，实际上相当于：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">task</span>(type: <span class=\"keyword\">Delete</span>, <span class=\"string\">&quot;clean&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他类似的 Transformer 大家可以自行分析。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？","path":"2021/04/12/gradle-task-syntax/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210411072516707.png","excerpt":"<blockquote>\n<p>任务名居然是以标识符的形式写出来的，你们难道没有觉得奇怪吗？ </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1ib4y1D74X&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","date":{"_isAMomentObject":true,"_i":"2021-04-11T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-04-11T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["gradle","groovy"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"《深入理解 Kotlin 协程》这书该怎么读？","keywords":"Kotlin 协程","date":"2021-01-30T16:00:00.000Z","description":null,"_content":"\n> 趁着面试官还没看，赶紧深入了解一下~~ \n\n\n\n<!-- more -->\n\n\n\n\n鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。\n\n不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。\n\n## 本书收到的评论\n\n以下来自京东自营商品的商品评价，用户关键信息已打码。\n\n### 负面评论\n\n**差评一：完全没干货**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png)\n\n**不正经的回应**：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png)\n\n**正经的回应**：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。\n\n**差评二：一上来就讲原理，压根接受不了**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png)\n\n**不正经的回应**：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png)\n\n**正经的回应**：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。\n\n**中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png)\n\n**不正经的回应**：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png)\n\n**正经的回应**：两个问题：\n1. 代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。\n2. 内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？\n\n**中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png)\n\n**不正经的回应**：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png)\n\n**正经的回应**：也是两个问题：\n1. 缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ\"\"\"  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？\n2. 至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。\n\n**中评三：篇幅太小，一笔带过，算不上深入理解**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png)\n\n**不正经的回应**：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ \n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png)\n\n**正经的回应**：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。\n\n### 正面评论\n\n整体上正面评论更多一些，我就挑了两个列出来：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png)\n\n**不正经的回应**：我没啥好说的，我也是这么想的(✪ω✪)！\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif)\n\n**正经的回应**：这种时候根本正经不起来好吧！\n\n## 本书的阅读建议\n\n咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png)\n\n而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃'▽'〃)\n\n所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。\n\n### 本书的内容来源\n\n要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。\n\n书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：\n\n* 看过我的“[新版Kotlin从入门到精通](https://coding.imooc.com/class/398.html)”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。\n    ![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png)\n    \n    **\"新版Kotlin从入门到精通\" 协程相关章节**\n\n* 看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。\n    ![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png)\n\n    **协程相关历史文章：关注公众号 Kotlin 回复 \"协程\" 获取**\n\n那么我写这本书是不是在重复消费以前的内容呢？\n\n熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png)\n\n而这次编纂成册，其实主要完成了以下两项目标：\n\n1. 概念的清晰化。\n\n    这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？\n    \n    为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。\n\n2. 知识的体系化。\n\n    除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。\n\n    为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。\n\n### 本书的目标读者 \n\n本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif)\n\n话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？\n\n但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。\n\n而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。\n\n至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif)\n\n另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。\n\n### 本书的内容安排\n\n#### 第一章：搞清楚异步程序设计\n\n* 内容难度：※\n* 阅读方式：掌握\n\n想要搞清楚协程，必须先搞清楚异步。\n\n之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。\n\n不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？\n\n本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。\n\n#### 第二章：搞清楚协程的概念\n\n* 内容难度：※※\n* 阅读方式：了解\n\n网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。\n\n这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？\n\n实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。\n\n#### 第三、四章：搞清楚 Kotlin 协程的基础\n\n* 内容难度：第三章 ※※※ 第四章 ※※※※\n* 阅读方式：第三章的内容需要理解，第四章仅供参考可跳过\n\nKotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。\n\n那这么说 Kotlin 协程的设计很失败啊。\n\n其实不然。\n\n协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。\n\nKotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。\n\n还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。\n\n没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png)\n\n讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。\n\n对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。\n\n#### 第五、六章：搞清楚官方的协程框架\n\n* 内容难度：第五章 ※※※※※ 第六章 ※※※\n* 阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法\n\n官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。\n\n我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。\n\n当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。\n\n那么问题来了，这一章算是劝退吗？\n\n显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。\n\n第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。\n\n#### 第七、八章：搞清楚协程的使用场景\n\n* 内容难度：※※※\n* 阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章\n\n这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。\n\n实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。\n\n#### 第九章：搞清楚协程对多平台的支持情况\n\n* 内容难度：※※※※\n* 阅读方式：了解即可\n\n多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。\n\n当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。\n\n## 本书的一些资源\n\n### 本书勘误\n\n从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)\n\n这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png)\n\n**《深入理解 Kotlin 协程》勘误表**\n\n这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 **llt** 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif)\n\n本书的勘误我一直在[我的博客当中关于本书的页面](https://www.bennyhuo.com/project/kotlin-coroutines.html)上有更新。\n\n哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆\n\n### 本书交流\n\n我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png)\n\n**使用手机 QQ 扫描加群**\n\n读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。\n\n另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png)\n\n### 本书源码\n\n本书源码在 GitHub 上完整的给了出来：[DiveIntoKotlinCoroutines-Sources](https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources)（没想到已经 100 多个小星星了(～￣▽￣)～ ）\n\n实际上如果你基础不错，自己研究一下 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。\n\n## 小结\n\n感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。\n\n最后，祝大家春节快乐~\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/how-to-read-the-book-of-coroutines.md","raw":"---\ntitle:  《深入理解 Kotlin 协程》这书该怎么读？ \nkeywords: Kotlin 协程 \ndate: 2021/01/31\ndescription: \ntags: \n    - kotlin\n    - 协程 \n---\n\n> 趁着面试官还没看，赶紧深入了解一下~~ \n\n\n\n<!-- more -->\n\n\n\n\n鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。\n\n不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。\n\n## 本书收到的评论\n\n以下来自京东自营商品的商品评价，用户关键信息已打码。\n\n### 负面评论\n\n**差评一：完全没干货**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png)\n\n**不正经的回应**：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png)\n\n**正经的回应**：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。\n\n**差评二：一上来就讲原理，压根接受不了**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png)\n\n**不正经的回应**：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png)\n\n**正经的回应**：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。\n\n**中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png)\n\n**不正经的回应**：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png)\n\n**正经的回应**：两个问题：\n1. 代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。\n2. 内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？\n\n**中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png)\n\n**不正经的回应**：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png)\n\n**正经的回应**：也是两个问题：\n1. 缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ\"\"\"  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？\n2. 至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。\n\n**中评三：篇幅太小，一笔带过，算不上深入理解**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png)\n\n**不正经的回应**：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ \n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png)\n\n**正经的回应**：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。\n\n### 正面评论\n\n整体上正面评论更多一些，我就挑了两个列出来：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png)\n\n**不正经的回应**：我没啥好说的，我也是这么想的(✪ω✪)！\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif)\n\n**正经的回应**：这种时候根本正经不起来好吧！\n\n## 本书的阅读建议\n\n咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png)\n\n而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃'▽'〃)\n\n所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。\n\n### 本书的内容来源\n\n要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。\n\n书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：\n\n* 看过我的“[新版Kotlin从入门到精通](https://coding.imooc.com/class/398.html)”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。\n    ![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png)\n    \n    **\"新版Kotlin从入门到精通\" 协程相关章节**\n\n* 看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。\n    ![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png)\n\n    **协程相关历史文章：关注公众号 Kotlin 回复 \"协程\" 获取**\n\n那么我写这本书是不是在重复消费以前的内容呢？\n\n熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png)\n\n而这次编纂成册，其实主要完成了以下两项目标：\n\n1. 概念的清晰化。\n\n    这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？\n    \n    为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。\n\n2. 知识的体系化。\n\n    除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。\n\n    为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。\n\n### 本书的目标读者 \n\n本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif)\n\n话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？\n\n但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。\n\n而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。\n\n至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif)\n\n另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。\n\n### 本书的内容安排\n\n#### 第一章：搞清楚异步程序设计\n\n* 内容难度：※\n* 阅读方式：掌握\n\n想要搞清楚协程，必须先搞清楚异步。\n\n之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。\n\n不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？\n\n本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。\n\n#### 第二章：搞清楚协程的概念\n\n* 内容难度：※※\n* 阅读方式：了解\n\n网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。\n\n这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？\n\n实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。\n\n#### 第三、四章：搞清楚 Kotlin 协程的基础\n\n* 内容难度：第三章 ※※※ 第四章 ※※※※\n* 阅读方式：第三章的内容需要理解，第四章仅供参考可跳过\n\nKotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。\n\n那这么说 Kotlin 协程的设计很失败啊。\n\n其实不然。\n\n协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。\n\nKotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。\n\n还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。\n\n没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png)\n\n讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。\n\n对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。\n\n#### 第五、六章：搞清楚官方的协程框架\n\n* 内容难度：第五章 ※※※※※ 第六章 ※※※\n* 阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法\n\n官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。\n\n我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。\n\n当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。\n\n那么问题来了，这一章算是劝退吗？\n\n显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。\n\n第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。\n\n#### 第七、八章：搞清楚协程的使用场景\n\n* 内容难度：※※※\n* 阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章\n\n这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。\n\n实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。\n\n#### 第九章：搞清楚协程对多平台的支持情况\n\n* 内容难度：※※※※\n* 阅读方式：了解即可\n\n多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。\n\n当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。\n\n## 本书的一些资源\n\n### 本书勘误\n\n从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)\n\n这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png)\n\n**《深入理解 Kotlin 协程》勘误表**\n\n这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 **llt** 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif)\n\n本书的勘误我一直在[我的博客当中关于本书的页面](https://www.bennyhuo.com/project/kotlin-coroutines.html)上有更新。\n\n哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆\n\n### 本书交流\n\n我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png)\n\n**使用手机 QQ 扫描加群**\n\n读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。\n\n另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。\n\n![img](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png)\n\n### 本书源码\n\n本书源码在 GitHub 上完整的给了出来：[DiveIntoKotlinCoroutines-Sources](https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources)（没想到已经 100 多个小星星了(～￣▽￣)～ ）\n\n实际上如果你基础不错，自己研究一下 [CoroutineLite](https://github.com/enbandari/CoroutineLite) 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。\n\n## 小结\n\n感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。\n\n最后，祝大家春节快乐~\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"how-to-read-the-book-of-coroutines","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003d001elduz4xb57cwf","content":"<blockquote>\n<p>趁着面试官还没看，赶紧深入了解一下~~ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。</p>\n<p>不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。</p>\n<h2 id=\"本书收到的评论\"><a href=\"#本书收到的评论\" class=\"headerlink\" title=\"本书收到的评论\"></a>本书收到的评论</h2><p>以下来自京东自营商品的商品评价，用户关键信息已打码。</p>\n<h3 id=\"负面评论\"><a href=\"#负面评论\" class=\"headerlink\" title=\"负面评论\"></a>负面评论</h3><p><strong>差评一：完全没干货</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png\"></p>\n<p><strong>不正经的回应</strong>：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png\"></p>\n<p><strong>正经的回应</strong>：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。</p>\n<p><strong>差评二：一上来就讲原理，压根接受不了</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png\"></p>\n<p><strong>不正经的回应</strong>：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png\"></p>\n<p><strong>正经的回应</strong>：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。</p>\n<p><strong>中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png\"></p>\n<p><strong>不正经的回应</strong>：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png\"></p>\n<p><strong>正经的回应</strong>：两个问题：</p>\n<ol>\n<li>代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。</li>\n<li>内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？</li>\n</ol>\n<p><strong>中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png\"></p>\n<p><strong>不正经的回应</strong>：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png\"></p>\n<p><strong>正经的回应</strong>：也是两个问题：</p>\n<ol>\n<li>缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ”””  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？</li>\n<li>至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。</li>\n</ol>\n<p><strong>中评三：篇幅太小，一笔带过，算不上深入理解</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png\"></p>\n<p><strong>不正经的回应</strong>：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png\"></p>\n<p><strong>正经的回应</strong>：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。</p>\n<h3 id=\"正面评论\"><a href=\"#正面评论\" class=\"headerlink\" title=\"正面评论\"></a>正面评论</h3><p>整体上正面评论更多一些，我就挑了两个列出来：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png\"></p>\n<p><strong>不正经的回应</strong>：我没啥好说的，我也是这么想的(✪ω✪)！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif\" alt=\"img\"></p>\n<p><strong>正经的回应</strong>：这种时候根本正经不起来好吧！</p>\n<h2 id=\"本书的阅读建议\"><a href=\"#本书的阅读建议\" class=\"headerlink\" title=\"本书的阅读建议\"></a>本书的阅读建议</h2><p>咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png\"></p>\n<p>而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃’▽’〃)</p>\n<p>所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。</p>\n<h3 id=\"本书的内容来源\"><a href=\"#本书的内容来源\" class=\"headerlink\" title=\"本书的内容来源\"></a>本书的内容来源</h3><p>要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。</p>\n<p>书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：</p>\n<ul>\n<li><p>看过我的“<a href=\"https://coding.imooc.com/class/398.html\">新版Kotlin从入门到精通</a>”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。<br>  <img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png\"></p>\n<p>  <strong>“新版Kotlin从入门到精通” 协程相关章节</strong></p>\n</li>\n<li><p>看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。<br>  <img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png\"></p>\n<p>  <strong>协程相关历史文章：关注公众号 Kotlin 回复 “协程” 获取</strong></p>\n</li>\n</ul>\n<p>那么我写这本书是不是在重复消费以前的内容呢？</p>\n<p>熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png\"></p>\n<p>而这次编纂成册，其实主要完成了以下两项目标：</p>\n<ol>\n<li><p>概念的清晰化。</p>\n<p> 这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？</p>\n<p> 为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。</p>\n</li>\n<li><p>知识的体系化。</p>\n<p> 除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。</p>\n<p> 为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。</p>\n</li>\n</ol>\n<h3 id=\"本书的目标读者\"><a href=\"#本书的目标读者\" class=\"headerlink\" title=\"本书的目标读者\"></a>本书的目标读者</h3><p>本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif\" alt=\"img\"></p>\n<p>话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？</p>\n<p>但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。</p>\n<p>而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。</p>\n<p>至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif\" alt=\"img\"></p>\n<p>另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。</p>\n<h3 id=\"本书的内容安排\"><a href=\"#本书的内容安排\" class=\"headerlink\" title=\"本书的内容安排\"></a>本书的内容安排</h3><h4 id=\"第一章：搞清楚异步程序设计\"><a href=\"#第一章：搞清楚异步程序设计\" class=\"headerlink\" title=\"第一章：搞清楚异步程序设计\"></a>第一章：搞清楚异步程序设计</h4><ul>\n<li>内容难度：※</li>\n<li>阅读方式：掌握</li>\n</ul>\n<p>想要搞清楚协程，必须先搞清楚异步。</p>\n<p>之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。</p>\n<p>不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？</p>\n<p>本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。</p>\n<h4 id=\"第二章：搞清楚协程的概念\"><a href=\"#第二章：搞清楚协程的概念\" class=\"headerlink\" title=\"第二章：搞清楚协程的概念\"></a>第二章：搞清楚协程的概念</h4><ul>\n<li>内容难度：※※</li>\n<li>阅读方式：了解</li>\n</ul>\n<p>网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。</p>\n<p>这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？</p>\n<p>实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。</p>\n<h4 id=\"第三、四章：搞清楚-Kotlin-协程的基础\"><a href=\"#第三、四章：搞清楚-Kotlin-协程的基础\" class=\"headerlink\" title=\"第三、四章：搞清楚 Kotlin 协程的基础\"></a>第三、四章：搞清楚 Kotlin 协程的基础</h4><ul>\n<li>内容难度：第三章 ※※※ 第四章 ※※※※</li>\n<li>阅读方式：第三章的内容需要理解，第四章仅供参考可跳过</li>\n</ul>\n<p>Kotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。</p>\n<p>那这么说 Kotlin 协程的设计很失败啊。</p>\n<p>其实不然。</p>\n<p>协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。</p>\n<p>Kotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。</p>\n<p>还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。</p>\n<p>没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png\"></p>\n<p>讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。</p>\n<p>对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。</p>\n<h4 id=\"第五、六章：搞清楚官方的协程框架\"><a href=\"#第五、六章：搞清楚官方的协程框架\" class=\"headerlink\" title=\"第五、六章：搞清楚官方的协程框架\"></a>第五、六章：搞清楚官方的协程框架</h4><ul>\n<li>内容难度：第五章 ※※※※※ 第六章 ※※※</li>\n<li>阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法</li>\n</ul>\n<p>官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。</p>\n<p>我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。</p>\n<p>当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。</p>\n<p>那么问题来了，这一章算是劝退吗？</p>\n<p>显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。</p>\n<p>第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。</p>\n<h4 id=\"第七、八章：搞清楚协程的使用场景\"><a href=\"#第七、八章：搞清楚协程的使用场景\" class=\"headerlink\" title=\"第七、八章：搞清楚协程的使用场景\"></a>第七、八章：搞清楚协程的使用场景</h4><ul>\n<li>内容难度：※※※</li>\n<li>阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章</li>\n</ul>\n<p>这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。</p>\n<p>实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。</p>\n<h4 id=\"第九章：搞清楚协程对多平台的支持情况\"><a href=\"#第九章：搞清楚协程对多平台的支持情况\" class=\"headerlink\" title=\"第九章：搞清楚协程对多平台的支持情况\"></a>第九章：搞清楚协程对多平台的支持情况</h4><ul>\n<li>内容难度：※※※※</li>\n<li>阅读方式：了解即可</li>\n</ul>\n<p>多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。</p>\n<p>当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。</p>\n<h2 id=\"本书的一些资源\"><a href=\"#本书的一些资源\" class=\"headerlink\" title=\"本书的一些资源\"></a>本书的一些资源</h2><h3 id=\"本书勘误\"><a href=\"#本书勘误\" class=\"headerlink\" title=\"本书勘误\"></a>本书勘误</h3><p>从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)</p>\n<p>这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png\"></p>\n<p><strong>《深入理解 Kotlin 协程》勘误表</strong></p>\n<p>这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 <strong>llt</strong> 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif\" alt=\"img\"></p>\n<p>本书的勘误我一直在<a href=\"https://www.bennyhuo.com/project/kotlin-coroutines.html\">我的博客当中关于本书的页面</a>上有更新。</p>\n<p>哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆</p>\n<h3 id=\"本书交流\"><a href=\"#本书交流\" class=\"headerlink\" title=\"本书交流\"></a>本书交流</h3><p>我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png\"></p>\n<p><strong>使用手机 QQ 扫描加群</strong></p>\n<p>读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。</p>\n<p>另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png\" alt=\"img\"></p>\n<h3 id=\"本书源码\"><a href=\"#本书源码\" class=\"headerlink\" title=\"本书源码\"></a>本书源码</h3><p>本书源码在 GitHub 上完整的给了出来：<a href=\"https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources\">DiveIntoKotlinCoroutines-Sources</a>（没想到已经 100 多个小星星了(～￣▽￣)～ ）</p>\n<p>实际上如果你基础不错，自己研究一下 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。</p>\n<p>最后，祝大家春节快乐~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>趁着面试官还没看，赶紧深入了解一下~~ </p>\n</blockquote>","more":"<p>鼠年进入了尾声，想想过去的这一年还是发生了很多事情：终于有了回家的高铁，可刚回家没几天就又匆匆踏上了返京的旅途；写了一本书；做了一次线下的大会分享；做了两次线上的分享；上线了一套课程；买了 * * *；在公司也终于起了一个跨平台（Android + Linux）的项目，体验了一把 Kotlin MPP 等等，话说我司今年的阳光有点儿刺眼啊 ：）。想了想，这一年也过得挺充实。</p>\n<p>不过，也有些地方做的不好，例如书出版之后就没怎么管过了，就感觉这本书不是我写的一样。最近终于得空，为了了解一下读者遇到的问题，就去京东上刷了一下本书的评论，发现其中的内容非常有趣。在对这些评论做出回应的同时，我也希望能够对大家阅读本书提供一些帮助。</p>\n<h2 id=\"本书收到的评论\"><a href=\"#本书收到的评论\" class=\"headerlink\" title=\"本书收到的评论\"></a>本书收到的评论</h2><p>以下来自京东自营商品的商品评价，用户关键信息已打码。</p>\n<h3 id=\"负面评论\"><a href=\"#负面评论\" class=\"headerlink\" title=\"负面评论\"></a>负面评论</h3><p><strong>差评一：完全没干货</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png\"></p>\n<p><strong>不正经的回应</strong>：我都惊呆了，居然说我的书没干货！你知道吗，以前大家可都是吐槽我写的东西干货太多了呢 ψ(*｀ー´)ψ。至于说“一会儿就翻完了”这事儿，200 多页如果只是翻的话，确实很快 (｀・ω・´)。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-30-13.png\"></p>\n<p><strong>正经的回应</strong>：想要了解 Kotlin 协程的底层原理，请参见：本书第 3 ~ 5 章，其中第 3 章重要从底层的标准库 API 讲起，对挂起函数的本质、协程上下文、拦截器等概念做了深入的讲解；第 4 章主要是对第 3 章知识的应用；第 5 章则是对官方协程框架内核的剖析，剖析的方法就是我们一步一步地实现了一套精简版的协程框架 CoroutineLite。</p>\n<p><strong>差评二：一上来就讲原理，压根接受不了</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-24.png\"></p>\n<p><strong>不正经的回应</strong>：我没有，我不是，别瞎说啊 ┗( ▔, ▔ )┛</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-34-00.png\"></p>\n<p><strong>正经的回应</strong>：实际上本书的开篇并没有讲原理，而是讲概念。我们必须先统一对概念的理解和认识，才能够在后续的深入理解上畅通无阻。因此，第 1 章是对整体异步程序的概念做了剖析，这是整个协程概念的基础；第 2 章剖析协程的概念，光讲概念太抽象，于是我还结合了常见的协程实现做了阐述。</p>\n<p><strong>中评一：代码贴得多，理论分析少；内容不深刻，停留在基础阶段</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-58-00.png\"></p>\n<p><strong>不正经的回应</strong>：额，你可能不知道，我的书刚出版的时候，群里的小伙伴们看了之后都在说比某某源码**强太多了，是我听错了么 (；´д｀)ゞ</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-37-20.png\"></p>\n<p><strong>正经的回应</strong>：两个问题：</p>\n<ol>\n<li>代码贴得多不多这个问题，技术书籍难免需要贴代码。到底什么是多，每个人的看法不一样，我只给出统计数据（基于本书底稿，与最终排版结果可能有稍许出入）（￣︶￣）↗：本书纯文字部分约 6000 行；插图共计 67 幅；代码部分约 3350 行，其中 Kotlin 约 3200 行，Java 62 行，JavaScript 41 行，Python 27 行，Lua 25 行，C 11 行。插图排版之后平均约占 10 行的篇幅，由此估计本书文字部分占比约 60%，插图部分占比约 7%，代码部分占比约 33%。</li>\n<li>内容不深刻，停留在基础阶段。不错，我确实是花了三分之一的篇幅讲基础，也花了三分之一的篇幅讲进阶，还花了三分之一的篇幅讲实战，你不妨看完第一章第一节之后再往后看一看(Θ０Θ●)？</li>\n</ol>\n<p><strong>中评二：缺乏系统性介绍；代码格式很??（目测是很乱的意思）</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-44-01.png\"></p>\n<p><strong>不正经的回应</strong>：你是不喜欢 JetBrains Mono 吗？难道你的代码用的是微软雅黑？╮(╯﹏╰）╭</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-41-05.png\"></p>\n<p><strong>正经的回应</strong>：也是两个问题：</p>\n<ol>\n<li>缺乏系统性介绍这个问题，可能真的不存在。我也做过反思，这本书可能最大的问题是没有迎合多数开发者“速成 Kotlin 协程”的想法，也就是说我可能就是因为讲的太系统了 (๑╹◡╹)ﾉ”””  —— 但饭要一口一口吃嘛，速成的东西又有什么价值呢？</li>\n<li>至于代码格式，审美这个东西也是因人而异。还是老规矩，我只列出我做过的一些努力：为了防止被动折行的产生，我将缩进调成了 2 个空格；本书终稿我把所有被动折行的部分全部通过手动重排以使代码看起来更加清晰，也就是说你看到的书上应该很少有代码单行字符数超过 80 的情况；另外，本书代码全部采用 JetBrains Mono 字体。如果你觉得这样不好，也可以评论告诉我具体怎么样是好的。</li>\n</ol>\n<p><strong>中评三：篇幅太小，一笔带过，算不上深入理解</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-08-54-14.png\"></p>\n<p><strong>不正经的回应</strong>：啊，我懂了！作为优秀的打工人，我猜你一定喜欢1000多页的大砖头！ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ </p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-43-40.png\"></p>\n<p><strong>正经的回应</strong>：其实吧，对于本书的评价，负面的主要是两种声音：一种是太深了，读不懂；另一种是算不上深入理解。ε=(´ο｀*)))唉，我好难。你好歹看一看书的内容再来喷也不迟啊。</p>\n<h3 id=\"正面评论\"><a href=\"#正面评论\" class=\"headerlink\" title=\"正面评论\"></a>正面评论</h3><p>整体上正面评论更多一些，我就挑了两个列出来：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-09-04-25.png\"></p>\n<p><strong>不正经的回应</strong>：我没啥好说的，我也是这么想的(✪ω✪)！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D2C7B5.gif\" alt=\"img\"></p>\n<p><strong>正经的回应</strong>：这种时候根本正经不起来好吧！</p>\n<h2 id=\"本书的阅读建议\"><a href=\"#本书的阅读建议\" class=\"headerlink\" title=\"本书的阅读建议\"></a>本书的阅读建议</h2><p>咳咳，严肃点儿哈。实际上之所以有差评，就是因为有误会。毕竟大家的知识背景有差异，而一本书想要填平这差异显然是不现实的。当然不排除有人恶意评价，但相信这种情况应该占少数。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-47-18.png\"></p>\n<p>而我本人呢，在出版这本书之后几乎没有再对它做过任何补充和说明，甚至连协程的文章都没有再写了，想来也有点儿没道理。有朋友说我简直佛系到家了。(〃’▽’〃)</p>\n<p>所以接下来我提供一些我对阅读本书的看法，看看能不能帮助大家更好的阅读这本书。</p>\n<h3 id=\"本书的内容来源\"><a href=\"#本书的内容来源\" class=\"headerlink\" title=\"本书的内容来源\"></a>本书的内容来源</h3><p>要搞清楚怎么阅读本书，先来看看本书的内容到底是怎么来的。</p>\n<p>书中的内容是从我这几年的公众号文章、视频课程以及项目实践当中逐渐积累下来的：</p>\n<ul>\n<li><p>看过我的“<a href=\"https://coding.imooc.com/class/398.html\">新版Kotlin从入门到精通</a>”视频课程第11-13章大概 10 个小时的协程内容的朋友可能会对本书的第3-5章比较熟悉，我在这部分内容主要系统的给出了协程的概念，以及框架封装的思路和方法。<br>  <img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-03-07.png\"></p>\n<p>  <strong>“新版Kotlin从入门到精通” 协程相关章节</strong></p>\n</li>\n<li><p>看过我在公众号之前发布的将近 20 篇文章的朋友，可能会对第 6 章以及第 7 章的很小的一部分内容感到熟悉。<br>  <img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-07-16.png\"></p>\n<p>  <strong>协程相关历史文章：关注公众号 Kotlin 回复 “协程” 获取</strong></p>\n</li>\n</ul>\n<p>那么我写这本书是不是在重复消费以前的内容呢？</p>\n<p>熟悉我的朋友可能会知道，我可从来不做这样的事儿。因为我也有学习的诉求，我也需要在讲给大家听的过程中保证自己也能学到东西。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-09-09-48-56.png\"></p>\n<p>而这次编纂成册，其实主要完成了以下两项目标：</p>\n<ol>\n<li><p>概念的清晰化。</p>\n<p> 这一点其实也是为了应对协程概念混乱的现状的。大家讨论来讨论去，还是搞不明白究竟什么是协程，好用不容易从理论的角度摸着点儿门道，一看 Kotlin 代码里面既有 startCoroutine ，也有 launch，于是就又蒙了：它们到底哪个启动的才是协程？</p>\n<p> 为了解决这个问题，我在本书的前几章给协程在不同应用层面的 API 下了个定义，前面的叫简单协程，后面的叫复合协程，方便我们在行文和讨论过程中区分开来；也总结了协程框架封装的套路，一方面希望大家看到官方框架时不要感到害怕，另一方面也能够在实践中令读者有能力自己做一些扩展。</p>\n</li>\n<li><p>知识的体系化。</p>\n<p> 除了搞不清楚什么是协程之外，大家最爱问题的问题就是协程有什么用，而且很多时候一些已经对协程掌握得还不错的开发者，当你问到他协程什么情况下能解决异步问题，或者为什么有时候协程并不轻量这些问题的时候，一样大概率讲不清楚。原因在哪儿？多数是因为对于某些问题的应用场景不熟悉，既没有搞清楚问题本身，也没有搞清楚问题的解决方案。</p>\n<p> 为了解决这个问题，我在本书的第 7、8 两章当中从问题本身出发，对比多年的解决方案的演进过程，进而阐述 Kotlin 协程的作用。搞清楚来龙去脉，自然很多问题也就迎刃而解了。</p>\n</li>\n</ol>\n<h3 id=\"本书的目标读者\"><a href=\"#本书的目标读者\" class=\"headerlink\" title=\"本书的目标读者\"></a>本书的目标读者</h3><p>本书的目标读者是真正希望能深入理解 Kotlin 协程的开发者。如果你只是想要速成，那本书真的会让你失望。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D20B1C.gif\" alt=\"img\"></p>\n<p>话说到这儿，可能多数开发者阅读本书的想法都是要速成 Kotlin 协程，那我应该照着这个思路去安排书的内容。没错，从商业化的角度，是应该这样，我又何尝不想写一本爆款，好好搏一把名声呢？</p>\n<p>但事儿可以这么想，但却不能这么做。我们要尊重客观事实，速成 Kotlin 协程这件事儿，真的不靠谱，因为你可能搞不清楚挂起函数到底是怎么挂起的，你也搞不清楚调度器到底是怎么调度协程的，你甚至还会在协程内部随意访问外部变量，以至于出了问题也根本不知道如何下手去解决。</p>\n<p>而这些问题的细节，只有我们试图“深入理解 Kotlin 协程”时，才能彻底明白。</p>\n<p>至于只是希望把协程当做切换线程的工具的朋友，你确实没必要阅读本书。非要跟我杠协程只是一个线程框架或者协程只是线程的封装的朋友，建议你把我拉黑。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D4A08C.gif\" alt=\"img\"></p>\n<p>另外，由于 Kotlin 协程算是 Kotlin 的高级特性了，对于 Kotlin 的基础语法要求比较高，这其中对于 Kotlin 的函数基础的要求尤为突出，因此读者需要有扎实的 Kotlin 语言基础。</p>\n<h3 id=\"本书的内容安排\"><a href=\"#本书的内容安排\" class=\"headerlink\" title=\"本书的内容安排\"></a>本书的内容安排</h3><h4 id=\"第一章：搞清楚异步程序设计\"><a href=\"#第一章：搞清楚异步程序设计\" class=\"headerlink\" title=\"第一章：搞清楚异步程序设计\"></a>第一章：搞清楚异步程序设计</h4><ul>\n<li>内容难度：※</li>\n<li>阅读方式：掌握</li>\n</ul>\n<p>想要搞清楚协程，必须先搞清楚异步。</p>\n<p>之前有人在我的博客下跟我争论什么是异步，提到异步必然切线程的事儿，这恐怕也是令大多数开发者感到困惑的地方。</p>\n<p>不切线程怎么实现异步？不理解这一点，说到底，还是对于程序设计了解得太少了。如果跳出我们平常习惯的领域，多看一看其他领域的程序设计，其实很容易想到：写 JavaScript 程序的开发者可能都没怎么接触过线程，但这也不妨碍人家使用异步 API。再说一个大家熟悉的，基于 Android Handler 的 post 方法，需要切线程吗？</p>\n<p>本书的开篇就在讲什么是异步，想要搞清楚异步程序设计，先仔细阅读这一章。这一章提到的异步程序设计思路，也正与后面第五章剖析官方协程框架设计思路相对应。</p>\n<h4 id=\"第二章：搞清楚协程的概念\"><a href=\"#第二章：搞清楚协程的概念\" class=\"headerlink\" title=\"第二章：搞清楚协程的概念\"></a>第二章：搞清楚协程的概念</h4><ul>\n<li>内容难度：※※</li>\n<li>阅读方式：了解</li>\n</ul>\n<p>网上关于协程的讨论是非常多的。我们在试图搞清楚 Kotlin 协程是什么的时候也难免会看到有人在讨论 Lua 协程是什么，async/await 是什么，Go routine 又是什么。大家都不一样，怎么都叫协程？这就是第二章讲的内容。</p>\n<p>这块儿有人也提出质疑：我只想学 Kotlin 协程，你为什么让我看什么 Lua、JavaScript？</p>\n<p>实际上，这一章的内容不需要读者对其他语言有深入的了解，我把它们的例子写出来也只是为了让大家找一下协程的感觉，仅此而已。当然，作为开发者，适当的多了解一些编程语言，对于深入认识自己所专注的领域是有帮助的。</p>\n<h4 id=\"第三、四章：搞清楚-Kotlin-协程的基础\"><a href=\"#第三、四章：搞清楚-Kotlin-协程的基础\" class=\"headerlink\" title=\"第三、四章：搞清楚 Kotlin 协程的基础\"></a>第三、四章：搞清楚 Kotlin 协程的基础</h4><ul>\n<li>内容难度：第三章 ※※※ 第四章 ※※※※</li>\n<li>阅读方式：第三章的内容需要理解，第四章仅供参考可跳过</li>\n</ul>\n<p>Kotlin 协程难就难在它的各种细节都被暴露了出来。相比之下无论是 Go routine、还是 JavaScript 的 async/await，内部实现细节都没有暴露，对于这些语言的协程设计，开发者确实可以实现“速成”。</p>\n<p>那这么说 Kotlin 协程的设计很失败啊。</p>\n<p>其实不然。</p>\n<p>协程的设计实现往往需要运行时的支持，也正是如此，Go routine 不需要暴露它的调度细节，这些工作全部由 Go 运行时来搞定；JavaScript 的 async/await 也不用，因为 JavaScript 的环境绝大多数都是单线程的，运行时也提供了足够多的异步 API 供我们调用，开发者根本不用关心什么线程调度，什么异常处理的细节。</p>\n<p>Kotlin 为什么不能在运行时提供此类支持呢？因为多数情况下，Kotlin 没有自己的运行时。Kotlin/JVM 运行在 JVM 上（或者 Android VM 上），Kotlin/JS 运行在 JavaScript 的环境当中（可能是浏览器，也可能是 Node.js 等等），没有自己的运行时的结果就是 Kotlin 协程只能在编译时加入“魔法”。它不能保证运行时能够自动处理调度；也不能保证运行时就只有一个线程；面对 JVM，它还必须能够灵活的切换线程； JVM 上的 API 多数都是阻塞的，它还要能够方便的实现阻塞与非阻塞的转换。所以它能简单吗？它不能。</p>\n<p>还有一个原因，Kotlin 要面向多平台来实现自己的协程。当它运行在 JVM 上时，Java 开发者可能用它来做高并发的服务，类似于 Go routine 那样的“轻量级线程”的使用场景更多；Android 开发者可能用它来做异步 UI，类似于 JavaScript 的 async/await 的场景更多。当它运行在 JavaScript 环境中时，还有能与 JavaScript 基于 Promise 的 async/await 无缝衔接。而当它运行在 Native 环境中时，Kotlin 官方现在似乎还没有完全确定最终能够实现成什么样。</p>\n<p>没有自己的运行时，还有面对这么多的目标场景，Kotlin 协程的设计能够设计成这样，也实属不易。每次想起这个事儿我都不得不感叹现在身为 Kotlin Leader 的 Roman 在设计协程时面临了怎样的挑战，不过大佬毕竟是大佬：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-10-11-39.png\"></p>\n<p>讲到这儿，我想说的是，一定要踏踏实实地搞清楚第三章的内容，这是整个 Kotlin 协程的基础。第四章是运用第三章的知识在落地实践，我在这一章也会摸索出一套构建协程框架的思路，这个思路将在第五章得到进一步实践。</p>\n<p>对了，稍微提一句的是，我在 Kotlin 教学过程中发现多数开发者搞不清楚 Receiver，对于 Kotlin 的函数的认知也比较浅，这会成为 Kotlin 协程学习的严重阻碍。再次强调，想要学好 Kotlin 协程，Kotlin 的基本功要扎实。</p>\n<h4 id=\"第五、六章：搞清楚官方的协程框架\"><a href=\"#第五、六章：搞清楚官方的协程框架\" class=\"headerlink\" title=\"第五、六章：搞清楚官方的协程框架\"></a>第五、六章：搞清楚官方的协程框架</h4><ul>\n<li>内容难度：第五章 ※※※※※ 第六章 ※※※</li>\n<li>阅读方式：第五章配合源码了解即可，第六章掌握框架的使用方法</li>\n</ul>\n<p>官方的协程框架实际上也是分了两个层次的。核心层就是我在第五章手把手带着大家实现的 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 所涉及的部分，包括调度器、异常处理、取消响应、作用域等内容，这部分内容官方没有特别多的文档，有些地方的设计也比较反直觉，所以如果搞不清楚其本质，很难在实际应用中做到心中有数。</p>\n<p>我也是在对官方框架不断地调试过程中逐渐分析总结，才形成了第五章的内容基础。为了降低对官方框架的理解难度，我从零开始一步一步介绍了 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 的设计和实现过程，框架代码整体也就几百行，稍微花点儿时间就能够达到掌握官方框架实现细节的水平，可以算是一条捷径了。</p>\n<p>当然，第五章真的是难，但难点本质上并不是协程的设计思路本身，而是对很多 Kotlin 基础语法特别是函数特性的综合运用，以及 对 Java 并发包当中的原子类型的运用，读者需要有扎实的 Kotlin 语言功底和 Java 并发编程基础才能很好的理解这一章。</p>\n<p>那么问题来了，这一章算是劝退吗？</p>\n<p>显然不是，知识本来就是递进的，基础不牢地动山摇，该补充什么背景知识，那就抓紧时间去补充。我已经知道有不少读者把这一章吃透了，甚至有朋友看过之后直呼过瘾，这说明只要有一定的基础，这一章就不是那么的难。</p>\n<p>第六章就比较中规中矩了，是对官方协程框架的应用层做的一些介绍，以用法为主，因此难度相对低一些。稍微提一句，协程框架的应用层（包括 Channel、Flow 等等）还在不断演进，因此本书的部分内容（例如 Flow，本书编写时还在实验阶段）可能与最新版本有些许出入，但这并不会影响你掌握官方的协程框架，因为前面的内容已经足够支撑你通过阅读官方 API 来了解其用法了。</p>\n<h4 id=\"第七、八章：搞清楚协程的使用场景\"><a href=\"#第七、八章：搞清楚协程的使用场景\" class=\"headerlink\" title=\"第七、八章：搞清楚协程的使用场景\"></a>第七、八章：搞清楚协程的使用场景</h4><ul>\n<li>内容难度：※※※</li>\n<li>阅读方式：Android 开发者重点看第七章，Java 开发者重点看第八章</li>\n</ul>\n<p>这部分内容主要就 Android 应用开发和 Java Web 服务应用开发过程当中遇到的异步和并发问题展开介绍。通过对比以往的 API 和协程风格的 API 之间的使用差异，以使读者充分了解协程的应用场景。</p>\n<p>实际上，这部分内容也对于协程在什么情况下表现得“轻量”以及怎么解决异步问题结合实际问题给出了答案，是理论联系实际的一部分内容。</p>\n<h4 id=\"第九章：搞清楚协程对多平台的支持情况\"><a href=\"#第九章：搞清楚协程对多平台的支持情况\" class=\"headerlink\" title=\"第九章：搞清楚协程对多平台的支持情况\"></a>第九章：搞清楚协程对多平台的支持情况</h4><ul>\n<li>内容难度：※※※※</li>\n<li>阅读方式：了解即可</li>\n</ul>\n<p>多平台作为 Kotlin 重要特性，Kotlin 协程对多平台的支持自然是对 Kotlin 协程进行系统化剖析时不可或缺的组成部分。但由于多平台特性仍处于快速演进的阶段，因此这部分内容很可能会在不久的将来“过时”。不过这并不影响大家通过阅读本章来理解 Kotlin 协程在多平台支持过程中的努力和方向。</p>\n<p>当然，这部分内容主要面向有跨平台需要的开发者，暂时没有多平台应用需要的读者，可以跳过或者简单浏览本章的内容。</p>\n<h2 id=\"本书的一些资源\"><a href=\"#本书的一些资源\" class=\"headerlink\" title=\"本书的一些资源\"></a>本书的一些资源</h2><h3 id=\"本书勘误\"><a href=\"#本书勘误\" class=\"headerlink\" title=\"本书勘误\"></a>本书勘误</h3><p>从书出版的一开始，我一直在维护勘误表，也不能算是对这本书不管不顾吧。(▼ヘ▼#)</p>\n<p>这本书是在 2020 年 6 月出版的。截止目前经读者反馈，第一版有共计 9 处问题，还好，问题不大，很容易就能看出来：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-29-07-19-23.png\"></p>\n<p><strong>《深入理解 Kotlin 协程》勘误表</strong></p>\n<p>这里也要感谢为本书勘误的读者。大家看，9 个问题有 7 个是一位 ID 叫 <strong>llt</strong> 的兄弟提出来的，他现在也是我们下面提到的 QQ 群里面目前为止唯一的管理员。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/05D8426B.gif\" alt=\"img\"></p>\n<p>本书的勘误我一直在<a href=\"https://www.bennyhuo.com/project/kotlin-coroutines.html\">我的博客当中关于本书的页面</a>上有更新。</p>\n<p>哦对了，这些问题在 2020 年 10 月印刷的版本里面已经看不到了，所以如果你发现书上的内容居然是对的，也不要感觉惊讶。(^_−)☆</p>\n<h3 id=\"本书交流\"><a href=\"#本书交流\" class=\"headerlink\" title=\"本书交流\"></a>本书交流</h3><p>我专门建了个 QQ 群用来方便大家交流，目前已经有一些读者加了进来，群号：612797230。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-02-01-11-15-45.png\"></p>\n<p><strong>使用手机 QQ 扫描加群</strong></p>\n<p>读书的目的是学到东西，与其在线上发泄情绪，不如跟我说说你到底遇到了什么问题。</p>\n<p>另外，没有微信群，因为微信群的二维码只有7天有效期，管理起来太麻烦。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/06188B73.png\" alt=\"img\"></p>\n<h3 id=\"本书源码\"><a href=\"#本书源码\" class=\"headerlink\" title=\"本书源码\"></a>本书源码</h3><p>本书源码在 GitHub 上完整的给了出来：<a href=\"https://github.com/enbandari/DiveIntoKotlinCoroutines-Sources\">DiveIntoKotlinCoroutines-Sources</a>（没想到已经 100 多个小星星了(～￣▽￣)～ ）</p>\n<p>实际上如果你基础不错，自己研究一下 <a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a> 这个项目一样可以对协程有深入的了解。之前看到有群友说这本书最有价值的部分应该就是 CoroutineLite 这个框架了 —— 是不是最有价值，不同人有不同的看法，但目前还没有看到第二个有类似功能的框架供大家参考。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>感谢每一位支持和帮助我的朋友，也希望《深入理解 Kotlin 协程》这本书能够帮助到大家。</p>\n<p>最后，祝大家春节快乐~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"《深入理解 Kotlin 协程》这书该怎么读？","path":"2021/01/31/how-to-read-the-book-of-coroutines/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-31-07-46-55.png","excerpt":"<blockquote>\n<p>趁着面试官还没看，赶紧深入了解一下~~ </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-01-30T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-01-30T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","协程"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 1.4 新特性预览","keywords":"Kotlin 1.4 新版本","date":"2020-03-25T16:00:00.000Z","description":null,"_content":"\n> Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 \n\n\n\n<!-- more -->\n\n\n\n\nKotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在[这里查看](https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md)。\n\n生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png)\n\n**<center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center>**\n\n安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png)\n\n**<center>图 2：升级 Kotlin 插件</center>**\n\n好了，重启 IntelliJ，新建一个工程试试看吧~~\n\n## 2. 主要的语法更新\n\n接下来我们就按照官方博客给出的介绍 [Kotlin 1.4-M1 Released](https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/) 来体验下新特性。\n\n本文源码均已整理至 GitHub：[Kotlin1.4FeaturesSample](https://github.com/enbandari/Kotlin1.4FeaturesSample)。\n\n### 2.1 Kotlin 接口和函数的 SAM 转换\n\n一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：\n\n```kotlin\n//注意 fun interface 是新特性\nfun interface Action {\n    fun run()\n}\n\n// Kotlin 函数，参数为 Kotlin 单一方法接口\nfun runAction(a: Action) = a.run()\n// Kotlin 函数，参数为 Java 单一方法接口\nfun runRunnable(r: Runnable) = r.run()\n```\n\n在 1.4 以前，我们只能：\n\n```kotlin\nrunAction(object: Action{\n    override fun run() {\n        println(\"Not good..\")\n    }\n})\n```\n\n或者\n\n```kotlin\nrunAction(Action { println(\"Not good..\") })\n```\n\nrunRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。\n\n现在在 1.4 当中呢？\n\n```kotlin\nrunAction { println(\"Hello, Kotlin 1.4!\") }\nrunRunnable { println(\"Hello, Kotlin 1.4!\") }\n```\n\n真是妙啊。\n\n### 2.2 类型推导支持了更多的场景\n\n类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。\n\n例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：\n\n```kotlin\nval rulesMap: Map<String, (String?) -> Boolean> = mapOf(\n    \"weak\" to { it != null },\n    \"medium\" to { !it.isNullOrBlank() },\n    \"strong\" to { it != null && \"^[a-zA-Z0-9]+$\".toRegex().matches(it) }\n)\n```\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png)\n\n**<center>图 3：Kotlin 1.3 中提示类型不匹配</center>**\n\n博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。\n\n### 2.3 Lambda 表达式最后一行的智能类型转换\n\n这个比较容易理解，直接看例子：\n\n```kotlin\nval result = run {\n    var str = currentValue()\n    if (str == null) {\n        str = \"test\"\n    }\n    str // the Kotlin compiler knows that str is not null here\n}\n// The type of 'result' is String? in Kotlin 1.3 and String in Kotlin 1.4\n```\n\n这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。\n\n在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。\n\n在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。\n\n稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png)\n\n**<center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center>**\n\n我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。\n\n当然，有些开发者经常会抱怨类似下面的这种情况：\n\n```kotlin\nvar x: String? = null\n\nfun main() {\n    x = \"Hello\"\n    if(x != null){\n        println(x.length) \n    }\n}\n```\n\n我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。\n\n### 2.4 带有默认参数的函数的类型支持\n\n如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：\n\n```kotlin\nfun foo(i: Int = 0): String = \"$i!\"\n```\n\n调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -> String 这样的类型，显得不是很方便，现在这个问题解决了：\n\n```kotlin\nfun apply1(func: () -> String): String = func()\nfun apply2(func: (Int) -> String): String = func(42)\n\nfun main() {\n    println(apply1(::foo))\n    println(apply2(::foo))\n}\n```\n\n不过请注意，通常情况下 ::foo 的类型始终为 (Int) -> String，除了作为参数传递给接收 () -> String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。\n\n### 2.5 属性代理的类型推导\n\n在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：\n\n```kotlin\nimport kotlin.properties.Delegates\n\nfun main() {\n    var prop: String? by Delegates.observable(null) { p, old, new ->\n        println(\"$old → $new\")\n    }\n    prop = \"abc\"\n    prop = \"xyz\"\n}\n```\n\n这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：\n\n```kotlin\nvar prop: String? by Delegates.observable<String?>(null) { p, old, new ->\n    println(\"$old → $new\")\n}\n```\n\n### 2.6 混合位置参数和具名参数\n\n位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png)\n\n**<center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center>**\n\n1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。\n\n其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png)\n\n**<center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center>**\n\n注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。\n\n因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。\n\n### 2.7 优化属性代理的编译\n\n如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：\n\n```kotlin\nclass MyOtherClass {\n    val lazyProp by lazy { 42 }\n}\n```\n\n编译后生成的字节码反编译之后：\n\n```java\npublic final class com.bennyhuo.kotlin.MyOtherClass {\n  static final kotlin.reflect.KProperty[] $$delegatedProperties;\n  static {};\n  public final int getLazyProp();\n  public com.bennyhuo.kotlin.MyOtherClass();\n}\n```\n\n其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。\n\n因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。\n\n这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：\n\n```kotlin\nclass MyOtherClass {\n    val lazyProp by lazy { 42 }\n    var myProp: String by Delegates.observable(\"<no name>\") {\n            kProperty, oldValue, newValue ->\n        println(\"${kProperty.name}: $oldValue -> $newValue\")\n    }\n}\n```\n\n其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。\n\n### 2.8 参数列表最后的逗号\n\n这个需求别看小，非常有用。我们来看一个例子：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val person = Person(\n        \"bennyhuo\",\n        30\n    )\n}\n```\n\nPerson 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png)\n\n**<center>图 7：多行编辑逗号的问题</center>**\n\n这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png)\n\n**<center>图 8：多行编辑所有参数</center>**\n\n除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png)\n\n**<center>图 9：增加参数给原来的参数加逗号</center>**\n\n这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。\n\n说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png)\n\n**<center>图 10：JavaScript 的对象字面量</center>**\n\n不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。\n\n### 2.9 when 表达式中使用 continue 和 break\n\ncontinue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。\n\n### 2.10 尾递归函数的优化\n\n尾递归函数估计大家用的不多，这里主要有两个优化点\n\n* 尾递归函数的默认参数的初始化顺序改为从左向右：\n* 尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png)\n\n**<center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center>**\n\n\n### 2.11 契约的支持\n\n从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。\n\n在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：\n\n* 支持使用内联特化的函数来实现契约\n* 1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）\n\n### 2.12 其他的一些改动\n\n除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。\n\n剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。\n\n补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。\n\n## 3. 小结\n\nKotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。\n\n未来可期。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-1.4-preview.md","raw":"---\ntitle:  Kotlin 1.4 新特性预览 \nkeywords: Kotlin 1.4 新版本 \ndate: 2020/03/26\ndescription: \ntags: \n    - kotlin\n    - release\n    - news \n---\n\n> Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 \n\n\n\n<!-- more -->\n\n\n\n\nKotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在[这里查看](https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md)。\n\n生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png)\n\n**<center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center>**\n\n安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png)\n\n**<center>图 2：升级 Kotlin 插件</center>**\n\n好了，重启 IntelliJ，新建一个工程试试看吧~~\n\n## 2. 主要的语法更新\n\n接下来我们就按照官方博客给出的介绍 [Kotlin 1.4-M1 Released](https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/) 来体验下新特性。\n\n本文源码均已整理至 GitHub：[Kotlin1.4FeaturesSample](https://github.com/enbandari/Kotlin1.4FeaturesSample)。\n\n### 2.1 Kotlin 接口和函数的 SAM 转换\n\n一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：\n\n```kotlin\n//注意 fun interface 是新特性\nfun interface Action {\n    fun run()\n}\n\n// Kotlin 函数，参数为 Kotlin 单一方法接口\nfun runAction(a: Action) = a.run()\n// Kotlin 函数，参数为 Java 单一方法接口\nfun runRunnable(r: Runnable) = r.run()\n```\n\n在 1.4 以前，我们只能：\n\n```kotlin\nrunAction(object: Action{\n    override fun run() {\n        println(\"Not good..\")\n    }\n})\n```\n\n或者\n\n```kotlin\nrunAction(Action { println(\"Not good..\") })\n```\n\nrunRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。\n\n现在在 1.4 当中呢？\n\n```kotlin\nrunAction { println(\"Hello, Kotlin 1.4!\") }\nrunRunnable { println(\"Hello, Kotlin 1.4!\") }\n```\n\n真是妙啊。\n\n### 2.2 类型推导支持了更多的场景\n\n类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。\n\n例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：\n\n```kotlin\nval rulesMap: Map<String, (String?) -> Boolean> = mapOf(\n    \"weak\" to { it != null },\n    \"medium\" to { !it.isNullOrBlank() },\n    \"strong\" to { it != null && \"^[a-zA-Z0-9]+$\".toRegex().matches(it) }\n)\n```\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png)\n\n**<center>图 3：Kotlin 1.3 中提示类型不匹配</center>**\n\n博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。\n\n### 2.3 Lambda 表达式最后一行的智能类型转换\n\n这个比较容易理解，直接看例子：\n\n```kotlin\nval result = run {\n    var str = currentValue()\n    if (str == null) {\n        str = \"test\"\n    }\n    str // the Kotlin compiler knows that str is not null here\n}\n// The type of 'result' is String? in Kotlin 1.3 and String in Kotlin 1.4\n```\n\n这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。\n\n在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。\n\n在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。\n\n稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png)\n\n**<center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center>**\n\n我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。\n\n当然，有些开发者经常会抱怨类似下面的这种情况：\n\n```kotlin\nvar x: String? = null\n\nfun main() {\n    x = \"Hello\"\n    if(x != null){\n        println(x.length) \n    }\n}\n```\n\n我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。\n\n### 2.4 带有默认参数的函数的类型支持\n\n如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：\n\n```kotlin\nfun foo(i: Int = 0): String = \"$i!\"\n```\n\n调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -> String 这样的类型，显得不是很方便，现在这个问题解决了：\n\n```kotlin\nfun apply1(func: () -> String): String = func()\nfun apply2(func: (Int) -> String): String = func(42)\n\nfun main() {\n    println(apply1(::foo))\n    println(apply2(::foo))\n}\n```\n\n不过请注意，通常情况下 ::foo 的类型始终为 (Int) -> String，除了作为参数传递给接收 () -> String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。\n\n### 2.5 属性代理的类型推导\n\n在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：\n\n```kotlin\nimport kotlin.properties.Delegates\n\nfun main() {\n    var prop: String? by Delegates.observable(null) { p, old, new ->\n        println(\"$old → $new\")\n    }\n    prop = \"abc\"\n    prop = \"xyz\"\n}\n```\n\n这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：\n\n```kotlin\nvar prop: String? by Delegates.observable<String?>(null) { p, old, new ->\n    println(\"$old → $new\")\n}\n```\n\n### 2.6 混合位置参数和具名参数\n\n位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png)\n\n**<center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center>**\n\n1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。\n\n其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png)\n\n**<center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center>**\n\n注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。\n\n因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。\n\n### 2.7 优化属性代理的编译\n\n如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：\n\n```kotlin\nclass MyOtherClass {\n    val lazyProp by lazy { 42 }\n}\n```\n\n编译后生成的字节码反编译之后：\n\n```java\npublic final class com.bennyhuo.kotlin.MyOtherClass {\n  static final kotlin.reflect.KProperty[] $$delegatedProperties;\n  static {};\n  public final int getLazyProp();\n  public com.bennyhuo.kotlin.MyOtherClass();\n}\n```\n\n其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。\n\n因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。\n\n这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：\n\n```kotlin\nclass MyOtherClass {\n    val lazyProp by lazy { 42 }\n    var myProp: String by Delegates.observable(\"<no name>\") {\n            kProperty, oldValue, newValue ->\n        println(\"${kProperty.name}: $oldValue -> $newValue\")\n    }\n}\n```\n\n其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。\n\n### 2.8 参数列表最后的逗号\n\n这个需求别看小，非常有用。我们来看一个例子：\n\n```kotlin\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val person = Person(\n        \"bennyhuo\",\n        30\n    )\n}\n```\n\nPerson 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png)\n\n**<center>图 7：多行编辑逗号的问题</center>**\n\n这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png)\n\n**<center>图 8：多行编辑所有参数</center>**\n\n除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png)\n\n**<center>图 9：增加参数给原来的参数加逗号</center>**\n\n这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。\n\n说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png)\n\n**<center>图 10：JavaScript 的对象字面量</center>**\n\n不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。\n\n### 2.9 when 表达式中使用 continue 和 break\n\ncontinue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。\n\n### 2.10 尾递归函数的优化\n\n尾递归函数估计大家用的不多，这里主要有两个优化点\n\n* 尾递归函数的默认参数的初始化顺序改为从左向右：\n* 尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png)\n\n**<center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center>**\n\n\n### 2.11 契约的支持\n\n从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。\n\n在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：\n\n* 支持使用内联特化的函数来实现契约\n* 1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）\n\n### 2.12 其他的一些改动\n\n除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。\n\n剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。\n\n补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。\n\n## 3. 小结\n\nKotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。\n\n未来可期。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-1.4-preview","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003e001hlduzfzi125gi","content":"<blockquote>\n<p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href=\"https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md\">这里查看</a>。</p>\n<p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png\"></p>\n<p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p>\n<p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png\"></p>\n<p><strong><center>图 2：升级 Kotlin 插件</center></strong></p>\n<p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p>\n<h2 id=\"2-主要的语法更新\"><a href=\"#2-主要的语法更新\" class=\"headerlink\" title=\"2. 主要的语法更新\"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href=\"https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/\">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p>\n<p>本文源码均已整理至 GitHub：<a href=\"https://github.com/enbandari/Kotlin1.4FeaturesSample\">Kotlin1.4FeaturesSample</a>。</p>\n<h3 id=\"2-1-Kotlin-接口和函数的-SAM-转换\"><a href=\"#2-1-Kotlin-接口和函数的-SAM-转换\" class=\"headerlink\" title=\"2.1 Kotlin 接口和函数的 SAM 转换\"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意 fun interface 是新特性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"keyword\">interface</span> Action &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runAction</span><span class=\"params\">(a: <span class=\"type\">Action</span>)</span></span> = a.run()</span><br><span class=\"line\"><span class=\"comment\">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runRunnable</span><span class=\"params\">(r: <span class=\"type\">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure>\n\n<p>在 1.4 以前，我们只能：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction(<span class=\"keyword\">object</span>: Action&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Not good..&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction(Action &#123; println(<span class=\"string\">&quot;Not good..&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p>\n<p>现在在 1.4 当中呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction &#123; println(<span class=\"string\">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br><span class=\"line\">runRunnable &#123; println(<span class=\"string\">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>真是妙啊。</p>\n<h3 id=\"2-2-类型推导支持了更多的场景\"><a href=\"#2-2-类型推导支持了更多的场景\" class=\"headerlink\" title=\"2.2 类型推导支持了更多的场景\"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p>\n<p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class=\"built_in\">Boolean</span>&gt; = mapOf(</span><br><span class=\"line\">    <span class=\"string\">&quot;weak&quot;</span> to &#123; it != <span class=\"literal\">null</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;medium&quot;</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;strong&quot;</span> to &#123; it != <span class=\"literal\">null</span> &amp;&amp; <span class=\"string\">&quot;^[a-zA-Z0-9]+$&quot;</span>.toRegex().matches(it) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png\"></p>\n<p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p>\n<p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p>\n<h3 id=\"2-3-Lambda-表达式最后一行的智能类型转换\"><a href=\"#2-3-Lambda-表达式最后一行的智能类型转换\" class=\"headerlink\" title=\"2.3 Lambda 表达式最后一行的智能类型转换\"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = run &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = currentValue()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        str = <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    str <span class=\"comment\">// the Kotlin compiler knows that str is not null here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The type of &#x27;result&#x27; is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure>\n\n<p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p>\n<p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p>\n<p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p>\n<p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png\"></p>\n<p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p>\n<p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p>\n<p>当然，有些开发者经常会抱怨类似下面的这种情况：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x: String? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        println(x.length) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p>\n<h3 id=\"2-4-带有默认参数的函数的类型支持\"><a href=\"#2-4-带有默认参数的函数的类型支持\" class=\"headerlink\" title=\"2.4 带有默认参数的函数的类型支持\"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">(i: <span class=\"type\">Int</span> = <span class=\"number\">0</span>)</span></span>: String = <span class=\"string\">&quot;<span class=\"variable\">$i</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">apply1</span><span class=\"params\">(func: () -&gt; <span class=\"type\">String</span>)</span></span>: String = func()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">apply2</span><span class=\"params\">(func: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span>)</span></span>: String = func(<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(apply1(::foo))</span><br><span class=\"line\">    println(apply2(::foo))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p>\n<h3 id=\"2-5-属性代理的类型推导\"><a href=\"#2-5-属性代理的类型推导\" class=\"headerlink\" title=\"2.5 属性代理的类型推导\"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prop: String? <span class=\"keyword\">by</span> Delegates.observable(<span class=\"literal\">null</span>) &#123; p, old, new -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"variable\">$old</span> → <span class=\"variable\">$new</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prop = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    prop = <span class=\"string\">&quot;xyz&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prop: String? <span class=\"keyword\">by</span> Delegates.observable&lt;String?&gt;(<span class=\"literal\">null</span>) &#123; p, old, new -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$old</span> → <span class=\"variable\">$new</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-混合位置参数和具名参数\"><a href=\"#2-6-混合位置参数和具名参数\" class=\"headerlink\" title=\"2.6 混合位置参数和具名参数\"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png\"></p>\n<p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p>\n<p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p>\n<p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png\"></p>\n<p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p>\n<p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p>\n<p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p>\n<h3 id=\"2-7-优化属性代理的编译\"><a href=\"#2-7-优化属性代理的编译\" class=\"headerlink\" title=\"2.7 优化属性代理的编译\"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> lazyProp <span class=\"keyword\">by</span> lazy &#123; <span class=\"number\">42</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译后生成的字节码反编译之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bennyhuo</span>.<span class=\"title\">kotlin</span>.<span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getLazyProp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p>\n<p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p>\n<p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> lazyProp <span class=\"keyword\">by</span> lazy &#123; <span class=\"number\">42</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myProp: String <span class=\"keyword\">by</span> Delegates.observable(<span class=\"string\">&quot;&lt;no name&gt;&quot;</span>) &#123;</span><br><span class=\"line\">            kProperty, oldValue, newValue -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;kProperty.name&#125;</span>: <span class=\"variable\">$oldValue</span> -&gt; <span class=\"variable\">$newValue</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p>\n<h3 id=\"2-8-参数列表最后的逗号\"><a href=\"#2-8-参数列表最后的逗号\" class=\"headerlink\" title=\"2.8 参数列表最后的逗号\"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> person = Person(</span><br><span class=\"line\">        <span class=\"string\">&quot;bennyhuo&quot;</span>,</span><br><span class=\"line\">        <span class=\"number\">30</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png\"></p>\n<p><strong><center>图 7：多行编辑逗号的问题</center></strong></p>\n<p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png\"></p>\n<p><strong><center>图 8：多行编辑所有参数</center></strong></p>\n<p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png\"></p>\n<p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p>\n<p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p>\n<p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png\"></p>\n<p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p>\n<p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p>\n<h3 id=\"2-9-when-表达式中使用-continue-和-break\"><a href=\"#2-9-when-表达式中使用-continue-和-break\" class=\"headerlink\" title=\"2.9 when 表达式中使用 continue 和 break\"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p>\n<h3 id=\"2-10-尾递归函数的优化\"><a href=\"#2-10-尾递归函数的优化\" class=\"headerlink\" title=\"2.10 尾递归函数的优化\"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p>\n<ul>\n<li>尾递归函数的默认参数的初始化顺序改为从左向右：</li>\n<li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li>\n</ul>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png\"></p>\n<p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p>\n<h3 id=\"2-11-契约的支持\"><a href=\"#2-11-契约的支持\" class=\"headerlink\" title=\"2.11 契约的支持\"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p>\n<p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p>\n<ul>\n<li>支持使用内联特化的函数来实现契约</li>\n<li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li>\n</ul>\n<h3 id=\"2-12-其他的一些改动\"><a href=\"#2-12-其他的一些改动\" class=\"headerlink\" title=\"2.12 其他的一些改动\"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p>\n<p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p>\n<p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p>\n<p>未来可期。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 </p>\n</blockquote>","more":"<p>Kotlin 1.4 的第一个里程碑版本发布了，具体发布信息可以在<a href=\"https://github.com/JetBrains/kotlin/blob/1.4-M1/ChangeLog.md\">这里查看</a>。</p>\n<p>生产环境当中最好仍然使用 Kotlin 的稳定版本（例如最新的 1.3.71），如果你想要立刻马上体验 1.4 的新特性，那么我的建议是先安装一个 EAP 版本的 IntelliJ IDEA EAP 版本是 IntelliJ IDEA 2020.1 Beta，然后再在这个版本的 IntelliJ 上安装最新版的 Kotlin 插件，这样既可以继续使用 1.3 做项目，又不耽误体验新特性：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png\"></p>\n<p><strong><center>图 1：IntelliJ IDEA EAP 版本与正式版可以共存</center></strong></p>\n<p>安装 Kotlin 1.4 的插件方法想必大家都已经轻车熟路了，打开设置，搜 Kotlin，找到插件版本管理的下拉菜单，选择 Early Access Preview 1.4.x 即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-20-21.png\"></p>\n<p><strong><center>图 2：升级 Kotlin 插件</center></strong></p>\n<p>好了，重启 IntelliJ，新建一个工程试试看吧~~</p>\n<h2 id=\"2-主要的语法更新\"><a href=\"#2-主要的语法更新\" class=\"headerlink\" title=\"2. 主要的语法更新\"></a>2. 主要的语法更新</h2><p>接下来我们就按照官方博客给出的介绍 <a href=\"https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/\">Kotlin 1.4-M1 Released</a> 来体验下新特性。</p>\n<p>本文源码均已整理至 GitHub：<a href=\"https://github.com/enbandari/Kotlin1.4FeaturesSample\">Kotlin1.4FeaturesSample</a>。</p>\n<h3 id=\"2-1-Kotlin-接口和函数的-SAM-转换\"><a href=\"#2-1-Kotlin-接口和函数的-SAM-转换\" class=\"headerlink\" title=\"2.1 Kotlin 接口和函数的 SAM 转换\"></a>2.1 Kotlin 接口和函数的 SAM 转换</h3><p>一个就是大家期待已久的 Kotlin 接口和函数的 SAM 转换。得益于新的类型推导算法，之前一直只有调用接收 Java 单一方法接口的 Java 的方法时才可以有 SAM 转换，现在这个问题不存在了，且看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意 fun interface 是新特性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"keyword\">interface</span> Action &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Kotlin 函数，参数为 Kotlin 单一方法接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runAction</span><span class=\"params\">(a: <span class=\"type\">Action</span>)</span></span> = a.run()</span><br><span class=\"line\"><span class=\"comment\">// Kotlin 函数，参数为 Java 单一方法接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runRunnable</span><span class=\"params\">(r: <span class=\"type\">Runnable</span>)</span></span> = r.run()</span><br></pre></td></tr></table></figure>\n\n<p>在 1.4 以前，我们只能：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction(<span class=\"keyword\">object</span>: Action&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Not good..&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction(Action &#123; println(<span class=\"string\">&quot;Not good..&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>runRunnable 函数虽然接收的是 Java 的接口，同样不支持 SAM。</p>\n<p>现在在 1.4 当中呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runAction &#123; println(<span class=\"string\">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br><span class=\"line\">runRunnable &#123; println(<span class=\"string\">&quot;Hello, Kotlin 1.4!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>真是妙啊。</p>\n<h3 id=\"2-2-类型推导支持了更多的场景\"><a href=\"#2-2-类型推导支持了更多的场景\" class=\"headerlink\" title=\"2.2 类型推导支持了更多的场景\"></a>2.2 类型推导支持了更多的场景</h3><p>类型推导让 Kotlin 的语法获得了极大的简洁性。不过，大家在使用 Kotlin 开发时，一定会发现有些情况下明明类型是很确定的，编译器却一定要让我们显式的声明出来，这其实就是类型推导算法没有覆盖到的场景了。</p>\n<p>例如以下代码在 Kotlin 1.3 当中会提示类型不匹配的问题：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rulesMap: Map&lt;String, (String?) -&gt; <span class=\"built_in\">Boolean</span>&gt; = mapOf(</span><br><span class=\"line\">    <span class=\"string\">&quot;weak&quot;</span> to &#123; it != <span class=\"literal\">null</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;medium&quot;</span> to &#123; !it.isNullOrBlank() &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;strong&quot;</span> to &#123; it != <span class=\"literal\">null</span> &amp;&amp; <span class=\"string\">&quot;^[a-zA-Z0-9]+$&quot;</span>.toRegex().matches(it) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-47-00.png\"></p>\n<p><strong><center>图 3：Kotlin 1.3 中提示类型不匹配</center></strong></p>\n<p>博客原文中给出的这个例子乍一看挺复杂，仔细想想问题主要在于我们可以通过 rulesMap 的类型来确定 mapOf 的返回值类型，进而再确定出 mapOf 的参数类型，即 Pair 的泛型参数类型。类型信息是充分的，不过这段代码在 Kotlin 1.4 以前是无法通过编译的，应该是类型推导的层次有点儿多导致算法没有覆盖到。好在新的推导算法解决了这个问题，能够应付更加复杂的推导场景。</p>\n<h3 id=\"2-3-Lambda-表达式最后一行的智能类型转换\"><a href=\"#2-3-Lambda-表达式最后一行的智能类型转换\" class=\"headerlink\" title=\"2.3 Lambda 表达式最后一行的智能类型转换\"></a>2.3 Lambda 表达式最后一行的智能类型转换</h3><p>这个比较容易理解，直接看例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = run &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = currentValue()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        str = <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    str <span class=\"comment\">// the Kotlin compiler knows that str is not null here</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The type of &#x27;result&#x27; is String? in Kotlin 1.3 and String in Kotlin 1.4</span></span><br></pre></td></tr></table></figure>\n\n<p>这里 result 作为 run 的返回值，实际上也是 run 的参数 Lambda 的返回值，因此它的类型需要通过 str 的类型来推断。</p>\n<p>在 1.3 当中，str 的类型是可以推断成 String 的，因为 str 是个局部变量，对它的修改是可控的。问题在于虽然 str 被推断为 String 类型，Lambda 表达式的返回值类型却没有使用推断的类型 String 来判断，而是选择使用了 str 的声明类型 String?。</p>\n<p>在 1.4 解决了这个问题，既然 str 可以被推断为 String，那么 Lambda 表达式的结果自然就是 String 了。</p>\n<p>稍微提一下，IntelliJ 的类型提示貌似有 bug，有些情况下会出现不一致的情况：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-12-55-09.png\"></p>\n<p><strong><center>图 4：疑似 IntelliJ 行内的类型提示的 bug</center></strong></p>\n<p>我们可以通过快捷键查看 result 的类型为 String，但是行内的类型提示却为 String?，不过这个不影响程序的运行。</p>\n<p>当然，有些开发者经常会抱怨类似下面的这种情况：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x: String? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        println(x.length) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我明明已经判断了 x 不为空，为什么却不能自动推导成 String？请一定要注意，这种情况不是类型推导算法的问题，而是 x 的类型确实无法推导，因为对于一个共享的可变变量来讲，任何前一秒的判断都无法作为后一秒的依据。</p>\n<h3 id=\"2-4-带有默认参数的函数的类型支持\"><a href=\"#2-4-带有默认参数的函数的类型支持\" class=\"headerlink\" title=\"2.4 带有默认参数的函数的类型支持\"></a>2.4 带有默认参数的函数的类型支持</h3><p>如果一个函数有默认参数，我们在调用它的时候就可以不传入这个参数了，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">(i: <span class=\"type\">Int</span> = <span class=\"number\">0</span>)</span></span>: String = <span class=\"string\">&quot;<span class=\"variable\">$i</span>!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用的时候既可以是 foo() 也可以是 foo(5)，看上去就如同两个函数一样。在 1.4 以前，如果我们想要获取它的引用，就只能获取到 (Int) -&gt; String 这样的类型，显得不是很方便，现在这个问题解决了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">apply1</span><span class=\"params\">(func: () -&gt; <span class=\"type\">String</span>)</span></span>: String = func()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">apply2</span><span class=\"params\">(func: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span>)</span></span>: String = func(<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(apply1(::foo))</span><br><span class=\"line\">    println(apply2(::foo))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过请注意，通常情况下 ::foo 的类型始终为 (Int) -&gt; String，除了作为参数传递给接收 () -&gt; String 的情况下编译器会自动帮忙转换以外，其他情况下是不可以的。</p>\n<h3 id=\"2-5-属性代理的类型推导\"><a href=\"#2-5-属性代理的类型推导\" class=\"headerlink\" title=\"2.5 属性代理的类型推导\"></a>2.5 属性代理的类型推导</h3><p>在推断代理表达式的类型时，以往不会考虑属性代理的类型，因此我们经常需要在代理表达式中显式的声明泛型参数，下面的例子就是这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlin.properties.Delegates</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prop: String? <span class=\"keyword\">by</span> Delegates.observable(<span class=\"literal\">null</span>) &#123; p, old, new -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"variable\">$old</span> → <span class=\"variable\">$new</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prop = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    prop = <span class=\"string\">&quot;xyz&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子在 1.4 中可以运行，但如果是在 1.3 当中，就需要明确泛型类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prop: String? <span class=\"keyword\">by</span> Delegates.observable&lt;String?&gt;(<span class=\"literal\">null</span>) &#123; p, old, new -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$old</span> → <span class=\"variable\">$new</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-混合位置参数和具名参数\"><a href=\"#2-6-混合位置参数和具名参数\" class=\"headerlink\" title=\"2.6 混合位置参数和具名参数\"></a>2.6 混合位置参数和具名参数</h3><p>位置参数就是按位置传入的参数，Java 当中只有位置参数，是大家最熟悉的写法。Kotlin 支持了具名参数，那么入参时二者混合使用会怎样呢？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-06-09.png\"></p>\n<p><strong><center>图 5：1.3 当中不允许在具名参数之后添加位置参数</center></strong></p>\n<p>1.3 当中，第三个参数会提示错误，理由就是位置参数前面已经有了具名参数了，这是禁止的。这样主要的目的也是希望开发者能够避免写出混乱的入参例子，不过这个例子似乎并不会有什么令人疑惑的地方，于是 1.4 我们可以在具名参数后面跟位置参数啦。</p>\n<p>其实这个特性并不会对入参有很大的影响。首先位置参数的位置仍然必须是对应的，其次具名参数的位置也不能乱来。例如我们为例子中的 a 添加一个默认值：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-08-16-35.png\"></p>\n<p><strong><center>图 6：1.4 当中具名参数之后添加位置参数需要保证位置对应</center></strong></p>\n<p>注意图 6 是 1.4 环境下的情形，这样调用时我们就可以不必显式的传入 a 的值了，这时候直觉告诉我参数 b 后面的参数应该是 c，然而编译器却不领情。这样看来，即便是在 1.4 当中，我们也需要确保具名参数和位置参数与形参的位置对应才能在具名参数之后添加位置参数。</p>\n<p>因此，我个人的建议是对于参数比较多且容易混淆的情形最好都以具名参数的形式给出，对于参数个数较少的情形则可以全部采用位置参数。在这里还有另外的一个建议就是函数的参数不宜过多，参数越多意味着函数复杂度越高，越可能需要重构。</p>\n<h3 id=\"2-7-优化属性代理的编译\"><a href=\"#2-7-优化属性代理的编译\" class=\"headerlink\" title=\"2.7 优化属性代理的编译\"></a>2.7 优化属性代理的编译</h3><p>如果大家自己写过属性代理类的话，一定知道 get 和 set 两个函数都有一个 KProperty 的参数，这个参数其实就是被代理的属性。为了获取这个参数，编译器会生成一个数组来存放这代理的属性，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> lazyProp <span class=\"keyword\">by</span> lazy &#123; <span class=\"number\">42</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译后生成的字节码反编译之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bennyhuo</span>.<span class=\"title\">kotlin</span>.<span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> kotlin.reflect.KProperty[] $$delegatedProperties;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getLazyProp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.bennyhuo.kotlin.MyOtherClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 $$delegatedProperties 这个数组就是我们所说的存被代理的属性的数组。不过，绝大多数的属性代理其实不会用到 KProperty 对象，因此无差别的生成这个数组其实存在一定的浪费。</p>\n<p>因此对于属性代理类的 get 和 set 函数实现为内联函数的情形，编译器可以确切的分析出 KProperty 是否被用到，如果没有被用到，那么就不会生成这个 KProperty 对象。</p>\n<p>这里还有一个细节，如果一个类当中同时存在用到和没用到 KProperty 对象的两类属性代理，那么生成的数组在 1.4 当中只包含用到的 KProperty 对象，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOtherClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> lazyProp <span class=\"keyword\">by</span> lazy &#123; <span class=\"number\">42</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myProp: String <span class=\"keyword\">by</span> Delegates.observable(<span class=\"string\">&quot;&lt;no name&gt;&quot;</span>) &#123;</span><br><span class=\"line\">            kProperty, oldValue, newValue -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;kProperty.name&#125;</span>: <span class=\"variable\">$oldValue</span> -&gt; <span class=\"variable\">$newValue</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 myProp 用到了 KProperty 对象，lazyProp 没有用到，那么生成的 $$delegatedProperties 当中就只包含 myProp 的属性引用了。</p>\n<h3 id=\"2-8-参数列表最后的逗号\"><a href=\"#2-8-参数列表最后的逗号\" class=\"headerlink\" title=\"2.8 参数列表最后的逗号\"></a>2.8 参数列表最后的逗号</h3><p>这个需求别看小，非常有用。我们来看一个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>(<span class=\"keyword\">val</span> name: String, <span class=\"keyword\">val</span> age: <span class=\"built_in\">Int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> person = Person(</span><br><span class=\"line\">        <span class=\"string\">&quot;bennyhuo&quot;</span>,</span><br><span class=\"line\">        <span class=\"number\">30</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Person 类有多个参数，传参的时候就会出现前面的参数后面都有个逗号，最后一个没有。这样看上去好像也没什么问题是吧？那有可能你没有用到过多行编辑：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-04-01.png\"></p>\n<p><strong><center>图 7：多行编辑逗号的问题</center></strong></p>\n<p>这里这个逗号有时候会特别碍事儿，但如何每一行都可以有一个逗号这个问题就简单多了：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-05-25.png\"></p>\n<p><strong><center>图 8：多行编辑所有参数</center></strong></p>\n<p>除了这个场景之外，还有就是调整参数列表的时候，例如我给 Person 在最后加了个 id，我还得单独给 age 的参数后面加个逗号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-08-36.png\"></p>\n<p><strong><center>图 9：增加参数给原来的参数加逗号</center></strong></p>\n<p>这时候我又觉得 id 应该放到最前面，于是做了个复制粘贴，发现还是要修改逗号。当然，最后的这个功能 IntelliJ 有个快捷键可以直接交换行，同时帮我们自动处理逗号的问题，不过整体上这个小功能还是很有意思的。</p>\n<p>说起来，JavaScript 当中的对象字面量当中也允许最后一个字段后面加逗号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-12-48.png\"></p>\n<p><strong><center>图 10：JavaScript 的对象字面量</center></strong></p>\n<p>不过请注意，尽管它与 JSON 有着深厚的渊源，但 JSON 的最后一个字段后面是不允许加逗号的（当然还有字段要加引号）。</p>\n<h3 id=\"2-9-when-表达式中使用-continue-和-break\"><a href=\"#2-9-when-表达式中使用-continue-和-break\" class=\"headerlink\" title=\"2.9 when 表达式中使用 continue 和 break\"></a>2.9 when 表达式中使用 continue 和 break</h3><p>continue 和 break 的含义没有任何变化，这二者仍然在循环当中使用，只不过循环内部的 when 表达式当中在之前是不可以使用 continue 和 break 的，按照官方的说法，他们之前有意将 continue 或者 break 用作 when 表达式条件 fallthrough 的，不过看样子现在还没想好，只是不想再耽误 continue 和 break 的正常功能了。</p>\n<h3 id=\"2-10-尾递归函数的优化\"><a href=\"#2-10-尾递归函数的优化\" class=\"headerlink\" title=\"2.10 尾递归函数的优化\"></a>2.10 尾递归函数的优化</h3><p>尾递归函数估计大家用的不多，这里主要有两个优化点</p>\n<ul>\n<li>尾递归函数的默认参数的初始化顺序改为从左向右：</li>\n<li>尾递归函数不能声明为 open 的，即不能被子类覆写，因为尾递归函数的形式有明确的要求，即函数的最后一个操作必须只能是调用自己，父类的函数声明为 tailrec 并不能保证子类能够正确地按要求覆写，于是产生矛盾。</li>\n</ul>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-26-11-25-23.png\"></p>\n<p><strong><center>图 11：1.4 中尾递归函数的默认参数列表初始化顺序</center></strong></p>\n<h3 id=\"2-11-契约的支持\"><a href=\"#2-11-契约的支持\" class=\"headerlink\" title=\"2.11 契约的支持\"></a>2.11 契约的支持</h3><p>从 1.3 开始，Kotlin 引入了一个实验特性契约（Contract），主要来应对一些“显而易见”情况下的类型推导或者智能类型转换。</p>\n<p>在 1.4 当中，这个特性仍然会继续保持实验状态，不过有两项改进：</p>\n<ul>\n<li>支持使用内联特化的函数来实现契约</li>\n<li>1.3当中不能为成员函数添加契约，从1.4开始支持为 final 的成员函数添加契约（当然任意成员函数可能存在被覆写的问题，因而不能添加）</li>\n</ul>\n<h3 id=\"2-12-其他的一些改动\"><a href=\"#2-12-其他的一些改动\" class=\"headerlink\" title=\"2.12 其他的一些改动\"></a>2.12 其他的一些改动</h3><p>除了语法上的明显的改动之外，1.4 当中也直接移除了 1.1-1.2 当中协程的实验阶段的 API，有条件的情况下应该尽快去除对废弃的协程 API 的使用，如果暂时无法完成迁移，也可以使用协程的兼容包 kotlin-coroutines-experimental-compat.jar。</p>\n<p>剩下的主要就是针对编译器、使用体验的各种优化了，实际上这才是 Kotlin 1.4 最重要的工作。这些内容相对抽象，我就不做介绍了。</p>\n<p>补充一点，在本文撰写过程中，我使用 IntelliJ IDEA 2019.3.3 来运行 Kotlin 1.3，使用 IntelliJ IDEA 2020.1 BETA 来运行 Kotlin 1.4-M1，结果发现后者的代码提示速度似乎有明显的提升，不知道是不是我的错觉，大家可以自行感受下并发表你的评论。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3. 小结\"></a>3. 小结</h2><p>Kotlin 目前的语法已经比较成熟了，还是那句话，提升开发体验，扩展应用场景才是它现在最应该发力的点。</p>\n<p>未来可期。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 1.4 新特性预览","path":"2020/03/26/kotlin-1.4-preview/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-03-25-11-10-40.png","excerpt":"<blockquote>\n<p>Kotlin 1.4 没有特别重大的更新，更多的是细节的优化。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-03-25T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-03-25T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","news","release"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 最近怎么样了","keywords":"Kotlin 新特性 近况","date":"2019-12-22T16:00:00.000Z","description":null,"_content":"\n> Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 \n\n<!-- more -->\n\n\n\n\n## 新特性\n\nKotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）\n\n```kotlin\nfun interface Action {\n    fun doAction()\n}\n\nfun runAction(action: Action){\n    \n}\n\nfun main(){\n    runAction {\n        //action here\n    }\n}\n```\n\n哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。\n\n## 新形势\n\nKotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。\n\n我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：\n\n**TIOBE Index for December 2019**\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg)\n\n这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。\n\n第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：\n\n**PYPL PopularitY of Programming Language**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg)\n\n（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）\n\n这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。\n\n也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg)\nPYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。\n\n## 新发展\n\n事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，[KTX 的库](https://developer.android.com/kotlin/ktx)已经非常丰富，[Lifecycle](https://developer.android.com/topic/libraries/architecture/lifecycle)、[Room](https://developer.android.com/topic/libraries/architecture/room) 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 [Retrofit](https://github.com/square/retrofit) 早在 2.6.0 就支持 suspend 函数，[OkHttp](https://github.com/square/okhttp) 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 [Shadow](https://github.com/Tencent/Shadow) 也有很多模块是使用 Kotlin 开发的。数不胜数。\n\n其次自然就是 Java 所覆盖的其他领域。印象中 [Spring 5.0 就开始支持 Kotlin](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0)，前不久试了下 [WebFlux 都已经支持 `suspend` 函数作为 RestController 的 API ](https://www.baeldung.com/spring-boot-kotlin-coroutines)，也提供了各种 `Flux` 与 `Flow` 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 [Ktor](https://ktor.io) 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 `suspend` 调用，感觉空气都新鲜了。\n\n不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 [Dukat](https://github.com/Kotlin/dukat) 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。\n\nKotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。\n\n还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 [Gradle 在 5.0 正式宣布支持 Kotlin](https://docs.gradle.org/5.0/release-notes.html)，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。\n\n更重磅的是，来看看新鲜出炉的 [kotlin-jupyter](https://github.com/Kotlin/kotlin-jupyter)，官方博客也刚刚更新了 [Kotlin 对科学计算支持的介绍文章](https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/)。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。\n\n稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 [Arrow](https://github.com/arrow-kt/arrow)  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。\n\n## 一如既往的建议\n\n尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下[中文 Kotlin 官网](https://www.kotlincn.net)，有问题可以到[Kotlin 中文论坛](https://discuss.kotliner.cn/)提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 \"[新版 Kotlin 从入门到精通](https://coding.imooc.com/class/398.html)\" 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。\n\nHave a nice Kotlin!\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-2019-whats-new.md","raw":"---\ntitle:  Kotlin 最近怎么样了 \nkeywords: Kotlin 新特性 近况 \ndate: 2019/12/23\ndescription: \ntags:\n  - Kotlin\n  - News\n---\n\n> Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 \n\n<!-- more -->\n\n\n\n\n## 新特性\n\nKotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）\n\n```kotlin\nfun interface Action {\n    fun doAction()\n}\n\nfun runAction(action: Action){\n    \n}\n\nfun main(){\n    runAction {\n        //action here\n    }\n}\n```\n\n哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。\n\n## 新形势\n\nKotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。\n\n我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：\n\n**TIOBE Index for December 2019**\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg)\n\n这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。\n\n第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：\n\n**PYPL PopularitY of Programming Language**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg)\n\n（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）\n\n这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。\n\n也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg)\nPYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。\n\n## 新发展\n\n事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，[KTX 的库](https://developer.android.com/kotlin/ktx)已经非常丰富，[Lifecycle](https://developer.android.com/topic/libraries/architecture/lifecycle)、[Room](https://developer.android.com/topic/libraries/architecture/room) 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 [Retrofit](https://github.com/square/retrofit) 早在 2.6.0 就支持 suspend 函数，[OkHttp](https://github.com/square/okhttp) 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 [Shadow](https://github.com/Tencent/Shadow) 也有很多模块是使用 Kotlin 开发的。数不胜数。\n\n其次自然就是 Java 所覆盖的其他领域。印象中 [Spring 5.0 就开始支持 Kotlin](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0)，前不久试了下 [WebFlux 都已经支持 `suspend` 函数作为 RestController 的 API ](https://www.baeldung.com/spring-boot-kotlin-coroutines)，也提供了各种 `Flux` 与 `Flow` 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 [Ktor](https://ktor.io) 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 `suspend` 调用，感觉空气都新鲜了。\n\n不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 [Dukat](https://github.com/Kotlin/dukat) 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。\n\nKotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。\n\n还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 [Gradle 在 5.0 正式宣布支持 Kotlin](https://docs.gradle.org/5.0/release-notes.html)，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。\n\n更重磅的是，来看看新鲜出炉的 [kotlin-jupyter](https://github.com/Kotlin/kotlin-jupyter)，官方博客也刚刚更新了 [Kotlin 对科学计算支持的介绍文章](https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/)。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。\n\n稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 [Arrow](https://github.com/arrow-kt/arrow)  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。\n\n## 一如既往的建议\n\n尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下[中文 Kotlin 官网](https://www.kotlincn.net)，有问题可以到[Kotlin 中文论坛](https://discuss.kotliner.cn/)提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 \"[新版 Kotlin 从入门到精通](https://coding.imooc.com/class/398.html)\" 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。\n\nHave a nice Kotlin!\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-2019-whats-new","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003e001jlduz7sge1hpo","content":"<blockquote>\n<p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"keyword\">interface</span> Action &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doAction</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runAction</span><span class=\"params\">(action: <span class=\"type\">Action</span>)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    runAction &#123;</span><br><span class=\"line\">        <span class=\"comment\">//action here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p>\n<h2 id=\"新形势\"><a href=\"#新形势\" class=\"headerlink\" title=\"新形势\"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p>\n<p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p>\n<p><strong>TIOBE Index for December 2019</strong><br><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg\"></p>\n<p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p>\n<p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p>\n<p><strong>PYPL PopularitY of Programming Language</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg\"></p>\n<p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p>\n<p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p>\n<p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg\"><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p>\n<h2 id=\"新发展\"><a href=\"#新发展\" class=\"headerlink\" title=\"新发展\"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href=\"https://developer.android.com/kotlin/ktx\">KTX 的库</a>已经非常丰富，<a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle\">Lifecycle</a>、<a href=\"https://developer.android.com/topic/libraries/architecture/room\">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href=\"https://github.com/square/retrofit\">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href=\"https://github.com/square/okhttp\">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href=\"https://github.com/Tencent/Shadow\">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p>\n<p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href=\"https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0\">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href=\"https://www.baeldung.com/spring-boot-kotlin-coroutines\">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href=\"https://ktor.io/\">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p>\n<p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href=\"https://github.com/Kotlin/dukat\">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p>\n<p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p>\n<p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href=\"https://docs.gradle.org/5.0/release-notes.html\">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p>\n<p>更重磅的是，来看看新鲜出炉的 <a href=\"https://github.com/Kotlin/kotlin-jupyter\">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href=\"https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/\">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p>\n<p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href=\"https://github.com/arrow-kt/arrow\">Arrow</a>  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p>\n<h2 id=\"一如既往的建议\"><a href=\"#一如既往的建议\" class=\"headerlink\" title=\"一如既往的建议\"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href=\"https://www.kotlincn.net/\">中文 Kotlin 官网</a>，有问题可以到<a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href=\"https://coding.imooc.com/class/398.html\">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p>\n<p>Have a nice Kotlin!</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 已经很成熟了。有多成熟呢？Kotlin Team 现在的重心已经是在为各个领域内的 Kotlin 实践提供支持了。 </p>\n</blockquote>","more":"<h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><p>KotlinConf 在 12月5日前后的那几天开完了。Kotlin 1.4 有什么新特性吗？还真有一个，那就是 Kotlin 接口的 SAM 转换（KT-7770）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"keyword\">interface</span> Action &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doAction</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">runAction</span><span class=\"params\">(action: <span class=\"type\">Action</span>)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    runAction &#123;</span><br><span class=\"line\">        <span class=\"comment\">//action here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哈哈，终于在新的类型推导到来时，这个特性被支持了。前不久我在录制 《Kotlin 入门到精通》这门课的时候讲到这个点的时候还说“我也不知道什么时候，会不会支持这个特性”，好了，Kotlin Team 终于听到了人民的呼声。</p>\n<h2 id=\"新形势\"><a href=\"#新形势\" class=\"headerlink\" title=\"新形势\"></a>新形势</h2><p>Kotlin 1.0 发布到现在已经快 4 年了，我推广 Kotlin 差不多也 4 年多了。在 Google 开始决定扶持 Kotlin 之前，我们社区的小伙伴的内心感觉大概跟之前的 Rust 社区的小伙伴差不多吧，然后 Google 从 2017 年把 Kotlin 确定为 Android 的一级语言（表示会从官方提供支持，开发者可以使用）到 2019 年转变为首选语言（表示官方推荐你用 Kotlin），社区小伙伴们最初得到这样的消息大概也许相当于 Rust 社区的小伙伴们听到微软决定要用 Rust 来重写部分操作系统模块一样吧（激动）。</p>\n<p>我们来看看现在 Kotlin 的排名情况，第一个是大家用的比较多的：</p>\n<p><strong>TIOBE Index for December 2019</strong><br><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761917429814.jpg\"></p>\n<p>这个排名上 Kotlin 上升的还是比较缓慢的，不过也已经不错了，两年前的时候还在 50 名那儿呢。当然，这个排名其实也有一些争议，因为它是按照互联网上现有的某一门语言的网页数来计算排名的，排名前几的某些语言其实有很多网页都大概都没什么人访问。</p>\n<p>第二个是我觉得比较能反映现在大家对待一门语言的态度的排名：</p>\n<p><strong>PYPL PopularitY of Programming Language</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15761920410684.jpg\"></p>\n<p>（我把图截得大了一些，主要是想把我同样也很喜欢的 Lua 截进来，(～￣▽￣)～）</p>\n<p>这个索引比较科学的地方主要在于它关注的是大家搜索这门语言的教程的频次，这个表明今年 12月大家学习 Kotlin 的热度比起去年上升了 0.5%，名次上升了 4 位。</p>\n<p>也就是说，这两个索引一个反应存量，一个反应增量，数据上就能看出 Kotlin 的潜力还是非常巨大的，尽管现在开发者群体还比不上当红的 Java Python 这类“发达”语言，但这个增速绝对就是“发展中”语言中一道亮丽的风景线。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15770731567913.jpg\"><br>PYPL 的排名确实能够比较真实的反映时下大家的态度，Java 已经被唱衰了好几年，Python 近几年火热到一下冒出特别多新书。Kotlin 在 Native 领域存活自然需要直面 Go，在 JavaScript 上当然也离不开 TypeScript，正好我们也对比下它们各自的发展，Kotlin 作为后起之秀真实有后来居上的气势。</p>\n<h2 id=\"新发展\"><a href=\"#新发展\" class=\"headerlink\" title=\"新发展\"></a>新发展</h2><p>事实上，Kotlin 的主要应用领域当然就是  Android 了。可以说 Kotlin 简直运气好到了极点（也可以说是 Kotlin Team 的决策高明），选择从 Android 撕开一道口子切入市场，道理很简单啊，搞后台的人选择面太广了，Android 端除了忍受 Java，实在没有什么办法，我当时尝试了 Groovy 和 Scala 写 Android，结果标准库方法数一个 3W ，一个 5W，几年前我们还在饱受方法数的折磨，大家应该懂我是什么意思。可是 Kotlin 就很聪明，我不造轮子，标准库方法数 7k ，而且一直到现在都没怎么增加太多，所以大家就开始尝试。到现在，很多人都还觉得 Kotlin 一定是给 Android 开发者准备的 —— 怎么会呢。不过要说支持的比较好的，当然还是 Android，<a href=\"https://developer.android.com/kotlin/ktx\">KTX 的库</a>已经非常丰富，<a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle\">Lifecycle</a>、<a href=\"https://developer.android.com/topic/libraries/architecture/room\">Room</a> 这样的组件也已经支持协程（前者提供 scope，后者的 Dao 支持 suspend 函数），第三方的 <a href=\"https://github.com/square/retrofit\">Retrofit</a> 早在 2.6.0 就支持 suspend 函数，<a href=\"https://github.com/square/okhttp\">OkHttp</a> 4.x 已经完全用 Kotlin 重写等等。就连我们公司年初开源的（实际上这个项目在内部也早就开源）插件化框架 <a href=\"https://github.com/Tencent/Shadow\">Shadow</a> 也有很多模块是使用 Kotlin 开发的。数不胜数。</p>\n<p>其次自然就是 Java 所覆盖的其他领域。印象中 <a href=\"https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0\">Spring 5.0 就开始支持 Kotlin</a>，前不久试了下 <a href=\"https://www.baeldung.com/spring-boot-kotlin-coroutines\">WebFlux 都已经支持 <code>suspend</code> 函数作为 RestController 的 API </a>，也提供了各种 <code>Flux</code> 与 <code>Flow</code> 的互转操作，使用体验真实不要太赞。Kotlin Team 的亲儿子 <a href=\"https://ktor.io/\">Ktor</a> 就更不用说了，函数式的 Route 声明，让我一度以为自己在写 Node.js，但又显然不是，Node.js 哪里会提示有什么 API 呢；原生的协程支持，让我们几乎处处可以写 <code>suspend</code> 调用，感觉空气都新鲜了。</p>\n<p>不甘寂寞的 Kotlin Team 很早就开始支持 Js，不过工具链却一直没有跟上，今年还是重点迭代的 <a href=\"https://github.com/Kotlin/dukat\">Dukat</a> 项目就是为了解决 Kotlin 与 JavaScript 交互时，Kotlin 的强类型问题。这个项目可以把现有的 JavaScript 界类型的事实标准 *.d.ts 文件转成 Kotlin 声明，这样就很好的解决了类型问题，省得我们以前写 Kotlin 调用 JavaScript API 的时候要么自己手动在 Kotlin 源码中声明对应的 API，要么就是各种类型都声明为 dynamic 逃过编译器检查。听说 WASM 也要独立门户了，过去一直都在 Kotlin Native 当中，后面也许也是一个重点的发力方向。</p>\n<p>Kotlin Native 最早比较让人难受的就是编译慢的问题了。最开始编译 Hello World 都需要 40s，后来终于缩短到了 10s 以内（我的笔记本是 2015 mbp），当然这个时间随着代码量的增加也并不会有特别显著的增长，所以对于大型项目来讲，编译时间已经不再是问题。还有就是调试麻烦的事儿，如果是写独立的 Kotlin Native 项目，可以直接 CLion 中调试，也可以在 IntelliJ 中安装 Native Debug 插件调试，可是最近很流行的 Kotlin Native 写 iOS 程序呢，貌似不太好办 —— Kotlin Team 宣布会在明年开始 preview 一款运行在 Android Studio 上的插件用来调试跑在 iOS 上的 Kotlin Native 代码，这就有点儿秀了。哦，对了，Kotlin Native 的协程只能跑在一个线程当中的问题也应该很快就能解决，期待一下。</p>\n<p>还有 Kotlin 的脚本，在 3.0 时代就开始尝试支持 Kotlin 的 <a href=\"https://docs.gradle.org/5.0/release-notes.html\">Gradle 在 5.0 正式宣布支持 Kotlin</a>，并且官方文档都配备了 Kotlin 和 Groovy 两个版本，写过 Gradle 插件的都知道，Gradle API 本来就比较复杂，用 Groovy 写没有 IDE 提示的日子有多痛苦，用 Kotlin 就完全不同了。</p>\n<p>更重磅的是，来看看新鲜出炉的 <a href=\"https://github.com/Kotlin/kotlin-jupyter\">kotlin-jupyter</a>，官方博客也刚刚更新了 <a href=\"https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/\">Kotlin 对科学计算支持的介绍文章</a>。看来，Kotlin Team 的野心真的不小啊，我现在就是有点儿担心 Kotlin Team 人手不够了 —— 玩笑话，Kotlin 已经不再是 Kotlin Team 自己的了，而是我们所有开发者的。</p>\n<p>稍微提一下，在函数式编程方面，Kotlin Team 目前没有（明面儿上）专门支持，不过开源项目 <a href=\"https://github.com/arrow-kt/arrow\">Arrow</a>  已经颇具规模，由于 Kotlin 1.4 有公开编译器插件的 API 的计划，Arrow 团队也在积极引进编译器层面的支持来加强某些特性的实现（例如 typeclass，目前在 Java 平台上主要靠 APT）。</p>\n<h2 id=\"一如既往的建议\"><a href=\"#一如既往的建议\" class=\"headerlink\" title=\"一如既往的建议\"></a>一如既往的建议</h2><p>尽管发展趋势日新月异，不过建议却一直没变。现如今的 Kotlin 的发展形势越来越好 ，如果现在你还没有趁早用起来，难道要等到几年后后悔吗？当然也有很多小伙伴说用 Kotlin 的时候“巨坑”，然后我问他们都哪儿坑了，说出来之后结果发现都是因为对 Kotlin 甚至是对 Java 不熟悉造成的。其实大家只要认真阅读官方文档，稍微练习上几天，一定会逐渐熟悉起来的，如果英文吃力，可以关注下<a href=\"https://www.kotlincn.net/\">中文 Kotlin 官网</a>，有问题可以到<a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a>提问。当然，如果大家喜欢通过视频学习，也可以在慕课网关注下 “<a href=\"https://coding.imooc.com/class/398.html\">新版 Kotlin 从入门到精通</a>“ 这门课，我大概从国庆前后开始基于 Kotlin 1.3.50 制作了这套新版的视频教程，Kotlin 的知识点基本上都有覆盖，也结合了过去推广教学的经验对重难点进行了深入剖析，希望对大家在 Kotlin 入门或是进阶的过程中提供帮助。</p>\n<p>Have a nice Kotlin!</p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，大家可以在2019年12月26日之前联系慕课网客服索取价值 150 元的定向代金券，结合课程的限时优惠只需要 115 元即可升级新课。新课限时优惠同样截止于2019年12月26日，因此有需要的小伙伴们一定要抓紧了哟！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"Kotlin 社区资源介绍","date":"2018-10-01T16:00:00.000Z","_content":"\nKotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。\n\n<!--more-->\n\n1. **[Kotlin 中文官网](https://www.kotlincn.net)**，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。\n2. **[Kotlin 中文博客](https://www.kotliner.cn)**，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。\n3. **[Kotlin 中文论坛](https://discuss.kotliner.cn)**，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。\n4. **微信公众号 Kotlin**，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。\n\n欢迎关注 Kotlin 公众号：\n\n![Kotlin 公众号](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg)","source":"_posts/kotlin-community-cn.md","raw":"---\ntitle: Kotlin 社区资源介绍\ndate: 2018/10/02\ntags:\n  - Kotlin\n  - Website\n---\n\nKotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。\n\n<!--more-->\n\n1. **[Kotlin 中文官网](https://www.kotlincn.net)**，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。\n2. **[Kotlin 中文博客](https://www.kotliner.cn)**，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。\n3. **[Kotlin 中文论坛](https://discuss.kotliner.cn)**，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。\n4. **微信公众号 Kotlin**，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。\n\n欢迎关注 Kotlin 公众号：\n\n![Kotlin 公众号](https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg)","slug":"kotlin-community-cn","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003f001mlduzew033abz","content":"<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>**<a href=\"https://www.kotlincn.net/\">Kotlin 中文官网</a>**，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li>\n<li>**<a href=\"https://www.kotliner.cn/\">Kotlin 中文博客</a>**，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li>\n<li>**<a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a>**，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li>\n<li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li>\n</ol>\n<p>欢迎关注 Kotlin 公众号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg\" alt=\"Kotlin 公众号\"></p>\n","site":{"data":{}},"excerpt":"<p>Kotlin 为人熟知已经很长时间了，这段时间里，我们为了宣传和推广 Kotlin 也做了不少工作，下面简单盘点一下 Kotlin 社区的资源。</p>","more":"<ol>\n<li>**<a href=\"https://www.kotlincn.net/\">Kotlin 中文官网</a>**，官网的中文镜像，有社区大佬负责及时跟进翻译，是中文学习的首选资料。</li>\n<li>**<a href=\"https://www.kotliner.cn/\">Kotlin 中文博客</a>**，官方博客的中文镜像，有社区大佬负责及时跟进翻译，可以及时获取 Kotlin 官方的最新动态。</li>\n<li>**<a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a>**，与官方论坛风格一致，保持原汁原味，大家可以在上面交流学习心得。</li>\n<li><strong>微信公众号 Kotlin</strong>，账号从 2016 年 10月创建，至今已经持续更新两年，主要是我在使用 Kotlin 或者教学过程中的一些经验分享。</li>\n</ol>\n<p>欢迎关注 Kotlin 公众号：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1f02bfeb-1755-4685-8804-83e6880f1bd1/assets/Kotlin.jpg\" alt=\"Kotlin 公众号\"></p>","popularPost_tmp_postPath":true},{"title":"Kotlin 中文论坛的使用技巧","keywords":"Kotlin 中文论坛","date":"2019-10-21T16:00:00.000Z","description":null,"_content":"\n> 我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ \n\n<!-- more -->\n\n\n\n\n欢迎访问 [Kotlin 中文论坛](https://discuss.kotliner.cn/) 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~\n\n大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 [Discourse](https://www.discourse.org/)，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg)\n\n我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg)\n\n之后呢？我们就可以在桌面上看到：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg)\n\n点击这个 icon 进入之后，就好像原生 App 一样：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg)\n\n浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！\n\n--- \n\n经过小伙伴们之处，桌面也可以：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg)\n\n然后就得到了一个桌面 APP 有木有！\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg)\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-forum-mobile.md","raw":"---\ntitle:  Kotlin 中文论坛的使用技巧 \nkeywords: Kotlin 中文论坛 \ndate: 2019/10/22\ndescription: \ntags:\n  - Kotlin\n  - Website\n---\n\n> 我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ \n\n<!-- more -->\n\n\n\n\n欢迎访问 [Kotlin 中文论坛](https://discuss.kotliner.cn/) 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~\n\n大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 [Discourse](https://www.discourse.org/)，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg)\n\n我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg)\n\n之后呢？我们就可以在桌面上看到：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg)\n\n点击这个 icon 进入之后，就好像原生 App 一样：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg)\n\n浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！\n\n--- \n\n经过小伙伴们之处，桌面也可以：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg)\n\n然后就得到了一个桌面 APP 有木有！\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg)\n\n\n\n\n\n---\n\nKotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系kf@imooc.com邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日\nps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！\n\n---\n\n想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-forum-mobile","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003g001olduz1upe58yi","content":"<blockquote>\n<p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>欢迎访问 <a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p>\n<p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href=\"https://www.discourse.org/\">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg\"></p>\n<p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg\"></p>\n<p>之后呢？我们就可以在桌面上看到：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg\"></p>\n<p>点击这个 icon 进入之后，就好像原生 App 一样：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg\"></p>\n<p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p>\n<hr>\n<p>经过小伙伴们之处，桌面也可以：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg\"></p>\n<p>然后就得到了一个桌面 APP 有木有！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg\"></p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>我也是刚发现的！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！ </p>\n</blockquote>","more":"<p>欢迎访问 <a href=\"https://discuss.kotliner.cn/\">Kotlin 中文论坛</a> 讨论 Kotlin！为了能够有时间刷论坛，我卸载了知乎卸载了脉脉，来吧，抛出你的问题~~</p>\n<p>大家知道，额，估计不知道吧。。。我们的 Kotlin 中文论坛实际上是采用了与官方论坛相同的框架 <a href=\"https://www.discourse.org/\">Discourse</a>，很厉害的项目呢。这个框架界面风格都非常的清爽，Github 的论坛、Gradle 论坛好多论坛都采用了这个项目搭建：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716995316308.jpg\"></p>\n<p>我其实一直以为它的优点就只有这么点儿，直到我发现用手机端的 Chrome 可以直接创建一个快捷方式：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716998152892.jpg\"></p>\n<p>之后呢？我们就可以在桌面上看到：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999181369.jpg\"></p>\n<p>点击这个 icon 进入之后，就好像原生 App 一样：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15716999799086.jpg\"></p>\n<p>浏览器的地址不见了有没有，使用体验也很不错，小伙伴们就可以随时随地刷论坛啦！再也不用担心自己抛出的问题被QQ群的水友给冲掉啦！</p>\n<hr>\n<p>经过小伙伴们之处，桌面也可以：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720452651204.jpg\"></p>\n<p>然后就得到了一个桌面 APP 有木有！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/15720453054368.jpg\"></p>\n<hr>\n<p>Kotlin 现在正在迅速成为广大开发者的新宠，如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的新课：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<p>升级说明：尽管这门课全新制作，内容相比之前也做了非常多的扩充，但考虑到照顾之前购买了 《Kotlin 入门到进阶》 的3000多位同学，请邮件联系<a href=\"mailto:&#x6b;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#111;&#x6d;\">&#x6b;&#102;&#x40;&#x69;&#x6d;&#x6f;&#x6f;&#99;&#x2e;&#99;&#111;&#x6d;</a>邮箱索取优惠码（在邮件联系时候请提供各自的慕课网账号昵称或者慕课网账号uid），然后使用优惠码加补差价的方式购买新课程。优惠码金额：150元，优惠码使用期限：2019年12月3日至2019年12月26日<br>ps: 新老课程都已购买的学员，请留意电话，慕课网的工作人员会电话联系各位详细沟通~~ 新课升级后新课老课可同时观看，相当于花一份钱购买两门课！</p>\n<hr>\n<p>想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课涉及内容均非浅尝辄止，目前已经有700+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"Kotlin 1.4.30-M1 增强的内联类是个什么东西？","keywords":"Kotlin News","date":"2021-01-17T16:00:00.000Z","description":null,"_content":"\n> 内联类从 1.3 推出，一直处于实验状态。 \n\n\n\n<!-- more -->\n\n\n\n\n内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。\n\n## 1. 从内联函数说起\n\n我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。\n\n函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：\n\n```kotlin\nfun max(a: Int, b: Int): Int = if(a > b) a else b\n\nfun main() {\n    println(max(1, 2))\n}\n```\n\n在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。\n\n不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：\n\n```java\n  public final static main()V\n   L0\n    LINENUMBER 6 L0\n    ICONST_1\n    ICONST_2\n    INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.max (II)I\n    INVOKESTATIC kotlin/io/ConsoleKt.println (I)V\n```\n\n如果我们把 max 声明成内联函数：\n\n```kotlin\ninline fun max(a: Int, b: Int): Int = if(a > b) a else b\n```\n\n结果就不一样了：\n\n```java\n  public final static main()V\n   L0\n    LINENUMBER 6 L0\n    ICONST_1\n    ISTORE 0\n    ICONST_2\n    ISTORE 1\n   L1\n    ICONST_0\n    ISTORE 2\n   L2\n    LINENUMBER 8 L2\n   L3\n    ILOAD 1\n   L4\n   L5\n    ISTORE 0\n   L6\n    LINENUMBER 6 L6\n   L7\n    ICONST_0\n    ISTORE 1\n   L8\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 0\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n```\n\n这样我们就已经看不到 max 函数的调用了。\n\n当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：\n\n```kotlin\ninline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n```\n\nforEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：\n\n```kotlin\narrayOf(1,2,3,4).forEach {\n    println(it)\n}\n```\n\n编译之后大致相当于：\n\n```kotlin\nfor (element in arrayOf(1,2,3,4)) {\n    { it: Int -> println(it) }(element)\n}\n```\n\n这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 `{ it: Int -> println(it) }(element)` 其实就是前面 forEach 定义当中的 `action(element)`，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。\n\n所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：\n\n```kotlin\nfor (element in arrayOf(1,2,3,4)) {\n    println(element)\n}\n```\n\n而且这样也更符合我们的直觉。\n\n总结一下，内联函数可以减少函数对象的创建和函数调用的次数。\n\n> 提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？\n\n## 2. 什么是内联类\n\n内联函数可以减少对象的创建，内联类实际上也是如此。\n\n内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。\n\n内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：\n\n```kotlin\ninline class PlayerState(val value: Int)\n```\n\n使用时大多数情况下就像普通类型那样：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState.value)\n```\n\n虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：\n\n```kotlin\nval value = 0\nprintln(value)\n```\n\n因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。\n\n我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：\n\n```kotlin\ninline class PlayerState(val value: Int) {\n    val isIdle\n        get() = value == 0\n    \n    fun isPlaying() = value == 1\n}\n```\n\n访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState.isIdle)\nprintln(idleState.isPlaying())\n```\n\n因而就相当于：\n\n```kotlin\nval value = 0\nprintln(PlayerState.isIdle-impl(value))\nprintln(PlayerState.isPlaying-impl(value))\n```\n\n`isIdle-impl` 和 `isPlaying-impl` 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 `-` 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。\n\n我们再看一个稍微复杂的情形：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState)\n```\n\n我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：\n\n```kotlin\nval value = 0\nprintln(PlayerState(value))\n```\n\n简单总结一下就是：\n\n1. 在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。\n2. 编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。\n\n## 3. 内联类有什么限制？\n\n通过前面对于内联类概念的讨论，我们已经知道内联类\n\n1. 有且仅有一个不可变的属性\n2. 可以定义其他属性，但不能有状态\n\n实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：\n\n```kotlin\ninline class UInt internal constructor(internal val data: Int) : Comparable<UInt> {\n  ...\n\n  override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n  ...\n}\n```\n\n这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：\n\n**以下为 Kotlin 1.4.20 当中的效果**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png)\n\n在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。\n\n不过，1.4.30-M1 当中已经解除了这一限制，详情参见：**KT-28056 Consider supporting non-public primary constructors for inline classes**(https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为 internal 或者 private，以防止外部随意创建新实例：\n\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n    }\n}\n```\n\n这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。\n\n除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png)\n\n1.4.30-M1 开始解除了这一限制，详情参见：**KT-28055 Consider supporting init blocks inside inline classes**(https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然 init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。\n\n## 4. 内联类有什么应用场景？\n\n前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。\n\n### 4.1 加强版的类型别名\n\n内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：\n\n```kotlin\ninline class Flag0(val value: Int)\ntypealias Flag1 = Int\n\nfun main() {\n    println(Flag0::class == Int::class) // false\n    println(Flag1::class == Int::class) // true\n    \n    val flag0 = Flag0(0)\n    val flag1 = 0\n}\n```\n\n### 4.2 替代枚举类\n\n内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：\n\n**内联类的写法**\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n    }\n}\n```\n\n**枚举类的写法**\n\n```kotlin\nenum class PlayerState {\n    error, idle, playing\n}\n```\n\n我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：\n\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n        \n        fun values() = arrayOf(error, idle, playing)\n    }\n    \n    fun isIdle() = this == idle\n}\n```\n\n虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。\n\n话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。\n\n当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：\n\n**使用内联类**\n\n```kotlin\nval result = when(state) {\n  PlayerState.error -> { ... }\n  PlayerState.idle -> { ... }\n  PlayerState.playing -> { ... }\n  else -> { ... } // 必须，因为编译器无法推断出前面的条件是完备的\n}\n```\n\n而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：\n\n**使用枚举类**\n\n```kotlin\nval result = when(state) {\n  PlayerState.error -> { ... }\n  PlayerState.idle -> { ... }\n  PlayerState.playing -> { ... }\n}\n```\n\n### 4.3 替代密封类\n\n密封类用于子类可数的场景，枚举类则用于实例可数的场景。\n\n我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：\n\n```kotlin\nclass Song {\n  ...\n}\n\nsealed class PlayerState\n\nclass Error(val t: Throwable): PlayerState()\nobject Idle: PlayerState()\nclass Playing(val song: Song): PlayerState()\n```\n\n如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。\n\n这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？\n\n其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：\n\n```kotlin\nsealed class PlayerState\n\ninline class Error(val t: Throwable): PlayerState()\nobject Idle: PlayerState()\ninline class Playing(val song: Song): PlayerState()\n```\n\n那么：\n\n```kotlin\nvar state: PlayerState = Idle\n...\nstate = Error(IOExeption(\"...\")) // 必须装箱，无法内联\n...\nstate = Playing(Song(...)) // 必须装箱，无法内联\n```\n\n这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。\n\n不过，作为变通，其实我们也可以这样改写上面的例子：\n\n```kotlin\ninline class PlayerState(val state: Any?) {\n    init {\n        require(state == null || state is Throwable || state is Song)\n    }\n    \n    fun isIdle() = state == null\n    fun isError() = state is Throwable\n    fun isPlaying() = state is Song\n}\n```\n\n这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：\n\n```kotlin\ninline class Result<out T> internal constructor(\n    internal val value: Any?\n) : Serializable {\n\n  val isSuccess: Boolean get() = value !is Failure\n\n  val isFailure: Boolean get() = value is Failure\n  \n  ...\n}\n```\n\n## 5. 小结\n\n本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：\n\n1. 内联类是对其他类实例的包装\n2. 内联类在编译时会尽可能地将实例替换成被包装的对象\n3. 内联类的函数（包括无状态属性）都将被编译成静态函数\n4. 内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用\n5. 内联类不能与 Java 兼容\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-inline-class-improvements.md","raw":"---\ntitle:  Kotlin 1.4.30-M1 增强的内联类是个什么东西？ \nkeywords: Kotlin News \ndate: 2021/01/18\ndescription: \ntags: \n    - kotlin\n    - news\n    - inline class \n---\n\n> 内联类从 1.3 推出，一直处于实验状态。 \n\n\n\n<!-- more -->\n\n\n\n\n内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。\n\n## 1. 从内联函数说起\n\n我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。\n\n函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：\n\n```kotlin\nfun max(a: Int, b: Int): Int = if(a > b) a else b\n\nfun main() {\n    println(max(1, 2))\n}\n```\n\n在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。\n\n不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：\n\n```java\n  public final static main()V\n   L0\n    LINENUMBER 6 L0\n    ICONST_1\n    ICONST_2\n    INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.max (II)I\n    INVOKESTATIC kotlin/io/ConsoleKt.println (I)V\n```\n\n如果我们把 max 声明成内联函数：\n\n```kotlin\ninline fun max(a: Int, b: Int): Int = if(a > b) a else b\n```\n\n结果就不一样了：\n\n```java\n  public final static main()V\n   L0\n    LINENUMBER 6 L0\n    ICONST_1\n    ISTORE 0\n    ICONST_2\n    ISTORE 1\n   L1\n    ICONST_0\n    ISTORE 2\n   L2\n    LINENUMBER 8 L2\n   L3\n    ILOAD 1\n   L4\n   L5\n    ISTORE 0\n   L6\n    LINENUMBER 6 L6\n   L7\n    ICONST_0\n    ISTORE 1\n   L8\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 0\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n```\n\n这样我们就已经看不到 max 函数的调用了。\n\n当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：\n\n```kotlin\ninline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n```\n\nforEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：\n\n```kotlin\narrayOf(1,2,3,4).forEach {\n    println(it)\n}\n```\n\n编译之后大致相当于：\n\n```kotlin\nfor (element in arrayOf(1,2,3,4)) {\n    { it: Int -> println(it) }(element)\n}\n```\n\n这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 `{ it: Int -> println(it) }(element)` 其实就是前面 forEach 定义当中的 `action(element)`，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。\n\n所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：\n\n```kotlin\nfor (element in arrayOf(1,2,3,4)) {\n    println(element)\n}\n```\n\n而且这样也更符合我们的直觉。\n\n总结一下，内联函数可以减少函数对象的创建和函数调用的次数。\n\n> 提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？\n\n## 2. 什么是内联类\n\n内联函数可以减少对象的创建，内联类实际上也是如此。\n\n内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。\n\n内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：\n\n```kotlin\ninline class PlayerState(val value: Int)\n```\n\n使用时大多数情况下就像普通类型那样：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState.value)\n```\n\n虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：\n\n```kotlin\nval value = 0\nprintln(value)\n```\n\n因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。\n\n我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：\n\n```kotlin\ninline class PlayerState(val value: Int) {\n    val isIdle\n        get() = value == 0\n    \n    fun isPlaying() = value == 1\n}\n```\n\n访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState.isIdle)\nprintln(idleState.isPlaying())\n```\n\n因而就相当于：\n\n```kotlin\nval value = 0\nprintln(PlayerState.isIdle-impl(value))\nprintln(PlayerState.isPlaying-impl(value))\n```\n\n`isIdle-impl` 和 `isPlaying-impl` 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 `-` 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。\n\n我们再看一个稍微复杂的情形：\n\n```kotlin\nval idleState = PlayerState(0)\nprintln(idleState)\n```\n\n我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：\n\n```kotlin\nval value = 0\nprintln(PlayerState(value))\n```\n\n简单总结一下就是：\n\n1. 在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。\n2. 编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。\n\n## 3. 内联类有什么限制？\n\n通过前面对于内联类概念的讨论，我们已经知道内联类\n\n1. 有且仅有一个不可变的属性\n2. 可以定义其他属性，但不能有状态\n\n实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：\n\n```kotlin\ninline class UInt internal constructor(internal val data: Int) : Comparable<UInt> {\n  ...\n\n  override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n  ...\n}\n```\n\n这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：\n\n**以下为 Kotlin 1.4.20 当中的效果**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png)\n\n在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。\n\n不过，1.4.30-M1 当中已经解除了这一限制，详情参见：**KT-28056 Consider supporting non-public primary constructors for inline classes**(https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为 internal 或者 private，以防止外部随意创建新实例：\n\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n    }\n}\n```\n\n这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。\n\n除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png)\n\n1.4.30-M1 开始解除了这一限制，详情参见：**KT-28055 Consider supporting init blocks inside inline classes**(https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然 init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。\n\n## 4. 内联类有什么应用场景？\n\n前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。\n\n### 4.1 加强版的类型别名\n\n内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：\n\n```kotlin\ninline class Flag0(val value: Int)\ntypealias Flag1 = Int\n\nfun main() {\n    println(Flag0::class == Int::class) // false\n    println(Flag1::class == Int::class) // true\n    \n    val flag0 = Flag0(0)\n    val flag1 = 0\n}\n```\n\n### 4.2 替代枚举类\n\n内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：\n\n**内联类的写法**\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n    }\n}\n```\n\n**枚举类的写法**\n\n```kotlin\nenum class PlayerState {\n    error, idle, playing\n}\n```\n\n我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：\n\n```kotlin\ninline class PlayerState\nprivate constructor(val value: Int) {\n    companion object {\n        val error = PlayerState(-1)\n        val idle = PlayerState(0)\n        val playing = PlayerState(1)\n        \n        fun values() = arrayOf(error, idle, playing)\n    }\n    \n    fun isIdle() = this == idle\n}\n```\n\n虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。\n\n话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。\n\n当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：\n\n**使用内联类**\n\n```kotlin\nval result = when(state) {\n  PlayerState.error -> { ... }\n  PlayerState.idle -> { ... }\n  PlayerState.playing -> { ... }\n  else -> { ... } // 必须，因为编译器无法推断出前面的条件是完备的\n}\n```\n\n而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：\n\n**使用枚举类**\n\n```kotlin\nval result = when(state) {\n  PlayerState.error -> { ... }\n  PlayerState.idle -> { ... }\n  PlayerState.playing -> { ... }\n}\n```\n\n### 4.3 替代密封类\n\n密封类用于子类可数的场景，枚举类则用于实例可数的场景。\n\n我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：\n\n```kotlin\nclass Song {\n  ...\n}\n\nsealed class PlayerState\n\nclass Error(val t: Throwable): PlayerState()\nobject Idle: PlayerState()\nclass Playing(val song: Song): PlayerState()\n```\n\n如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。\n\n这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？\n\n其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：\n\n```kotlin\nsealed class PlayerState\n\ninline class Error(val t: Throwable): PlayerState()\nobject Idle: PlayerState()\ninline class Playing(val song: Song): PlayerState()\n```\n\n那么：\n\n```kotlin\nvar state: PlayerState = Idle\n...\nstate = Error(IOExeption(\"...\")) // 必须装箱，无法内联\n...\nstate = Playing(Song(...)) // 必须装箱，无法内联\n```\n\n这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。\n\n不过，作为变通，其实我们也可以这样改写上面的例子：\n\n```kotlin\ninline class PlayerState(val state: Any?) {\n    init {\n        require(state == null || state is Throwable || state is Song)\n    }\n    \n    fun isIdle() = state == null\n    fun isError() = state is Throwable\n    fun isPlaying() = state is Song\n}\n```\n\n这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：\n\n```kotlin\ninline class Result<out T> internal constructor(\n    internal val value: Any?\n) : Serializable {\n\n  val isSuccess: Boolean get() = value !is Failure\n\n  val isFailure: Boolean get() = value is Failure\n  \n  ...\n}\n```\n\n## 5. 小结\n\n本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：\n\n1. 内联类是对其他类实例的包装\n2. 内联类在编译时会尽可能地将实例替换成被包装的对象\n3. 内联类的函数（包括无状态属性）都将被编译成静态函数\n4. 内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用\n5. 内联类不能与 Java 兼容\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-inline-class-improvements","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003g001rlduzbwew9i40","content":"<blockquote>\n<p>内联类从 1.3 推出，一直处于实验状态。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。</p>\n<h2 id=\"1-从内联函数说起\"><a href=\"#1-从内联函数说起\" class=\"headerlink\" title=\"1. 从内联函数说起\"></a>1. 从内联函数说起</h2><p>我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。</p>\n<p>函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">max</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = <span class=\"keyword\">if</span>(a &gt; b) a <span class=\"keyword\">else</span> b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(max(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。</p>\n<p>不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"title\">main</span><span class=\"params\">()</span>V</span></span><br><span class=\"line\"><span class=\"function\"> L0</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_1</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_2</span></span><br><span class=\"line\"><span class=\"function\">  INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.<span class=\"title\">max</span> <span class=\"params\">(II)</span>I</span></span><br><span class=\"line\"><span class=\"function\">  INVOKESTATIC kotlin/io/ConsoleKt.<span class=\"title\">println</span> <span class=\"params\">(I)</span>V</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们把 max 声明成内联函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">max</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = <span class=\"keyword\">if</span>(a &gt; b) a <span class=\"keyword\">else</span> b</span><br></pre></td></tr></table></figure>\n\n<p>结果就不一样了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"title\">main</span><span class=\"params\">()</span>V</span></span><br><span class=\"line\"><span class=\"function\"> L0</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_1</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_2</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 1</span></span><br><span class=\"line\"><span class=\"function\"> L1</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_0</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 2</span></span><br><span class=\"line\"><span class=\"function\"> L2</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 8 L2</span></span><br><span class=\"line\"><span class=\"function\"> L3</span></span><br><span class=\"line\"><span class=\"function\">  ILOAD 1</span></span><br><span class=\"line\"><span class=\"function\"> L4</span></span><br><span class=\"line\"><span class=\"function\"> L5</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 0</span></span><br><span class=\"line\"><span class=\"function\"> L6</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L6</span></span><br><span class=\"line\"><span class=\"function\"> L7</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_0</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 1</span></span><br><span class=\"line\"><span class=\"function\"> L8</span></span><br><span class=\"line\"><span class=\"function\">  GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class=\"line\">  ILOAD <span class=\"number\">0</span></span><br><span class=\"line\">  INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就已经看不到 max 函数的调用了。</p>\n<p>当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>forEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>).forEach &#123;</span><br><span class=\"line\">    println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译之后大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">    &#123; it: <span class=\"built_in\">Int</span> -&gt; println(it) &#125;(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 <code>&#123; it: Int -&gt; println(it) &#125;(element)</code> 其实就是前面 forEach 定义当中的 <code>action(element)</code>，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。</p>\n<p>所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">    println(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且这样也更符合我们的直觉。</p>\n<p>总结一下，内联函数可以减少函数对象的创建和函数调用的次数。</p>\n<blockquote>\n<p>提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？</p>\n</blockquote>\n<h2 id=\"2-什么是内联类\"><a href=\"#2-什么是内联类\" class=\"headerlink\" title=\"2. 什么是内联类\"></a>2. 什么是内联类</h2><p>内联函数可以减少对象的创建，内联类实际上也是如此。</p>\n<p>内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。</p>\n<p>内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>使用时大多数情况下就像普通类型那样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState.value)</span><br></pre></td></tr></table></figure>\n\n<p>虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(value)</span><br></pre></td></tr></table></figure>\n\n<p>因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。</p>\n<p>我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> isIdle</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = value == <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPlaying</span><span class=\"params\">()</span></span> = value == <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState.isIdle)</span><br><span class=\"line\">println(idleState.isPlaying())</span><br></pre></td></tr></table></figure>\n\n<p>因而就相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(PlayerState.isIdle-impl(value))</span><br><span class=\"line\">println(PlayerState.isPlaying-impl(value))</span><br></pre></td></tr></table></figure>\n\n<p><code>isIdle-impl</code> 和 <code>isPlaying-impl</code> 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 <code>-</code> 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。</p>\n<p>我们再看一个稍微复杂的情形：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState)</span><br></pre></td></tr></table></figure>\n\n<p>我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(PlayerState(value))</span><br></pre></td></tr></table></figure>\n\n<p>简单总结一下就是：</p>\n<ol>\n<li>在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。</li>\n<li>编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。</li>\n</ol>\n<h2 id=\"3-内联类有什么限制？\"><a href=\"#3-内联类有什么限制？\" class=\"headerlink\" title=\"3. 内联类有什么限制？\"></a>3. 内联类有什么限制？</h2><p>通过前面对于内联类概念的讨论，我们已经知道内联类</p>\n<ol>\n<li>有且仅有一个不可变的属性</li>\n<li>可以定义其他属性，但不能有状态</li>\n</ol>\n<p>实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UInt</span> <span class=\"keyword\">internal</span> <span class=\"keyword\">constructor</span></span>(<span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) : Comparable&lt;UInt&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">compareTo</span><span class=\"params\">(other: <span class=\"type\">UInt</span>)</span></span>: <span class=\"built_in\">Int</span> = uintCompare(<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span>, other.<span class=\"keyword\">data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：</p>\n<p><strong>以下为 Kotlin 1.4.20 当中的效果</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png\"></p>\n<p>在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。</p>\n<p>不过，1.4.30-M1 当中已经解除了这一限制，详情参见：<strong>KT-28056 Consider supporting non-public primary constructors for inline classes</strong>(<a href=\"https://youtrack.jetbrains.com/issue/KT-28056)%EF%BC%8C%E5%9B%A0%E8%80%8C%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%86%85%E8%81%94%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E%E4%B8%BA\">https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为</a> internal 或者 private，以防止外部随意创建新实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。</p>\n<p>除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png\"></p>\n<p>1.4.30-M1 开始解除了这一限制，详情参见：<strong>KT-28055 Consider supporting init blocks inside inline classes</strong>(<a href=\"https://youtrack.jetbrains.com/issue/KT-28055)%E3%80%82%E4%B8%8D%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%99%BD%E7%84%B6\">https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然</a> init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。</p>\n<h2 id=\"4-内联类有什么应用场景？\"><a href=\"#4-内联类有什么应用场景？\" class=\"headerlink\" title=\"4. 内联类有什么应用场景？\"></a>4. 内联类有什么应用场景？</h2><p>前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。</p>\n<h3 id=\"4-1-加强版的类型别名\"><a href=\"#4-1-加强版的类型别名\" class=\"headerlink\" title=\"4.1 加强版的类型别名\"></a>4.1 加强版的类型别名</h3><p>内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Flag0</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>)</span><br><span class=\"line\"><span class=\"keyword\">typealias</span> Flag1 = <span class=\"built_in\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(Flag0::<span class=\"class\"><span class=\"keyword\">class</span> == <span class=\"title\">Int</span>:<span class=\"type\">:class) // false</span></span></span><br><span class=\"line\">    println(Flag1::<span class=\"class\"><span class=\"keyword\">class</span> == <span class=\"title\">Int</span>:<span class=\"type\">:class) // true</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">val</span> flag0 = Flag0(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> flag1 = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-替代枚举类\"><a href=\"#4-2-替代枚举类\" class=\"headerlink\" title=\"4.2 替代枚举类\"></a>4.2 替代枚举类</h3><p>内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：</p>\n<p><strong>内联类的写法</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>枚举类的写法</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    error, idle, playing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">values</span><span class=\"params\">()</span></span> = arrayOf(error, idle, playing)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isIdle</span><span class=\"params\">()</span></span> = <span class=\"keyword\">this</span> == idle</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。</p>\n<p>话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。</p>\n<p>当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：</p>\n<p><strong>使用内联类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"keyword\">when</span>(state) &#123;</span><br><span class=\"line\">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> -&gt; &#123; ... &#125; <span class=\"comment\">// 必须，因为编译器无法推断出前面的条件是完备的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：</p>\n<p><strong>使用枚举类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"keyword\">when</span>(state) &#123;</span><br><span class=\"line\">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-替代密封类\"><a href=\"#4-3-替代密封类\" class=\"headerlink\" title=\"4.3 替代密封类\"></a>4.3 替代密封类</h3><p>密封类用于子类可数的场景，枚举类则用于实例可数的场景。</p>\n<p>我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>\n\n<p>如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。</p>\n<p>这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？</p>\n<p>其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>\n\n<p>那么：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> state: PlayerState = Idle</span><br><span class=\"line\">...</span><br><span class=\"line\">state = Error(IOExeption(<span class=\"string\">&quot;...&quot;</span>)) <span class=\"comment\">// 必须装箱，无法内联</span></span><br><span class=\"line\">...</span><br><span class=\"line\">state = Playing(Song(...)) <span class=\"comment\">// 必须装箱，无法内联</span></span><br></pre></td></tr></table></figure>\n\n<p>这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。</p>\n<p>不过，作为变通，其实我们也可以这样改写上面的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> state: Any?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        require(state == <span class=\"literal\">null</span> || state <span class=\"keyword\">is</span> Throwable || state <span class=\"keyword\">is</span> Song)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isIdle</span><span class=\"params\">()</span></span> = state == <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isError</span><span class=\"params\">()</span></span> = state <span class=\"keyword\">is</span> Throwable</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPlaying</span><span class=\"params\">()</span></span> = state <span class=\"keyword\">is</span> Song</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span>&lt;<span class=\"type\">out T</span>&gt; <span class=\"keyword\">internal</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> value: Any?</span><br><span class=\"line\">) : Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> isSuccess: <span class=\"built_in\">Boolean</span> <span class=\"keyword\">get</span>() = value !<span class=\"keyword\">is</span> Failure</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> isFailure: <span class=\"built_in\">Boolean</span> <span class=\"keyword\">get</span>() = value <span class=\"keyword\">is</span> Failure</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：</p>\n<ol>\n<li>内联类是对其他类实例的包装</li>\n<li>内联类在编译时会尽可能地将实例替换成被包装的对象</li>\n<li>内联类的函数（包括无状态属性）都将被编译成静态函数</li>\n<li>内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用</li>\n<li>内联类不能与 Java 兼容</li>\n</ol>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>内联类从 1.3 推出，一直处于实验状态。 </p>\n</blockquote>","more":"<p>内联类要解决的问题呢，其实也与以往我们接触到的内联函数类似，大体思路就是提供某种语法，提升代码编写体验和效率，同时又借助编译器的优化手段来减少这样做的成本。</p>\n<h2 id=\"1-从内联函数说起\"><a href=\"#1-从内联函数说起\" class=\"headerlink\" title=\"1. 从内联函数说起\"></a>1. 从内联函数说起</h2><p>我们先以各类编程语言当中广泛存在的内联函数为例来说明内联的作用。</p>\n<p>函数调用时有成本的，这涉及到参数的传递，结果的返回，调用栈的维护等一系列工作。因此，对于一些比较小的函数，可以在编译时使用函数的内容替换函数的调用，以减少函数的调用层次，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">max</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = <span class=\"keyword\">if</span>(a &gt; b) a <span class=\"keyword\">else</span> b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(max(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 main 函数当中调用 max 函数，从代码编写的角度来看，使用函数 max 让我们的代码意图更加明显，也使得求最大值的逻辑更容易复用，因此在日常的开发当中我们也一直鼓励大家这样做。</p>\n<p>不过，这样的结果就是一个简单的比较大小的事儿变成了一次函数的调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"title\">main</span><span class=\"params\">()</span>V</span></span><br><span class=\"line\"><span class=\"function\"> L0</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_1</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_2</span></span><br><span class=\"line\"><span class=\"function\">  INVOKESTATIC com/bennyhuo/kotlin/InlineFunctionKt.<span class=\"title\">max</span> <span class=\"params\">(II)</span>I</span></span><br><span class=\"line\"><span class=\"function\">  INVOKESTATIC kotlin/io/ConsoleKt.<span class=\"title\">println</span> <span class=\"params\">(I)</span>V</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们把 max 声明成内联函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">max</span><span class=\"params\">(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> = <span class=\"keyword\">if</span>(a &gt; b) a <span class=\"keyword\">else</span> b</span><br></pre></td></tr></table></figure>\n\n<p>结果就不一样了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"title\">main</span><span class=\"params\">()</span>V</span></span><br><span class=\"line\"><span class=\"function\"> L0</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_1</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 0</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_2</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 1</span></span><br><span class=\"line\"><span class=\"function\"> L1</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_0</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 2</span></span><br><span class=\"line\"><span class=\"function\"> L2</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 8 L2</span></span><br><span class=\"line\"><span class=\"function\"> L3</span></span><br><span class=\"line\"><span class=\"function\">  ILOAD 1</span></span><br><span class=\"line\"><span class=\"function\"> L4</span></span><br><span class=\"line\"><span class=\"function\"> L5</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 0</span></span><br><span class=\"line\"><span class=\"function\"> L6</span></span><br><span class=\"line\"><span class=\"function\">  LINENUMBER 6 L6</span></span><br><span class=\"line\"><span class=\"function\"> L7</span></span><br><span class=\"line\"><span class=\"function\">  ICONST_0</span></span><br><span class=\"line\"><span class=\"function\">  ISTORE 1</span></span><br><span class=\"line\"><span class=\"function\"> L8</span></span><br><span class=\"line\"><span class=\"function\">  GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class=\"line\">  ILOAD <span class=\"number\">0</span></span><br><span class=\"line\">  INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就已经看不到 max 函数的调用了。</p>\n<p>当然，对于这样的小函数，编译器和运行时已经足够聪明到可以自己自动做优化了，内联函数在 Kotlin 当中最大的作用其实是高阶函数的内联，我们就以最为常见的 forEach 为例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>forEach 函数被声明为 inline，这说明它是一个内联函数。按照我们的前面对内联函数的理解，下面的代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>).forEach &#123;</span><br><span class=\"line\">    println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译之后大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">    &#123; it: <span class=\"built_in\">Int</span> -&gt; println(it) &#125;(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样 forEach 自身的调用就被消除掉了。不过，这还不够，因为我们看到 <code>&#123; it: Int -&gt; println(it) &#125;(element)</code> 其实就是前面 forEach 定义当中的 <code>action(element)</code>，这也是一个函数调用，也是有成本的。更为甚者，每一次循环当中都会创建一个函数对象（Lambda）并且调用它，这样一来，还会有频繁创建对象的开销。</p>\n<p>所以，Kotlin 当中的内联函数也会同时对函数类型的参数进行内联，因此前面的调用编译之后实际上相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> arrayOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">    println(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且这样也更符合我们的直觉。</p>\n<p>总结一下，内联函数可以减少函数对象的创建和函数调用的次数。</p>\n<blockquote>\n<p>提问：所以你知道为什么 IDE 会对 max 这样的非高阶函数的内联发出警告了吗？</p>\n</blockquote>\n<h2 id=\"2-什么是内联类\"><a href=\"#2-什么是内联类\" class=\"headerlink\" title=\"2. 什么是内联类\"></a>2. 什么是内联类</h2><p>内联函数可以减少对象的创建，内联类实际上也是如此。</p>\n<p>内联类实际上就是对其他类型的一个包装，就像内联函数其实是对一段代码的包装一样，在编译的时候对于内联类对象的访问都会被编译器拆掉包装而得到内部真实的类型。因此，内联类一定有且只有一个属性，而且这个属性还不能被修改。</p>\n<p>内联类的语法其实也简单，与 Kotlin 当中其他的枚举类、密封类、数据类的定义方式类似，在 class 前面加一个 inline 即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>使用时大多数情况下就像普通类型那样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState.value)</span><br></pre></td></tr></table></figure>\n\n<p>虽然这里创建了一个 PlayerState 的实例 idleState，我们也对这个实例的成员 value 进行了访问，但编译完之后这段代码大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(value)</span><br></pre></td></tr></table></figure>\n\n<p>因为 PlayerState 这个类型的实例被内联，结果就剩下 value 本身了。</p>\n<p>我们当然也可以给内联类定义其他成员，这其中包括无状态的属性（没有 backing field）和函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> isIdle</span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = value == <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPlaying</span><span class=\"params\">()</span></span> = value == <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问这些成员的时候，编译器也并不会将内联类的实例创建出来，而是转换成静态方法调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState.isIdle)</span><br><span class=\"line\">println(idleState.isPlaying())</span><br></pre></td></tr></table></figure>\n\n<p>因而就相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(PlayerState.isIdle-impl(value))</span><br><span class=\"line\">println(PlayerState.isPlaying-impl(value))</span><br></pre></td></tr></table></figure>\n\n<p><code>isIdle-impl</code> 和 <code>isPlaying-impl</code> 这两个函数是编译器自动为 PlayerState 生成的静态方法，它们的方法名中加了 <code>-</code> 这样的非法字符，这意味着这些方法对于 Java 来讲是不友好的，换句话讲，内联类不能与 Java 的语法兼容。</p>\n<p>我们再看一个稍微复杂的情形：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> idleState = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">println(idleState)</span><br></pre></td></tr></table></figure>\n\n<p>我们直接将这个内联类的实例传给 println，这下编译器会怎么办呢？编译器只会在尽可能需要的情况下完成内联，但对于这种强制需要内联类实例的情况，也是无法绕过的，因此在这里会发生一次“装箱”操作，把内联类实例真正创建出来，大致相当于：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> value = <span class=\"number\">0</span></span><br><span class=\"line\">println(PlayerState(value))</span><br></pre></td></tr></table></figure>\n\n<p>简单总结一下就是：</p>\n<ol>\n<li>在一定范围内，内联类可以像普通类那样使用。言外之意，其实内联类也有挺多限制的，这个我们待会儿再聊。</li>\n<li>编译之后，编译器会尽可能地将内联类的实例替换成其成员，减少对象的创建。</li>\n</ol>\n<h2 id=\"3-内联类有什么限制？\"><a href=\"#3-内联类有什么限制？\" class=\"headerlink\" title=\"3. 内联类有什么限制？\"></a>3. 内联类有什么限制？</h2><p>通过前面对于内联类概念的讨论，我们已经知道内联类</p>\n<ol>\n<li>有且仅有一个不可变的属性</li>\n<li>可以定义其他属性，但不能有状态</li>\n</ol>\n<p>实际上，由于内联类存在状态限制，因此内联类也不能继承其他类型，但这不会影响它实现接口，例如标准库当中的无符号整型 UInt 定义如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UInt</span> <span class=\"keyword\">internal</span> <span class=\"keyword\">constructor</span></span>(<span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> <span class=\"keyword\">data</span>: <span class=\"built_in\">Int</span>) : Comparable&lt;UInt&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">compareTo</span><span class=\"params\">(other: <span class=\"type\">UInt</span>)</span></span>: <span class=\"built_in\">Int</span> = uintCompare(<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span>, other.<span class=\"keyword\">data</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子里面其实还有惊喜，那就是 UInt 的构造器是 internal 的，如果你想要一样画葫芦在自己的代码当中这样写，怕是要看一下编译器的脸色了：</p>\n<p><strong>以下为 Kotlin 1.4.20 当中的效果</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png\"></p>\n<p>在 Kotlin 1.4.30 以前，内联类的构造器必须是 public 的，这意味着在过去我们不能通过内联类来完成对某一种特定类型的部分值的包装：因为外部一样可以创造出来新的内联类实例。</p>\n<p>不过，1.4.30-M1 当中已经解除了这一限制，详情参见：<strong>KT-28056 Consider supporting non-public primary constructors for inline classes</strong>(<a href=\"https://youtrack.jetbrains.com/issue/KT-28056)%EF%BC%8C%E5%9B%A0%E8%80%8C%E6%88%91%E4%BB%AC%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%86%85%E8%81%94%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%A3%B0%E6%98%8E%E4%B8%BA\">https://youtrack.jetbrains.com/issue/KT-28056)，因而我们现在可以将内联类的构造器声明为</a> internal 或者 private，以防止外部随意创建新实例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，PlayerState 的实例就仅限于 error、idle、playing 这几个了。</p>\n<p>除了前面限制实例的场景，有些情况下我们其实只是希望通过内联类提供一些运行时的校验，这就需要我们在 init 块当中来完成这样的工作了，但内联类的 init 块在 1.4.30 以前也是禁止的：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-43-05.png\"></p>\n<p>1.4.30-M1 开始解除了这一限制，详情参见：<strong>KT-28055 Consider supporting init blocks inside inline classes</strong>(<a href=\"https://youtrack.jetbrains.com/issue/KT-28055)%E3%80%82%E4%B8%8D%E8%BF%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%99%BD%E7%84%B6\">https://youtrack.jetbrains.com/issue/KT-28055)。不过需要注意的是，虽然</a> init 块当中的逻辑只在运行时有效，但这样的特性可以让被包装类型的值与它的条件在代码当中紧密结合起来，提供更良好的一致性。</p>\n<h2 id=\"4-内联类有什么应用场景？\"><a href=\"#4-内联类有什么应用场景？\" class=\"headerlink\" title=\"4. 内联类有什么应用场景？\"></a>4. 内联类有什么应用场景？</h2><p>前面在讨论内联类的概念和限制时，我们已经给出了一些示例，大家也大概能够想到内联类的具体作用。接下来我们再整体梳理一下内联类的应用场景。</p>\n<h3 id=\"4-1-加强版的类型别名\"><a href=\"#4-1-加强版的类型别名\" class=\"headerlink\" title=\"4.1 加强版的类型别名\"></a>4.1 加强版的类型别名</h3><p>内联类最一开始给人的感觉就是“类型别名 Plus”，因为内联类在运行时会被尽可能替换成被包装的类型，这与类型别名看上去很接近。不过，类型别名本质上就是一个别名，它不会导致新类型的产生，而内联类是确实会产生新类型的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Flag0</span></span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>)</span><br><span class=\"line\"><span class=\"keyword\">typealias</span> Flag1 = <span class=\"built_in\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(Flag0::<span class=\"class\"><span class=\"keyword\">class</span> == <span class=\"title\">Int</span>:<span class=\"type\">:class) // false</span></span></span><br><span class=\"line\">    println(Flag1::<span class=\"class\"><span class=\"keyword\">class</span> == <span class=\"title\">Int</span>:<span class=\"type\">:class) // true</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">val</span> flag0 = Flag0(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> flag1 = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-替代枚举类\"><a href=\"#4-2-替代枚举类\" class=\"headerlink\" title=\"4.2 替代枚举类\"></a>4.2 替代枚举类</h3><p>内联类在 1.4.30 之后可以通过私有化构造函数来限制实例个数，这样也可以达到枚举的目的，我们前面已经给出过例子：</p>\n<p><strong>内联类的写法</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>枚举类的写法</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    error, idle, playing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以为内联类添加各种函数来增强它的功能，这些函数最终都会被编译成静态方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span>(<span class=\"keyword\">val</span> value: <span class=\"built_in\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> error = PlayerState(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> idle = PlayerState(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> playing = PlayerState(<span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">values</span><span class=\"params\">()</span></span> = arrayOf(error, idle, playing)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isIdle</span><span class=\"params\">()</span></span> = <span class=\"keyword\">this</span> == idle</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然内联类似乎写起来稍微啰嗦了一些，但在内存上却跟直接使用整型几乎是一样的效果。</p>\n<p>话说到这儿，不知道大家是不是能想起 Android 当中的注解 IntDef，结果上都是使用整型来替代枚举，但内联类显然更安全，IntDef 只是一种提示而已。不仅如此，内联类也可以用来包装字符串等其他类型，无疑将是一种更加灵活的手段。</p>\n<p>当然，使用的内联类相较于枚举类有一点点小缺点，那就是使用 when 表达式时必须添加 else 分支：</p>\n<p><strong>使用内联类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"keyword\">when</span>(state) &#123;</span><br><span class=\"line\">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> -&gt; &#123; ... &#125; <span class=\"comment\">// 必须，因为编译器无法推断出前面的条件是完备的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而由于编译器能够确定枚举类的实例可数的，因此 else 不再需要了：</p>\n<p><strong>使用枚举类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = <span class=\"keyword\">when</span>(state) &#123;</span><br><span class=\"line\">  PlayerState.error -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.idle -&gt; &#123; ... &#125;</span><br><span class=\"line\">  PlayerState.playing -&gt; &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-替代密封类\"><a href=\"#4-3-替代密封类\" class=\"headerlink\" title=\"4.3 替代密封类\"></a>4.3 替代密封类</h3><p>密封类用于子类可数的场景，枚举类则用于实例可数的场景。</p>\n<p>我们前面给出的 PlayerState 其实不够完善，例如状态为 error 时，也应该同时附带错误信息；状态为 playing 时也应该同时有歌曲信息。显然当前一个简单的整型是做不到这一点的，因此我们很容易能想到用密封类替代枚举：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>\n\n<p>如果应用场景对于内存不敏感，这样写实际上一点儿问题都没有，而且代码的可读性和可维护性都会比状态值与其相对应的异常和播放信息独立存储要强得多。</p>\n<p>这里的 Error、Playing 这两个类型其实就是包装了另外的两个类型 Throwable 和 Song 而已，是不是我们可以把它们定义为内联类呢？直接定义肯定是不行的，因为 PlayerState 是个密封类，密封类本质上也是一个类，我们前面提到过内联类有不能继承类型的限制，当时给出的理由是内联类不能包含其他状态。这样看来，如果父类当中足够简单，不包含状态，是不是将来有希望支持继承呢？</p>\n<p>其实问题不只是状态那么简单，还有多态引发的装箱和拆箱的问题。因为一旦涉及到父类，内联类很多时候都无法实现内联，我们假定下面的写法是合法的：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br></pre></td></tr></table></figure>\n\n<p>那么：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> state: PlayerState = Idle</span><br><span class=\"line\">...</span><br><span class=\"line\">state = Error(IOExeption(<span class=\"string\">&quot;...&quot;</span>)) <span class=\"comment\">// 必须装箱，无法内联</span></span><br><span class=\"line\">...</span><br><span class=\"line\">state = Playing(Song(...)) <span class=\"comment\">// 必须装箱，无法内联</span></span><br></pre></td></tr></table></figure>\n\n<p>这里内联机制就失效了，因为我们无法将 Song 的实例直接赋值给 state，IOException 的实例也是如此。</p>\n<p>不过，作为变通，其实我们也可以这样改写上面的例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span></span>(<span class=\"keyword\">val</span> state: Any?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        require(state == <span class=\"literal\">null</span> || state <span class=\"keyword\">is</span> Throwable || state <span class=\"keyword\">is</span> Song)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isIdle</span><span class=\"params\">()</span></span> = state == <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isError</span><span class=\"params\">()</span></span> = state <span class=\"keyword\">is</span> Throwable</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPlaying</span><span class=\"params\">()</span></span> = state <span class=\"keyword\">is</span> Song</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样写就与标准库当中大名鼎鼎的 Result 类有异曲同工之妙了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span>&lt;<span class=\"type\">out T</span>&gt; <span class=\"keyword\">internal</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"keyword\">val</span> value: Any?</span><br><span class=\"line\">) : Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> isSuccess: <span class=\"built_in\">Boolean</span> <span class=\"keyword\">get</span>() = value !<span class=\"keyword\">is</span> Failure</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> isFailure: <span class=\"built_in\">Boolean</span> <span class=\"keyword\">get</span>() = value <span class=\"keyword\">is</span> Failure</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>本文我们简单介绍了一下内联类的作用，实现细节，以及使用场景。简单总结如下：</p>\n<ol>\n<li>内联类是对其他类实例的包装</li>\n<li>内联类在编译时会尽可能地将实例替换成被包装的对象</li>\n<li>内联类的函数（包括无状态属性）都将被编译成静态函数</li>\n<li>内联类在内存敏感的场景下可以一定程度上替代枚举类、密封类的使用</li>\n<li>内联类不能与 Java 兼容</li>\n</ol>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 1.4.30-M1 增强的内联类是个什么东西？","path":"2021/01/18/kotlin-inline-class-improvements/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-17-09-21-50.png","excerpt":"<blockquote>\n<p>内联类从 1.3 推出，一直处于实验状态。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-01-17T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-01-17T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","news","inline class"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 新版本也有了交叉类型和联合类型？","keywords":"Kotlin 1.4 类型系统","date":"2020-04-05T16:00:00.000Z","description":null,"_content":"\n> Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 \n\n\n\n<!-- more -->\n\n\n\n\n先来看一段代码：\n\n**代码清单 1：Kotlin 的分支表达式**\n\n```kotlin\nval number = if (validation()) 1F else 2.0\n```\n\n请问 number 的类型是什么？\n\n直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。\n\n逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？\n\n都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png)\n\n**<center>图 1：Kotlin 1.3 对分支表达式的类型推导</center>**\n\n是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。\n\n当然，如果你为 number 添加类型声明，例如：\n\n**代码清单 2：为分支表达式添加类型信息**\n\n```kotlin\nval number: Number = if (validation()) 1F else 2.0\n```\n\n这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。\n\n> 有关这个问题的详细分析，我曾经在两年前写过一篇文章 [val b = a?: 0，a 是 Double 类型，那 b 是什么类型？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd)，有兴趣的读者可以去了解下。\n\n## 2. 新类型推导算法的推导结果\n\n那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png)\n\n**<center>图 2：Kotlin 1.4 对分支表达式的类型推导</center>**\n\n这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A & B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double & Float} & Number} 这个类型既是 Comparable 类型，又是 Number 类型。\n\n于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：\n\n**代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用**\n\n```kotlin\noperator fun Number.compareTo(other: Number): Int {\n    return this.toDouble().compareTo(other.toDouble())\n}\n\nval number = if (validation()) 1F else 2.0\nif (number > 2) {\n    println(\"$number > 2\")\n} else {\n    println(\"$number <= 2\")\n}\n```\n\n这段代码在 Kotlin 1.3 当中默认会无法通过编译。\n\n## 3. 交叉类型与联合类型\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png)\n\n**<center>图 3：Double 和 Float 的类型关系</center>**\n\n两个类型的交叉类型就是两个类型的交集，因此对于类型 A & B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。\n\n既然如此，从图上来看，Comparable & Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。\n\n坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：\n\n**代码清单 4：TypeScript 中的联合类型**\n\n```typescript\ninterface Bird {\n    fly(): void;\n    layEggs(): void;\n}\n\ninterface Fish {\n    swim(): void;\n    layEggs(): void;\n}\n\ndeclare function getSmallPet(): Fish | Bird;\n\nlet pet = getSmallPet();\n// OK，两个类型的公共成员\npet.layEggs();\n```\n\n虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：\n\n**代码清单 5：Kotlin 的联合类型**\n\n```kotlin\ninterface Bird {\n    fun fly()\n    fun layEggs()\n}\n\ninterface Fish {\n    fun swim()\n    fun layEggs()\n}\n\nval pet = if(validation()) object : Bird{ ... } else object : Fish{ ... }\npet.layEggs() // Error\n```\n\n这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。\n\n按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。\n\n## 4. 为什么不直接支持交叉类型和联合类型呢？\n\n其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：\n\n1. 伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。\n2. 存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。\n\n对于这个问题大家怎么看呢？留言说出你的看法吧。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-intersect-type.md","raw":"---\ntitle:  Kotlin 新版本也有了交叉类型和联合类型？ \nkeywords: Kotlin 1.4 类型系统 \ndate: 2020/04/06\ndescription: \ntags: \n    - kotlin\n    - type \n---\n\n> Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 \n\n\n\n<!-- more -->\n\n\n\n\n先来看一段代码：\n\n**代码清单 1：Kotlin 的分支表达式**\n\n```kotlin\nval number = if (validation()) 1F else 2.0\n```\n\n请问 number 的类型是什么？\n\n直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。\n\n逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？\n\n都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png)\n\n**<center>图 1：Kotlin 1.3 对分支表达式的类型推导</center>**\n\n是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。\n\n当然，如果你为 number 添加类型声明，例如：\n\n**代码清单 2：为分支表达式添加类型信息**\n\n```kotlin\nval number: Number = if (validation()) 1F else 2.0\n```\n\n这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。\n\n> 有关这个问题的详细分析，我曾经在两年前写过一篇文章 [val b = a?: 0，a 是 Double 类型，那 b 是什么类型？](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd)，有兴趣的读者可以去了解下。\n\n## 2. 新类型推导算法的推导结果\n\n那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png)\n\n**<center>图 2：Kotlin 1.4 对分支表达式的类型推导</center>**\n\n这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A & B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double & Float} & Number} 这个类型既是 Comparable 类型，又是 Number 类型。\n\n于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：\n\n**代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用**\n\n```kotlin\noperator fun Number.compareTo(other: Number): Int {\n    return this.toDouble().compareTo(other.toDouble())\n}\n\nval number = if (validation()) 1F else 2.0\nif (number > 2) {\n    println(\"$number > 2\")\n} else {\n    println(\"$number <= 2\")\n}\n```\n\n这段代码在 Kotlin 1.3 当中默认会无法通过编译。\n\n## 3. 交叉类型与联合类型\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png)\n\n**<center>图 3：Double 和 Float 的类型关系</center>**\n\n两个类型的交叉类型就是两个类型的交集，因此对于类型 A & B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。\n\n既然如此，从图上来看，Comparable & Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。\n\n坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：\n\n**代码清单 4：TypeScript 中的联合类型**\n\n```typescript\ninterface Bird {\n    fly(): void;\n    layEggs(): void;\n}\n\ninterface Fish {\n    swim(): void;\n    layEggs(): void;\n}\n\ndeclare function getSmallPet(): Fish | Bird;\n\nlet pet = getSmallPet();\n// OK，两个类型的公共成员\npet.layEggs();\n```\n\n虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：\n\n**代码清单 5：Kotlin 的联合类型**\n\n```kotlin\ninterface Bird {\n    fun fly()\n    fun layEggs()\n}\n\ninterface Fish {\n    fun swim()\n    fun layEggs()\n}\n\nval pet = if(validation()) object : Bird{ ... } else object : Fish{ ... }\npet.layEggs() // Error\n```\n\n这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。\n\n按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。\n\n## 4. 为什么不直接支持交叉类型和联合类型呢？\n\n其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：\n\n1. 伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。\n2. 存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。\n\n对于这个问题大家怎么看呢？留言说出你的看法吧。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-intersect-type","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003h001tlduz0v3shhan","content":"<blockquote>\n<p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>先来看一段代码：</p>\n<p><strong>代码清单 1：Kotlin 的分支表达式</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n\n<p>请问 number 的类型是什么？</p>\n<p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p>\n<p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</p>\n<p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png\"></p>\n<p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p>\n<p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p>\n<p>当然，如果你为 number 添加类型声明，例如：</p>\n<p><strong>代码清单 2：为分支表达式添加类型信息</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number: Number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n\n<p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p>\n<blockquote>\n<p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd\">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p>\n</blockquote>\n<h2 id=\"2-新类型推导算法的推导结果\"><a href=\"#2-新类型推导算法的推导结果\" class=\"headerlink\" title=\"2. 新类型推导算法的推导结果\"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png\"></p>\n<p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p>\n<p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p>\n<p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p>\n<p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> Number.<span class=\"title\">compareTo</span><span class=\"params\">(other: <span class=\"type\">Number</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (number &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$number</span> &gt; 2&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$number</span> &lt;= 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p>\n<h2 id=\"3-交叉类型与联合类型\"><a href=\"#3-交叉类型与联合类型\" class=\"headerlink\" title=\"3. 交叉类型与联合类型\"></a>3. 交叉类型与联合类型</h2><p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png\"></p>\n<p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p>\n<p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p>\n<p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p>\n<p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p>\n<p><strong>代码清单 4：TypeScript 中的联合类型</strong></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    fly(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    layEggs(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    swim(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    layEggs(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\"><span class=\"comment\">// OK，两个类型的公共成员</span></span><br><span class=\"line\">pet.layEggs();</span><br></pre></td></tr></table></figure>\n\n<p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p>\n<p><strong>代码清单 5：Kotlin 的联合类型</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">layEggs</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">layEggs</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> pet = <span class=\"keyword\">if</span>(validation()) <span class=\"keyword\">object</span> : Bird&#123; ... &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">object</span> : Fish&#123; ... &#125;</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p>\n<p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p>\n<h2 id=\"4-为什么不直接支持交叉类型和联合类型呢？\"><a href=\"#4-为什么不直接支持交叉类型和联合类型呢？\" class=\"headerlink\" title=\"4. 为什么不直接支持交叉类型和联合类型呢？\"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p>\n<ol>\n<li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li>\n<li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li>\n</ol>\n<p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 </p>\n</blockquote>","more":"<p>先来看一段代码：</p>\n<p><strong>代码清单 1：Kotlin 的分支表达式</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n\n<p>请问 number 的类型是什么？</p>\n<p>直觉告诉我们，number 的类型应该就是 Number 呀，因为两个分支分别是 Float 和 Double 类型，而 Number 是它俩的父类，因此是 Number 没毛病。</p>\n<p>逻辑上确实如此，不过实际情况就要各种打脸了。你也许想不到，Float 还实现了一个 Comparable<Float> 的接口，而 Double 则实现了 Comparable<Double>，于是 Float 和 Double 应该同样是 Comparable 的子类才对。也就是说 Float 和 Double 有两个父类（接口），那么再想想，number 究竟是什么类型？Comparable 还是 Number？</p>\n<p>都不是。Kotlin 1.3 当中，我们可以通过 IntelliJ 很容易的得到答案：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png\"></p>\n<p><strong><center>图 1：Kotlin 1.3 对分支表达式的类型推导</center></strong></p>\n<p>是不是很吃惊？居然是 Any。因为 Kotlin 编译器在类型推导时遇到这种模棱两可的情况实在不知道如何做出选择，因此干脆不选。</p>\n<p>当然，如果你为 number 添加类型声明，例如：</p>\n<p><strong>代码清单 2：为分支表达式添加类型信息</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> number: Number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br></pre></td></tr></table></figure>\n\n<p>这样 number 的类型就可以确定为 Number 了，Kotlin 编译器也算是松了一口气。</p>\n<blockquote>\n<p>有关这个问题的详细分析，我曾经在两年前写过一篇文章 <a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484051&idx=1&sn=4676580d88e9751df9a5ae192fd8d0da&chksm=e8a05daedfd7d4b8d7b7cc9201f287ba3f3206ddba246266c450c02d821959b99344e4cbf42c&token=482430266&lang=zh_CN#rd\">val b = a?: 0，a 是 Double 类型，那 b 是什么类型？</a>，有兴趣的读者可以去了解下。</p>\n</blockquote>\n<h2 id=\"2-新类型推导算法的推导结果\"><a href=\"#2-新类型推导算法的推导结果\" class=\"headerlink\" title=\"2. 新类型推导算法的推导结果\"></a>2. 新类型推导算法的推导结果</h2><p>那么问题来了，新类型推导算法难道可以自动帮我们选择我们想要的类型嘛？额，说实话，这种情况下编译器并不知道你究竟想要什么类型，于是做出选择那是不可能的事儿了。既然做不出选择，那为什么还要选呢？小孩子才做选择，我当然是都要啊！</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-26-20.png\"></p>\n<p><strong><center>图 2：Kotlin 1.4 对分支表达式的类型推导</center></strong></p>\n<p>这是什么情况？这个类型我没见过啊。确实如此，这样的类型我们也没有办法显式声明出来，只有靠编译器推导才能得到。那么这个 {A &amp; B} 的类型究竟算是什么类型呢？字面意思就是既是 A 类型，又是 B 类型，实际含义也是如此。也就是说，{Comparable{Double &amp; Float} &amp; Number} 这个类型既是 Comparable 类型，又是 Number 类型。</p>\n<p>于是在 Kotlin 1.4 当中，以下代码就成了合法的用法：</p>\n<p><strong>代码清单 3：Kotlin 1.4 中对于分支表达式类型的使用</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> Number.<span class=\"title\">compareTo</span><span class=\"params\">(other: <span class=\"type\">Number</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.toDouble().compareTo(other.toDouble())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> number = <span class=\"keyword\">if</span> (validation()) <span class=\"number\">1F</span> <span class=\"keyword\">else</span> <span class=\"number\">2.0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (number &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$number</span> &gt; 2&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"variable\">$number</span> &lt;= 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在 Kotlin 1.3 当中默认会无法通过编译。</p>\n<h2 id=\"3-交叉类型与联合类型\"><a href=\"#3-交叉类型与联合类型\" class=\"headerlink\" title=\"3. 交叉类型与联合类型\"></a>3. 交叉类型与联合类型</h2><p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-49-34.png\"></p>\n<p><strong><center>图 3：Double 和 Float 的类型关系</center></strong></p>\n<p>两个类型的交叉类型就是两个类型的交集，因此对于类型 A &amp; B，如果我们把 A 和 B 看做集合的话，相当于 A ∩ B。图 3 的含义其实还涉及到另一个概念：联合类型。对于文章开头的分支表达式，它的类型是 Double 或者 Float，即 Double | Float，这个类型就是一个联合类型，从集合的角度来讲实际上就是 Double ∪ Float。通俗的说，交叉类型是“既是 A 也是 B”的关系，联合类型则是“不是 A 就是 B”的关系。</p>\n<p>既然如此，从图上来看，Comparable &amp; Number == Double | Float，因为我们前面讲到过，Double 和 Float 的公共父类（接口）包括 Comparable 和 Number。请注意，Kotlin 在表达联合类型时实际上是取了一个类型的近似值，这个值就是公共父类。</p>\n<p>坦率地讲，Kotlin 当中的联合类型与真正理想的联合类型还是不一样的，我们给出 TypeScript 中的联合类型让大家感受下：</p>\n<p><strong>代码清单 4：TypeScript 中的联合类型</strong></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    fly(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    layEggs(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    swim(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    layEggs(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\"><span class=\"comment\">// OK，两个类型的公共成员</span></span><br><span class=\"line\">pet.layEggs();</span><br></pre></td></tr></table></figure>\n\n<p>虽然 Bird 和 Fish 两个接口没有公共父接口，但 Bird | Fish 却有二者的公共成员 layEggs。如果这段代码放到 Kotlin 当中，结果可想而知：</p>\n<p><strong>代码清单 5：Kotlin 的联合类型</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">layEggs</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">layEggs</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> pet = <span class=\"keyword\">if</span>(validation()) <span class=\"keyword\">object</span> : Bird&#123; ... &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">object</span> : Fish&#123; ... &#125;</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>这里 pet 理论上应该是 Bird | Fish，但 Kotlin 编译器总是会尝试将其类型“退化”成一个当前类型系统可表达的类型，这个退化的方法就是寻找二者的公共父类，即 Any。因此，Kotlin 编译器将分支表达式的类型推导为 Any，pet 自然无法直接访问 layEggs 了，尽管 Bird 和 Fish 都有这个函数。</p>\n<p>按照 Kotlin 语言规范的说法，Kotlin 当中的交叉类型和联合类型都是不能直接声明的，只是会在某些语法现象中产生，例如类型智能转换等等。一旦产生了这样的类型，Kotlin 会采用类型近似、类型退化等手段来找到一个现有类型系统中合适的类型来表达它们。</p>\n<h2 id=\"4-为什么不直接支持交叉类型和联合类型呢？\"><a href=\"#4-为什么不直接支持交叉类型和联合类型呢？\" class=\"headerlink\" title=\"4. 为什么不直接支持交叉类型和联合类型呢？\"></a>4. 为什么不直接支持交叉类型和联合类型呢？</h2><p>其实这个问题已经争论了挺久了。从各方的讨论来看，目前 Kotlin 没有正式引入这样的类型主要有以下原因：</p>\n<ol>\n<li>伪需求。支持引入这个特性的开发者提供的一些 use case 多数情况下可以通过诸如函数重载、泛型约束等特性来实现，有些情况下实际上更应该优化类型设计而不是寄希望于一个更复杂的类型系统。</li>\n<li>存在滥用风险。类型系统复杂一点点，带来的项目代码的复杂度提升可能都会是巨大的。这一点从 Kotlin 对函数类型的支持上就可见一斑，当然不同之处在于函数类型确实是刚需。</li>\n</ol>\n<p>对于这个问题大家怎么看呢？留言说出你的看法吧。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 新版本也有了交叉类型和联合类型？","path":"2020/04/06/kotlin-intersect-type/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-06-16-13-42.png","excerpt":"<blockquote>\n<p>Kotlin 1.4 会默认使用一套新的类型推导算法，类型系统也相比之前更强大了。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-04-05T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-04-05T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","type"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？","keywords":"Kotlin Map","date":"2020-06-08T16:00:00.000Z","description":null,"_content":"\n> Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 \n\n\n\n<!-- more -->\n\n\n\n\n### 1. getOrElse\n\n这个比较简单，我们先来看下它的定义：\n\n```kotlin\ninline fun <K, V> Map<K, V>.getOrElse(\n  key: K, \n  defaultValue: () -> V\n): V = get(key) ?: defaultValue()\n```\n\n如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。\n\n这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：\n\n```kotlin\nval config = HashMap<String, Boolean>()\nval isEnabled = config.getOrElse(\"isEnabled\", { false })\n```\n\n### 2. getOrPut\n\n需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：\n\n我们有一个事件回调接口，不同事件用 eventId 来区分：\n\n```kotlin\ninterface OnEventListener {\n    fun onEvent(eventId: String, data: String)\n}\n```\n\n我们需要提供对事件回调注册的能力：\n\n```kotlin\nval eventListeners = HashMap<String, ArrayList<OnEventListener>>()\n\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    ...\n}\n```\n\n添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：\n\n```kotlin\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    var listenerList = eventListeners[eventId]\n    if (listenerList == null) {\n        listenerList = ArrayList()\n        eventListeners[eventId] = listenerList\n    }\n    listenerList.add(listener)\n}\n```\n\n但这个也太不 Kotlin 了。\n\n好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：\n\n```kotlin\ninline fun <K, V> MutableMap<K, V>.getOrPut(\n  key: K, defaultValue: () -> V\n): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n```\n\n既然如此，我们就可以简化 addOnEventListener 的实现了：\n\n```kotlin\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    eventListeners.getOrPut(eventId, defaultCreator).add(listener)\n}\n```\n\n### 3. 隐式默认值\n\n除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：\n\n```kotlin\nval config = HashMap<String, Boolean>().withDefault { false }\n```\n\n这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 `{ false }` 的求值结果了。\n\n不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：\n\n```kotlin\nval isEnabled = config[\"isEnabled\"] // null\n```\n\n用于此时我们的 config 只是一个空 Map，因此不存在 `isEnabled` 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 `config[\"isEnabled\"]` 或者说等价的 `config.get(\"isEnabled\")` 调用并不会触发默认值的求值。\n\n那我想要获得默认值要怎么做呢？\n\n调用另外的一个扩展方法：\n\n```kotlin\nval isEnabled = config.getValue(\"isEnabled\") // false\n```\n\n### 4. 默认值的提供方式\n\n前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？\n\n其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。\n\n还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。\n\n### 5. 小结\n\n好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-map-default.md","raw":"---\ntitle:  Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？ \nkeywords: Kotlin Map \ndate: 2020/06/09\ndescription: \ntags: \n    - kotlin\n    - map \n---\n\n> Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 \n\n\n\n<!-- more -->\n\n\n\n\n### 1. getOrElse\n\n这个比较简单，我们先来看下它的定义：\n\n```kotlin\ninline fun <K, V> Map<K, V>.getOrElse(\n  key: K, \n  defaultValue: () -> V\n): V = get(key) ?: defaultValue()\n```\n\n如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。\n\n这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：\n\n```kotlin\nval config = HashMap<String, Boolean>()\nval isEnabled = config.getOrElse(\"isEnabled\", { false })\n```\n\n### 2. getOrPut\n\n需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：\n\n我们有一个事件回调接口，不同事件用 eventId 来区分：\n\n```kotlin\ninterface OnEventListener {\n    fun onEvent(eventId: String, data: String)\n}\n```\n\n我们需要提供对事件回调注册的能力：\n\n```kotlin\nval eventListeners = HashMap<String, ArrayList<OnEventListener>>()\n\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    ...\n}\n```\n\n添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：\n\n```kotlin\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    var listenerList = eventListeners[eventId]\n    if (listenerList == null) {\n        listenerList = ArrayList()\n        eventListeners[eventId] = listenerList\n    }\n    listenerList.add(listener)\n}\n```\n\n但这个也太不 Kotlin 了。\n\n好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：\n\n```kotlin\ninline fun <K, V> MutableMap<K, V>.getOrPut(\n  key: K, defaultValue: () -> V\n): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n```\n\n既然如此，我们就可以简化 addOnEventListener 的实现了：\n\n```kotlin\nfun addOnEventListener(eventId: String, listener: OnEventListener) {\n    eventListeners.getOrPut(eventId, defaultCreator).add(listener)\n}\n```\n\n### 3. 隐式默认值\n\n除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：\n\n```kotlin\nval config = HashMap<String, Boolean>().withDefault { false }\n```\n\n这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 `{ false }` 的求值结果了。\n\n不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：\n\n```kotlin\nval isEnabled = config[\"isEnabled\"] // null\n```\n\n用于此时我们的 config 只是一个空 Map，因此不存在 `isEnabled` 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 `config[\"isEnabled\"]` 或者说等价的 `config.get(\"isEnabled\")` 调用并不会触发默认值的求值。\n\n那我想要获得默认值要怎么做呢？\n\n调用另外的一个扩展方法：\n\n```kotlin\nval isEnabled = config.getValue(\"isEnabled\") // false\n```\n\n### 4. 默认值的提供方式\n\n前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？\n\n其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。\n\n还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。\n\n### 5. 小结\n\n好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-map-default","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003i001wlduzapwp12tw","content":"<blockquote>\n<p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h3 id=\"1-getOrElse\"><a href=\"#1-getOrElse\" class=\"headerlink\" title=\"1. getOrElse\"></a>1. getOrElse</h3><p>这个比较简单，我们先来看下它的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;K, V&gt;</span> Map<span class=\"type\">&lt;K, V&gt;</span>.<span class=\"title\">getOrElse</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"type\">K</span>, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  defaultValue: () -&gt; <span class=\"type\">V</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: V = <span class=\"keyword\">get</span>(key) ?: defaultValue()</span><br></pre></td></tr></table></figure>\n\n<p>如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。</p>\n<p>这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> config = HashMap&lt;String, <span class=\"built_in\">Boolean</span>&gt;()</span><br><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config.getOrElse(<span class=\"string\">&quot;isEnabled&quot;</span>, &#123; <span class=\"literal\">false</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-getOrPut\"><a href=\"#2-getOrPut\" class=\"headerlink\" title=\"2. getOrPut\"></a>2. getOrPut</h3><p>需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：</p>\n<p>我们有一个事件回调接口，不同事件用 eventId 来区分：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnEventListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onEvent</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, <span class=\"keyword\">data</span>: <span class=\"type\">String</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要提供对事件回调注册的能力：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> eventListeners = HashMap&lt;String, ArrayList&lt;OnEventListener&gt;&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> listenerList = eventListeners[eventId]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listenerList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        listenerList = ArrayList()</span><br><span class=\"line\">        eventListeners[eventId] = listenerList</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listenerList.add(listener)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这个也太不 Kotlin 了。</p>\n<p>好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;K, V&gt;</span> MutableMap<span class=\"type\">&lt;K, V&gt;</span>.<span class=\"title\">getOrPut</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"type\">K</span>, defaultValue: () -&gt; <span class=\"type\">V</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: V &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = <span class=\"keyword\">get</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> answer = defaultValue()</span><br><span class=\"line\">        put(key, answer)</span><br><span class=\"line\">        answer</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然如此，我们就可以简化 addOnEventListener 的实现了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    eventListeners.getOrPut(eventId, defaultCreator).add(listener)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-隐式默认值\"><a href=\"#3-隐式默认值\" class=\"headerlink\" title=\"3. 隐式默认值\"></a>3. 隐式默认值</h3><p>除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> config = HashMap&lt;String, <span class=\"built_in\">Boolean</span>&gt;().withDefault &#123; <span class=\"literal\">false</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 <code>&#123; false &#125;</code> 的求值结果了。</p>\n<p>不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config[<span class=\"string\">&quot;isEnabled&quot;</span>] <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>用于此时我们的 config 只是一个空 Map，因此不存在 <code>isEnabled</code> 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 <code>config[&quot;isEnabled&quot;]</code> 或者说等价的 <code>config.get(&quot;isEnabled&quot;)</code> 调用并不会触发默认值的求值。</p>\n<p>那我想要获得默认值要怎么做呢？</p>\n<p>调用另外的一个扩展方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config.getValue(<span class=\"string\">&quot;isEnabled&quot;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-默认值的提供方式\"><a href=\"#4-默认值的提供方式\" class=\"headerlink\" title=\"4. 默认值的提供方式\"></a>4. 默认值的提供方式</h3><p>前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？</p>\n<p>其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。</p>\n<p>还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。</p>\n<h3 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h3><p>好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 </p>\n</blockquote>","more":"<h3 id=\"1-getOrElse\"><a href=\"#1-getOrElse\" class=\"headerlink\" title=\"1. getOrElse\"></a>1. getOrElse</h3><p>这个比较简单，我们先来看下它的定义：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;K, V&gt;</span> Map<span class=\"type\">&lt;K, V&gt;</span>.<span class=\"title\">getOrElse</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"type\">K</span>, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  defaultValue: () -&gt; <span class=\"type\">V</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: V = <span class=\"keyword\">get</span>(key) ?: defaultValue()</span><br></pre></td></tr></table></figure>\n\n<p>如果没有元素 key，那么就返回默认值，默认值通过对参数中的 defaultValue 进行求值得到。当然，如果不需要默认值，那么这个求值过程也是不会发生的。</p>\n<p>这种情况比较适合空值的语义与默认值相同的情况，例如我用 Map 中的值做为某种配置：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> config = HashMap&lt;String, <span class=\"built_in\">Boolean</span>&gt;()</span><br><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config.getOrElse(<span class=\"string\">&quot;isEnabled&quot;</span>, &#123; <span class=\"literal\">false</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-getOrPut\"><a href=\"#2-getOrPut\" class=\"headerlink\" title=\"2. getOrPut\"></a>2. getOrPut</h3><p>需要注意的是，getOrElse 的调用过程中 Map 没有被修改，即默认值并没有真正成为 Map 的元素。如果我们有下面的需求，那就要考虑使用 getOrPut 了：</p>\n<p>我们有一个事件回调接口，不同事件用 eventId 来区分：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnEventListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onEvent</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, <span class=\"keyword\">data</span>: <span class=\"type\">String</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要提供对事件回调注册的能力：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> eventListeners = HashMap&lt;String, ArrayList&lt;OnEventListener&gt;&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加 listener 的思路也很简单，先看看 eventListeners 当中有没有对应的 eventId 的事件回调 list，如果有，直接添加；如果没有，先构造一个 list 实例，然后再添加。所以最为朴素的实现就是下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> listenerList = eventListeners[eventId]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listenerList == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        listenerList = ArrayList()</span><br><span class=\"line\">        eventListeners[eventId] = listenerList</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listenerList.add(listener)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这个也太不 Kotlin 了。</p>\n<p>好在我们有 getOrPut，它提供了在 Map 中不存在对应的 Key 时返回默认值并将默认值添加到 Map 中的能力，它的实现非常直接：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;K, V&gt;</span> MutableMap<span class=\"type\">&lt;K, V&gt;</span>.<span class=\"title\">getOrPut</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: <span class=\"type\">K</span>, defaultValue: () -&gt; <span class=\"type\">V</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>: V &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = <span class=\"keyword\">get</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> answer = defaultValue()</span><br><span class=\"line\">        put(key, answer)</span><br><span class=\"line\">        answer</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然如此，我们就可以简化 addOnEventListener 的实现了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addOnEventListener</span><span class=\"params\">(eventId: <span class=\"type\">String</span>, listener: <span class=\"type\">OnEventListener</span>)</span></span> &#123;</span><br><span class=\"line\">    eventListeners.getOrPut(eventId, defaultCreator).add(listener)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-隐式默认值\"><a href=\"#3-隐式默认值\" class=\"headerlink\" title=\"3. 隐式默认值\"></a>3. 隐式默认值</h3><p>除了在获取时才能确定的默认值以外，还有一个在 Map 定义的时候就可以指定的方式，即：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> config = HashMap&lt;String, <span class=\"built_in\">Boolean</span>&gt;().withDefault &#123; <span class=\"literal\">false</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个也被称为隐式默认值，它的效果与 getOrElse 一致，在获取某一个不存在的 Key 时，直接返回默认值表达式的求值结果，在上面的例子当中就是 <code>&#123; false &#125;</code> 的求值结果了。</p>\n<p>不过如果大家用过这个功能的话，应该一开始都会感到比较疑惑，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config[<span class=\"string\">&quot;isEnabled&quot;</span>] <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>用于此时我们的 config 只是一个空 Map，因此不存在 <code>isEnabled</code> 这个 Key，按照我们的直觉，这时应该触发默认值的求值过程并返回 false 对吧？但实际上不是这样的，标准库 API 的设计者为了确保对应的实现复合 Map 的接口定义，在我们调用 Map 接口的方法时，行为与普通的 Map 保持一致，因此 <code>config[&quot;isEnabled&quot;]</code> 或者说等价的 <code>config.get(&quot;isEnabled&quot;)</code> 调用并不会触发默认值的求值。</p>\n<p>那我想要获得默认值要怎么做呢？</p>\n<p>调用另外的一个扩展方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> isEnabled = config.getValue(<span class=\"string\">&quot;isEnabled&quot;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-默认值的提供方式\"><a href=\"#4-默认值的提供方式\" class=\"headerlink\" title=\"4. 默认值的提供方式\"></a>4. 默认值的提供方式</h3><p>前面提到的三种方式中，默认值都是通过一个函数提供的，这样做有什么好处呢？</p>\n<p>其实如果 Map 的 Value 类型是不可变的数据类型，那么直接使用一个默认值即可，例如 Boolean、String 这样的基本类型。但对于可变的类型，例如前面例子中的 ArrayList，提供统一的默认值显然是行不通的，对象被不同的 Key 共享必然会造成逻辑的混乱。</p>\n<p>还有一个原因，函数可以共享，只需要创建一个统一的对象，每次使用的时候复用即可，默认值本身并不总是需要，自然也并不总是需要创建出来，因此这里采用延迟计算还可以减少对象创建的成本。</p>\n<h3 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h3><p>好啦，这一篇文章没有什么有难度的地方，源码大家一看就明白，使用时只要注意其中的细节即可。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 为 Map 提供的那些默认值相关的扩展，你用过吗？","path":"2020/06/09/kotlin-map-default/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>Map 的 Value 类型是一个可空类型，Kotlin 早就想好了怎么帮你优雅地面对它。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-06-08T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-06-08T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","map"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构","keywords":"Kotlin Kotlin-Native Jni 跨平台","date":"2020-04-18T16:00:00.000Z","description":null,"_content":"\n> 前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 \n\n\n\n<!-- more -->\n\n\n\n\n* [用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏](https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/)\n* [Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法](https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/)\n\n之前两篇文章已经介绍了如何通过 `CName` 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 `JNI_OnLoad` 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。\n\n前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。\n\n接下来我们就把之前的工程改造一下，工程源码见：[hello-kni](https://github.com/enbandari/hello-kni)。\n\n首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png)\n\n接着，在 settings.gradle.kts 当中引入这个 Module：\n\n```kotlin\ninclude(\":app\", \":nativeLib\")\n```\n\n好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：\n\n```kotlin\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.71\"\n    id(\"com.android.library\")\n}\n```\n\n这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。\n\n所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：\n\n```kotlin\nval jniLibDir = File(project.buildDir, arrayOf(\"generated\", \"jniLibs\").joinToString(File.separator))\n\nandroid {\n    ...\n    sourceSets {\n        val main by getting {\n            jniLibs.srcDir(jniLibDir)\n        }\n    }\n}\n```\n\n我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：\n\n```kotlin\nkotlin {\n    androidNativeArm32 {\n        binaries {\n            sharedLib(\"knlib\") {\n                if(buildType == NativeBuildType.RELEASE){\n                    linkTask.doLast {\n                        copy {\n                            from(outputFile)\n                            into(File(jniLibDir, \"armeabi-v7a\"))\n                        }\n                    }\n\n                    afterEvaluate {\n                        val preReleaseBuild by tasks.getting\n                        preReleaseBuild.dependsOn(linkTask)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nkotlin mpp 的工程配置非常清晰：\n\n1. 内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。\n2. 第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。\n3. 我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。\n4. 为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。\n\n工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png)\n\n另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。\n\n至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：\n\n```kotlin\nimplementation(project(\":nativeLib\"))\n```\n\n直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-native-android-mpp.md","raw":"---\ntitle:  Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构 \nkeywords: Kotlin Kotlin-Native Jni 跨平台 \ndate: 2020/04/19\ndescription: \ntags: \n    - kotlin\n    - kotlin-native\n    - mpp \n---\n\n> 前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 \n\n\n\n<!-- more -->\n\n\n\n\n* [用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏](https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/)\n* [Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法](https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/)\n\n之前两篇文章已经介绍了如何通过 `CName` 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 `JNI_OnLoad` 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。\n\n前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。\n\n接下来我们就把之前的工程改造一下，工程源码见：[hello-kni](https://github.com/enbandari/hello-kni)。\n\n首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png)\n\n接着，在 settings.gradle.kts 当中引入这个 Module：\n\n```kotlin\ninclude(\":app\", \":nativeLib\")\n```\n\n好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：\n\n```kotlin\nplugins {\n    kotlin(\"multiplatform\") version \"1.3.71\"\n    id(\"com.android.library\")\n}\n```\n\n这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。\n\n所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：\n\n```kotlin\nval jniLibDir = File(project.buildDir, arrayOf(\"generated\", \"jniLibs\").joinToString(File.separator))\n\nandroid {\n    ...\n    sourceSets {\n        val main by getting {\n            jniLibs.srcDir(jniLibDir)\n        }\n    }\n}\n```\n\n我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：\n\n```kotlin\nkotlin {\n    androidNativeArm32 {\n        binaries {\n            sharedLib(\"knlib\") {\n                if(buildType == NativeBuildType.RELEASE){\n                    linkTask.doLast {\n                        copy {\n                            from(outputFile)\n                            into(File(jniLibDir, \"armeabi-v7a\"))\n                        }\n                    }\n\n                    afterEvaluate {\n                        val preReleaseBuild by tasks.getting\n                        preReleaseBuild.dependsOn(linkTask)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nkotlin mpp 的工程配置非常清晰：\n\n1. 内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。\n2. 第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。\n3. 我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。\n4. 为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。\n\n工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png)\n\n另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。\n\n至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：\n\n```kotlin\nimplementation(project(\":nativeLib\"))\n```\n\n直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-native-android-mpp","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003i001ylduz0f9xews0","content":"<blockquote>\n<p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<ul>\n<li><a href=\"https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/\">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li>\n<li><a href=\"https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/\">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li>\n</ul>\n<p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p>\n<p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p>\n<p>接下来我们就把之前的工程改造一下，工程源码见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a>。</p>\n<p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png\"></p>\n<p>接着，在 settings.gradle.kts 当中引入这个 Module：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include(<span class=\"string\">&quot;:app&quot;</span>, <span class=\"string\">&quot;:nativeLib&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    kotlin(<span class=\"string\">&quot;multiplatform&quot;</span>) version <span class=\"string\">&quot;1.3.71&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.library&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p>\n<p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class=\"string\">&quot;generated&quot;</span>, <span class=\"string\">&quot;jniLibs&quot;</span>).joinToString(File.separator))</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> main <span class=\"keyword\">by</span> getting &#123;</span><br><span class=\"line\">            jniLibs.srcDir(jniLibDir)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin &#123;</span><br><span class=\"line\">    androidNativeArm32 &#123;</span><br><span class=\"line\">        binaries &#123;</span><br><span class=\"line\">            sharedLib(<span class=\"string\">&quot;knlib&quot;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class=\"line\">                    linkTask.doLast &#123;</span><br><span class=\"line\">                        copy &#123;</span><br><span class=\"line\">                            from(outputFile)</span><br><span class=\"line\">                            into(File(jniLibDir, <span class=\"string\">&quot;armeabi-v7a&quot;</span>))</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    afterEvaluate &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">val</span> preReleaseBuild <span class=\"keyword\">by</span> tasks.getting</span><br><span class=\"line\">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kotlin mpp 的工程配置非常清晰：</p>\n<ol>\n<li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li>\n<li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li>\n<li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li>\n<li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li>\n</ol>\n<p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png\"></p>\n<p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p>\n<p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(project(<span class=\"string\">&quot;:nativeLib&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 </p>\n</blockquote>","more":"<ul>\n<li><a href=\"https://www.bennyhuo.com/2018/12/17/kotlin_native_jni/\">用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏</a></li>\n<li><a href=\"https://www.bennyhuo.com/2018/12/31/kotlin-native-jni-dynamic/\">Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法</a></li>\n</ul>\n<p>之前两篇文章已经介绍了如何通过 <code>CName</code> 注解来限定 Kotlin-Native 代码编出来的动态链接库的符号名，以实现与 Java 的 native 方法的绑定，也介绍了如何使用 <code>JNI_OnLoad</code> 来动态注册 native 方法来实现绑定。换句话说，如果你想要知道如何用 Kotlin-Native 写 Android 的 Jni 的 Native 层代码，那么前面的两篇文章里面就有答案。</p>\n<p>前文撰写的时候 Kotlin-Native 的构建插件尚未稳定，当时除了 Multiplatform Project（以下简称 mpp） 的 Gradle 插件以外还有一个单独的 native 的插件，用法也不是特别统一，现在后者已经被废弃，因此我们只需要用 mpp 的插件来构建 Kotlin-Native 的工程即可。顺带提一句，现在使用 Kotlin DSL 来编写 Gradle 脚本体验已经比之前强多了，建议大家把 IDE 的 Kotlin 插件升级到 1.3.70 以上版本来体验。</p>\n<p>接下来我们就把之前的工程改造一下，工程源码见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a>。</p>\n<p>首先我们创建一个 Module，你可以选择使用 IntelliJ 的 new module 方式，选择创建一个 Android library，当然也可以自己创建一个目录，然后再创建一个 build.gradle.kts 文件，就像这样：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png\"></p>\n<p>接着，在 settings.gradle.kts 当中引入这个 Module：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include(<span class=\"string\">&quot;:app&quot;</span>, <span class=\"string\">&quot;:nativeLib&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>好，关键来了，剩下的主要就是修改 build.gradle.kts。我们先来添加 mpp 的 Gradle 插件：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    kotlin(<span class=\"string\">&quot;multiplatform&quot;</span>) version <span class=\"string\">&quot;1.3.71&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.library&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到我们还添加了 Android 的 library 插件，原因是我们想要把 Kotlin-Native 编译出来的 so 打进一个 aar 里面作为 Android 的依赖提供给 app 工程。</p>\n<p>所以构建出来的 so 文件我们需要引入到 aar 的编译流程中，可以将这个 so 文件复制到一个路径，我们把这个路径添加为 Android 的 jniLibs 路径即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> jniLibDir = File(project.buildDir, arrayOf(<span class=\"string\">&quot;generated&quot;</span>, <span class=\"string\">&quot;jniLibs&quot;</span>).joinToString(File.separator))</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> main <span class=\"keyword\">by</span> getting &#123;</span><br><span class=\"line\">            jniLibs.srcDir(jniLibDir)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 build 目录下选了 generated/jniLibs 作为 jniLibs 目录添加到了 aar 的编译流程中。接下来我们只需要完成 so 文件的复制即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlin &#123;</span><br><span class=\"line\">    androidNativeArm32 &#123;</span><br><span class=\"line\">        binaries &#123;</span><br><span class=\"line\">            sharedLib(<span class=\"string\">&quot;knlib&quot;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(buildType == NativeBuildType.RELEASE)&#123;</span><br><span class=\"line\">                    linkTask.doLast &#123;</span><br><span class=\"line\">                        copy &#123;</span><br><span class=\"line\">                            from(outputFile)</span><br><span class=\"line\">                            into(File(jniLibDir, <span class=\"string\">&quot;armeabi-v7a&quot;</span>))</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    afterEvaluate &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">val</span> preReleaseBuild <span class=\"keyword\">by</span> tasks.getting</span><br><span class=\"line\">                        preReleaseBuild.dependsOn(linkTask)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kotlin mpp 的工程配置非常清晰：</p>\n<ol>\n<li>内部的第一层是选择目标平台，这里选择的是 androidNativeArm32，当然如果你想要构建 iOS 平台的，也可以选择 iosArm64 等等。</li>\n<li>第二层是 binaries 就是定义产出物，其内部的 sharedLib 表示产出物是共享库（shared object，so），当然如果希望编译出可执行文件，就替换成 executable。sharedLib 有两个参数，第一个是库的名字，我们这里与原来保持了一致，将库的名字指定为 knlib，这样编译出来的 so 文件就是 libknlib.so。</li>\n<li>我们通过 buildType 来选择将 RELEASE 的产出物复制到指定路径（也就是刚才定义的 jniLibDir），如果做得更完善的话也可以分别对 DEBUG/RELEASE 进行处理。</li>\n<li>为 aar 的构建流程中的 preReleaseBuild 任务添加依赖，这样在 assembleRelease 执行时可以触发对 Kotlin-Native 代码的编译。当然，这里也可以选择其他的任务进行依赖，只要能够在 assemble 时触发编译即可。</li>\n</ol>\n<p>工程配置搞定之后，我们还需要把源码添加进来。androidNativeArm32 的源码路径默认为 src/androidNativeArm32Main/kotlin，因此我们把之前已经写好的 Kotlin-Native 的源文件添加进去即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-18-01-24.png\"></p>\n<p>另外作为 Android Library 工程，manifest 文件当然是必须的，不过里面也不需要有什么特别的配置。</p>\n<p>至此，使用 Kotlin-Native 编写 Jni 的工程改造就完成了，在 app 工程中添加依赖：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation(project(<span class=\"string\">&quot;:nativeLib&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>直接编译运行 app 工程即可运行，再也不用使用命令行编译啦。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构","path":"2020/04/19/kotlin-native-android-mpp/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-04-19-08-37-45.png","excerpt":"<blockquote>\n<p>前不久有个兄弟问有没有可能把之前 Native 写 Jni 的工程改造成 Gradle 的。正好借此机会把之前的工程整理得更完整一些。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-04-18T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-04-18T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","kotlin-native","mpp"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？","keywords":"Kotlin-Native","date":"2020-07-14T16:00:00.000Z","description":null,"_content":"\n> 一直想写点儿 Kotlin-Native 相关的话题，今天开始~ \n\n\n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png)\n\n**<center>官方题图：Kotlin-Native 的世界</center>**\n\nKotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png)\n\n**<center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center>**\n\n说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？\n\n 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。\n \n 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png)\n\n**<center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center>**\n\n就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png)\n\n**<center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center>**\n\n那 Kotlin-Native 就这么凉了？\n\n据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。\n\n不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）\n\n这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。\n\n当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。\n\n## 为什么我们需要了解下 Kotlin-Native\n\n### 零成本多平台抽象\n\n前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png)\n\n原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png)\n\n**<center>Kotlin 在 Android & iOS 上共享逻辑</center>**\n\n用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：[moko-widgets](https://github.com/icerockdev/moko-widgets)。\n\n官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。\n\n你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。\n\n不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：[pw.binom.io](https://github.com/caffeine-mgn/pw.binom.io)，使用这个框架可以在它支持的所有平台上写出下面的代码：\n\n```kotlin\nfun main(args: Array<String>) {\n    val data = \"Simple Text\".asUTF8ByteArray()\n\n    val file = File(\"Simple File\")\n    FileOutputStream(file, false).use {\n        it.write(data, 0, data.size)\n        it.flush()\n    }\n\n    println(\"Write data: \\\"${data.asUTF8String()}\\\"\")\n\n    val out = ByteArrayOutputStream()\n    FileInputStream(file).use {\n        it.copyTo(out)\n    }\n\n    println(\"Read data: \\\"${out.toByteArray().asUTF8String()}\\\"\")\n}\n```\n\n这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。\n\n### 多平台特性的持续优化\n\n1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。\n\n多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。\n\n这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png)\n\n**<center>结构化多平台特性示意图</center>**\n\n1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。\n\n多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。\n\n### “新基建”的时代背景\n\n前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png)\n\n**<center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center>**\n\n过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。\n\n说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？\n\n现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。\n\n而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。\n\n## 我们该怎么学习 Kotlin-Native 呢？\n\n先了解下 Kotlin-Native 需要的背景知识。\n\n1. 扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。\n2. C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。\n\n有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。\n\n接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。\n\n或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。\n\n说了这么多，我后面的文章大概会写点儿什么内容呢？\n\n1. Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。\n2. Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。\n3. Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。\n4. 研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。\n5. 协程在 Kotlin-Native 上对于并发的支持。\n6. Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。\n\n其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。\n\n## 小结\n\n这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-native-introduction.md","raw":"---\ntitle:  闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？ \nkeywords: Kotlin-Native \ndate: 2020/07/15\ndescription: \ntags: \n    - kotlin\n    - native \n---\n\n> 一直想写点儿 Kotlin-Native 相关的话题，今天开始~ \n\n\n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png)\n\n**<center>官方题图：Kotlin-Native 的世界</center>**\n\nKotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png)\n\n**<center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center>**\n\n说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？\n\n 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。\n \n 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png)\n\n**<center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center>**\n\n就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png)\n\n**<center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center>**\n\n那 Kotlin-Native 就这么凉了？\n\n据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。\n\n不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）\n\n这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。\n\n当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。\n\n## 为什么我们需要了解下 Kotlin-Native\n\n### 零成本多平台抽象\n\n前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png)\n\n原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png)\n\n**<center>Kotlin 在 Android & iOS 上共享逻辑</center>**\n\n用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：[moko-widgets](https://github.com/icerockdev/moko-widgets)。\n\n官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。\n\n你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。\n\n不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：[pw.binom.io](https://github.com/caffeine-mgn/pw.binom.io)，使用这个框架可以在它支持的所有平台上写出下面的代码：\n\n```kotlin\nfun main(args: Array<String>) {\n    val data = \"Simple Text\".asUTF8ByteArray()\n\n    val file = File(\"Simple File\")\n    FileOutputStream(file, false).use {\n        it.write(data, 0, data.size)\n        it.flush()\n    }\n\n    println(\"Write data: \\\"${data.asUTF8String()}\\\"\")\n\n    val out = ByteArrayOutputStream()\n    FileInputStream(file).use {\n        it.copyTo(out)\n    }\n\n    println(\"Read data: \\\"${out.toByteArray().asUTF8String()}\\\"\")\n}\n```\n\n这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。\n\n### 多平台特性的持续优化\n\n1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。\n\n多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。\n\n这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png)\n\n**<center>结构化多平台特性示意图</center>**\n\n1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。\n\n多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。\n\n### “新基建”的时代背景\n\n前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png)\n\n**<center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center>**\n\n过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。\n\n说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？\n\n现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。\n\n而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。\n\n## 我们该怎么学习 Kotlin-Native 呢？\n\n先了解下 Kotlin-Native 需要的背景知识。\n\n1. 扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。\n2. C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。\n\n有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。\n\n接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。\n\n或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。\n\n说了这么多，我后面的文章大概会写点儿什么内容呢？\n\n1. Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。\n2. Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。\n3. Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。\n4. 研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。\n5. 协程在 Kotlin-Native 上对于并发的支持。\n6. Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。\n\n其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。\n\n## 小结\n\n这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-native-introduction","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003j0021lduzdhxu038t","content":"<blockquote>\n<p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~ </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png\"></p>\n<p><strong><center>官方题图：Kotlin-Native 的世界</center></strong></p>\n<p>Kotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png\"></p>\n<p><strong><center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center></strong></p>\n<p>说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？</p>\n<p> 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。</p>\n<p> 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png\"></p>\n<p><strong><center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center></strong></p>\n<p>就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png\"></p>\n<p><strong><center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center></strong></p>\n<p>那 Kotlin-Native 就这么凉了？</p>\n<p>据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。</p>\n<p>不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）</p>\n<p>这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。</p>\n<p>当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。</p>\n<h2 id=\"为什么我们需要了解下-Kotlin-Native\"><a href=\"#为什么我们需要了解下-Kotlin-Native\" class=\"headerlink\" title=\"为什么我们需要了解下 Kotlin-Native\"></a>为什么我们需要了解下 Kotlin-Native</h2><h3 id=\"零成本多平台抽象\"><a href=\"#零成本多平台抽象\" class=\"headerlink\" title=\"零成本多平台抽象\"></a>零成本多平台抽象</h3><p>前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png\"></p>\n<p>原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png\"></p>\n<p><strong><center>Kotlin 在 Android &amp; iOS 上共享逻辑</center></strong></p>\n<p>用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：<a href=\"https://github.com/icerockdev/moko-widgets\">moko-widgets</a>。</p>\n<p>官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。</p>\n<p>你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。</p>\n<p>不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：<a href=\"https://github.com/caffeine-mgn/pw.binom.io\">pw.binom.io</a>，使用这个框架可以在它支持的所有平台上写出下面的代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = <span class=\"string\">&quot;Simple Text&quot;</span>.asUTF8ByteArray()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> file = File(<span class=\"string\">&quot;Simple File&quot;</span>)</span><br><span class=\"line\">    FileOutputStream(file, <span class=\"literal\">false</span>).use &#123;</span><br><span class=\"line\">        it.write(<span class=\"keyword\">data</span>, <span class=\"number\">0</span>, <span class=\"keyword\">data</span>.size)</span><br><span class=\"line\">        it.flush()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;Write data: \\&quot;<span class=\"subst\">$&#123;data.asUTF8String()&#125;</span>\\&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">out</span> = ByteArrayOutputStream()</span><br><span class=\"line\">    FileInputStream(file).use &#123;</span><br><span class=\"line\">        it.copyTo(<span class=\"keyword\">out</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;Read data: \\&quot;<span class=\"subst\">$&#123;out.toByteArray().asUTF8String()&#125;</span>\\&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。</p>\n<h3 id=\"多平台特性的持续优化\"><a href=\"#多平台特性的持续优化\" class=\"headerlink\" title=\"多平台特性的持续优化\"></a>多平台特性的持续优化</h3><p>1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。</p>\n<p>多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。</p>\n<p>这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png\"></p>\n<p><strong><center>结构化多平台特性示意图</center></strong></p>\n<p>1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。</p>\n<p>多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。</p>\n<h3 id=\"“新基建”的时代背景\"><a href=\"#“新基建”的时代背景\" class=\"headerlink\" title=\"“新基建”的时代背景\"></a>“新基建”的时代背景</h3><p>前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png\"></p>\n<p><strong><center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center></strong></p>\n<p>过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。</p>\n<p>说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？</p>\n<p>现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。</p>\n<p>而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。</p>\n<h2 id=\"我们该怎么学习-Kotlin-Native-呢？\"><a href=\"#我们该怎么学习-Kotlin-Native-呢？\" class=\"headerlink\" title=\"我们该怎么学习 Kotlin-Native 呢？\"></a>我们该怎么学习 Kotlin-Native 呢？</h2><p>先了解下 Kotlin-Native 需要的背景知识。</p>\n<ol>\n<li>扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。</li>\n<li>C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。</li>\n</ol>\n<p>有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。</p>\n<p>接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。</p>\n<p>或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。</p>\n<p>说了这么多，我后面的文章大概会写点儿什么内容呢？</p>\n<ol>\n<li>Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。</li>\n<li>Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。</li>\n<li>Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。</li>\n<li>研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。</li>\n<li>协程在 Kotlin-Native 上对于并发的支持。</li>\n<li>Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。</li>\n</ol>\n<p>其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~ </p>\n</blockquote>","more":"<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png\"></p>\n<p><strong><center>官方题图：Kotlin-Native 的世界</center></strong></p>\n<p>Kotlin-Native 的定位略显尴尬，为什么这么说呢？ 因为现在的编程语言实在太多了，新语言出来必然要解决现有某个语言的痛点，这样才能快速切入该语言所覆盖的领域。Kotlin 也是这样在当年崭露头角的，要不是 Android 上没有很好的替代语言，估计 Kotlin 也不会这么快进入大家的视野。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-44-05.png\"></p>\n<p><strong><center>2017 年 Google IO 大会宣布 Kotlin 称为 Android 一级开发语言</center></strong></p>\n<p>说到这里问题就来了， Kotlin-Native 的目标用户到底是谁呢？</p>\n<p> 编译成机器码可以直接在原生环境中运行，我首先能想到的自然是 C 语言。可真的是要去替代 C 吗？显然不可能，毕竟没有 Go 跑得快，用 Go 来替代 C 语言似乎更说得过去。</p>\n<p> 当然有专家尝试用 Go 写了个操作系统发现 Go 的 GC 时间的不确定性会给系统的运行带来一些问题。那没关系啊，对于实时性要求高的场景可以换 Rust 嘛，至少微软已经决定要这么做了，Rust 可以精准控制内存的管理，这一点到现在可能还真没有哪一门语言与之媲美，也难怪它最近几年这么火。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-17-42-11.png\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-47-36.png\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-18-48-03.png\"></p>\n<p><strong><center>2020.07 TIOBE 编程语言排名：C:1，Go:12，Rust:18，Kotlin:27</center></strong></p>\n<p>就算将来 Kotlin-Native 在性能上也优化到 Go 和 Rust 的水平，考虑到它的 Java 背景， C 和 C++ 的程序员可能也不太愿意接受这样一个“外来户”。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-49-01.png\"></p>\n<p><strong><center>Java 跟 C++ 的火拼现场，PHP 或成最大受害者</center></strong></p>\n<p>那 Kotlin-Native 就这么凉了？</p>\n<p>据我观察它的目标用户群体至少应该不是 Java 开发者，因为 Java 开发者只有在写 JNI 的时候才会有 Native 代码开发的需要，而 Kotlin-Native 做了 C-interop 就去做 Objective-C 的 interop，很多人开 issue 问官方要不要搞一个简化 JNI 调用的功能，官方的答复竟然是“为啥不直接在 Java 虚拟机上写 Kotlin 呢？” 。</p>\n<p>不过说到这儿似乎官方的意图很明显了，就是要去拉拢 iOS 的开发了，但高傲的 iOS 开发者们会这么轻易被收买吗？Hmmm，我突然想到了之前跟某位大哥聊天，他说搞 Flutter 的基本上都是 Android 转的，所以。。Kotlin-Native 的实际目标用户群体还是 Android 开发者，只不过是在他们的老板裁掉同组的 iOS 开发之后或者。。。（啊，我是不是说太多了！）</p>\n<p>这么说来接下来我写的这系列 Kotlin-Native 的文章的目标用户还是 Android 开发者为主的 Kotlin 开发者。</p>\n<p>当我跟几个小伙伴说了我的下一步的想法，《Kotlin 编程实践》的译者禹昂就打趣到：“你的协程书还没看完呢，跟不上了啊。” 没事儿没事儿，Kotlin 的版本更新已经算是很慢的了，我也会尽量让自己的文章更新的慢一点儿（似乎找到了一个很好的拖更的理由！）。</p>\n<h2 id=\"为什么我们需要了解下-Kotlin-Native\"><a href=\"#为什么我们需要了解下-Kotlin-Native\" class=\"headerlink\" title=\"为什么我们需要了解下 Kotlin-Native\"></a>为什么我们需要了解下 Kotlin-Native</h2><h3 id=\"零成本多平台抽象\"><a href=\"#零成本多平台抽象\" class=\"headerlink\" title=\"零成本多平台抽象\"></a>零成本多平台抽象</h3><p>前面我们的分析大致可以得出结论：Kotlin-Native 似乎也就是在 iOS 上有些前途。然而现实可能更残酷，因为可能大多数 App 根本没有什么逻辑，用 Flutter 跨平台岂不是更好，为什么还要搞 Kotlin-Native 呢？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-15-10-16-22.png\"></p>\n<p>原因也很简单，与 Flutter 的定位不同，Kotlin-Native 给予了我们开发者更多的可能。Kotlin 的设计思路其实一直都是这样，给开发者或者社区留足发挥的空间，做好语言应该做的事儿。类似的还有协程的设计，语言层面打好基础你就可以在框架层面造出各种飞机大炮。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-53-40.png\"></p>\n<p><strong><center>Kotlin 在 Android &amp; iOS 上共享逻辑</center></strong></p>\n<p>用 Kotlin 的多平台特性，其实我们完全可以抽象出一套 UI 框架，用相同的 API 在不同的平台上使用各自的 UI 控件。这似乎有点儿像 React Native？对，思路完全一样，不同之处在于 Kotlin 没有额外的开销，Android 上 Kotlin 代码就是原生的代码，iOS 上 Kotlin-Native 与 Swift 编译出来的机器码没有任何实质上的区别。实际上已经有牛人开发了这样一个框架了，有兴趣的同学可以了解下：<a href=\"https://github.com/icerockdev/moko-widgets\">moko-widgets</a>。</p>\n<p>官方在这方面也是非常努力的，从 1.4 预览版就开始都支持 Swift 调用 suspend 函数了，我倒是很期待 Android Studio 直接开发 iOS 的事儿。这也真不是我瞎说，Kotlin 之父在 Kotlin Conf 上自己说的，1.4 官宣发布的时候又再次提到了这一点，而且 JetBrains 全家桶里面本来就有 AppCode 用来开发 Apple 体系下的应用，整合一下应该不是什么难事，工作量问题吧。</p>\n<p>你可以在不同的平台上做抽象，而这根本没有什么成本，不仅仅在 Android 与 iOS 上。我注意到最近关于 Rust 写前端的文章尤其多，其实就是因为 Rust 支持编译成 WASM 跑在支持它的浏览器上，Kotlin-Native 又何尝不可呢。</p>\n<p>不仅如此，Kotlin-Native 现在的开发体验已经比以前强太多了，标准库虽然还比较小，不过至少基本的集合框架类都是有的，字符串之类的支持也都是有的。没有的我们自己用 C 接口包装一下也不是什么事儿对吧，照着 JDK 的 API，用 MPP 的特性自己实现其他平台的，似乎也不是什么不可能的事儿。还真有人在尝试这么干，不信大家瞧瞧这里：<a href=\"https://github.com/caffeine-mgn/pw.binom.io\">pw.binom.io</a>，使用这个框架可以在它支持的所有平台上写出下面的代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = <span class=\"string\">&quot;Simple Text&quot;</span>.asUTF8ByteArray()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> file = File(<span class=\"string\">&quot;Simple File&quot;</span>)</span><br><span class=\"line\">    FileOutputStream(file, <span class=\"literal\">false</span>).use &#123;</span><br><span class=\"line\">        it.write(<span class=\"keyword\">data</span>, <span class=\"number\">0</span>, <span class=\"keyword\">data</span>.size)</span><br><span class=\"line\">        it.flush()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;Write data: \\&quot;<span class=\"subst\">$&#123;data.asUTF8String()&#125;</span>\\&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">out</span> = ByteArrayOutputStream()</span><br><span class=\"line\">    FileInputStream(file).use &#123;</span><br><span class=\"line\">        it.copyTo(<span class=\"keyword\">out</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println(<span class=\"string\">&quot;Read data: \\&quot;<span class=\"subst\">$&#123;out.toByteArray().asUTF8String()&#125;</span>\\&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子告诉我们 Kotlin 的这个特性为我们提供了把任意它支持的平台当做我们最熟悉的那个平台来开发的机会。</p>\n<h3 id=\"多平台特性的持续优化\"><a href=\"#多平台特性的持续优化\" class=\"headerlink\" title=\"多平台特性的持续优化\"></a>多平台特性的持续优化</h3><p>1.4-M2 开始支持结构化多平台特性，也就是大佬们经常提到的 HMPP。</p>\n<p>多平台代码之间之前只有 common 部分是可以共享的，但这显然不够，例如 Linux 的各种衍生版本之间还可以共享一部分代码，之前不能，现在终于可以了。</p>\n<p>这个特性咱们普通开发者可能感受不是特别明显，不过你很难想想框架开发的大佬期待这个特性期待了多久，协程框架马上就用这个特性把多线程的能力做了抽象，等后面达到一个相对稳定的状态之后也许你就会发现 Jvm 和 Native 上的多线程抽象居然用的是同一套代码，不同的就是各自的线程的具体 API 的使用。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-07-51-38.png\"></p>\n<p><strong><center>结构化多平台特性示意图</center></strong></p>\n<p>1.4 发布之后，多平台特性官宣进入 alpha 阶段，尽管还不是 release 的状态，但也是 release 倒计时了。客观的讲，多平台相关的绝大多数 API 经过几轮大规模迭代，已经进入较为稳定的状态，之所以还称为 alpha，估计是部分平台的周边支持例如 kotlin-js 的 dukat 还在快速迭代当中。</p>\n<p>多平台的重大意义在于 Kotlin 生态的建立。一旦这个特性扶正了，那 Kotlin 跨平台的框架生态发展可以直接得到提速，框架的开发者可以花更低的成本开发全平台适用的 Kotlin 框架，生态好才是王道。</p>\n<h3 id=\"“新基建”的时代背景\"><a href=\"#“新基建”的时代背景\" class=\"headerlink\" title=\"“新基建”的时代背景\"></a>“新基建”的时代背景</h3><p>前面我们已经看到 C 语言又力压 Java Python 夺得榜首，因为物联网？因为 5G？因为新基建？反正这几年公司项目的原因接触了不少智能硬件相关的团队和公司，虽然 Android 开始逐渐进入大家的视野，但厉害点儿的硬件还是用 Linux 直接开发。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-22-06-10.png\"></p>\n<p><strong><center>4G 时代为消费互联网的繁荣提供了土壤，而 5G 时代下的赢家又是谁？</center></strong></p>\n<p>过去的十年迅猛发展的手机性能极大的改善了我们的生活，而现在手机的发展似乎除了大屏和高性能已经没有什么新意了，互联网的浪潮也早已没有了昔日的疯狂。</p>\n<p>说到这儿，想起一个有趣的故事。我曾听曾经在 3W 咖啡馆工作的师兄讲那会儿有人在大冬天极冷的条件下坐在外面干活，想要以此证明他顽强的毅力来吸引投资人的注意。现在想想真是不可思议。那个年代只要会写 APP 就能进大公司，现在遍地都是会写 APP 的，你的竞争力体现在哪里呢？</p>\n<p>现在很多时候我们要解决的需求大不再是简单的写个 APP 那么简单，搭配硬件已经是常规操作。IoT 在 5G 背景下可以实现高速率、低延时的远程控制和更多设备的接入，专业领域的小系统在这方面有着天然的优势。</p>\n<p>而硬件厂商通常有着多年的 Linux 系统开发的经验积累，同时又对 Android 系统在此类场景下的稳定性表现出了极大的不信任。开发者在这个时代背景下想要脱颖而出，C 语言功底总要有吧？了解下 Kotlin-Native 还能顺带提高一下 C 的水平，与自己现有技术栈也能充分结合起来，甚至还可以把以前运行在其他平台的逻辑轻松地移植过来，何乐而不为呢。</p>\n<h2 id=\"我们该怎么学习-Kotlin-Native-呢？\"><a href=\"#我们该怎么学习-Kotlin-Native-呢？\" class=\"headerlink\" title=\"我们该怎么学习 Kotlin-Native 呢？\"></a>我们该怎么学习 Kotlin-Native 呢？</h2><p>先了解下 Kotlin-Native 需要的背景知识。</p>\n<ol>\n<li>扎实的 Kotlin 语法基础。这一点只要是习惯了使用 Kotlin 开发 Android 应用的开发者，一般来讲问题不大。语法上 Kotlin 不管是在哪个平台，包括 Kotlin-js，差异几乎可以忽略。</li>\n<li>C 语言背景。学习 Kotlin-Native 之前掌握 C 语言是必要的，这与我们开发 Kotlin-Jvm 程序需要先了解 Java 及其生态是一样的道理。</li>\n</ol>\n<p>有了这两点基础，在学习的过程中就基本上不会有太大的障碍了。</p>\n<p>接下来就是搞清楚自己的需求。学习 Kotlin-Native 的目的是什么呢？如果是开发一款与 Android 共享部分代码的 iOS 应用来实践 Kotlin 跨平台的特性，那么你还需要对 Objective-C 或者 Swift 有一定的了解。</p>\n<p>或者你想要了解一下 Kotlin-Native 的垃圾回收机制，对比下与 C++ 的智能指针、Rust 的内存管理甚至与 JVM 的内存垃圾回收机制的区别，那你就要去啃一下 Kotlin-Native 的源码了。</p>\n<p>说了这么多，我后面的文章大概会写点儿什么内容呢？</p>\n<ol>\n<li>Kotlin-Native 编译逻辑以及工程的搭建。这个是必不可少的，而且这块儿还稍微有点儿复杂。幸运的是 Gradle 也支持 Kotlin 脚本，所以我们不必再忍受 Groovy 的动态特性的摧残。</li>\n<li>Kotlin-Native 组件的发布逻辑。也许我们将来会考虑自己发一款跨平台的框架来取悦自己，所以这个也是很重要的。</li>\n<li>Kotlin-Native 与其他语言的互调用，主要是 C 和 Objective-C（Swift）。当然，我们也可以尝试通过 C 接口调用一下 Python 或者 Lua，甚至是 JNI。</li>\n<li>研究一下 Kotlin-Native 的运行机制，目前能想到的主要就是内存管理吧。</li>\n<li>协程在 Kotlin-Native 上对于并发的支持。</li>\n<li>Ktor 上 CIO 对 Kotlin-Native 的支持。目前这个特性还在开发中，CIO 已经对 JVM 做了支持，我也在《深入理解 Kotlin 协程》当中稍微做了介绍，不过跨平台版本应该很值得期待。</li>\n</ol>\n<p>其他。。。我还没有想到，先挖这么多坑吧，后面慢慢填。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这篇文章算是这一系列的先导篇吧，谢谢大家的关注，咱们下一篇再见。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"闲聊 Kotlin-Native (0) - 我们为什么应该关注一下 Kotlin Native？","path":"2020/07/15/kotlin-native-introduction/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-14-21-41-58.png","excerpt":"<blockquote>\n<p>一直想写点儿 Kotlin-Native 相关的话题，今天开始~ </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-07-14T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-07-14T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","native"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法","date":"2018-12-30T16:00:00.000Z","_content":"\n上一篇文章我讲了用 `@CName` 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。\n\n<!-- more -->\n\n如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：\n\n```kotlin\n@CName(\"JNI_OnLoad\")\nfun JNI_OnLoad(vm: CPointer<JavaVMVar>, preserved: COpaquePointer): jint {\n    return memScoped {\n        val envStorage = alloc<CPointerVar<JNIEnvVar>>()\n        val vmValue = vm.pointed.pointed!!\n        val result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)\n        __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"JNI_OnLoad\")\n        if(result == JNI_OK){\n            val env = envStorage.pointed!!.pointed!!\n            val jclass = env.FindClass!!(envStorage.value, \"com/example/hellojni/HelloJni\".cstr.ptr)\n\n            val jniMethod = allocArray<JNINativeMethod>(1)\n            jniMethod[0].fnPtr = staticCFunction(::sayHello2)\n            jniMethod[0].name = \"sayHello2\".cstr.ptr\n            jniMethod[0].signature = \"()V\".cstr.ptr\n            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, 1)\n\n            __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"register say hello2, %d, %d\", sizeOf<CPointerVar<JNINativeMethod>>(), sizeOf<JNINativeMethod>())\n        }\n        JNI_VERSION_1_6\n    }\n}\n```\n\n思路很简单，就是先通过 `CName` 注解搞定 `JNI_OnLoad` 函数，让 Java  虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。\n\n再说下 `memScope` 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 `memScope` 来提醒 Kotlin Native 这些变量需要来统一管理。\n\n获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：\n\n```kotlin\nval envStorage = alloc<CPointerVar<JNIEnvVar>>()\n```\n\n这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，`CPointer` 的左值类型会映射成 `CPointerVar`，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。\n\n接下来我们看这句：\n\n```kotlin\nval vmValue = vm.pointed.pointed!!\n```\n\nC 版本的定义 `JavaVM` 其实本身也是一个指针：\n\n```c\ntypedef const struct JNIInvokeInterface* JavaVM;\n```\n\n因此两个 `pointed` 的调用相当于获取到了 `JNIInvokeInterface` 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 `JNIEnv` 的操作了：\n\n```kotlin\nval result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)\n```\n\n再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 `!!`  的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。\n\n接下来我们要实现动态绑定了：\n\n```kotlin\nval jclass = env.FindClass!!(envStorage.value, \"com/example/hellojni/HelloJni\".cstr.ptr)\nval jniMethod = allocArray<JNINativeMethod>(1)\njniMethod[0].fnPtr = staticCFunction(::sayHello2)\njniMethod[0].name = \"sayHello2\".cstr.ptr\njniMethod[0].signature = \"()V\".cstr.ptr\nenv.RegisterNatives!!(envStorage.value, jclass, jniMethod, 1)\n```\n\n这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。\n\n问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：\n\n```kotlin\npublic final var RegisterNatives: kotlinx.cinterop.CPointer<kotlinx.cinterop.CFunction<(kotlinx.cinterop.CPointer<platform.android.JNIEnvVar /* = kotlinx.cinterop.CPointerVarOf<platform.android.JNIEnv /* = kotlinx.cinterop.CPointer<platform.android.JNINativeInterface> */> */>?, platform.android.jclass? /* = kotlinx.cinterop.CPointer<out kotlinx.cinterop.CPointed>? */, kotlinx.cinterop.CPointer<platform.android.JNINativeMethod>?, platform.android.jint /* = kotlin.Int */) -> platform.android.jint /* = kotlin.Int */>>? /* compiled code */\n```\n\n这其实就是 `RegisterNatives` 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。\n\n这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。\n\n简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。\n\n本文涉及源码参见：[hello-kni](https://github.com/enbandari/hello-kni)\n\n","source":"_posts/kotlin-native-jni-dynamic.md","raw":"---\ntitle: Kotlin Native 写 Jni 第二弹：动态绑定 Native 方法\ndate: 2018/12/31\ntags:\n  - Kotlin\n  - Kotlin-Native\n---\n\n上一篇文章我讲了用 `@CName` 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。\n\n<!-- more -->\n\n如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：\n\n```kotlin\n@CName(\"JNI_OnLoad\")\nfun JNI_OnLoad(vm: CPointer<JavaVMVar>, preserved: COpaquePointer): jint {\n    return memScoped {\n        val envStorage = alloc<CPointerVar<JNIEnvVar>>()\n        val vmValue = vm.pointed.pointed!!\n        val result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)\n        __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"JNI_OnLoad\")\n        if(result == JNI_OK){\n            val env = envStorage.pointed!!.pointed!!\n            val jclass = env.FindClass!!(envStorage.value, \"com/example/hellojni/HelloJni\".cstr.ptr)\n\n            val jniMethod = allocArray<JNINativeMethod>(1)\n            jniMethod[0].fnPtr = staticCFunction(::sayHello2)\n            jniMethod[0].name = \"sayHello2\".cstr.ptr\n            jniMethod[0].signature = \"()V\".cstr.ptr\n            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, 1)\n\n            __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"register say hello2, %d, %d\", sizeOf<CPointerVar<JNINativeMethod>>(), sizeOf<JNINativeMethod>())\n        }\n        JNI_VERSION_1_6\n    }\n}\n```\n\n思路很简单，就是先通过 `CName` 注解搞定 `JNI_OnLoad` 函数，让 Java  虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。\n\n再说下 `memScope` 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 `memScope` 来提醒 Kotlin Native 这些变量需要来统一管理。\n\n获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：\n\n```kotlin\nval envStorage = alloc<CPointerVar<JNIEnvVar>>()\n```\n\n这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，`CPointer` 的左值类型会映射成 `CPointerVar`，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。\n\n接下来我们看这句：\n\n```kotlin\nval vmValue = vm.pointed.pointed!!\n```\n\nC 版本的定义 `JavaVM` 其实本身也是一个指针：\n\n```c\ntypedef const struct JNIInvokeInterface* JavaVM;\n```\n\n因此两个 `pointed` 的调用相当于获取到了 `JNIInvokeInterface` 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 `JNIEnv` 的操作了：\n\n```kotlin\nval result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)\n```\n\n再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 `!!`  的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。\n\n接下来我们要实现动态绑定了：\n\n```kotlin\nval jclass = env.FindClass!!(envStorage.value, \"com/example/hellojni/HelloJni\".cstr.ptr)\nval jniMethod = allocArray<JNINativeMethod>(1)\njniMethod[0].fnPtr = staticCFunction(::sayHello2)\njniMethod[0].name = \"sayHello2\".cstr.ptr\njniMethod[0].signature = \"()V\".cstr.ptr\nenv.RegisterNatives!!(envStorage.value, jclass, jniMethod, 1)\n```\n\n这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。\n\n问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：\n\n```kotlin\npublic final var RegisterNatives: kotlinx.cinterop.CPointer<kotlinx.cinterop.CFunction<(kotlinx.cinterop.CPointer<platform.android.JNIEnvVar /* = kotlinx.cinterop.CPointerVarOf<platform.android.JNIEnv /* = kotlinx.cinterop.CPointer<platform.android.JNINativeInterface> */> */>?, platform.android.jclass? /* = kotlinx.cinterop.CPointer<out kotlinx.cinterop.CPointed>? */, kotlinx.cinterop.CPointer<platform.android.JNINativeMethod>?, platform.android.jint /* = kotlin.Int */) -> platform.android.jint /* = kotlin.Int */>>? /* compiled code */\n```\n\n这其实就是 `RegisterNatives` 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。\n\n这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。\n\n简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。\n\n本文涉及源码参见：[hello-kni](https://github.com/enbandari/hello-kni)\n\n","slug":"kotlin-native-jni-dynamic","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003j0023lduzcp0e9j18","content":"<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p>\n<span id=\"more\"></span>\n\n<p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;JNI_OnLoad&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">JNI_OnLoad</span><span class=\"params\">(vm: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JavaVMVar</span>&gt;, preserved: <span class=\"type\">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> vmValue = vm.pointed.pointed!!</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class=\"line\">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;JNI_OnLoad&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result == JNI_OK)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class=\"line\">            <span class=\"keyword\">val</span> jclass = env.FindClass!!(envStorage.value, <span class=\"string\">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class=\"number\">1</span>)</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].name = <span class=\"string\">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].signature = <span class=\"string\">&quot;()V&quot;</span>.cstr.ptr</span><br><span class=\"line\">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;register say hello2, %d, %d&quot;</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        JNI_VERSION_1_6</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java  虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p>\n<p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p>\n<p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p>\n<p>接下来我们看这句：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure>\n\n<p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure>\n\n<p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code>  的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p>\n<p>接下来我们要实现动态绑定了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> jclass = env.FindClass!!(envStorage.value, <span class=\"string\">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class=\"line\"><span class=\"keyword\">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class=\"number\">1</span>)</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].name = <span class=\"string\">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].signature = <span class=\"string\">&quot;()V&quot;</span>.cstr.ptr</span><br><span class=\"line\">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p>\n<p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class=\"comment\">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv <span class=\"comment\">/* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */</span>&gt;?, platform.android.jclass? <span class=\"comment\">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class=\"comment\">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class=\"comment\">/* = kotlin.Int */</span>&gt;&gt;? <span class=\"comment\">/* compiled code */</span></span><br></pre></td></tr></table></figure>\n\n<p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p>\n<p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p>\n<p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p>\n<p>本文涉及源码参见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a></p>\n","site":{"data":{}},"excerpt":"<p>上一篇文章我讲了用 <code>@CName</code> 这个神奇的注解，可以配置 Kotlin Native 函数在符号表中的名字，进而根据 Jni 静态绑定的规则来对应到 Java native 方法，但实际开发当中我们更喜欢用动态注册的方式，因为一方面不受名字的约束，不影响代码重构，函数名也相对美观，另一方面调用起来也相对高效，节省了静态绑定的查找过程。</p>","more":"<p>如果大家习惯用 C 写动态绑定的代码，那么 Kotlin Native 写起来思路也是很简单的，只要依样画葫芦，就可以写出来，我们先给出代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;JNI_OnLoad&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">JNI_OnLoad</span><span class=\"params\">(vm: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JavaVMVar</span>&gt;, preserved: <span class=\"type\">COpaquePointer</span>)</span></span>: jint &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> vmValue = vm.pointed.pointed!!</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br><span class=\"line\">        __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;JNI_OnLoad&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result == JNI_OK)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> env = envStorage.pointed!!.pointed!!</span><br><span class=\"line\">            <span class=\"keyword\">val</span> jclass = env.FindClass!!(envStorage.value, <span class=\"string\">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class=\"number\">1</span>)</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].name = <span class=\"string\">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class=\"line\">            jniMethod[<span class=\"number\">0</span>].signature = <span class=\"string\">&quot;()V&quot;</span>.cstr.ptr</span><br><span class=\"line\">            env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;register say hello2, %d, %d&quot;</span>, sizeOf&lt;CPointerVar&lt;JNINativeMethod&gt;&gt;(), sizeOf&lt;JNINativeMethod&gt;())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        JNI_VERSION_1_6</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路很简单，就是先通过 <code>CName</code> 注解搞定 <code>JNI_OnLoad</code> 函数，让 Java  虚拟机能够在加载 so 库的时候找到这个入口函数，那么我们接下来就是纯调用 Jni 的 C 接口了。</p>\n<p>再说下 <code>memScope</code> 这个东西，C 当中内存管理是人工不智能的，Kotlin Native 则有自己的内存管理机制，因此如果我们需要在 Kotlin Native 当中访问 C 接口，并且创建 C 变量，就需要通过 <code>memScope</code> 来提醒 Kotlin Native 这些变量需要来统一管理。</p>\n<p>获取 JNIEnv 的指针时我们首先构造了一个指针的左值类型：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> envStorage = alloc&lt;CPointerVar&lt;JNIEnvVar&gt;&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>这么说有些奇怪，总之在 C 的指针类型向 Kotlin Native 映射时，<code>CPointer</code> 的左值类型会映射成 <code>CPointerVar</code>，我现在对 Kotlin Native 与 C 的交互还没有仔细研究，就暂时不展开说了，等后面有机会再系统介绍 Kotlin Native 的细节。</p>\n<p>接下来我们看这句：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> vmValue = vm.pointed.pointed!!</span><br></pre></td></tr></table></figure>\n\n<p>C 版本的定义 <code>JavaVM</code> 其实本身也是一个指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此两个 <code>pointed</code> 的调用相当于获取到了 <code>JNIInvokeInterface</code> 这个结构体，于是后面我们就可以用它持有的函数指针进行获取 <code>JNIEnv</code> 的操作了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> result = vmValue.GetEnv!!(vm, envStorage.ptr.reinterpret(), JNI_VERSION_1_6)</span><br></pre></td></tr></table></figure>\n\n<p>再稍微提一个事儿，那就是这些类型从 C 的角度映射过来，空类型安全自然是无法保证的，因此我们会见到各种 <code>!!</code>  的使用，这样实际上对于开发来讲非常不友好。因此理想的状况是，我们用 Kotlin Native 对 C 接口进行封装，将这些底层的工作按照 Kotlin 的风格进行转换，这样我们使用起来就会容易得多——官方的 AndroidNativeActivity 的例子当中提供了 JniBridge 及一系列的类其实就是做了这样一件事儿，只不过还不算太完整。</p>\n<p>接下来我们要实现动态绑定了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> jclass = env.FindClass!!(envStorage.value, <span class=\"string\">&quot;com/example/hellojni/HelloJni&quot;</span>.cstr.ptr)</span><br><span class=\"line\"><span class=\"keyword\">val</span> jniMethod = allocArray&lt;JNINativeMethod&gt;(<span class=\"number\">1</span>)</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].fnPtr = staticCFunction(::sayHello2)</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].name = <span class=\"string\">&quot;sayHello2&quot;</span>.cstr.ptr</span><br><span class=\"line\">jniMethod[<span class=\"number\">0</span>].signature = <span class=\"string\">&quot;()V&quot;</span>.cstr.ptr</span><br><span class=\"line\">env.RegisterNatives!!(envStorage.value, jclass, jniMethod, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里面也向大家展示了如何将 Kotlin 函数转为 C 的函数指针，总体来讲思路还是很简单的，毕竟我们只是照猫画虎。</p>\n<p>问题也是很显然的，如果你也尝试这样做了，一定被这些映射过来的接口函数的签名给搞晕过：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> RegisterNatives: kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlinx.cinterop.CPointer&lt;platform.android.JNIEnvVar <span class=\"comment\">/* = kotlinx.cinterop.CPointerVarOf&lt;platform.android.JNIEnv <span class=\"comment\">/* = kotlinx.cinterop.CPointer&lt;platform.android.JNINativeInterface&gt; */</span>&gt; */</span>&gt;?, platform.android.jclass? <span class=\"comment\">/* = kotlinx.cinterop.CPointer&lt;out kotlinx.cinterop.CPointed&gt;? */</span>, kotlinx.cinterop.CPointer&lt;platform.android.JNINativeMethod&gt;?, platform.android.jint <span class=\"comment\">/* = kotlin.Int */</span>) -&gt; platform.android.jint <span class=\"comment\">/* = kotlin.Int */</span>&gt;&gt;? <span class=\"comment\">/* compiled code */</span></span><br></pre></td></tr></table></figure>\n\n<p>这其实就是 <code>RegisterNatives</code> 这个函数指针的签名，它接受 JNIEnv 的值，jclass，以及一个 JNINativeMethod 结构体的数组和这个数组的长度作为参数，但我们点进去看源码或者看函数前面却需要看这么一大堆东西，直接晕菜。</p>\n<p>这其实也是目前 Kotlin Native 比较麻烦的问题之一：开发体验。尽管 1.0-Beta 出来之后，相比过去要好了许多，但开发体验似乎仍然有待提高，这其实也会直接影响开发者的涌入。</p>\n<p>简单来说，这篇文章没什么太大的技术含量，只是对上一篇文章的一个补充。</p>\n<p>本文涉及源码参见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a></p>","popularPost_tmp_postPath":true},{"title":"Kotlin 官网大变样？这是要干啥？","keywords":"Kotlin 更新 移动端跨平台 数据科学","date":"2020-02-12T16:00:00.000Z","description":null,"_content":"\n> Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 \n\n\n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png)\n\n这是要干啥？我听说过的没听说过的您这是都要承包吗？\n\n最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？\n\n所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png)\n\n其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。\n\n不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png)\n\n当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 [Slack](https://kotl.in/slack)，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C & Swift 的互调用的支持，真是任性~~\n\n如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？\n\n说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png)\n\nFlutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。\n\n而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png)\n\n还有一个比较引人注目的就是 **Data science** 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 [kotlin-numpy](https://github.com/Kotlin/kotlin-numpy)；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。\n\n忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png)\n\n很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [[原文](https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/)] [[中文翻译](https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/)]。\n\n顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度([Integrating GPGPU computations with CPU coroutines in C++](https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf))，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。\n\n这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。\n\n我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：\n\n* Kotlin 1.0：2016.2\n* Kotlin 1.1：2017.3（13个月之后）\n* Kotlin 1.2：2017.11（8个月之后）\n* Kotlin 1.3：2018.10（11个月之后）\n\n多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-news-202002.md","raw":"---\ntitle:  Kotlin 官网大变样？这是要干啥？ \nkeywords: Kotlin 更新 移动端跨平台 数据科学 \ndate: 2020/02/13\ndescription: \ntags: \n    - kotlin\n    - news \n---\n\n> Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 \n\n\n\n<!-- more -->\n\n\n\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png)\n\n这是要干啥？我听说过的没听说过的您这是都要承包吗？\n\n最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？\n\n所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png)\n\n其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。\n\n不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png)\n\n当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 [Slack](https://kotl.in/slack)，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C & Swift 的互调用的支持，真是任性~~\n\n如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？\n\n说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png)\n\nFlutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。\n\n而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png)\n\n还有一个比较引人注目的就是 **Data science** 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 [kotlin-numpy](https://github.com/Kotlin/kotlin-numpy)；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。\n\n忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png)\n\n很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [[原文](https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/)] [[中文翻译](https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/)]。\n\n顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度([Integrating GPGPU computations with CPU coroutines in C++](https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf))，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。\n\n这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。\n\n我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：\n\n* Kotlin 1.0：2016.2\n* Kotlin 1.1：2017.3（13个月之后）\n* Kotlin 1.2：2017.11（8个月之后）\n* Kotlin 1.3：2018.10（11个月之后）\n\n多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-news-202002","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003k0026lduzej5c7qbb","content":"<blockquote>\n<p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png\"></p>\n<p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p>\n<p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p>\n<p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png\"></p>\n<p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p>\n<p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png\"></p>\n<p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href=\"https://kotl.in/slack\">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p>\n<p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p>\n<p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png\"></p>\n<p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p>\n<p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png\"></p>\n<p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href=\"https://github.com/Kotlin/kotlin-numpy\">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p>\n<p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png\"></p>\n<p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href=\"https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/\">原文</a>] [<a href=\"https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/\">中文翻译</a>]。</p>\n<p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href=\"https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf\">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p>\n<p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p>\n<p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p>\n<ul>\n<li>Kotlin 1.0：2016.2</li>\n<li>Kotlin 1.1：2017.3（13个月之后）</li>\n<li>Kotlin 1.2：2017.11（8个月之后）</li>\n<li>Kotlin 1.3：2018.10（11个月之后）</li>\n</ul>\n<p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 </p>\n</blockquote>","more":"<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png\"></p>\n<p>这是要干啥？我听说过的没听说过的您这是都要承包吗？</p>\n<p>最有意思的是居然把 Android 放到了最后，hmmm，Kotlin 开发者里面搞 Android 的应该是最多的吧？这么不受待见？</p>\n<p>所以我有个大胆的想法，Kotlin 团队肯定觉得 Android 大军切换 Kotlin 指日可待，基本上稳稳的，所以过河拆桥：Android 已经不再是 Kotlin 唯一的大腿啦，你们看看，最前面的是移动端跨平台，原来谷爸爸的大腿刚捂热乎，就又抱上了果爸爸，真是不得了哇：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-38-52.png\"></p>\n<p>其实很早之前我们就一直在聊到 Kotlin 2019 年的重心一定在 Native 上，当时觉得可能是盯上了 5G 时代的物联网的机会？不过一年过去了，5G 手机我还没用上，这不小米 10 刚发布，正琢磨要不要换个呢，嵌入式领域 C 称霸天下哪里会那么快换代，再说还有 Go 和 Rust 虎视眈眈，哪儿有 Kotlin 什么事儿。</p>\n<p>不过从 Android 起家的 Kotlin 横向切入 iOS 这个路子真的是很合适，用户群体都不用怎么变，还让过去不会 iOS 的 Android 开发者有了更多更容易的机会扩展自己的技术栈，即可以扩大自己的影响力，又给开发者带来福利，真是双赢 666。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-17-54-20.png\"></p>\n<p>当然，这个移动端跨平台并不是什么特别新鲜的事儿，毕竟开源项目嘛，没事儿刷刷 Kotlin 的 <a href=\"https://kotl.in/slack\">Slack</a>，啥都能提前知道。而且本身 Kotlin 跨平台共享代码从 1.2 刚开始公测就理论上包含了 Kotlin-Jvm@Android 和 Kotlin-Native@iOS 的代码共享能力，所以我们似乎不应该意外，我只是想说 JetBrains 居然把移动端跨平台专门上升到了这么高的优先级，还专门做了 Kotlin Native 与 Objective-C &amp; Swift 的互调用的支持，真是任性~~</p>\n<p>如果过一段时间 Dukat 这个项目逐渐成熟，Kotlin-Js 的编译工具也进一步完善，特别是对 npm 依赖的管理能更加灵活（目前 Kotlin-js 的 Gradle 依赖当中不会自动携带 npm 依赖这个让人非常难受），JavaScript 常见的框架都有了自己的 Kotlin 接口声明，那时候我估计写到最前面的也许还会发生一些变化，那时候也许叫 “Kotlin for 大前端”？</p>\n<p>说到这里有人担心 Kotlin 这是不是在跟 Flutter 叫板。显然不是嘛，Kotlin 跨平台一直都声称自己只是为了逻辑代码的共享，UI 大家还是用原生的就好啦。于是乎 Android 原来该用 ConstraintLayout 你就用你的 XML 布局，iOS 呢就还是用你的 storyboard。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-02-29.png\"></p>\n<p>Flutter 抢的是 UI 的饭碗，UI 层跨平台的问题解决了，有人就说我们底层的逻辑也选一套跨平台的方案好不好？这要是放到几年前，怕是没有别的选择了，C++ 是最好的语言；而现在，你可以选择 Kotlin，最为神奇的是 Kotlin 的跨平台和 C++ 的机制非常不同，它在 Android 上使用 Kotlin-Jvm，iOS 上则使用 Kotlin-Native。你要是非想在 Android 上使用 JNI 的话，Kotlin-Native 也已经支持了绝大多数 Android 的 CPU 架构。所以很早就有人发文章报告 Flutter + Kotlin-Native 实现移动端跨平台开发的优秀体验，所以 Flutter 该学就学，不矛盾。</p>\n<p>而且它俩的这基友关系嘛。。。依我看，这 Logo 就已经说明一切了。。。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-18-06-19.png\"></p>\n<p>还有一个比较引人注目的就是 <strong>Data science</strong> 了吧。毕竟 Python 因为这个都火的不得了了，过去的一年里我已经鼓动我们组好几个小伙伴上手 Python，要恰饭的嘛，艺多不压身，免得错过一些项目的机会。现在好了，Kotlin 也能搞科学计算了，目测大概的切入思路暂时还是依托于强大的 Jvm，Java 能用的框架 Kotlin 自然能用，Java 不能直接用的，例如 Python numpy，可以 JNI 直接搞一个封装 <a href=\"https://github.com/Kotlin/kotlin-numpy\">kotlin-numpy</a>；等 Kotlin Native 翅膀硬了之后就更省事儿了，直接跟 C 玩去，连 Jvm 都用不着了。这么发展着，最后也许是我的当然是我的，你的也是我的。。。</p>\n<p>忘了说了，现在已经有了 Jupyter 的 Kotlin 内核，所以以前在 Jupyter Notebook 里用 Python 写的代码也可以用 Kotlin 写了，贴一张官网的效果图：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-16-54-47.png\"></p>\n<p>很美是吧，之前 KotlinConf 2019 期间官博就发了一篇文章介绍这个能力，也可以参考一下：Making Kotlin Ready for Data Science [<a href=\"https://blog.jetbrains.com/kotlin/2019/12/making-kotlin-ready-for-data-science/\">原文</a>] [<a href=\"https://www.kotliner.cn/2020/01/making-kotlin-ready-for-data-science/\">中文翻译</a>]。</p>\n<p>顺便提一句，调用 GPU 其实也是 IO 操作，我看了几个 cuda 的程序都很有意思，要么是阻塞调用，要么就是异步调用之后在主流程里死循环等待结果返回。这似乎与我们的 Socket 读写类似，异步的 API 可能在大规模调用时性能更好，但代码编写起来更加复杂。前几天读到一篇论文讲的就是如何使用 C++ 的协程来降低 GPU 编程的复杂度(<a href=\"https://iopscience.iop.org/article/10.1088/1742-6596/681/1/012048/pdf\">Integrating GPGPU computations with CPU coroutines in C++</a>)，随着 Kotlin Native 的逐渐成熟稳定，我们可以直接通过 C 接口编写 GPU 相关程序，Kotlin 协程也许可以为 GPU 编程带来一定的便利。</p>\n<p>这么看来，预计在 2020年春天发布的 Kotlin 1.4 的形势也比较明朗了，正如 Kotlin 之父 Andrey 说的，这个版本没有什么太多的新特性。因为作为一门语言本身，Kotlin 已经比较成熟，现在最应当关注的是开发体验，开发效率，稳定性，易用性以及应用场景等等语言生态的内容。</p>\n<p>我之前还比较担心 Kotlin Multiplatform 和 Kotlin Native 会不会借此机会正式发布，从官网的这次改动来看，这样的担心应该是多余的了。我们来回顾一下过去 Kotlin 的重要版本的发布时间：</p>\n<ul>\n<li>Kotlin 1.0：2016.2</li>\n<li>Kotlin 1.1：2017.3（13个月之后）</li>\n<li>Kotlin 1.2：2017.11（8个月之后）</li>\n<li>Kotlin 1.3：2018.10（11个月之后）</li>\n</ul>\n<p>多数情况下 Kotlin 的大版本都是保持一年左右一个的（1.2 这个版本估计是趁着热度努力冲了一波 KPI，毕竟 2017 年 Kotlin 出名了），小版本大概两个月一个，所以一般小版本到 1.x.7 的时候也就是下一个大版本发布的时间。现在 1.3.70 已经 EAP 了一个多月了，你们懂我意思吧。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 官网大变样？这是要干啥？","path":"2020/02/13/kotlin-news-202002/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-02-13-15-34-00.png","excerpt":"<blockquote>\n<p>Kotlin 官网这次更新可以算是历史上最大的一次了，跨平台、数据科学等内容也搬到了最前面。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-02-12T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-02-12T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","news"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"说说最近官方公布的 Kotlin 的动态","keywords":"Kotlin News","date":"2020-10-18T16:00:00.000Z","description":null,"_content":"\n> Kotlin 的发展可以认为是正式进入了下一个阶段。 \n\n\n\n<!-- more -->\n\n\n\n\n今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。\n\n不过，官方最近有些消息放出来让我有些坐不住了。\n\n## 1. Kotlin 的发版节奏\n\n过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。\n\n功能优先还是版本优先？\n\n显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。\n\n而现如今，\n\nKotlin 经过 1.0 正式发布\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png)\n\n1.1 正式支持 JavaScript 并开始试验协程\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png)\n\n1.2 开始试验多平台\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png)\n\n1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png)\n\n1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png)\n\n可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。\n\n接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。\n\n这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。\n\n## 2. Kotlin 的 Roadmap\n\n我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。\n\n再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png)\n\n现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png)\n\n顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。\n\n这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png)\n\n多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。\n\nKotlin 近期公布的 Roadmap 见：[Kotlin Roadmap](https://kotlinlang.org/roadmap.html)，大家可以自己看看有没有自己感兴趣的内容。\n\n## 3. KMM 插件\n\nKMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png)\n\n毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。\n\nKMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。\n\n不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：\n\n1. Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。\n2. Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。\n3. Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。\n\n不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。\n\n至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。\n\n再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。\n\n## 4. 小结\n\nKotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。\n\n---\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png)\n\n最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 [Kotlin 1.4 Online Event](https://kotlinlang.org/lp/event-14/) 这个地址找到所有的视频，内容还是值得了解一下的。\n\n当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-news-202010.md","raw":"---\ntitle:  说说最近官方公布的 Kotlin 的动态 \nkeywords: Kotlin News \ndate: 2020/10/19\ndescription: \ntags: \n    - kotlin\n    - news \n---\n\n> Kotlin 的发展可以认为是正式进入了下一个阶段。 \n\n\n\n<!-- more -->\n\n\n\n\n今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。\n\n不过，官方最近有些消息放出来让我有些坐不住了。\n\n## 1. Kotlin 的发版节奏\n\n过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。\n\n功能优先还是版本优先？\n\n显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。\n\n而现如今，\n\nKotlin 经过 1.0 正式发布\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png)\n\n1.1 正式支持 JavaScript 并开始试验协程\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png)\n\n1.2 开始试验多平台\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png)\n\n1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png)\n\n1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png)\n\n可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。\n\n接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。\n\n这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。\n\n## 2. Kotlin 的 Roadmap\n\n我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。\n\n再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png)\n\n现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png)\n\n顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。\n\n这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png)\n\n多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。\n\nKotlin 近期公布的 Roadmap 见：[Kotlin Roadmap](https://kotlinlang.org/roadmap.html)，大家可以自己看看有没有自己感兴趣的内容。\n\n## 3. KMM 插件\n\nKMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png)\n\n毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。\n\nKMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。\n\n不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：\n\n1. Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。\n2. Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。\n3. Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。\n\n不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。\n\n至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。\n\n再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。\n\n## 4. 小结\n\nKotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。\n\n---\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png)\n\n最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 [Kotlin 1.4 Online Event](https://kotlinlang.org/lp/event-14/) 这个地址找到所有的视频，内容还是值得了解一下的。\n\n当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-news-202010","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003k0028lduzcfqe9emh","content":"<blockquote>\n<p>Kotlin 的发展可以认为是正式进入了下一个阶段。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。</p>\n<p>不过，官方最近有些消息放出来让我有些坐不住了。</p>\n<h2 id=\"1-Kotlin-的发版节奏\"><a href=\"#1-Kotlin-的发版节奏\" class=\"headerlink\" title=\"1. Kotlin 的发版节奏\"></a>1. Kotlin 的发版节奏</h2><p>过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。</p>\n<p>功能优先还是版本优先？</p>\n<p>显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。</p>\n<p>而现如今，</p>\n<p>Kotlin 经过 1.0 正式发布</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png\"></p>\n<p>1.1 正式支持 JavaScript 并开始试验协程</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png\"></p>\n<p>1.2 开始试验多平台</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png\"></p>\n<p>1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png\"></p>\n<p>1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png\"></p>\n<p>可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。</p>\n<p>接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。</p>\n<p>这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。</p>\n<h2 id=\"2-Kotlin-的-Roadmap\"><a href=\"#2-Kotlin-的-Roadmap\" class=\"headerlink\" title=\"2. Kotlin 的 Roadmap\"></a>2. Kotlin 的 Roadmap</h2><p>我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。</p>\n<p>再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png\"></p>\n<p>现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png\"></p>\n<p>顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。</p>\n<p>这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png\"></p>\n<p>多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。</p>\n<p>Kotlin 近期公布的 Roadmap 见：<a href=\"https://kotlinlang.org/roadmap.html\">Kotlin Roadmap</a>，大家可以自己看看有没有自己感兴趣的内容。</p>\n<h2 id=\"3-KMM-插件\"><a href=\"#3-KMM-插件\" class=\"headerlink\" title=\"3. KMM 插件\"></a>3. KMM 插件</h2><p>KMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png\"></p>\n<p>毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。</p>\n<p>KMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。</p>\n<p>不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：</p>\n<ol>\n<li>Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。</li>\n<li>Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。</li>\n<li>Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。</li>\n</ol>\n<p>不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。</p>\n<p>至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。</p>\n<p>再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。</p>\n<h2 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h2><p>Kotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。</p>\n<hr>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png\"></p>\n<p>最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 <a href=\"https://kotlinlang.org/lp/event-14/\">Kotlin 1.4 Online Event</a> 这个地址找到所有的视频，内容还是值得了解一下的。</p>\n<p>当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Kotlin 的发展可以认为是正式进入了下一个阶段。 </p>\n</blockquote>","more":"<p>今年年底还有些事情要做，所幸大多数都与 Kotlin 有关系，不算耽搁太多。加上现阶段大家有相对充足的资料学习 Kotlin，尽管协程之前的资料相对匮乏，我也在年中出版了一本书暂时补齐了这块儿缺漏，因此我就这么安慰自己不要压力太大，以免腰更加突出，哈哈。</p>\n<p>不过，官方最近有些消息放出来让我有些坐不住了。</p>\n<h2 id=\"1-Kotlin-的发版节奏\"><a href=\"#1-Kotlin-的发版节奏\" class=\"headerlink\" title=\"1. Kotlin 的发版节奏\"></a>1. Kotlin 的发版节奏</h2><p>过去 Kotlin 的版本节奏一直比较佛系，从 1.0 到 1.1 花了一年多，到 1.2 才半年，到 1.3 又近一年，1.4 却花了将近两年。为什么会这样呢？因为越往后，Kotlin 自身的体系越庞大，想要做点儿什么的复杂度可想而知的变高，自然版本节奏就没那么好把控了。</p>\n<p>功能优先还是版本优先？</p>\n<p>显然这个问题在不同的发展阶段是有不同的答案的。项目刚开始，自然需要稳扎稳打，做一个功能就是一个功能，因此可以说 1.4 及以前的所有版本的迭代计划都是按照这个思路展开的，功能啥时候做好啥时候上，做不好就 delay。</p>\n<p>而现如今，</p>\n<p>Kotlin 经过 1.0 正式发布</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png\"></p>\n<p>1.1 正式支持 JavaScript 并开始试验协程</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-08.png\"></p>\n<p>1.2 开始试验多平台</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-29.png\"></p>\n<p>1.3 正式支持协程并开始了 Native 的 beta，多平台的生态随之也开始逐渐展开</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-01-48.png\"></p>\n<p>1.4 有做了一系列整体的性能优化和提升，编译器重构也基本完成</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-02-06.png\"></p>\n<p>可以说 Kotlin 现阶段的基本盘已经形成，当前版本足以长期支撑开发者完成开发工作了。</p>\n<p>接下来的工作重点我们在之前的文章当中就曾经谈到，其实就是应用场景的挖掘，开发体验的优化和提升，以及多平台的完善和生态的建设。这些大都不算是巨大的语言特性，因此 Kotlin Team 宣布后面发版半年一次，这意味着 Kotlin 1.5 将在明年春天发布，规划的特性实行班车机制，赶得上版本就发布，赶不上就下一趟。</p>\n<p>这样做好处也是很明显的，版本的节奏感会给开发者带来期待，我们不再需要猜下一个版本什么时候来，以及下一个版本会有什么，因为这些都会很早就公布；一些细节的改进我们也不需要苦等很久才能体验到，因为版本节奏快了，一些小的改进会更快的被呈现在开发者面前。</p>\n<h2 id=\"2-Kotlin-的-Roadmap\"><a href=\"#2-Kotlin-的-Roadmap\" class=\"headerlink\" title=\"2. Kotlin 的 Roadmap\"></a>2. Kotlin 的 Roadmap</h2><p>我过去想要提前了解 Kotlin 下一步的动态，主要去 Kotlin 的 GitHub 的仓库和 YouTrack 当中去爬 issue，看大家的讨论，这个过程会比较有趣，因为大佬们经常吵架。如果只是想要消遣，这个方式跟刷知乎也没什么两样，不过如果是去获取信息，那就需要自己认认真真的瞎猜了。</p>\n<p>再往前的时候，Kotlin Team 还会维护一下 Kotlin 在 GitHub 上开的 Keep 仓库，不过这个仓库现在已经是一副年久失修的感觉了。说来还真是要好好提一下，Kotlin 协程的设计文档就在 Keep 仓库当中，虽然感觉比较久远了，但还是很值得一读的。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-27-41.png\"></p>\n<p>现在好了，官方直接公布了 Roadmap，这一招配合 Kotlin 的发版节奏的改变，极大的方便了我们这些吃瓜群众。不是想知道 Kotlin 啥时候实现自举吗？Kotlin Team 已经在解决这个问题了，不信看这里：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-54-22.png\"></p>\n<p>顺便我们也看到了 Kotlin 编译器插件的 API 现在还没有排到最高优先级，所以等等吧。</p>\n<p>这次 Roadmap 的公布，还是有一些比较有趣的点的，例如：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-18-21-57-40.png\"></p>\n<p>多个 receiver 的函数，可能有些朋友还没有用到过。其实这个特性现在也有办法来模拟，就是通过隐式 receiver 的方式来实现，但如果能够有专门的语法来支持的，应该还会有更会玩的用法出现。</p>\n<p>Kotlin 近期公布的 Roadmap 见：<a href=\"https://kotlinlang.org/roadmap.html\">Kotlin Roadmap</a>，大家可以自己看看有没有自己感兴趣的内容。</p>\n<h2 id=\"3-KMM-插件\"><a href=\"#3-KMM-插件\" class=\"headerlink\" title=\"3. KMM 插件\"></a>3. KMM 插件</h2><p>KMM 算是 Kotlin Team 为多平台这个重磅特性挖掘的一个重要的应用场景。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-28-19.png\"></p>\n<p>毕竟 Kotlin 的用户大多是 Android 开发，Android 开发者的老板们有迫切的希望他手底下的 Android 开发能拿一份工资干两人的活，对吧。不仅如此，Android 开发也希望自己在市场上更有竞争力，如果 Kotlin 适用场景变多了，那么自己岂不是就像买了股票一样跑赢大盘？所以 KMM 简直就是众望所归。</p>\n<p>KMM 运行在 iOS 上的实际上就是 Kotlin Native 的代码，通过 Kotlin MPP 与运行在 Android 上的 Kotlin Jvm 代码来共享逻辑。最近随着 Kotlin 1.4 发布推出的 KMM 插件也支持了在 Android Studio 上直接运行 iOS 应用，启动 iOS 模拟器，甚至单步调试运行在 iOS 上的 Kotlin Native 代码的能力。</p>\n<p>不过，如果想要将 KMM 直接应用于移动端跨平台上上，还是有些问题需要解决的，这主要就是 Kotlin Native 对于 iOS 的支持的问题，例如：</p>\n<ol>\n<li>Kotlin Native 的并发模型比较严格，也正是如此，Kotlin 协程的 Kotlin Native 版本迟迟没有正式推出多线程版本，在 iOS 上使用 Kotlin 协程目前还受制于所调用的 API 是否本身已经自己支持了异步以及回调的线程切换。</li>\n<li>Kotlin 目前尚不能像在 Android 上那样全面替代 Java，从目前以导出 Framework 的方式引入 iOS 工程的做法来看，Swift 和 Objective-C 暂时还是无法完全干掉的。</li>\n<li>Kotlin Native 可用的框架目前仍然比较少，如果想要编写 Kotlin 多平台的代码，也需要我们引入的框架支持 Kotlin 多平台，例如序列化框架可选的目前主要就是官方的 kotlinx-serialization，时间框架主要也是官方提供的 kotlinx-datetime 等等。</li>\n</ol>\n<p>不过这倒也不算什么大问题，毕竟才刚刚开始，Kotlin Native 的并发模型的问题以及 Kotlin Native 开发 iOS 的支持问题都在逐渐优化。</p>\n<p>至于依赖框架的问题，这恰恰也是 Kotlin 的生存哲学之一，Kotlin 游走与各个平台上，一向是以充分利用所在平台的优势为基础的。我们且等它把这些平台的基础 API 进行统一封装，以方便我们实现逻辑层的一致性。</p>\n<p>再稍微提一下，KMM 插件尽管支持了很多功能，但对于 iOS 工程却仍然不能有效支持，这主要体现在对于 Swift、Objective-C 的代码无法高亮、调试等问题上，如果需要编辑 SwiftUI 或者其他使用 Swift 编写的代码模块，还是需要在 Xcode 当中完成。至于将来会不会支持，这一点目前还没有确切的消息。</p>\n<h2 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h2><p>Kotlin 1.4 发布了两个月，整体反应来看，大家还是比较平静的，因为这次确实出了 SAM 转换让人期待已久以外，别的都不是很以外。不过，从最近发生的这些变化来看，Kotlin 的将来还是值得期待一下的，至少，它已经找到了自己的路，并开始一步一步走下去了。</p>\n<hr>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-34-14.png\"></p>\n<p>最后再提一句，国外疫情肆虐，KotlinConf 今年没法线下开展，这不，也改成线上了。大家可以在 <a href=\"https://kotlinlang.org/lp/event-14/\">Kotlin 1.4 Online Event</a> 这个地址找到所有的视频，内容还是值得了解一下的。</p>\n<p>当然，视频直接收看可能需要一些操作，后面的话我看看能不能跟官方的小伙伴商量下尽快搬到国内的视频平台上。此外，我们目前也在准备后面结合这次 Kotlin 的 Event 在国内做一些分享，届时也会通过公众号发布具体的安排，请大家留意~</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"说说最近官方公布的 Kotlin 的动态","path":"2020/10/19/kotlin-news-202010/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-10-19-12-00-49.png","excerpt":"<blockquote>\n<p>Kotlin 的发展可以认为是正式进入了下一个阶段。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-10-18T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-10-18T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","news"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"基于 Node.js 环境的 KotlinJs 工程的完美搭建","date":"2019-03-10T16:00:00.000Z","_content":"\n\n### 为什么需要这样一篇文章\n\n我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。\n\n而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。\n\n这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：\n\n* 依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装\n* 右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样\n* 单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知\n\n基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。\n\n<!-- more -->\n\n## 准备工作\n\n首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。\n\n接着，你需要在 IU 中安装 NodeJS 插件，如图：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg)\n\n我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。\n\n最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。\n\n## 创建工程\n\n创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg)\n\n工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg)\n\n## 开始调试\n\n我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：\n\n```kotlin\nfun main() {\n    println(\"Hello\")\n}\n```\n然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg)\n\n点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg)\n\n首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。\n\n当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs  编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：\n\n```groovy\ncompileKotlin2Js {\n    kotlinOptions.moduleKind = 'commonjs'\n    kotlinOptions.sourceMap = true\n    kotlinOptions.metaInfo = true\n}\n```\n\n其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。\n\n这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 `require('kotlin')`，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：\n\n```groovy\ndependencies {\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-js\"\n    testImplementation \"org.jetbrains.kotlin:kotlin-test-js\"\n}\n```\n\n这怎么能运行得起来呢？\n\n因此我们还需要一个插件：\n\n```groovy\napply plugin: 'org.jetbrains.kotlin.frontend'\n```\n\n为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：\n\n```groovy\nbuildscript {\n    repositories {\n        maven {\n            url \"https://dl.bintray.com/kotlin/kotlin-eap\"\n        }\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45\"\n    }\n}\n```\n\n这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg)\n\n而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：\n\n```groovy\nkotlinFrontend {\n    npm {\n        dependency \"style-loader\" // production dependency\n        devDependency \"karma\"     // development dependency\n    }\n}\n```\n\n还支持 webpack 。\n\n好啦，这时候再运行咱们的程序，就会得到结果：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg)\n\n## 体验一把 KotlinJs 的协程\n\n首先添加依赖：\n\n```gradle\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1'\n```\n\n接着，编写我们的 Kotlin 代码：\n\n```kotlin\nfun log(msg: Any) {\n    println(\"[${Date().toLocaleTimeString()}] $msg\")\n}\n\nfun main() {\n    log(1)\n    GlobalScope.launch {\n        log(3)\n        val result = withContext(coroutineContext) {\n            delay(1000)\n            log(4)\n            \"HelloWorld\"\n        }\n        log(\"5. $result\")\n    }\n    log(2)\n}\n```\n\n运行结果如下：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg)\n\n单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg)\n\n我们可以看到 result 的值正是协程内部返回的 HelloWorld。\n\n是不是很美？\n\n## 小结\n\n虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑>◡<๑)۶\n\n>从此，小伙伴们与 KotlinJs 过上了幸福的生活~\n\n---\n\n* Bennyhuo 所在的组招 Android 实习生啦\n* 主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生\n* Java 基础扎实者优先，熟悉 Kotlin 优先\n* 腾讯地图相关业务，坐标 **北京中关村**\n* 有兴趣的小伙伴可以发简历到 bennyhuo@kotliner.cn 哈~\n\n--- \n\n另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n\n\n\n\n\n","source":"_posts/kotlin-nodejs.md","raw":"---\ntitle: 基于 Node.js 环境的 KotlinJs 工程的完美搭建\ndate: 2019/03/11\ntags:\n  - Kotlin\n  - Kotlni-Js\n---\n\n\n### 为什么需要这样一篇文章\n\n我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。\n\n而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。\n\n这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：\n\n* 依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装\n* 右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样\n* 单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知\n\n基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。\n\n<!-- more -->\n\n## 准备工作\n\n首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。\n\n接着，你需要在 IU 中安装 NodeJS 插件，如图：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg)\n\n我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。\n\n最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。\n\n## 创建工程\n\n创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg)\n\n工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg)\n\n## 开始调试\n\n我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：\n\n```kotlin\nfun main() {\n    println(\"Hello\")\n}\n```\n然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg)\n\n点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg)\n\n首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。\n\n当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs  编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：\n\n```groovy\ncompileKotlin2Js {\n    kotlinOptions.moduleKind = 'commonjs'\n    kotlinOptions.sourceMap = true\n    kotlinOptions.metaInfo = true\n}\n```\n\n其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。\n\n这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 `require('kotlin')`，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：\n\n```groovy\ndependencies {\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-js\"\n    testImplementation \"org.jetbrains.kotlin:kotlin-test-js\"\n}\n```\n\n这怎么能运行得起来呢？\n\n因此我们还需要一个插件：\n\n```groovy\napply plugin: 'org.jetbrains.kotlin.frontend'\n```\n\n为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：\n\n```groovy\nbuildscript {\n    repositories {\n        maven {\n            url \"https://dl.bintray.com/kotlin/kotlin-eap\"\n        }\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45\"\n    }\n}\n```\n\n这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg)\n\n而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：\n\n```groovy\nkotlinFrontend {\n    npm {\n        dependency \"style-loader\" // production dependency\n        devDependency \"karma\"     // development dependency\n    }\n}\n```\n\n还支持 webpack 。\n\n好啦，这时候再运行咱们的程序，就会得到结果：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg)\n\n## 体验一把 KotlinJs 的协程\n\n首先添加依赖：\n\n```gradle\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1'\n```\n\n接着，编写我们的 Kotlin 代码：\n\n```kotlin\nfun log(msg: Any) {\n    println(\"[${Date().toLocaleTimeString()}] $msg\")\n}\n\nfun main() {\n    log(1)\n    GlobalScope.launch {\n        log(3)\n        val result = withContext(coroutineContext) {\n            delay(1000)\n            log(4)\n            \"HelloWorld\"\n        }\n        log(\"5. $result\")\n    }\n    log(2)\n}\n```\n\n运行结果如下：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg)\n\n单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg)\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg)\n\n我们可以看到 result 的值正是协程内部返回的 HelloWorld。\n\n是不是很美？\n\n## 小结\n\n虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑>◡<๑)۶\n\n>从此，小伙伴们与 KotlinJs 过上了幸福的生活~\n\n---\n\n* Bennyhuo 所在的组招 Android 实习生啦\n* 主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生\n* Java 基础扎实者优先，熟悉 Kotlin 优先\n* 腾讯地图相关业务，坐标 **北京中关村**\n* 有兴趣的小伙伴可以发简历到 bennyhuo@kotliner.cn 哈~\n\n--- \n\n另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n\n\n\n\n\n","slug":"kotlin-nodejs","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003l002blduz3pdz47y1","content":"<h3 id=\"为什么需要这样一篇文章\"><a href=\"#为什么需要这样一篇文章\" class=\"headerlink\" title=\"为什么需要这样一篇文章\"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p>\n<p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p>\n<p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p>\n<ul>\n<li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li>\n<li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li>\n<li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li>\n</ul>\n<p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p>\n<p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg\"></p>\n<p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p>\n<p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p>\n<h2 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg\"></p>\n<p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg\"></p>\n<h2 id=\"开始调试\"><a href=\"#开始调试\" class=\"headerlink\" title=\"开始调试\"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg\"></p>\n<p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg\"></p>\n<p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p>\n<p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs  编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileKotlin2Js &#123;</span><br><span class=\"line\">    kotlinOptions.moduleKind = <span class=\"string\">&#x27;commonjs&#x27;</span></span><br><span class=\"line\">    kotlinOptions.sourceMap = <span class=\"literal\">true</span></span><br><span class=\"line\">    kotlinOptions.metaInfo = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p>\n<p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib-js&quot;</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-test-js&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这怎么能运行得起来呢？</p>\n<p>因此我们还需要一个插件：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;org.jetbrains.kotlin.frontend&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url <span class=\"string\">&quot;https://dl.bintray.com/kotlin/kotlin-eap&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg\"></p>\n<p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinFrontend &#123;</span><br><span class=\"line\">    npm &#123;</span><br><span class=\"line\">        dependency <span class=\"string\">&quot;style-loader&quot;</span> <span class=\"comment\">// production dependency</span></span><br><span class=\"line\">        devDependency <span class=\"string\">&quot;karma&quot;</span>     <span class=\"comment\">// development dependency</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还支持 webpack 。</p>\n<p>好啦，这时候再运行咱们的程序，就会得到结果：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg\"></p>\n<h2 id=\"体验一把-KotlinJs-的协程\"><a href=\"#体验一把-KotlinJs-的协程\" class=\"headerlink\" title=\"体验一把 KotlinJs 的协程\"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>接着，编写我们的 Kotlin 代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;[<span class=\"subst\">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class=\"variable\">$msg</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = withContext(coroutineContext) &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">4</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;HelloWorld&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg\"></p>\n<p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg\"></p>\n<p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p>\n<p>是不是很美？</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p>\n<blockquote>\n<p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p>\n</blockquote>\n<hr>\n<ul>\n<li>Bennyhuo 所在的组招 Android 实习生啦</li>\n<li>主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生</li>\n<li>Java 基础扎实者优先，熟悉 Kotlin 优先</li>\n<li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li>\n<li>有兴趣的小伙伴可以发简历到 <a href=\"mailto:&#98;&#x65;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#111;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#x65;&#x72;&#46;&#x63;&#110;\">&#98;&#x65;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#111;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#x65;&#x72;&#46;&#x63;&#110;</a> 哈~</li>\n</ul>\n<hr>\n<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"为什么需要这样一篇文章\"><a href=\"#为什么需要这样一篇文章\" class=\"headerlink\" title=\"为什么需要这样一篇文章\"></a>为什么需要这样一篇文章</h3><p>我们知道 Kotlin 对 Jvm 的支持实在是太好了，以至于我们创建一个 Java 工程，配置一下 Kotlin 的编译插件和标准库就可以很轻松愉快的开始玩耍，什么互调用、什么单步调试都没有毛病——毕竟 KotlinJvm 与 Java 无论从使用上还是从生态上都尽可能的保持了一致，构建也主要用了 gradle，所以从 Java 到 Kotlin 的切换可谓是无缝衔接。</p>\n<p>而 Kotlin 同样支持的 JavaScript 就似乎有点儿麻烦了，毕竟二者所处的生态差异略大，KotlinJs 仍然主要采用 gradle 构建，而 JavaScript 的话，例如 Node.js，就使用 npm/yarn 安装管理依赖了。想想可能还是有点儿别扭，你当然可以自己创建一个简单的 KotlinJs 工程，并且自己负责管理 node_modules，但那样的话，node_modules 的依赖并不会被 KotlinJs 直接依赖到，还需要管理 JavaScript 映射到 Kotlin 的接口依赖，例如 jQuery 在 Kotlinjs 侧就有一个接口库方便 Kotlin 以类型安全的方式调用，不过你还是要自己安装好 jQuery 才行，很麻烦对吧。</p>\n<p>这一节我们将给大家展示如何搭建一个基于 Node.js 的相对完美的 KotlinJs 的开发环境，这个环境可以做到：</p>\n<ul>\n<li>依赖只需要在 Gradle 中统一管理即可，node_modules 会被自动安装</li>\n<li>右键运行 Kotlin 中的 main 函数，就像我们在 KotlinJvm 当中一样</li>\n<li>单步调试 Kotlin 代码，全程对 JavaScript 的编译结果无感知</li>\n</ul>\n<p>基于这个工程，大家就可以很愉快的测试 KotlinJs 的特性啦，就像我们在 KotlinJvm 上面那样，毫无违和感。</p>","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先，你需要一个 IntelliJ Idea Utilmate，俗称的 IU。为什么呢？因为我们需要 IDE 支持 Gradle，所以 WebStorm 就不行啦。</p>\n<p>接着，你需要在 IU 中安装 NodeJS 插件，如图：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519977140851.jpg\"></p>\n<p>我的 IU 已经安装了 NodeJS 的插件，因此在左侧可以看到，如果你没有安装，那么点击 Browse repositories 搜索安装即可。安装完成后重启 IU。</p>\n<p>最后，为了能够正常运行 Node.js 程序，请大家提前安装好 Node，这个就比较简单了，我就不多说啦。</p>\n<h2 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h2><p>创建工程其实也比较简单，选 Gradle，再选择 Kotlin(JavaScript) 即可，后面的根据你的实际情况配置即可。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15519983002372.jpg\"></p>\n<p>工程创建完成后，等待 Gradle sync 完成，会得到下图所示的工程目录结构，非常熟悉对不对：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520002020882.jpg\"></p>\n<h2 id=\"开始调试\"><a href=\"#开始调试\" class=\"headerlink\" title=\"开始调试\"></a>开始调试</h2><p>我们直接在 src/main/kotlin 下面创建一个目录，例如 com/bennyhuo/kotlin/js，创建一个 Main.kt 文件，写下著名的一小步：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，这时候你就可以看到 IDE 提示你这个东西可以直接运行：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520003818003.jpg\"></p>\n<p>点击这个按钮，或者右键 main 函数，你都可以看到运行它的选项，点击之~</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520004304111.jpg\"></p>\n<p>首先你要选择一个合适的 node 环境，其次这个图提示我们要正确的 JavaScript 路径，由于我们实际上运行的是 Kotlin 编译生成的 JavaScript 文件，因此不要 care 下面的这个 Error，直接点击 run，下一个对话框再点击 “Continue Anyway”。</p>\n<p>当然这时候肯定是会报错的，它会报错说没有 kotlin 这个东西，因为默认情况下 KotlinJs  编译得到的 JavaScript 是 plain 类型的，引用的依赖都需要作为全局变量出现。我们要配置它为 commonjs 或者 umd，在 gradle 最后填下以下配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileKotlin2Js &#123;</span><br><span class=\"line\">    kotlinOptions.moduleKind = <span class=\"string\">&#x27;commonjs&#x27;</span></span><br><span class=\"line\">    kotlinOptions.sourceMap = <span class=\"literal\">true</span></span><br><span class=\"line\">    kotlinOptions.metaInfo = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的两项配置主要是为了调试用，比如单步调试映射代码位置等等。</p>\n<p>这时候你当然可以选择继续运行了，不过还是会报错，虽然编译的结果已经能够主动去 <code>require(&#39;kotlin&#39;)</code>，但这个 kotlin 在哪儿呢？我们并没有主动去安装它，甚至我们从一开始就声称是基于 node.js 的，我们连 npm init 都没有做过，我们所有的依赖都在 gradle 当中配置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib-js&quot;</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-test-js&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这怎么能运行得起来呢？</p>\n<p>因此我们还需要一个插件：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;org.jetbrains.kotlin.frontend&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>为了依赖这个插件，我们需要添加一个仓库，毕竟这个插件还没有发布到 jcenter 的公共仓库或者 gradle 的插件仓库：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            url <span class=\"string\">&quot;https://dl.bintray.com/kotlin/kotlin-eap&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们耐心的 sync 一下 gradle，你就会发现 build 目录下多了一些东西：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520010125911.jpg\"></p>\n<p>而这正包含了我们所需要的运行时依赖。kotlin frontend 这个插件会帮我们把 gradle 中配置的依赖也一并通过 npm 安装，它还可以在 gradle 当中为 npm 配置依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kotlinFrontend &#123;</span><br><span class=\"line\">    npm &#123;</span><br><span class=\"line\">        dependency <span class=\"string\">&quot;style-loader&quot;</span> <span class=\"comment\">// production dependency</span></span><br><span class=\"line\">        devDependency <span class=\"string\">&quot;karma&quot;</span>     <span class=\"comment\">// development dependency</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还支持 webpack 。</p>\n<p>好啦，这时候再运行咱们的程序，就会得到结果：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520011485464.jpg\"></p>\n<h2 id=\"体验一把-KotlinJs-的协程\"><a href=\"#体验一把-KotlinJs-的协程\" class=\"headerlink\" title=\"体验一把 KotlinJs 的协程\"></a>体验一把 KotlinJs 的协程</h2><p>首先添加依赖：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>接着，编写我们的 Kotlin 代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;[<span class=\"subst\">$&#123;Date().toLocaleTimeString()&#125;</span>] <span class=\"variable\">$msg</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    GlobalScope.launch &#123;</span><br><span class=\"line\">        log(<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> result = withContext(coroutineContext) &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            log(<span class=\"number\">4</span>)</span><br><span class=\"line\">            <span class=\"string\">&quot;HelloWorld&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(<span class=\"string\">&quot;5. <span class=\"variable\">$result</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520012610528.jpg\"></p>\n<p>单步调试无需任何特殊配置，直接打断点，点 debug 运行的按钮即可：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013471387.jpg\"></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520013961599.jpg\"></p>\n<p>我们可以看到 result 的值正是协程内部返回的 HelloWorld。</p>\n<p>是不是很美？</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>虽然，在最开始运行的时候会被配置 JavaScript 文件的路径恶心一把，但这个并不会有太多影响，整体体验已经非常不错了。嗯，公司正好有个做了半年的 NodeJs 项目，感觉可以玩一把了，反正组里用啥我说了算 ٩(๑&gt;◡&lt;๑)۶</p>\n<blockquote>\n<p>从此，小伙伴们与 KotlinJs 过上了幸福的生活~</p>\n</blockquote>\n<hr>\n<ul>\n<li>Bennyhuo 所在的组招 Android 实习生啦</li>\n<li>主要面向 2020（暑期实习）或者2021 （日常实习）年毕业的计算机相关专业本科及以上的在校生</li>\n<li>Java 基础扎实者优先，熟悉 Kotlin 优先</li>\n<li>腾讯地图相关业务，坐标 <strong>北京中关村</strong></li>\n<li>有兴趣的小伙伴可以发简历到 <a href=\"mailto:&#98;&#x65;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#111;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#x65;&#x72;&#46;&#x63;&#110;\">&#98;&#x65;&#x6e;&#x6e;&#x79;&#x68;&#x75;&#111;&#64;&#107;&#111;&#x74;&#x6c;&#105;&#x6e;&#x65;&#x72;&#46;&#x63;&#110;</a> 哈~</li>\n</ul>\n<hr>\n<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"Kotlin 1.4.30-RC 密封接口来啦！","keywords":"Kotlin News","date":"2021-01-22T16:00:00.000Z","description":null,"_content":"\n> 密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 \n\n\n\n<!-- more -->\n\n\n\n\n### Java 的密封接口\n\n我们先来看看 Java 的密封接口是怎么回事吧：\n\n```java\nsealed interface PlayerState permits Idle, Playing, Error { }\n\nfinal class Idle implements PlayerState { }\n\nfinal class Playing implements PlayerState { }\n\nfinal class Error implements PlayerState { }\n```\n\n功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。\n\n语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 `permits`，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。\n\n我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。\n\n说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 `--enable-preview` 参数，具体在 Gradle 当中可参考以下配置：\n\n```gradle\ncompileJava {\n    it.options.compilerArgs.add('--enable-preview')\n}\n```\n\n如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：\n\n```gradle\ncompileKotlin {\n    kotlinOptions {\n        languageVersion = \"1.5\" // Kotlin 1.5 experimental\n        freeCompilerArgs += \"-Xjvm-enable-preview\" // for java preview \n    }\n}\n```\n\n### 密封类型子类的子类\n\n那么灵魂拷问来了，不加 final 行不行？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png)\n\n三选一，\n\n第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的\n\n第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。\n\n啊？？那这样子类不就不受限制了吗？\n\n对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。\n\n第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。\n\n这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？\n\n非也非也！\n\nKotlin 的密封类的子类，也可以有子类的！列位请看：\n\n```kotlin\nclass Song\nclass Options\n\nsealed class PlayerState {\n    class Error(val t: Throwable): PlayerState()\n    object Idle: PlayerState()\n\n    open class Playing(val song: Song): PlayerState()\n    class PlayingWithOptions(song: Song, val options: Options): Playing(song)\n}\n```\n\nPlaying 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？\n\n当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。\n\n### Kotlin 的密封接口\n\n好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：\n\n```kotlin\nsealed interface PlayerState {\n    class Error(val t: Throwable): PlayerState\n    object Idle: PlayerState\n    open class Playing(val song: Song): PlayerState\n    class PlayingWithOptions(song: Song, val options: Options): Playing(song)\n}\n```\n\n为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png)\n\n而且你会神奇的发现，内联类跟密封接口可以一起使用了：\n\n```kotlin\nsealed interface PlayerState {\n    // 注意这里！\n    inline class Error(val t: Throwable): PlayerState\n\n    ...\n}\n```\n\n我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：\n\n```kotlin\nval playerState: PlayerState = Idle\n...\nplayerState = Error(...) // 装箱\n```\n\n所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。\n\n稍微提一句，官方在 [KT-42434 Release inline classes as Stable, secure Valhalla compatibility](https://youtrack.jetbrains.com/issue/KT-42434) 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 [Valhalla](https://openjdk.java.net/projects/valhalla/) 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-sealed-interface.md","raw":"---\ntitle:  Kotlin 1.4.30-RC 密封接口来啦！ \nkeywords: Kotlin News \ndate: 2021/01/23\ndescription: \ntags: \n    - kotlin\n    - news\n    - sealed interface \n---\n\n> 密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 \n\n\n\n<!-- more -->\n\n\n\n\n### Java 的密封接口\n\n我们先来看看 Java 的密封接口是怎么回事吧：\n\n```java\nsealed interface PlayerState permits Idle, Playing, Error { }\n\nfinal class Idle implements PlayerState { }\n\nfinal class Playing implements PlayerState { }\n\nfinal class Error implements PlayerState { }\n```\n\n功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。\n\n语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 `permits`，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。\n\n我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。\n\n说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 `--enable-preview` 参数，具体在 Gradle 当中可参考以下配置：\n\n```gradle\ncompileJava {\n    it.options.compilerArgs.add('--enable-preview')\n}\n```\n\n如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：\n\n```gradle\ncompileKotlin {\n    kotlinOptions {\n        languageVersion = \"1.5\" // Kotlin 1.5 experimental\n        freeCompilerArgs += \"-Xjvm-enable-preview\" // for java preview \n    }\n}\n```\n\n### 密封类型子类的子类\n\n那么灵魂拷问来了，不加 final 行不行？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png)\n\n三选一，\n\n第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的\n\n第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。\n\n啊？？那这样子类不就不受限制了吗？\n\n对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。\n\n第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。\n\n这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？\n\n非也非也！\n\nKotlin 的密封类的子类，也可以有子类的！列位请看：\n\n```kotlin\nclass Song\nclass Options\n\nsealed class PlayerState {\n    class Error(val t: Throwable): PlayerState()\n    object Idle: PlayerState()\n\n    open class Playing(val song: Song): PlayerState()\n    class PlayingWithOptions(song: Song, val options: Options): Playing(song)\n}\n```\n\nPlaying 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？\n\n当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。\n\n### Kotlin 的密封接口\n\n好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：\n\n```kotlin\nsealed interface PlayerState {\n    class Error(val t: Throwable): PlayerState\n    object Idle: PlayerState\n    open class Playing(val song: Song): PlayerState\n    class PlayingWithOptions(song: Song, val options: Options): Playing(song)\n}\n```\n\n为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png)\n\n而且你会神奇的发现，内联类跟密封接口可以一起使用了：\n\n```kotlin\nsealed interface PlayerState {\n    // 注意这里！\n    inline class Error(val t: Throwable): PlayerState\n\n    ...\n}\n```\n\n我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：\n\n```kotlin\nval playerState: PlayerState = Idle\n...\nplayerState = Error(...) // 装箱\n```\n\n所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。\n\n稍微提一句，官方在 [KT-42434 Release inline classes as Stable, secure Valhalla compatibility](https://youtrack.jetbrains.com/issue/KT-42434) 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 [Valhalla](https://openjdk.java.net/projects/valhalla/) 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。\n\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-sealed-interface","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003l002dlduz38cc792m","content":"<blockquote>\n<p>密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<h3 id=\"Java-的密封接口\"><a href=\"#Java-的密封接口\" class=\"headerlink\" title=\"Java 的密封接口\"></a>Java 的密封接口</h3><p>我们先来看看 Java 的密封接口是怎么回事吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealed <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> <span class=\"title\">permits</span> <span class=\"title\">Idle</span>, <span class=\"title\">Playing</span>, <span class=\"title\">Error</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Idle</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。</p>\n<p>语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 <code>permits</code>，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。</p>\n<p>我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。</p>\n<p>说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 <code>--enable-preview</code> 参数，具体在 Gradle 当中可参考以下配置：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileJava &#123;</span><br><span class=\"line\">    it.<span class=\"keyword\">options</span>.compilerArgs.add(<span class=\"string\">&#x27;--enable-preview&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileKotlin &#123;</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        languageVersion = <span class=\"string\">&quot;1.5&quot;</span> <span class=\"comment\">// Kotlin 1.5 experimental</span></span><br><span class=\"line\">        freeCompilerArgs += <span class=\"string\">&quot;-Xjvm-enable-preview&quot;</span> <span class=\"comment\">// for java preview </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"密封类型子类的子类\"><a href=\"#密封类型子类的子类\" class=\"headerlink\" title=\"密封类型子类的子类\"></a>密封类型子类的子类</h3><p>那么灵魂拷问来了，不加 final 行不行？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png\"></p>\n<p>三选一，</p>\n<p>第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的</p>\n<p>第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。</p>\n<p>啊？？那这样子类不就不受限制了吗？</p>\n<p>对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。</p>\n<p>第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。</p>\n<p>这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？</p>\n<p>非也非也！</p>\n<p>Kotlin 的密封类的子类，也可以有子类的！列位请看：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Options</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\">    <span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayingWithOptions</span></span>(song: Song, <span class=\"keyword\">val</span> options: Options): Playing(song)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Playing 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？</p>\n<p>当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。</p>\n<h3 id=\"Kotlin-的密封接口\"><a href=\"#Kotlin-的密封接口\" class=\"headerlink\" title=\"Kotlin 的密封接口\"></a>Kotlin 的密封接口</h3><p>好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState</span><br><span class=\"line\">    <span class=\"keyword\">object</span> Idle: PlayerState</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayingWithOptions</span></span>(song: Song, <span class=\"keyword\">val</span> options: Options): Playing(song)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png\"></p>\n<p>而且你会神奇的发现，内联类跟密封接口可以一起使用了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> playerState: PlayerState = Idle</span><br><span class=\"line\">...</span><br><span class=\"line\">playerState = Error(...) <span class=\"comment\">// 装箱</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。</p>\n<p>稍微提一句，官方在 <a href=\"https://youtrack.jetbrains.com/issue/KT-42434\">KT-42434 Release inline classes as Stable, secure Valhalla compatibility</a> 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 <a href=\"https://openjdk.java.net/projects/valhalla/\">Valhalla</a> 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 </p>\n</blockquote>","more":"<h3 id=\"Java-的密封接口\"><a href=\"#Java-的密封接口\" class=\"headerlink\" title=\"Java 的密封接口\"></a>Java 的密封接口</h3><p>我们先来看看 Java 的密封接口是怎么回事吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sealed <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> <span class=\"title\">permits</span> <span class=\"title\">Idle</span>, <span class=\"title\">Playing</span>, <span class=\"title\">Error</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Idle</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span> <span class=\"keyword\">implements</span> <span class=\"title\">PlayerState</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能上，与 Kotlin 的密封类类似，都是限制子类个数的，所以这一点儿不应当有什么理解上的困难。</p>\n<p>语法上，Java 秉持着它一贯的“啰嗦”的特点，在密封接口定义时，还要明确写出 <code>permits</code>，告诉大家这个接口只能够被以下几个类实现。你会不会感觉很奇怪，看一下后面这几行不就知道了，为什么还有加一个 permits？因为我们编写 Java 代码的时候，通常一个类就是一个文件，因此 Java 的密封接口不会去限制只能在文件内部定义实现类（就像 Kotlin 那样），因此 permits 是必须的。</p>\n<p>我们还注意到，PlayerState 的子类前面都加了个 final 关键字，意思就是不能被继承。这一点与 Kotlin 的密封类语法类似，Kotlin 当中类型默认就是 final 的，大家可能都没有注意过这个限制。</p>\n<p>说到这里，如果大家想要体验 Java 的密封接口的特性，需要给编译器添加 <code>--enable-preview</code> 参数，具体在 Gradle 当中可参考以下配置：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileJava &#123;</span><br><span class=\"line\">    it.<span class=\"keyword\">options</span>.compilerArgs.add(<span class=\"string\">&#x27;--enable-preview&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用 Kotlin 与 Java 15 互调用，在 Kotlin 1.4.30-RC 版本当中需要添加下面的参数：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compileKotlin &#123;</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        languageVersion = <span class=\"string\">&quot;1.5&quot;</span> <span class=\"comment\">// Kotlin 1.5 experimental</span></span><br><span class=\"line\">        freeCompilerArgs += <span class=\"string\">&quot;-Xjvm-enable-preview&quot;</span> <span class=\"comment\">// for java preview </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"密封类型子类的子类\"><a href=\"#密封类型子类的子类\" class=\"headerlink\" title=\"密封类型子类的子类\"></a>密封类型子类的子类</h3><p>那么灵魂拷问来了，不加 final 行不行？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png\"></p>\n<p>三选一，</p>\n<p>第一种：sealed，就是你自己也称为密封类，这样子类还是受限制的</p>\n<p>第二种： non-sealed，就是明确告诉大家，你不是密封类，而且不是 final，这意味着 Playing 这个类型是可以被其他类型继承的。</p>\n<p>啊？？那这样子类不就不受限制了吗？</p>\n<p>对呀，子类是不受限制了，但直接子类的个数还是有限的。也就是说密封类实际上限制的是直接子类的个数，这一点之前我们很少提到。</p>\n<p>第三种，final，这就比较好理解了，直接把子类的路堵死完事儿。</p>\n<p>这么看来，Java 除了支持密封接口以外，也是直接密封类的，而且还能允许密封接口或者密封类的 non-sealed 子类有其他子类，看上去是不是比 Kotlin 高级？</p>\n<p>非也非也！</p>\n<p>Kotlin 的密封类的子类，也可以有子类的！列位请看：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Options</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState()</span><br><span class=\"line\">    <span class=\"keyword\">object</span> Idle: PlayerState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState()</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayingWithOptions</span></span>(song: Song, <span class=\"keyword\">val</span> options: Options): Playing(song)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Playing 居然可以有个子类，叫做 PlayingWithOptions！这样搞，是不是密封类的特性就被破坏了呀？</p>\n<p>当然不是，密封类的子类除了 Error、Idle 以外，仍然只有一种可能，那就是 Playing。这很好理解，对吧。</p>\n<h3 id=\"Kotlin-的密封接口\"><a href=\"#Kotlin-的密封接口\" class=\"headerlink\" title=\"Kotlin 的密封接口\"></a>Kotlin 的密封接口</h3><p>好了，接下来我们终于要抬出 1.4.30-RC 当中新增的 Kotlin 的密封接口了，前面的 PlayerState 里面什么都没有，显然我们把它定义成接口更好：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState</span><br><span class=\"line\">    <span class=\"keyword\">object</span> Idle: PlayerState</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Playing</span></span>(<span class=\"keyword\">val</span> song: Song): PlayerState</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlayingWithOptions</span></span>(song: Song, <span class=\"keyword\">val</span> options: Options): Playing(song)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了配合密封接口的新特性，IDE 在创建 Kotlin 类型的时候也多了个选择：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-10-12-23.png\"></p>\n<p>而且你会神奇的发现，内联类跟密封接口可以一起使用了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sealed</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayerState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Error</span></span>(<span class=\"keyword\">val</span> t: Throwable): PlayerState</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在上一篇文章里面刚刚说到这事儿，虽然可以这么写，这样做意义并不大。因为密封类的子类在使用的过程中总是会声明成父类，这个过程总是会出现装箱：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> playerState: PlayerState = Idle</span><br><span class=\"line\">...</span><br><span class=\"line\">playerState = Error(...) <span class=\"comment\">// 装箱</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们几乎可以认为，内联类在密封类当中使用基本上都是错误的用法。</p>\n<p>稍微提一句，官方在 <a href=\"https://youtrack.jetbrains.com/issue/KT-42434\">KT-42434 Release inline classes as Stable, secure Valhalla compatibility</a> 当中明确了 inline class 将在 1.4.30 进入 Beta 阶段，在 1.5.0 进入稳定状态；不仅如此，为了配合 <a href=\"https://openjdk.java.net/projects/valhalla/\">Valhalla</a> 的 Value Type 特性，后续内联类计划被改名叫做 value class，这当然都是后面的事儿了，我们后面有机会再聊。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 1.4.30-RC 密封接口来啦！","path":"2021/01/23/kotlin-sealed-interface/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2021-01-23-09-51-41.png","excerpt":"<blockquote>\n<p>密封类是 Kotlin 的老成员了，现在也可以有密封接口了。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-01-22T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-01-22T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","news","sealed interface"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper","keywords":"Kotlin Swift Property","date":"2020-05-07T16:00:00.000Z","description":null,"_content":"\n> Swift 的属性代理，见识一下 \n\n\n\n<!-- more -->\n\n\n\n\n> Swift：我不是我没有别瞎说。\n\n本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。\n\n## Kotlin 的属性代理（Property Delegate）\n\n我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。\n\n### 简化存储的读写\n\nKotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：\n\n```kotlin\n[Kotlin]\n\n// write\nval prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)\nprefs.putString(key, value)\nprefs.apply()\n\n// read\nval value = prefs.getString(key, defaultValue)\n```\n\n这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。\n\n实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：\n\n```kotlin\n[Kotlin]\n\nvar loginName by pref(context, default = \"\")\n\n// save \"bennyhuo\" as key \"loginName\"\nloginName = \"bennyhuo\" \n\n// load key \"loginName\" from SharedPreferences\nval currentLoginName = loginName \n```\n\n请大家注意，`pref` 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 `loginName` 的读写等同于对 SharedPreferences 中的 \"loginName\" 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 `String` 为例给出实现：\n\n```kotlin\n[Kotlin]\n\nclass Preference<T>(val context: Context, val name: String, \n        val default: T, val prefName: String = \"default\") : ReadWriteProperty<Any?, T> {\n\n    val prefs by lazy { context.getSharedPreferences(prefName, Context.MODE_PRIVATE) }\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(findProperName(property), default)\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(findProperName(property), value)\n    }\n\n    private fun findProperName(property: KProperty<*>) = if(name.isEmpty()) property.name else name\n\n    private fun <U> findPreference(name: String, default: U): U = with(prefs) {\n        val res: Any = when (default) {\n            is String -> getString(name, default)\n            ...\n        }\n\n        res as U\n    }\n\n    private fun <U> putPreference(name: String, value: U) = with(prefs.edit()) {\n        when (value) {\n            is String -> putString(name, value)\n            ...\n        }.apply()\n    }\n}\n```\n\n其他数据类型的支持大家可以根据需要自行扩展。\n\n属性代理的本质就是 `getValue` 和 `setValue` 这两个方法，这里的代码实现了 `ReadWriteProperty` 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：\n\n```kotlin\n[Kotlin]\n\nclass Preference<T>(...) {\n\n    ...\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(findProperName(property), default)\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(findProperName(property), value)\n    }\n\n    ...\n}\n```\n\n原来 `getValue` 和 `setValue` 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。\n\n既然如此，那我们是不是还可以对 Java 的 `Properties` 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 `Properties` 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：[AbsProperties.kt](https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt)。\n\n官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：\n\n```kotlin\n[Kotlin]\n\nclass User(val map: Map<String, Any?>) {\n    val name : String by map\n    val age  : Int    by map\n}\n```\n\n我在很早的时候还专门写过一篇文章来介绍这个用法：[用 Map 为你的属性做代理](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd)。其实 `Map` 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？\n\n这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。\n\n### 控制属性的生命周期\n\n标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：\n\n```kotlin\n[Kotlin]\n\nval textView by lazy { rootView.findViewById(R.id.text) }\n```\n\n我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。\n\n我们再来看个例子。\n\nKotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity {\n    lateinit var image: Bitmap\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        image = null // Error!!\n    }\n}\n```\n\n`image` 在定义时如果定义为 `Bitmap?`，那么在不需要的时候自然是可以置为 `null` 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 `Bitmap`，用的时候倒是省事儿了，可是最后我们又无法将其置为 `null`。怎么办？\n\n有人说你这个是伪需求，不置为 `null` 也不会有内存泄露。不过，`Activity` 经常在 `onStop` 调用之后还会存续一段时间才会被销毁，对应的 `Bitmap` 对象也要晚一段时间才能被释放，不置为 `null` 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 `Bitmap` 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。\n\n但如果我们用属性代理来控制对象的内部逻辑呢：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity {\n    var image by releasableNotNull<Bitmap>()\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        // release the Bitmap instance.\n        ::image.release() \n    }\n}\n```\n\n我们通过 `releasableNotNull` 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：\n\n```kotlin\n[Kotlin]\n\nfun <T : Any> releasableNotNull() = ReleasableNotNull<T>()\n\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Not Initialized or released already.\")\n    }\n\n    fun isInitialized() = value != null\n\n    fun release() {\n        value = null\n    }\n}\n\nfun <R> KProperty0<R>.release() {\n    isAccessible = true\n    return (getDelegate() as? ReleasableNotNull<*>)?.release()\n        ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n}\n```\n\n我们通过对属性代理类 `ReleasableNotNull` 实现了对真正存储值的 `value` 的代理，前面对 `image` 的访问实际上就是对 `value` 的访问，而 `value` 的类型又是可空的，因此我们实现了既可将属性置为 `null` 又可将属性 `image` 声明为不可空的 `Bitmap` 类型的需求。\n\n这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 `com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0` 来使用它，也可以直接到我的 GitHub 上查看它的源码：[ReleasableVar](https://github.com/enbandari/ReleasableVar)，源码当中我也给出了不依赖 Kotlin 反射的实现方法。\n\n> 例子当中的 `KProperty0<R>.release` 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 `::image.release()` 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。\n\n### 代理其他类属性或者方法\n\n前面的例子都比较直观，我们再给大家看一个更复杂的用法。\n\n假设我们现在有这么一类，它有一些方法和属性：\n\n```kotlin\n[Kotlin]\n\nclass Wrapped(var x: Boolean) {\n    val z = 10L\n    fun setY(y: Int) {\n        ...\n    }\n\n    fun getY() = 12\n}\n```\n\n这个类的实例会被包在另一个类当中：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x: Boolean = ...\n    var y: Int = ...\n    val z: Long = ...\n}\n```\n\n我们在 `Wrapper` 类当中还想把 `Wrapped` 类的一些成员暴露给外部调用者，可能的实现就像这样：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x: Boolean\n        get() = wrapped.x\n        set(value) { wrapped.x = value }\n\n    ...\n}\n```\n\n这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x by wrapped::x.delegator()\n    ...\n}\n```\n\n属性代理本质上就是 `setValue` 和 `getValue`，所以代理 getter 和 setter `也是顺理成章。delegator` 函数是 `x` 的属性引用的扩展成员，定义也不复杂：\n\n```kotlin\n[Kotlin]\n\nfun <T> KProperty0<T>.delegator(initializedValue: T? = null)\n    : ReadWriteProperty<Any, T>\n        = ObjectPropertyDelegate0(\n            propertyRef = this as PropertyReference, \n            initializedValue = initializedValue\n        )\n\ninternal class ObjectPropertyDelegate0<T>(\n        val getter: (() -> T), \n        val setter: ((T) -> Unit)? = null, \n        initializedValue: T? = null) : ReadWriteProperty<Any, T> {\n\n    constructor(\n        propertyRef: PropertyReference, \n        initializedValue: T? = null\n        ): this(\n            (propertyRef as KProperty0<T>)::get, \n            if (propertyRef is KMutableProperty0<*>) (propertyRef as KMutableProperty0<T>)::set else null, initializedValue\n        )\n\n    init {\n        initializedValue?.let { setter?.invoke(it) }\n    }\n\n    override operator fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return getter.invoke()\n    }\n\n    override operator fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        setter?.invoke(value)\n    }\n}\n```\n\n这有点儿像请求转发一样，对 `Wrapper` 的属性 `x` 的读写直接转发给了 `Wrapped` 的属性 `x` 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 `Wrapped` 的 `getY` 也可以代理成一个只读属性，`setY` 也可以单独代理成一个可变属性：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var y by wrapped::setY.delegator(defaultValue = 0)\n    val yGetter by wrapped::getY.delegator()\n    ...\n}\n```\n\n对于 `getY` 的代理比较容易理解。对于 `setY` 的代理就有些奇怪了，属性 `y` 只代理了 `wrapped::setY`，那读取 `y` 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 `View` 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。\n\n当然，类似的扩展我们还可以做很多，甚至支持 lazy：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity() {\n\n    val name by delegateLazyOf(TextView::getText, TextView::setText) { textView }\n\n}\n```\n\n我们前面的例子当中 `wrapped` 从一开始就被初始化了，而这个例子当中 `textView` 需要等到 `Activity` 的 `onCreate` 调用之后才会初始化，因此 `lazy` 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：[ObjectPropertyDelegate](https://github.com/enbandari/ObjectPropertyDelegate)，大家也可以通过引入 `com.bennyhuo.kotlin:delegates:1.0` 来直接使用它。\n\n需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：\n\n```kotlin\n[Kotlin]\n\nclass MyClass {\n   var newName: Int = 0\n   @Deprecated(\"Use 'newName' instead\", ReplaceWith(\"newName\"))\n   var oldName: Int by this::newName\n}\n```\n\n这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 `KProperty0<R>` 实现了 `getValue` 和 `setValue` 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：\n\n```kotlin\n[Kotlin]\n\noperator fun <R> KProperty0<R>.getValue(thisRef: Any, property: KProperty<*>): R {\n    return get()\n}\n\noperator fun <R> KMutableProperty0<R>.setValue(thisRef: Any, property: KProperty<*>, value: R) {\n    set(value)\n}\n```\n\n这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 `KProperty0` 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。\n\n## Swift 的属性包装器（Property Wrapper）\n\nSwift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。\n\n大家也可以参考 [Swift 的属性包装器的设计文档](https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults)，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。\n\n这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 \"diss\" 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。\n\n### 代理 UserDefaults\n\n`UserDefaults` 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：\n\n```swift\n[Swift]\n\n@propertyWrapper\nstruct UserDefault<T> {\n    let key: String\n    let defaultValue: T\n\n    var wrappedValue: T {\n        get {\n            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue\n        }\n        set {\n            UserDefaults.standard.set(newValue, forKey: key)\n        }\n    }\n}\n```\n\n通过 `@PropertyWrapper` 将 `UserDefault` 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 `wrappedValue` 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 `wrappedValue` 的访问上。用法也很直接：\n\n```swift\n[Swift]\n\nenum GlobalSettings {\n    @UserDefault(key: \"FOO_FEATURE_ENABLED\", defaultValue: false)\n    static var isFooFeatureEnabled: Bool\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n}\n```\n\n这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。\n\n稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。\n\n除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 `getValue` 和 `setValue` 的实现，不同之处在于 Kotlin 在 `getValue` 和 `setValue` 中提供了 `KProperty` 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。\n\n相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：\n\n```kotlin\n[Kotlin]\n\ninterface PropertyWrapper<Value> {\n\n    var wrappedValue: Value\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): Value = wrappedValue\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: Value) {\n        wrappedValue = value\n    }\n}\n```\n\n按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：\n\n```kotlin\n[Kotlin]\n\nclass ObservableDelegate<Value>(\n    initializedValue: Value,\n    val changedListener: (previous: Value, current: Value) -> Unit\n) : PropertyWrapper<Value> {\n    override var wrappedValue: Value = initializedValue\n        set(value) {\n            val previous = field\n            field = value\n            changedListener(previous, value)\n        }\n}\n```\n\n用法没有什么特殊之处：\n\n```kotlin\n[Kotlin]\n\nvar state: Int by ObservableDelegate(0) { previous, current ->\n    println(\"changed $previous -> $current\")\n}\nstate = 2 // changed 0 -> 2\nstate = 3 // changed 2 -> 3\nstate = 4 // changed 3 -> 4\n```\n\n### 属性包装器的 projectedValue\n\n我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。\n\n我们来看一个简单的例子：\n\n```swift\n[Swift]\n\nstruct TestView: View {\n    \n    @State var isEnabled: Bool\n    \n    var body: some View {\n        Toggle(isOn: $isEnabled) {\n            isEnabled ? Text(\"Click to disable\").foregroundColor(.red)\n                : Text(\"Click to enable\").foregroundColor(.green)\n        }.padding()\n    }\n}\n```\n\n`body` 是布局的 View，里面只有一个控件就是一个开关 `Toggle`，它需要与 `isEnabled` 这个属性绑定，UI 的效果如下：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png)\n\n**<center>isEnabled 为 false 时的 UI</center>**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png)\n\n**<center>isEnabled 为 true 时的 UI</center>**\n\n`isEnabled` 这个属性被 `State` 这个属性包装器包装，`State` 为它提供了一个 `projectedValue` 的属性，这个 `projectedValue` 可以通过 **`$` + 属性名** 来获取，也就是说作为 `Toggle` 的参数 `isOn` 的 `$isEnabled` 实际上就是 `isEnabled` 这个属性的包装器提供的 `projectValue`。\n\n这个 `projectedValue` 实际上也是一个属性包装器，它的类型是 `Binding<Bool>`，`Binding` 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 `wrapped::x.delegator()`，它的作用就是提供了属性的 getter 和 setter，这样我们将 `Binding<Bool>` 对象传给 `Toggle` 的时候，它就可以在其中方便的修改 `isEnabled` 这个属性了。\n\n`State` 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 `DynamicProperty` 协议，可以在属性被修改时调用 `update` 方法来刷新 UI。\n\n下面我们给出 `State` 的声明，具体实现没有开源，但可以想到的是在 `wrappedValue` 的 setter 调用时一定会触发 `DynamicProperty` 协议的 `update` 方法的调用，`projectedValue` 则是返回一个包装了被 `State` 包装的属性的 getter 和 setter 的对象：\n\n```swift\n[Swift]\n\n@frozen @propertyWrapper public struct State<Value> : DynamicProperty {\n\n    /// Initialize with the provided initial value.\n    public init(wrappedValue value: Value)\n\n    /// Initialize with the provided initial value.\n    public init(initialValue value: Value)\n\n    /// The current state value.\n    public var wrappedValue: Value { get nonmutating set }\n\n    /// Produces the binding referencing this state value\n    public var projectedValue: Binding<Value> { get }\n}\n```\n\n下面我们考虑下 Kotlin 当中是否存在对应的特性。\n\n对于 `Binding` 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：\n\n```kotlin\n[Kotlin]\n\nclass View {\n    var isEnabled: Boolean = false\n}\n\n// get property reference\nval view = View()\nval isEnabledRef = view::isEnabled\n\n// operate on property reference\nisEnabledRef.set(true)\nprintln(isEnabledRef.get())\n```\n\n也就是说，Swift UI 当中的 `Binding` 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。\n\n但可以确定的是，Kotlin 当中没有 `projectedValue` 这样的特性，即便我们在前面模拟 Swift 声明的 `PropertyWrapper` 接口中添加这样的属性，我们也没有直接的类似于 `$isEnabled` 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 `projectedValue` 直接返回自身（也可以返回别的，例如 `State` 中就没有返回自己，而是返回了 `Binding`）：\n\n```swift\n[Swift]\n\n@propertyWrapper\nstruct UserDefault<T> {\n    let key: String\n    let defaultValue: T\n\n    var wrappedValue: T {\n        ...\n    }\n\n    var projectedValue: UserDefault<T> {\n        get { self }\n    }\n}\n\nenum GlobalSettings {\n    @UserDefault(key: \"FOO_FEATURE_ENABLED\", defaultValue: false)\n    static var isFooFeatureEnabled: Bool\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n}\n\n// false\nprint(GlobalSettings.isBarFeatureEnabled) \n\n// UserDefault<Bool>(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\nprint(GlobalSettings.$isBarFeatureEnabled) \n\n// false\nprint(GlobalSettings.$isBarFeatureEnabled.wrappedValue) \n\n// UserDefault<Bool>(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\nprint(GlobalSettings.$isBarFeatureEnabled.projectedValue) \n```\n\n实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：\n\n```swift\n[Swift]\n\nenum GlobalSettings {\n    ...\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n\n    static func getIsBarFeatureEnabledWrapper() -> UserDefault<Bool> {\n        _isBarFeatureEnabled\n    }\n}\n```\n\n访问 `_isBarFeatureEnabled` 得到的就是包装 `isBarFeatureEnabled` 的实例。\n\n而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 `getDelegate` 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 `Any?` 也同样不如 Swift 当中可以通过 `$` 直接获取 `projectedValue` 以及通过 `_` 获取属性包装器实例来的直接和安全。更何况 `getDelegate` 这个反射方法目前只能在 JVM 上使用，无法实现多平台。\n\n```kotlin\n[Kotlin]\n\npublic actual interface KProperty0<out R> : KProperty<R>, () -> R {\n\n    /**\n     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.\n     */\n    @SinceKotlin(\"1.1\")\n    public fun getDelegate(): Any?\n\n    ...\n}\n\n```\n\n当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：\n\n```kotlin\n[Kotlin]\nval delegate = ObservableDelegate(0) { previous, current ->\n    println(\"changed $previous -> $current\")\n}\n\nvar state by delegate\n```\n\n但这个写法又显得 `delegate` 与 `state` 的联系没有那么紧密，因此 Swift 的属性包装器在 `projectedValue` 的设计上为开发者提供了更大的发挥空间。\n\nKotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 `projectedValue` 的功能，也许可以借助一下 Kotlin 编译器插件来完成。\n\n## 小结\n\n属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。\n\nKotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 `getValue` 和 `setValue` 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 `Any?`，没有静态类型的约束。\n\n相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/kotlin-swift-property-delegate.md","raw":"---\ntitle:  Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper  \nkeywords: Kotlin Swift Property \ndate: 2020/05/08\ndescription: \ntags: \n    - kotlin\n    - swift\n    - property \n---\n\n> Swift 的属性代理，见识一下 \n\n\n\n<!-- more -->\n\n\n\n\n> Swift：我不是我没有别瞎说。\n\n本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。\n\n## Kotlin 的属性代理（Property Delegate）\n\n我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。\n\n### 简化存储的读写\n\nKotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：\n\n```kotlin\n[Kotlin]\n\n// write\nval prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)\nprefs.putString(key, value)\nprefs.apply()\n\n// read\nval value = prefs.getString(key, defaultValue)\n```\n\n这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。\n\n实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：\n\n```kotlin\n[Kotlin]\n\nvar loginName by pref(context, default = \"\")\n\n// save \"bennyhuo\" as key \"loginName\"\nloginName = \"bennyhuo\" \n\n// load key \"loginName\" from SharedPreferences\nval currentLoginName = loginName \n```\n\n请大家注意，`pref` 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 `loginName` 的读写等同于对 SharedPreferences 中的 \"loginName\" 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 `String` 为例给出实现：\n\n```kotlin\n[Kotlin]\n\nclass Preference<T>(val context: Context, val name: String, \n        val default: T, val prefName: String = \"default\") : ReadWriteProperty<Any?, T> {\n\n    val prefs by lazy { context.getSharedPreferences(prefName, Context.MODE_PRIVATE) }\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(findProperName(property), default)\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(findProperName(property), value)\n    }\n\n    private fun findProperName(property: KProperty<*>) = if(name.isEmpty()) property.name else name\n\n    private fun <U> findPreference(name: String, default: U): U = with(prefs) {\n        val res: Any = when (default) {\n            is String -> getString(name, default)\n            ...\n        }\n\n        res as U\n    }\n\n    private fun <U> putPreference(name: String, value: U) = with(prefs.edit()) {\n        when (value) {\n            is String -> putString(name, value)\n            ...\n        }.apply()\n    }\n}\n```\n\n其他数据类型的支持大家可以根据需要自行扩展。\n\n属性代理的本质就是 `getValue` 和 `setValue` 这两个方法，这里的代码实现了 `ReadWriteProperty` 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：\n\n```kotlin\n[Kotlin]\n\nclass Preference<T>(...) {\n\n    ...\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return findPreference(findProperName(property), default)\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putPreference(findProperName(property), value)\n    }\n\n    ...\n}\n```\n\n原来 `getValue` 和 `setValue` 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。\n\n既然如此，那我们是不是还可以对 Java 的 `Properties` 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 `Properties` 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：[AbsProperties.kt](https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt)。\n\n官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：\n\n```kotlin\n[Kotlin]\n\nclass User(val map: Map<String, Any?>) {\n    val name : String by map\n    val age  : Int    by map\n}\n```\n\n我在很早的时候还专门写过一篇文章来介绍这个用法：[用 Map 为你的属性做代理](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd)。其实 `Map` 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？\n\n这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。\n\n### 控制属性的生命周期\n\n标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：\n\n```kotlin\n[Kotlin]\n\nval textView by lazy { rootView.findViewById(R.id.text) }\n```\n\n我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。\n\n我们再来看个例子。\n\nKotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity {\n    lateinit var image: Bitmap\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        image = null // Error!!\n    }\n}\n```\n\n`image` 在定义时如果定义为 `Bitmap?`，那么在不需要的时候自然是可以置为 `null` 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 `Bitmap`，用的时候倒是省事儿了，可是最后我们又无法将其置为 `null`。怎么办？\n\n有人说你这个是伪需求，不置为 `null` 也不会有内存泄露。不过，`Activity` 经常在 `onStop` 调用之后还会存续一段时间才会被销毁，对应的 `Bitmap` 对象也要晚一段时间才能被释放，不置为 `null` 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 `Bitmap` 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。\n\n但如果我们用属性代理来控制对象的内部逻辑呢：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity {\n    var image by releasableNotNull<Bitmap>()\n    \n    override fun onStart(){\n        super.onStart()\n        image = Bitmap.create(...)\n    }\n    \n    override fun onStop(){\n        super.onStop()\n        image.recycle()\n        // release the Bitmap instance.\n        ::image.release() \n    }\n}\n```\n\n我们通过 `releasableNotNull` 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：\n\n```kotlin\n[Kotlin]\n\nfun <T : Any> releasableNotNull() = ReleasableNotNull<T>()\n\nclass ReleasableNotNull<T : Any> : ReadWriteProperty<Any, T> {\n\n    private var value: T? = null\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return value ?: throw IllegalStateException(\"Not Initialized or released already.\")\n    }\n\n    fun isInitialized() = value != null\n\n    fun release() {\n        value = null\n    }\n}\n\nfun <R> KProperty0<R>.release() {\n    isAccessible = true\n    return (getDelegate() as? ReleasableNotNull<*>)?.release()\n        ?: throw IllegalAccessException(\"Delegate is null or is not an instance of ReleasableNotNull.\")\n}\n```\n\n我们通过对属性代理类 `ReleasableNotNull` 实现了对真正存储值的 `value` 的代理，前面对 `image` 的访问实际上就是对 `value` 的访问，而 `value` 的类型又是可空的，因此我们实现了既可将属性置为 `null` 又可将属性 `image` 声明为不可空的 `Bitmap` 类型的需求。\n\n这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 `com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0` 来使用它，也可以直接到我的 GitHub 上查看它的源码：[ReleasableVar](https://github.com/enbandari/ReleasableVar)，源码当中我也给出了不依赖 Kotlin 反射的实现方法。\n\n> 例子当中的 `KProperty0<R>.release` 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 `::image.release()` 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。\n\n### 代理其他类属性或者方法\n\n前面的例子都比较直观，我们再给大家看一个更复杂的用法。\n\n假设我们现在有这么一类，它有一些方法和属性：\n\n```kotlin\n[Kotlin]\n\nclass Wrapped(var x: Boolean) {\n    val z = 10L\n    fun setY(y: Int) {\n        ...\n    }\n\n    fun getY() = 12\n}\n```\n\n这个类的实例会被包在另一个类当中：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x: Boolean = ...\n    var y: Int = ...\n    val z: Long = ...\n}\n```\n\n我们在 `Wrapper` 类当中还想把 `Wrapped` 类的一些成员暴露给外部调用者，可能的实现就像这样：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x: Boolean\n        get() = wrapped.x\n        set(value) { wrapped.x = value }\n\n    ...\n}\n```\n\n这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var x by wrapped::x.delegator()\n    ...\n}\n```\n\n属性代理本质上就是 `setValue` 和 `getValue`，所以代理 getter 和 setter `也是顺理成章。delegator` 函数是 `x` 的属性引用的扩展成员，定义也不复杂：\n\n```kotlin\n[Kotlin]\n\nfun <T> KProperty0<T>.delegator(initializedValue: T? = null)\n    : ReadWriteProperty<Any, T>\n        = ObjectPropertyDelegate0(\n            propertyRef = this as PropertyReference, \n            initializedValue = initializedValue\n        )\n\ninternal class ObjectPropertyDelegate0<T>(\n        val getter: (() -> T), \n        val setter: ((T) -> Unit)? = null, \n        initializedValue: T? = null) : ReadWriteProperty<Any, T> {\n\n    constructor(\n        propertyRef: PropertyReference, \n        initializedValue: T? = null\n        ): this(\n            (propertyRef as KProperty0<T>)::get, \n            if (propertyRef is KMutableProperty0<*>) (propertyRef as KMutableProperty0<T>)::set else null, initializedValue\n        )\n\n    init {\n        initializedValue?.let { setter?.invoke(it) }\n    }\n\n    override operator fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return getter.invoke()\n    }\n\n    override operator fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        setter?.invoke(value)\n    }\n}\n```\n\n这有点儿像请求转发一样，对 `Wrapper` 的属性 `x` 的读写直接转发给了 `Wrapped` 的属性 `x` 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 `Wrapped` 的 `getY` 也可以代理成一个只读属性，`setY` 也可以单独代理成一个可变属性：\n\n```kotlin\n[Kotlin]\n\nclass Wrapper {\n    private val wrapped: Wrapped = Wrapped(false)\n\n    var y by wrapped::setY.delegator(defaultValue = 0)\n    val yGetter by wrapped::getY.delegator()\n    ...\n}\n```\n\n对于 `getY` 的代理比较容易理解。对于 `setY` 的代理就有些奇怪了，属性 `y` 只代理了 `wrapped::setY`，那读取 `y` 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 `View` 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。\n\n当然，类似的扩展我们还可以做很多，甚至支持 lazy：\n\n```kotlin\n[Kotlin]\n\nclass MainActivity: Activity() {\n\n    val name by delegateLazyOf(TextView::getText, TextView::setText) { textView }\n\n}\n```\n\n我们前面的例子当中 `wrapped` 从一开始就被初始化了，而这个例子当中 `textView` 需要等到 `Activity` 的 `onCreate` 调用之后才会初始化，因此 `lazy` 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：[ObjectPropertyDelegate](https://github.com/enbandari/ObjectPropertyDelegate)，大家也可以通过引入 `com.bennyhuo.kotlin:delegates:1.0` 来直接使用它。\n\n需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：\n\n```kotlin\n[Kotlin]\n\nclass MyClass {\n   var newName: Int = 0\n   @Deprecated(\"Use 'newName' instead\", ReplaceWith(\"newName\"))\n   var oldName: Int by this::newName\n}\n```\n\n这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 `KProperty0<R>` 实现了 `getValue` 和 `setValue` 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：\n\n```kotlin\n[Kotlin]\n\noperator fun <R> KProperty0<R>.getValue(thisRef: Any, property: KProperty<*>): R {\n    return get()\n}\n\noperator fun <R> KMutableProperty0<R>.setValue(thisRef: Any, property: KProperty<*>, value: R) {\n    set(value)\n}\n```\n\n这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 `KProperty0` 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。\n\n## Swift 的属性包装器（Property Wrapper）\n\nSwift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。\n\n大家也可以参考 [Swift 的属性包装器的设计文档](https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults)，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。\n\n这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 \"diss\" 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。\n\n### 代理 UserDefaults\n\n`UserDefaults` 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：\n\n```swift\n[Swift]\n\n@propertyWrapper\nstruct UserDefault<T> {\n    let key: String\n    let defaultValue: T\n\n    var wrappedValue: T {\n        get {\n            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue\n        }\n        set {\n            UserDefaults.standard.set(newValue, forKey: key)\n        }\n    }\n}\n```\n\n通过 `@PropertyWrapper` 将 `UserDefault` 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 `wrappedValue` 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 `wrappedValue` 的访问上。用法也很直接：\n\n```swift\n[Swift]\n\nenum GlobalSettings {\n    @UserDefault(key: \"FOO_FEATURE_ENABLED\", defaultValue: false)\n    static var isFooFeatureEnabled: Bool\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n}\n```\n\n这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。\n\n稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。\n\n除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 `getValue` 和 `setValue` 的实现，不同之处在于 Kotlin 在 `getValue` 和 `setValue` 中提供了 `KProperty` 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。\n\n相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：\n\n```kotlin\n[Kotlin]\n\ninterface PropertyWrapper<Value> {\n\n    var wrappedValue: Value\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): Value = wrappedValue\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: Value) {\n        wrappedValue = value\n    }\n}\n```\n\n按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：\n\n```kotlin\n[Kotlin]\n\nclass ObservableDelegate<Value>(\n    initializedValue: Value,\n    val changedListener: (previous: Value, current: Value) -> Unit\n) : PropertyWrapper<Value> {\n    override var wrappedValue: Value = initializedValue\n        set(value) {\n            val previous = field\n            field = value\n            changedListener(previous, value)\n        }\n}\n```\n\n用法没有什么特殊之处：\n\n```kotlin\n[Kotlin]\n\nvar state: Int by ObservableDelegate(0) { previous, current ->\n    println(\"changed $previous -> $current\")\n}\nstate = 2 // changed 0 -> 2\nstate = 3 // changed 2 -> 3\nstate = 4 // changed 3 -> 4\n```\n\n### 属性包装器的 projectedValue\n\n我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。\n\n我们来看一个简单的例子：\n\n```swift\n[Swift]\n\nstruct TestView: View {\n    \n    @State var isEnabled: Bool\n    \n    var body: some View {\n        Toggle(isOn: $isEnabled) {\n            isEnabled ? Text(\"Click to disable\").foregroundColor(.red)\n                : Text(\"Click to enable\").foregroundColor(.green)\n        }.padding()\n    }\n}\n```\n\n`body` 是布局的 View，里面只有一个控件就是一个开关 `Toggle`，它需要与 `isEnabled` 这个属性绑定，UI 的效果如下：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png)\n\n**<center>isEnabled 为 false 时的 UI</center>**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png)\n\n**<center>isEnabled 为 true 时的 UI</center>**\n\n`isEnabled` 这个属性被 `State` 这个属性包装器包装，`State` 为它提供了一个 `projectedValue` 的属性，这个 `projectedValue` 可以通过 **`$` + 属性名** 来获取，也就是说作为 `Toggle` 的参数 `isOn` 的 `$isEnabled` 实际上就是 `isEnabled` 这个属性的包装器提供的 `projectValue`。\n\n这个 `projectedValue` 实际上也是一个属性包装器，它的类型是 `Binding<Bool>`，`Binding` 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 `wrapped::x.delegator()`，它的作用就是提供了属性的 getter 和 setter，这样我们将 `Binding<Bool>` 对象传给 `Toggle` 的时候，它就可以在其中方便的修改 `isEnabled` 这个属性了。\n\n`State` 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 `DynamicProperty` 协议，可以在属性被修改时调用 `update` 方法来刷新 UI。\n\n下面我们给出 `State` 的声明，具体实现没有开源，但可以想到的是在 `wrappedValue` 的 setter 调用时一定会触发 `DynamicProperty` 协议的 `update` 方法的调用，`projectedValue` 则是返回一个包装了被 `State` 包装的属性的 getter 和 setter 的对象：\n\n```swift\n[Swift]\n\n@frozen @propertyWrapper public struct State<Value> : DynamicProperty {\n\n    /// Initialize with the provided initial value.\n    public init(wrappedValue value: Value)\n\n    /// Initialize with the provided initial value.\n    public init(initialValue value: Value)\n\n    /// The current state value.\n    public var wrappedValue: Value { get nonmutating set }\n\n    /// Produces the binding referencing this state value\n    public var projectedValue: Binding<Value> { get }\n}\n```\n\n下面我们考虑下 Kotlin 当中是否存在对应的特性。\n\n对于 `Binding` 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：\n\n```kotlin\n[Kotlin]\n\nclass View {\n    var isEnabled: Boolean = false\n}\n\n// get property reference\nval view = View()\nval isEnabledRef = view::isEnabled\n\n// operate on property reference\nisEnabledRef.set(true)\nprintln(isEnabledRef.get())\n```\n\n也就是说，Swift UI 当中的 `Binding` 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。\n\n但可以确定的是，Kotlin 当中没有 `projectedValue` 这样的特性，即便我们在前面模拟 Swift 声明的 `PropertyWrapper` 接口中添加这样的属性，我们也没有直接的类似于 `$isEnabled` 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 `projectedValue` 直接返回自身（也可以返回别的，例如 `State` 中就没有返回自己，而是返回了 `Binding`）：\n\n```swift\n[Swift]\n\n@propertyWrapper\nstruct UserDefault<T> {\n    let key: String\n    let defaultValue: T\n\n    var wrappedValue: T {\n        ...\n    }\n\n    var projectedValue: UserDefault<T> {\n        get { self }\n    }\n}\n\nenum GlobalSettings {\n    @UserDefault(key: \"FOO_FEATURE_ENABLED\", defaultValue: false)\n    static var isFooFeatureEnabled: Bool\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n}\n\n// false\nprint(GlobalSettings.isBarFeatureEnabled) \n\n// UserDefault<Bool>(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\nprint(GlobalSettings.$isBarFeatureEnabled) \n\n// false\nprint(GlobalSettings.$isBarFeatureEnabled.wrappedValue) \n\n// UserDefault<Bool>(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\nprint(GlobalSettings.$isBarFeatureEnabled.projectedValue) \n```\n\n实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：\n\n```swift\n[Swift]\n\nenum GlobalSettings {\n    ...\n\n    @UserDefault(key: \"BAR_FEATURE_ENABLED\", defaultValue: false)\n    static var isBarFeatureEnabled: Bool\n\n    static func getIsBarFeatureEnabledWrapper() -> UserDefault<Bool> {\n        _isBarFeatureEnabled\n    }\n}\n```\n\n访问 `_isBarFeatureEnabled` 得到的就是包装 `isBarFeatureEnabled` 的实例。\n\n而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 `getDelegate` 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 `Any?` 也同样不如 Swift 当中可以通过 `$` 直接获取 `projectedValue` 以及通过 `_` 获取属性包装器实例来的直接和安全。更何况 `getDelegate` 这个反射方法目前只能在 JVM 上使用，无法实现多平台。\n\n```kotlin\n[Kotlin]\n\npublic actual interface KProperty0<out R> : KProperty<R>, () -> R {\n\n    /**\n     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.\n     */\n    @SinceKotlin(\"1.1\")\n    public fun getDelegate(): Any?\n\n    ...\n}\n\n```\n\n当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：\n\n```kotlin\n[Kotlin]\nval delegate = ObservableDelegate(0) { previous, current ->\n    println(\"changed $previous -> $current\")\n}\n\nvar state by delegate\n```\n\n但这个写法又显得 `delegate` 与 `state` 的联系没有那么紧密，因此 Swift 的属性包装器在 `projectedValue` 的设计上为开发者提供了更大的发挥空间。\n\nKotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 `projectedValue` 的功能，也许可以借助一下 Kotlin 编译器插件来完成。\n\n## 小结\n\n属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。\n\nKotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 `getValue` 和 `setValue` 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 `Any?`，没有静态类型的约束。\n\n相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。\n\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"kotlin-swift-property-delegate","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003l002elduzegred8b9","content":"<blockquote>\n<p>Swift 的属性代理，见识一下 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<blockquote>\n<p>Swift：我不是我没有别瞎说。</p>\n</blockquote>\n<p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p>\n<h2 id=\"Kotlin-的属性代理（Property-Delegate）\"><a href=\"#Kotlin-的属性代理（Property-Delegate）\" class=\"headerlink\" title=\"Kotlin 的属性代理（Property Delegate）\"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p>\n<h3 id=\"简化存储的读写\"><a href=\"#简化存储的读写\" class=\"headerlink\" title=\"简化存储的读写\"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// write</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class=\"line\">prefs.putString(key, value)</span><br><span class=\"line\">prefs.apply()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure>\n\n<p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p>\n<p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> loginName <span class=\"keyword\">by</span> pref(context, default = <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save &quot;bennyhuo&quot; as key &quot;loginName&quot;</span></span><br><span class=\"line\">loginName = <span class=\"string\">&quot;bennyhuo&quot;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load key &quot;loginName&quot; from SharedPreferences</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> currentLoginName = loginName </span><br></pre></td></tr></table></figure>\n\n<p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preference</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> name: String, </span><br><span class=\"line\">        <span class=\"keyword\">val</span> default: T, <span class=\"keyword\">val</span> prefName: String = <span class=\"string\">&quot;default&quot;</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> prefs <span class=\"keyword\">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(findProperName(property), default)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        putPreference(findProperName(property), value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">findProperName</span><span class=\"params\">(property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span> = <span class=\"keyword\">if</span>(name.isEmpty()) property.name <span class=\"keyword\">else</span> name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;U&gt;</span> <span class=\"title\">findPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, default: <span class=\"type\">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> res: Any = <span class=\"keyword\">when</span> (default) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; getString(name, default)</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res <span class=\"keyword\">as</span> U</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;U&gt;</span> <span class=\"title\">putPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, value: <span class=\"type\">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; putString(name, value)</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他数据类型的支持大家可以根据需要自行扩展。</p>\n<p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preference</span>&lt;<span class=\"type\">T</span>&gt;</span>(...) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(findProperName(property), default)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        putPreference(findProperName(property), value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p>\n<p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href=\"https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt\">AbsProperties.kt</a>。</p>\n<p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name : String <span class=\"keyword\">by</span> map</span><br><span class=\"line\">    <span class=\"keyword\">val</span> age  : <span class=\"built_in\">Int</span>    <span class=\"keyword\">by</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd\">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p>\n<p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p>\n<h3 id=\"控制属性的生命周期\"><a href=\"#控制属性的生命周期\" class=\"headerlink\" title=\"控制属性的生命周期\"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> textView <span class=\"keyword\">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p>\n<p>我们再来看个例子。</p>\n<p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> image: Bitmap</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        image = <span class=\"literal\">null</span> <span class=\"comment\">// Error!!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p>\n<p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p>\n<p>但如果我们用属性代理来控制对象的内部逻辑呢：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> image <span class=\"keyword\">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        <span class=\"comment\">// release the Bitmap instance.</span></span><br><span class=\"line\">        ::image.release() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> <span class=\"title\">releasableNotNull</span><span class=\"params\">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isInitialized</span><span class=\"params\">()</span></span> = value != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        value = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class=\"line\">        ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p>\n<p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href=\"https://github.com/enbandari/ReleasableVar\">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p>\n<blockquote>\n<p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p>\n</blockquote>\n<h3 id=\"代理其他类属性或者方法\"><a href=\"#代理其他类属性或者方法\" class=\"headerlink\" title=\"代理其他类属性或者方法\"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p>\n<p>假设我们现在有这么一类，它有一些方法和属性：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapped</span></span>(<span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> z = <span class=\"number\">10L</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setY</span><span class=\"params\">(y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getY</span><span class=\"params\">()</span></span> = <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类的实例会被包在另一个类当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span> = ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"built_in\">Int</span> = ...</span><br><span class=\"line\">    <span class=\"keyword\">val</span> z: <span class=\"built_in\">Long</span> = ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = wrapped.x</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x <span class=\"keyword\">by</span> wrapped::x.delegator()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> KProperty0<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">delegator</span><span class=\"params\">(initializedValue: <span class=\"type\">T</span>? = <span class=\"literal\">null</span>)</span></span></span><br><span class=\"line\">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class=\"line\">        = ObjectPropertyDelegate0(</span><br><span class=\"line\">            propertyRef = <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> PropertyReference, </span><br><span class=\"line\">            initializedValue = initializedValue</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectPropertyDelegate0</span>&lt;<span class=\"type\">T</span>&gt;</span>(</span><br><span class=\"line\">        <span class=\"keyword\">val</span> getter: (() -&gt; T), </span><br><span class=\"line\">        <span class=\"keyword\">val</span> setter: ((T) -&gt; <span class=\"built_in\">Unit</span>)? = <span class=\"literal\">null</span>, </span><br><span class=\"line\">        initializedValue: T? = <span class=\"literal\">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(</span><br><span class=\"line\">        propertyRef: PropertyReference, </span><br><span class=\"line\">        initializedValue: T? = <span class=\"literal\">null</span></span><br><span class=\"line\">        ): <span class=\"keyword\">this</span>(</span><br><span class=\"line\">            (propertyRef <span class=\"keyword\">as</span> KProperty0&lt;T&gt;)::<span class=\"keyword\">get</span>, </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (propertyRef <span class=\"keyword\">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class=\"keyword\">as</span> KMutableProperty0&lt;T&gt;)::<span class=\"keyword\">set</span> <span class=\"keyword\">else</span> <span class=\"literal\">null</span>, initializedValue</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getter.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        setter?.invoke(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y <span class=\"keyword\">by</span> wrapped::setY.delegator(defaultValue = <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> yGetter <span class=\"keyword\">by</span> wrapped::getY.delegator()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p>\n<p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name <span class=\"keyword\">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href=\"https://github.com/enbandari/ObjectPropertyDelegate\">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p>\n<p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> newName: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"meta\">@Deprecated(<span class=\"meta-string\">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class=\"meta-string\">&quot;newName&quot;</span>)</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> oldName: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> <span class=\"keyword\">this</span>::newName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 <code>KProperty0&lt;R&gt;</code> 实现了 <code>getValue</code> 和 <code>setValue</code> 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: R &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">get</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KMutableProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">R</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 <code>KProperty0</code> 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p>\n<h2 id=\"Swift-的属性包装器（Property-Wrapper）\"><a href=\"#Swift-的属性包装器（Property-Wrapper）\" class=\"headerlink\" title=\"Swift 的属性包装器（Property Wrapper）\"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p>\n<p>大家也可以参考 <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults\">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p>\n<p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p>\n<h3 id=\"代理-UserDefaults\"><a href=\"#代理-UserDefaults\" class=\"headerlink\" title=\"代理 UserDefaults\"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefault</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultValue: <span class=\"type\">T</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.object(forKey: key) <span class=\"keyword\">as?</span> <span class=\"type\">T</span> <span class=\"operator\">??</span> defaultValue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">UserDefaults</span>.standard.set(newValue, forKey: key)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isFooFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p>\n<p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p>\n<p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p>\n<p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PropertyWrapper</span>&lt;<span class=\"type\">Value</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: Value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">Value</span>)</span></span> &#123;</span><br><span class=\"line\">        wrappedValue = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObservableDelegate</span>&lt;<span class=\"type\">Value</span>&gt;</span>(</span><br><span class=\"line\">    initializedValue: Value,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> wrappedValue: Value = initializedValue</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> previous = field</span><br><span class=\"line\">            field = value</span><br><span class=\"line\">            changedListener(previous, value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法没有什么特殊之处：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> state: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> ObservableDelegate(<span class=\"number\">0</span>) &#123; previous, current -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;changed <span class=\"variable\">$previous</span> -&gt; <span class=\"variable\">$current</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">state = <span class=\"number\">2</span> <span class=\"comment\">// changed 0 -&gt; 2</span></span><br><span class=\"line\">state = <span class=\"number\">3</span> <span class=\"comment\">// changed 2 -&gt; 3</span></span><br><span class=\"line\">state = <span class=\"number\">4</span> <span class=\"comment\">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性包装器的-projectedValue\"><a href=\"#属性包装器的-projectedValue\" class=\"headerlink\" title=\"属性包装器的 projectedValue\"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p>\n<p>我们来看一个简单的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TestView</span>: <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">var</span> isEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Toggle</span>(isOn: <span class=\"variable\">$isEnabled</span>) &#123;</span><br><span class=\"line\">            isEnabled <span class=\"operator\">?</span> <span class=\"type\">Text</span>(<span class=\"string\">&quot;Click to disable&quot;</span>).foregroundColor(.red)</span><br><span class=\"line\">                : <span class=\"type\">Text</span>(<span class=\"string\">&quot;Click to enable&quot;</span>).foregroundColor(.green)</span><br><span class=\"line\">        &#125;.padding()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png\"></p>\n<p><strong><center>isEnabled 为 false 时的 UI</center></strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png\"></p>\n<p><strong><center>isEnabled 为 true 时的 UI</center></strong></p>\n<p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p>\n<p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p>\n<p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p>\n<p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@frozen</span> <span class=\"keyword\">@propertyWrapper</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">State</span>&lt;<span class=\"title\">Value</span>&gt; : <span class=\"title\">DynamicProperty</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initialize with the provided initial value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">wrappedValue</span> <span class=\"params\">value</span>: <span class=\"type\">Value</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initialize with the provided initial value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">initialValue</span> <span class=\"params\">value</span>: <span class=\"type\">Value</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The current state value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">Value</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">nonmutating</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Produces the binding referencing this state value</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> projectedValue: <span class=\"type\">Binding</span>&lt;<span class=\"type\">Value</span>&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p>\n<p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isEnabled: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get property reference</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> view = View()</span><br><span class=\"line\"><span class=\"keyword\">val</span> isEnabledRef = view::isEnabled</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operate on property reference</span></span><br><span class=\"line\">isEnabledRef.<span class=\"keyword\">set</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">println(isEnabledRef.<span class=\"keyword\">get</span>())</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p>\n<p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefault</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultValue: <span class=\"type\">T</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> projectedValue: <span class=\"type\">UserDefault</span>&lt;<span class=\"type\">T</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">self</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isFooFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>.wrappedValue) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>.projectedValue) </span><br></pre></td></tr></table></figure>\n\n<p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"operator\">...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getIsBarFeatureEnabledWrapper</span>()</span> -&gt; <span class=\"type\">UserDefault</span>&lt;<span class=\"type\">Bool</span>&gt; &#123;</span><br><span class=\"line\">        _isBarFeatureEnabled</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p>\n<p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KProperty0</span>&lt;<span class=\"type\">out R</span>&gt; : <span class=\"type\">KProperty</span>&lt;<span class=\"type\">R</span>&gt;, <span class=\"type\"></span></span>() -&gt; R &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.1&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getDelegate</span><span class=\"params\">()</span></span>: Any?</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"><span class=\"keyword\">val</span> delegate = ObservableDelegate(<span class=\"number\">0</span>) &#123; previous, current -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;changed <span class=\"variable\">$previous</span> -&gt; <span class=\"variable\">$current</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> state <span class=\"keyword\">by</span> delegate</span><br></pre></td></tr></table></figure>\n\n<p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p>\n<p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p>\n<p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p>\n<p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Swift 的属性代理，见识一下 </p>\n</blockquote>","more":"<blockquote>\n<p>Swift：我不是我没有别瞎说。</p>\n</blockquote>\n<p>本文我们来聊聊二者的属性代理的设计和使用。通过对比，我们能够更加清楚的认识到属性代理的设计意图，以及其优势和不足，此外我们还能够了解更多属性代理这一语法特性的使用场景。</p>\n<h2 id=\"Kotlin-的属性代理（Property-Delegate）\"><a href=\"#Kotlin-的属性代理（Property-Delegate）\" class=\"headerlink\" title=\"Kotlin 的属性代理（Property Delegate）\"></a>Kotlin 的属性代理（Property Delegate）</h2><p>我们先来简单回顾下 Kotlin 的属性代理的一些基础知识和应用场景。</p>\n<h3 id=\"简化存储的读写\"><a href=\"#简化存储的读写\" class=\"headerlink\" title=\"简化存储的读写\"></a>简化存储的读写</h3><p>Kotlin 的属性代理算是大多数开发者在学习过程中会遇到的一个小难点。这其实让我一直都感到比较意外，因为属性代理本身应该是一个很自然的需求，例如我们经常在 Android 当中会读写 SharedPreference，一个 Key 对应于一个 Value，读写的过程高度相似且繁琐：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// write</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> prefs = context.getSharedPreferences(prefName, Context.MODE_PRIVATE)</span><br><span class=\"line\">prefs.putString(key, value)</span><br><span class=\"line\">prefs.apply()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> value = prefs.getString(key, defaultValue)</span><br></pre></td></tr></table></figure>\n\n<p>这当中还经常需要定义一堆常量作为 key 的值，无论从代码编写的舒适度上还是从代码的编写效率上来看都不是最理想的状态。</p>\n<p>实际上，如果我们把 SharedPreference 看成是类似内存一样的存储空间，那么为什么我们不能像读写内存中的变量那样轻松自在呢？于是乎我们通过属性代理将 SharedPreference 的读写操作做一下封装，实现了使用对变量的读写方式来读写 SharedPreference 的效果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> loginName <span class=\"keyword\">by</span> pref(context, default = <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save &quot;bennyhuo&quot; as key &quot;loginName&quot;</span></span><br><span class=\"line\">loginName = <span class=\"string\">&quot;bennyhuo&quot;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load key &quot;loginName&quot; from SharedPreferences</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> currentLoginName = loginName </span><br></pre></td></tr></table></figure>\n\n<p>请大家注意，<code>pref</code> 是一个函数，它有一个泛型参数可以通过第二个函数参数的类型推导出来。对 <code>loginName</code> 的读写等同于对 SharedPreferences 中的 “loginName” 这个 key 的读写，这个操作是不是非常方便？想要实现这样的功能也不需要太多的逻辑，我们以 <code>String</code> 为例给出实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preference</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> name: String, </span><br><span class=\"line\">        <span class=\"keyword\">val</span> default: T, <span class=\"keyword\">val</span> prefName: String = <span class=\"string\">&quot;default&quot;</span>) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> prefs <span class=\"keyword\">by</span> lazy &#123; context.getSharedPreferences(prefName, Context.MODE_PRIVATE) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(findProperName(property), default)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        putPreference(findProperName(property), value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">findProperName</span><span class=\"params\">(property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span> = <span class=\"keyword\">if</span>(name.isEmpty()) property.name <span class=\"keyword\">else</span> name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;U&gt;</span> <span class=\"title\">findPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, default: <span class=\"type\">U</span>)</span></span>: U = with(prefs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> res: Any = <span class=\"keyword\">when</span> (default) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; getString(name, default)</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res <span class=\"keyword\">as</span> U</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;U&gt;</span> <span class=\"title\">putPreference</span><span class=\"params\">(name: <span class=\"type\">String</span>, value: <span class=\"type\">U</span>)</span></span> = with(prefs.edit()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> (value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">is</span> String -&gt; putString(name, value)</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;.apply()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他数据类型的支持大家可以根据需要自行扩展。</p>\n<p>属性代理的本质就是 <code>getValue</code> 和 <code>setValue</code> 这两个方法，这里的代码实现了 <code>ReadWriteProperty</code> 这个接口，不过这不是必须的，我们当然也可以改成下面的样子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Preference</span>&lt;<span class=\"type\">T</span>&gt;</span>(...) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findPreference(findProperName(property), default)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        putPreference(findProperName(property), value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来 <code>getValue</code> 和 <code>setValue</code> 还是运算符方法，其实这里我们甚至可以把它们定义成扩展方法，只要方法的类型符合要求就可以。</p>\n<p>既然如此，那我们是不是还可以对 Java 的 <code>Properties</code> 文件提供类似的支持呢？当然。我们同样可以通过被代理的属性名来查询对应 key 在 <code>Properties</code> 文件中的值，这个逻辑与 SharedPreferences 如出一辙，大家有兴趣可以参考这里：<a href=\"https://github.com/enbandari/QCloudImageUploaderForMarkDown/blob/master/src/main/kotlin/com/bennyhuo/qcloud/prop/AbsProperties.kt\">AbsProperties.kt</a>。</p>\n<p>官网在介绍属性代理的时候还给出了 Map 作为属性代理的用法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(<span class=\"keyword\">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name : String <span class=\"keyword\">by</span> map</span><br><span class=\"line\">    <span class=\"keyword\">val</span> age  : <span class=\"built_in\">Int</span>    <span class=\"keyword\">by</span> map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在很早的时候还专门写过一篇文章来介绍这个用法：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484018&idx=1&sn=170499992c0f29d9304eeddc4379f34e&chksm=e8a05d4fdfd7d459d7e75fa987eda85b39d43ce9b2ea5c8d2b8c884efc7b0431ae39b3c9c22f&token=397611765&lang=zh_CN#rd\">用 Map 为你的属性做代理</a>。其实 <code>Map</code> 也是一种存储的方式，这与前面提到的 SharedPreferences 又有什么区别呢？</p>\n<p>这样的例子我们还能列举很多，如数据库读写、文件读写甚至网络读写等等。</p>\n<h3 id=\"控制属性的生命周期\"><a href=\"#控制属性的生命周期\" class=\"headerlink\" title=\"控制属性的生命周期\"></a>控制属性的生命周期</h3><p>标准库中也提供了 Lazy、Observable 这样的属性代理实现，它们与前面的简化存储的写法不同，二者分别代表了控制、监听属性的读写的使用场景。Lazy 的例子想必大家已经见过很多了，我们可以通过 Lazy 代理属性的初始化逻辑，确保只有在第一次访问时才会对属性进行初始化：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> textView <span class=\"keyword\">by</span> lazy &#123; rootView.findViewById(R.id.text) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对属性进行延迟初始化的理由总是会有很多，例如初始化可能比较耗时，依赖的其他成员尚未初始化等等。</p>\n<p>我们再来看个例子。</p>\n<p>Kotlin 当中的变量类型分为可空和不可空，定义时必须明确其类型，例如下面例子中的 image：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> image: Bitmap</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        image = <span class=\"literal\">null</span> <span class=\"comment\">// Error!!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>image</code> 在定义时如果定义为 <code>Bitmap?</code>，那么在不需要的时候自然是可以置为 <code>null</code> 的，只不过用的时候每次都需要判空，感觉就很让人难受。而如果定义成 <code>Bitmap</code>，用的时候倒是省事儿了，可是最后我们又无法将其置为 <code>null</code>。怎么办？</p>\n<p>有人说你这个是伪需求，不置为 <code>null</code> 也不会有内存泄露。不过，<code>Activity</code> 经常在 <code>onStop</code> 调用之后还会存续一段时间才会被销毁，对应的 <code>Bitmap</code> 对象也要晚一段时间才能被释放，不置为 <code>null</code> 似乎并不是一个最优的选择。不管怎样，如果我们就是想要把这个 <code>Bitmap</code> 对象（或者其他什么对象）置为空，又想不影响开发体验，似乎是不可行的。</p>\n<p>但如果我们用属性代理来控制对象的内部逻辑呢：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> image <span class=\"keyword\">by</span> releasableNotNull&lt;Bitmap&gt;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart()</span><br><span class=\"line\">        image = Bitmap.create(...)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop()</span><br><span class=\"line\">        image.recycle()</span><br><span class=\"line\">        <span class=\"comment\">// release the Bitmap instance.</span></span><br><span class=\"line\">        ::image.release() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 <code>releasableNotNull</code> 函数来创建这样一个属性代理，这个属性代理的工作就是提供一个真正的属性存储，可读可写可释放，它的实现并不复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Any&gt;</span> <span class=\"title\">releasableNotNull</span><span class=\"params\">()</span></span> = ReleasableNotNull&lt;T&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleasableNotNull</span>&lt;<span class=\"type\">T : Any</span>&gt; : <span class=\"type\">ReadWriteProperty</span>&lt;<span class=\"type\">Any, T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value: T? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value ?: <span class=\"keyword\">throw</span> IllegalStateException(<span class=\"string\">&quot;Not Initialized or released already.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isInitialized</span><span class=\"params\">()</span></span> = value != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        value = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">release</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    isAccessible = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getDelegate() <span class=\"keyword\">as</span>? ReleasableNotNull&lt;*&gt;)?.release()</span><br><span class=\"line\">        ?: <span class=\"keyword\">throw</span> IllegalAccessException(<span class=\"string\">&quot;Delegate is null or is not an instance of ReleasableNotNull.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过对属性代理类 <code>ReleasableNotNull</code> 实现了对真正存储值的 <code>value</code> 的代理，前面对 <code>image</code> 的访问实际上就是对 <code>value</code> 的访问，而 <code>value</code> 的类型又是可空的，因此我们实现了既可将属性置为 <code>null</code> 又可将属性 <code>image</code> 声明为不可空的 <code>Bitmap</code> 类型的需求。</p>\n<p>这个小功能已经开源并上传到 jcenter，大家可以通过配置依赖 <code>com.bennyhuo.kotlin:releasable-nonnull-vars:1.1.0</code> 来使用它，也可以直接到我的 GitHub 上查看它的源码：<a href=\"https://github.com/enbandari/ReleasableVar\">ReleasableVar</a>，源码当中我也给出了不依赖 Kotlin 反射的实现方法。</p>\n<blockquote>\n<p>例子当中的 <code>KProperty0&lt;R&gt;.release</code> 扩展方法实际上是为被代理的属性的引用添加了一个扩展，其中使用反射可以获取到代理对象，这样我们就可以使用 <code>::image.release()</code> 来实现对 image 背后的值的置空。请大家留意我们获取属性代理对象的方式，这在 Kotlin 当中需要用到反射；后面我们会看到， Swift 则直接提供了更好的语法来支持这样的功能。</p>\n</blockquote>\n<h3 id=\"代理其他类属性或者方法\"><a href=\"#代理其他类属性或者方法\" class=\"headerlink\" title=\"代理其他类属性或者方法\"></a>代理其他类属性或者方法</h3><p>前面的例子都比较直观，我们再给大家看一个更复杂的用法。</p>\n<p>假设我们现在有这么一类，它有一些方法和属性：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapped</span></span>(<span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> z = <span class=\"number\">10L</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setY</span><span class=\"params\">(y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getY</span><span class=\"params\">()</span></span> = <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类的实例会被包在另一个类当中：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span> = ...</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"built_in\">Int</span> = ...</span><br><span class=\"line\">    <span class=\"keyword\">val</span> z: <span class=\"built_in\">Long</span> = ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在 <code>Wrapper</code> 类当中还想把 <code>Wrapped</code> 类的一些成员暴露给外部调用者，可能的实现就像这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"built_in\">Boolean</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span>() = wrapped.x</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) &#123; wrapped.x = value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的写法并不是很简洁，我们可以通过属性代理实现这样的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> x <span class=\"keyword\">by</span> wrapped::x.delegator()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>属性代理本质上就是 <code>setValue</code> 和 <code>getValue</code>，所以代理 getter 和 setter <code>也是顺理成章。delegator</code> 函数是 <code>x</code> 的属性引用的扩展成员，定义也不复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> KProperty0<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">delegator</span><span class=\"params\">(initializedValue: <span class=\"type\">T</span>? = <span class=\"literal\">null</span>)</span></span></span><br><span class=\"line\">    : ReadWriteProperty&lt;Any, T&gt;</span><br><span class=\"line\">        = ObjectPropertyDelegate0(</span><br><span class=\"line\">            propertyRef = <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> PropertyReference, </span><br><span class=\"line\">            initializedValue = initializedValue</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectPropertyDelegate0</span>&lt;<span class=\"type\">T</span>&gt;</span>(</span><br><span class=\"line\">        <span class=\"keyword\">val</span> getter: (() -&gt; T), </span><br><span class=\"line\">        <span class=\"keyword\">val</span> setter: ((T) -&gt; <span class=\"built_in\">Unit</span>)? = <span class=\"literal\">null</span>, </span><br><span class=\"line\">        initializedValue: T? = <span class=\"literal\">null</span>) : ReadWriteProperty&lt;Any, T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(</span><br><span class=\"line\">        propertyRef: PropertyReference, </span><br><span class=\"line\">        initializedValue: T? = <span class=\"literal\">null</span></span><br><span class=\"line\">        ): <span class=\"keyword\">this</span>(</span><br><span class=\"line\">            (propertyRef <span class=\"keyword\">as</span> KProperty0&lt;T&gt;)::<span class=\"keyword\">get</span>, </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (propertyRef <span class=\"keyword\">is</span> KMutableProperty0&lt;*&gt;) (propertyRef <span class=\"keyword\">as</span> KMutableProperty0&lt;T&gt;)::<span class=\"keyword\">set</span> <span class=\"keyword\">else</span> <span class=\"literal\">null</span>, initializedValue</span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        initializedValue?.let &#123; setter?.invoke(it) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getter.invoke()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">        setter?.invoke(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这有点儿像请求转发一样，对 <code>Wrapper</code> 的属性 <code>x</code> 的读写直接转发给了 <code>Wrapped</code> 的属性 <code>x</code> 。既然我们把属性拆解开看做是 getter 和 setter，那么所有符合此类特征的函数也是可以被代理的，因此对于 <code>Wrapped</code> 的 <code>getY</code> 也可以代理成一个只读属性，<code>setY</code> 也可以单独代理成一个可变属性：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Wrapped = Wrapped(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y <span class=\"keyword\">by</span> wrapped::setY.delegator(defaultValue = <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> yGetter <span class=\"keyword\">by</span> wrapped::getY.delegator()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于 <code>getY</code> 的代理比较容易理解。对于 <code>setY</code> 的代理就有些奇怪了，属性 <code>y</code> 只代理了 <code>wrapped::setY</code>，那读取 <code>y</code> 的值时从哪儿获取呢？这其实也不难做到，我们可以通过属性代理提供一个 backingfield 来保存这个值就可以了。其实对于 setter 的代理的场景还真有，例如对于 Android 中某些 <code>View</code> 的属性只有 setter 的方法，没有对应的 getter，如果我想要做一个属性动画，那么这样的属性代理就会比较有帮助。</p>\n<p>当然，类似的扩展我们还可以做很多，甚至支持 lazy：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>: <span class=\"type\">Activity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name <span class=\"keyword\">by</span> delegateLazyOf(TextView::getText, TextView::setText) &#123; textView &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们前面的例子当中 <code>wrapped</code> 从一开始就被初始化了，而这个例子当中 <code>textView</code> 需要等到 <code>Activity</code> 的 <code>onCreate</code> 调用之后才会初始化，因此 <code>lazy</code> 就显得非常必要了。具体实现就不一一列举了，有兴趣的朋友可以参考我的 GitHub 项目：<a href=\"https://github.com/enbandari/ObjectPropertyDelegate\">ObjectPropertyDelegate</a>，大家也可以通过引入 <code>com.bennyhuo.kotlin:delegates:1.0</code> 来直接使用它。</p>\n<p>需要补充说明的一点是，根据 Kotlin 官方最新发布的博客来看，从 Kotlin 1.4-M2 开始会直接支持使用属性代理其他属性，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> newName: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"meta\">@Deprecated(<span class=\"meta-string\">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class=\"meta-string\">&quot;newName&quot;</span>)</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> oldName: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> <span class=\"keyword\">this</span>::newName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上与我们前面使用属性代理其他属性问题的处理上如出一辙。其实这个写法只不过是为 <code>KProperty0&lt;R&gt;</code> 实现了 <code>getValue</code> 和 <code>setValue</code> 扩展，我们在 Kotlin 1.4 以前的版本自己就可以实现这样的效果，只需要添加以下扩展即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: R &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">get</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> KMutableProperty0<span class=\"type\">&lt;R&gt;</span>.<span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">R</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个用法实际上也进一步说明了 Kotlin 对属性代理类本身没有类型要求的好处，如果强制属性代理类实现某一个接口的话，那这个效果就只能通过修改 <code>KProperty0</code> 的继承结果来实现了。当然，官方给出的这个例子还直接展示了这个特性的一个使用场景，即属性重命名。</p>\n<h2 id=\"Swift-的属性包装器（Property-Wrapper）\"><a href=\"#Swift-的属性包装器（Property-Wrapper）\" class=\"headerlink\" title=\"Swift 的属性包装器（Property Wrapper）\"></a>Swift 的属性包装器（Property Wrapper）</h2><p>Swift 的属性包装器其实就是属性代理，最早推出这个特性的时候实际上也叫做 Property Delegate，但设计者们觉得 Property Wrapper 更贴切它的实际用法和含义，加上 Delegate 这个词在 Swift 当中（或者说更早的 Objective-C 当中）已经有了非常确切的含义，因此改成了Property Wrapper。这个名字看上去确实比属性代理表达出来的意图更加明显。</p>\n<p>大家也可以参考 <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults\">Swift 的属性包装器的设计文档</a>，文档中详细列出了一些使用场景和方法，以及一些设计细节，这其中绝大多数的使用场景我们也可以通过 Kotlin 的属性代理在 Kotlin 当中实现。</p>\n<p>这个特性在 Swift 5 才推出，可以说是非常晚了。说来也有趣，在它的设计文档中还特意 “diss” 了 Kotlin 的属性代理的语法设计：单独为了属性代理搞了一个 by 关键字实在是有些重，在其他场景下也不太好复用，于是 Swift 的属性包装器采用了与 Java/Kotlin 的注解类似的长相的设计。</p>\n<h3 id=\"代理-UserDefaults\"><a href=\"#代理-UserDefaults\" class=\"headerlink\" title=\"代理 UserDefaults\"></a>代理 UserDefaults</h3><p><code>UserDefaults</code> 是苹果家族的平台上通用的类似于 SharedPreferences 的配置存储，也是 key-value 的形式进行读写，我们可以使用属性包装器来进行代理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefault</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultValue: <span class=\"type\">T</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">UserDefaults</span>.standard.object(forKey: key) <span class=\"keyword\">as?</span> <span class=\"type\">T</span> <span class=\"operator\">??</span> defaultValue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">UserDefaults</span>.standard.set(newValue, forKey: key)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>@PropertyWrapper</code> 将 <code>UserDefault</code> 声明为一个属性包装器，我们很自然想到要提供 getter 和 setter 的实现，Swift 通过 <code>wrappedValue</code> 这个计算属性来做到这一点，这样对于被包装的属性的访问其实就转发到对 <code>wrappedValue</code> 的访问上。用法也很直接：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isFooFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子就是设计文档中的例子，大家可以在 Swift 5.2 当中运行测试。</p>\n<p>稍微提一句，在 Swift 中，struct 是值类型，class 是引用类型，对于属性包装器来讲，二者都是可以的，用哪个取决于具体需求。</p>\n<p>除了语法形式的不同之外，从功能上，Swift 的属性包装器的 wrappedValue 相当于 Kotlin 的属性代理的 <code>getValue</code> 和 <code>setValue</code> 的实现，不同之处在于 Kotlin 在 <code>getValue</code> 和 <code>setValue</code> 中提供了 <code>KProperty</code> 这个参数，我们可以通过它来获取对应属性的一些元信息，最常用的就是 name，所以我们在前面使用 Kotlin 代理 SharedPreferences 的例子当中完全可以不用主动传入 key 的值。</p>\n<p>相比之下，Kotlin 的属性代理的语法更加自由，我们可以轻松地模拟 Swift 的写法来实现属性代理，主要以下是 Kotlin 代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PropertyWrapper</span>&lt;<span class=\"type\">Value</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: Value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;)</span></span>: Value = wrappedValue</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setValue</span><span class=\"params\">(thisRef: <span class=\"type\">Any</span>?, property: <span class=\"type\">KProperty</span>&lt;*&gt;, value: <span class=\"type\">Value</span>)</span></span> &#123;</span><br><span class=\"line\">        wrappedValue = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照这个思路，实现具体的属性代理，只需要实现这个接口并覆写即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObservableDelegate</span>&lt;<span class=\"type\">Value</span>&gt;</span>(</span><br><span class=\"line\">    initializedValue: Value,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> changedListener: (previous: Value, current: Value) -&gt; <span class=\"built_in\">Unit</span></span><br><span class=\"line\">) : PropertyWrapper&lt;Value&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> wrappedValue: Value = initializedValue</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> previous = field</span><br><span class=\"line\">            field = value</span><br><span class=\"line\">            changedListener(previous, value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法没有什么特殊之处：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> state: <span class=\"built_in\">Int</span> <span class=\"keyword\">by</span> ObservableDelegate(<span class=\"number\">0</span>) &#123; previous, current -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;changed <span class=\"variable\">$previous</span> -&gt; <span class=\"variable\">$current</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">state = <span class=\"number\">2</span> <span class=\"comment\">// changed 0 -&gt; 2</span></span><br><span class=\"line\">state = <span class=\"number\">3</span> <span class=\"comment\">// changed 2 -&gt; 3</span></span><br><span class=\"line\">state = <span class=\"number\">4</span> <span class=\"comment\">// changed 3 -&gt; 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性包装器的-projectedValue\"><a href=\"#属性包装器的-projectedValue\" class=\"headerlink\" title=\"属性包装器的 projectedValue\"></a>属性包装器的 projectedValue</h3><p>我是在学 Swift UI 的时候才开始接触到 Swift 的属性包装器的。Swift UI 就是使用 Swift 代码直接布局的写法，这种写法现在比较流行，例如 Flutter 的 Dart， Android 上之前的 Kotlin Anko 以及现在的 Compose。</p>\n<p>我们来看一个简单的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TestView</span>: <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">var</span> isEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Toggle</span>(isOn: <span class=\"variable\">$isEnabled</span>) &#123;</span><br><span class=\"line\">            isEnabled <span class=\"operator\">?</span> <span class=\"type\">Text</span>(<span class=\"string\">&quot;Click to disable&quot;</span>).foregroundColor(.red)</span><br><span class=\"line\">                : <span class=\"type\">Text</span>(<span class=\"string\">&quot;Click to enable&quot;</span>).foregroundColor(.green)</span><br><span class=\"line\">        &#125;.padding()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>body</code> 是布局的 View，里面只有一个控件就是一个开关 <code>Toggle</code>，它需要与 <code>isEnabled</code> 这个属性绑定，UI 的效果如下：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png\"></p>\n<p><strong><center>isEnabled 为 false 时的 UI</center></strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-42.png\"></p>\n<p><strong><center>isEnabled 为 true 时的 UI</center></strong></p>\n<p><code>isEnabled</code> 这个属性被 <code>State</code> 这个属性包装器包装，<code>State</code> 为它提供了一个 <code>projectedValue</code> 的属性，这个 <code>projectedValue</code> 可以通过 <strong><code>$</code> + 属性名</strong> 来获取，也就是说作为 <code>Toggle</code> 的参数 <code>isOn</code> 的 <code>$isEnabled</code> 实际上就是 <code>isEnabled</code> 这个属性的包装器提供的 <code>projectValue</code>。</p>\n<p>这个 <code>projectedValue</code> 实际上也是一个属性包装器，它的类型是 <code>Binding&lt;Bool&gt;</code>，<code>Binding</code> 这个属性包装器的作用比较直接，类似于我们前面介绍 Kotlin 的属性代理时提到的 <code>wrapped::x.delegator()</code>，它的作用就是提供了属性的 getter 和 setter，这样我们将 <code>Binding&lt;Bool&gt;</code> 对象传给 <code>Toggle</code> 的时候，它就可以在其中方便的修改 <code>isEnabled</code> 这个属性了。</p>\n<p><code>State</code> 当然还提供了与 View 的刷新机制相关的逻辑，它实现了 <code>DynamicProperty</code> 协议，可以在属性被修改时调用 <code>update</code> 方法来刷新 UI。</p>\n<p>下面我们给出 <code>State</code> 的声明，具体实现没有开源，但可以想到的是在 <code>wrappedValue</code> 的 setter 调用时一定会触发 <code>DynamicProperty</code> 协议的 <code>update</code> 方法的调用，<code>projectedValue</code> 则是返回一个包装了被 <code>State</code> 包装的属性的 getter 和 setter 的对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@frozen</span> <span class=\"keyword\">@propertyWrapper</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">State</span>&lt;<span class=\"title\">Value</span>&gt; : <span class=\"title\">DynamicProperty</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initialize with the provided initial value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">wrappedValue</span> <span class=\"params\">value</span>: <span class=\"type\">Value</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initialize with the provided initial value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">initialValue</span> <span class=\"params\">value</span>: <span class=\"type\">Value</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// The current state value.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">Value</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">nonmutating</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Produces the binding referencing this state value</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> projectedValue: <span class=\"type\">Binding</span>&lt;<span class=\"type\">Value</span>&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们考虑下 Kotlin 当中是否存在对应的特性。</p>\n<p>对于 <code>Binding</code> 的使用场景，Kotlin 当中大可不必这么大费周章，因为 Kotlin 的属性引用可以很方便的允许我们传递一个属性的 setter 和 getter，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isEnabled: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get property reference</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> view = View()</span><br><span class=\"line\"><span class=\"keyword\">val</span> isEnabledRef = view::isEnabled</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operate on property reference</span></span><br><span class=\"line\">isEnabledRef.<span class=\"keyword\">set</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">println(isEnabledRef.<span class=\"keyword\">get</span>())</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，Swift UI 当中的 <code>Binding</code> 在当中可以使用 Kotlin 的属性引用来替代，以上代码也不需要额外引入 Kotlin 反射。</p>\n<p>但可以确定的是，Kotlin 当中没有 <code>projectedValue</code> 这样的特性，即便我们在前面模拟 Swift 声明的 <code>PropertyWrapper</code> 接口中添加这样的属性，我们也没有直接的类似于 <code>$isEnabled</code> 这样的语法来获取它。不仅如此，在 Kotlin 当中想要获取属性代理对象本身也不是一件轻松的事情，而在 Swift 当中我们可以使用 <code>projectedValue</code> 直接返回自身（也可以返回别的，例如 <code>State</code> 中就没有返回自己，而是返回了 <code>Binding</code>）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UserDefault</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultValue: <span class=\"type\">T</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> projectedValue: <span class=\"type\">UserDefault</span>&lt;<span class=\"type\">T</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">self</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;FOO_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isFooFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.isBarFeatureEnabled) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>.wrappedValue) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UserDefault&lt;Bool&gt;(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">GlobalSettings</span>.<span class=\"variable\">$isBarFeatureEnabled</span>.projectedValue) </span><br></pre></td></tr></table></figure>\n\n<p>实际上如果是在被包装的属性所在的类内部，我们还可以直接拿到包装属性的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">GlobalSettings</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"operator\">...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UserDefault</span>(key: <span class=\"string\">&quot;BAR_FEATURE_ENABLED&quot;</span>, defaultValue: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> isBarFeatureEnabled: <span class=\"type\">Bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getIsBarFeatureEnabledWrapper</span>()</span> -&gt; <span class=\"type\">UserDefault</span>&lt;<span class=\"type\">Bool</span>&gt; &#123;</span><br><span class=\"line\">        _isBarFeatureEnabled</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问 <code>_isBarFeatureEnabled</code> 得到的就是包装 <code>isBarFeatureEnabled</code> 的实例。</p>\n<p>而这在 Kotlin 当中我们就只能通过反射来做到这一点了。不知道大家是否注意到我们用 Kotlin 属性代理实现的 ReleasableVar 这个组件中用到了 Kotlin 反射方法 <code>getDelegate</code> 来获取属性代理对象，即便我们可以接受使用反射这个前提，但它返回的类型 <code>Any?</code> 也同样不如 Swift 当中可以通过 <code>$</code> 直接获取 <code>projectedValue</code> 以及通过 <code>_</code> 获取属性包装器实例来的直接和安全。更何况 <code>getDelegate</code> 这个反射方法目前只能在 JVM 上使用，无法实现多平台。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">actual</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">KProperty0</span>&lt;<span class=\"type\">out R</span>&gt; : <span class=\"type\">KProperty</span>&lt;<span class=\"type\">R</span>&gt;, <span class=\"type\"></span></span>() -&gt; R &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the value of the delegate if this is a delegated property, or `null` if this property is not delegated.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SinceKotlin(<span class=\"meta-string\">&quot;1.1&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getDelegate</span><span class=\"params\">()</span></span>: Any?</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然，我们在 Kotlin 当中可以直接把属性代理对象先定义出来，就像下面这样：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"><span class=\"keyword\">val</span> delegate = ObservableDelegate(<span class=\"number\">0</span>) &#123; previous, current -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;changed <span class=\"variable\">$previous</span> -&gt; <span class=\"variable\">$current</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> state <span class=\"keyword\">by</span> delegate</span><br></pre></td></tr></table></figure>\n\n<p>但这个写法又显得 <code>delegate</code> 与 <code>state</code> 的联系没有那么紧密，因此 Swift 的属性包装器在 <code>projectedValue</code> 的设计上为开发者提供了更大的发挥空间。</p>\n<p>Kotlin 的规划和提议方面也暂时没有看到有类似的设计，如果我们想要在 Kotlin 当中也实现类似于 <code>projectedValue</code> 的功能，也许可以借助一下 Kotlin 编译器插件来完成。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>属性代理或者属性包装器本质上提供了把读写操作简化成对变量的读写的可能性，能够提供更大程度上的抽象，简化程序的代码重复度。</p>\n<p>Kotlin 的属性代理的语法结构没有类型上的强制约束，只要实现 <code>getValue</code> 和 <code>setValue</code> 这两个方法即可用作属性代理的对象，没有实现接口的限制可以为已有的类型提供更多的扩展可能性；不过，获取一个属性的代理对象的方式不是特别友好，一方面需要使用到反射，另一方面获取到的类型是 <code>Any?</code>，没有静态类型的约束。</p>\n<p>相比之下 Swift 的属性包装器提供了类似的能力，也通过提供 projectedValue 可以衍生出更多灵活的用法。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin 的 Property Delegate 与 Swift 的 Property Wrapper","path":"2020/05/08/kotlin-swift-property-delegate/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-05-02-18-34-23.png","excerpt":"<blockquote>\n<p>Swift 的属性代理，见识一下 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-05-07T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-05-07T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","swift","property"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Kotlin 协程版的 AutoDispose","date":"2019-01-06T16:00:00.000Z","_content":"\n大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。\n\n因此大家一定会用到 Uber 的开源框架 [AutoDispose](https://github.com/uber/AutoDispose)。\n\n<!--more-->\n\n什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 `View` 的 `OnAttachStateChangeListener` ，当 `View` 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。\n\n```java\n  static final class Listener extends MainThreadDisposable implements View.OnAttachStateChangeListener {\n    private final View view;\n    private final CompletableObserver observer;\n\n    Listener(View view, CompletableObserver observer) {\n      this.view = view;\n      this.observer = observer;\n    }\n\n    @Override public void onViewAttachedToWindow(View v) { }\n\n    @Override public void onViewDetachedFromWindow(View v) {\n      if (!isDisposed()) {\n      //看到没看到没看到没？\n        observer.onComplete();\n      }\n    }\n\n    @Override protected void onDispose() {\n      view.removeOnAttachStateChangeListener(this);\n    }\n  }\n```\n\n好了，我最近在想我们用协程其实也会有这样的问题呀：\n\n```kotlin\nbutton.onClick {\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n\n如果 `await` 返回结果之前我们就退出了当前的 `Activity` 那么，后面 `updateUI` 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 `onClickAutoDisposable` 嘛。\n\n```kotlin\nfun View.onClickAutoDisposable (\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: android.view.View?) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }.asAutoDisposable(v)\n    }\n}\n```\n\n第一步，不要脸的先抄 Anko 的 `onClick`，不同之处在于我们改了个名 XD。啊，还有我们加了个 `.asAutoDisposable(v)`，大家就假装有这个方法吧。。。\n\n> (╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。\n\nOK OK，咱们下面来实现它。。想想，`GlobalScope.launch` 其实返回的是一个 `Job`，所以嘛，我们给 `Job` 搞一个扩展方法不就得了。\n\n```kotlin\nfun Job.asAutoDisposable(view: View) = AutoDisposableJob(view, this)\n```\n\n第二步，我们再偷偷的创建一个类，叫 `AutoDisposableJob`，抄一下前面的 `Listener`：\n\n```kotlin\nclass AutoDisposableJob(private val view: View, private val wrapped: Job)\n    //我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口\n     : Job by wrapped, OnAttachStateChangeListener {\n    override fun onViewAttachedToWindow(v: View?) = Unit\n\n    override fun onViewDetachedFromWindow(v: View?) {\n        //当 View 被移除的时候，取消协程\n        cancel()\n        view.removeOnAttachStateChangeListener(this)\n    }\n\n    private fun isViewAttached() =\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && view.isAttachedToWindow || view.windowToken != null\n\n    init {\n        if(isViewAttached()) {\n            view.addOnAttachStateChangeListener(this)\n        } else {\n            cancel()\n        }\n\n        //协程执行完毕时要及时移除 listener 免得造成泄露\n        invokeOnCompletion() {\n            view.removeOnAttachStateChangeListener(this)\n        }\n    }\n}\n```\n\n这样的话，我们就可以使用这个扩展了：\n\n```kotlin\nbutton.onClickAutoDisposable{\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n当 `button` 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。\n\n\n\n\n","source":"_posts/kotlin_AutoDispose.md","raw":"---\ntitle: Kotlin 协程版的 AutoDispose\ndate: 2019/01/07\ntags:\n  - Kotlin\n  - Coroutine\n  - Android\n---\n\n大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。\n\n因此大家一定会用到 Uber 的开源框架 [AutoDispose](https://github.com/uber/AutoDispose)。\n\n<!--more-->\n\n什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 `View` 的 `OnAttachStateChangeListener` ，当 `View` 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。\n\n```java\n  static final class Listener extends MainThreadDisposable implements View.OnAttachStateChangeListener {\n    private final View view;\n    private final CompletableObserver observer;\n\n    Listener(View view, CompletableObserver observer) {\n      this.view = view;\n      this.observer = observer;\n    }\n\n    @Override public void onViewAttachedToWindow(View v) { }\n\n    @Override public void onViewDetachedFromWindow(View v) {\n      if (!isDisposed()) {\n      //看到没看到没看到没？\n        observer.onComplete();\n      }\n    }\n\n    @Override protected void onDispose() {\n      view.removeOnAttachStateChangeListener(this);\n    }\n  }\n```\n\n好了，我最近在想我们用协程其实也会有这样的问题呀：\n\n```kotlin\nbutton.onClick {\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n\n如果 `await` 返回结果之前我们就退出了当前的 `Activity` 那么，后面 `updateUI` 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 `onClickAutoDisposable` 嘛。\n\n```kotlin\nfun View.onClickAutoDisposable (\n        context: CoroutineContext = Dispatchers.Main,\n        handler: suspend CoroutineScope.(v: android.view.View?) -> Unit\n) {\n    setOnClickListener { v ->\n        GlobalScope.launch(context, CoroutineStart.DEFAULT) {\n            handler(v)\n        }.asAutoDisposable(v)\n    }\n}\n```\n\n第一步，不要脸的先抄 Anko 的 `onClick`，不同之处在于我们改了个名 XD。啊，还有我们加了个 `.asAutoDisposable(v)`，大家就假装有这个方法吧。。。\n\n> (╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。\n\nOK OK，咱们下面来实现它。。想想，`GlobalScope.launch` 其实返回的是一个 `Job`，所以嘛，我们给 `Job` 搞一个扩展方法不就得了。\n\n```kotlin\nfun Job.asAutoDisposable(view: View) = AutoDisposableJob(view, this)\n```\n\n第二步，我们再偷偷的创建一个类，叫 `AutoDisposableJob`，抄一下前面的 `Listener`：\n\n```kotlin\nclass AutoDisposableJob(private val view: View, private val wrapped: Job)\n    //我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口\n     : Job by wrapped, OnAttachStateChangeListener {\n    override fun onViewAttachedToWindow(v: View?) = Unit\n\n    override fun onViewDetachedFromWindow(v: View?) {\n        //当 View 被移除的时候，取消协程\n        cancel()\n        view.removeOnAttachStateChangeListener(this)\n    }\n\n    private fun isViewAttached() =\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && view.isAttachedToWindow || view.windowToken != null\n\n    init {\n        if(isViewAttached()) {\n            view.addOnAttachStateChangeListener(this)\n        } else {\n            cancel()\n        }\n\n        //协程执行完毕时要及时移除 listener 免得造成泄露\n        invokeOnCompletion() {\n            view.removeOnAttachStateChangeListener(this)\n        }\n    }\n}\n```\n\n这样的话，我们就可以使用这个扩展了：\n\n```kotlin\nbutton.onClickAutoDisposable{\n    try {\n        val req = Request()\n        val resp = async { sendRequest(req) }.await()\n        updateUI(resp)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n}\n```\n当 `button` 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。\n\n\n\n\n","slug":"kotlin_AutoDispose","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003m002hlduzf7mphvtw","content":"<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>\n<p>因此大家一定会用到 Uber 的开源框架 <a href=\"https://github.com/uber/AutoDispose\">AutoDispose</a>。</p>\n<span id=\"more\"></span>\n\n<p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span> <span class=\"keyword\">extends</span> <span class=\"title\">MainThreadDisposable</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> View view;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompletableObserver observer;</span><br><span class=\"line\"></span><br><span class=\"line\">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.view = view;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(View v)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//看到没看到没看到没？</span></span><br><span class=\"line\">      observer.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClick &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickAutoDisposable</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">android</span>.<span class=\"type\">view</span>.<span class=\"type\">View</span>?) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;.asAutoDisposable(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p>\n<blockquote>\n<p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p>\n</blockquote>\n<p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Job.<span class=\"title\">asAutoDisposable</span><span class=\"params\">(view: <span class=\"type\">View</span>)</span></span> = AutoDisposableJob(view, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoDisposableJob</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> view: View, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Job)</span><br><span class=\"line\">    <span class=\"comment\">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class=\"line\">     : Job <span class=\"keyword\">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> = <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 View 被移除的时候，取消协程</span></span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isViewAttached</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isViewAttached()) &#123;</span><br><span class=\"line\">            view.addOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class=\"line\">        invokeOnCompletion() &#123;</span><br><span class=\"line\">            view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们就可以使用这个扩展了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClickAutoDisposable&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>\n","site":{"data":{}},"excerpt":"<p>大家一定用过 RxJava，也一定知道用 RxJava 发了个任务，任务还没结束页面就被关闭了，如果任务迟迟不回来，页面就会被泄露；如果任务后面回来了，执行回调更新 UI 的时候也会大概率空指针。</p>\n<p>因此大家一定会用到 Uber 的开源框架 <a href=\"https://github.com/uber/AutoDispose\">AutoDispose</a>。</p>","more":"<p>什么？你说你没用？好吧，那就没用吧。。我是不会介绍它的。⊙﹏⊙|||。怎么可能。(～￣▽￣)～。。它其实就是利用 <code>View</code> 的 <code>OnAttachStateChangeListener</code> ，当 <code>View</code> 被拿下的时候，我们就取消所有之前用 RxJava 发出去的请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span> <span class=\"keyword\">extends</span> <span class=\"title\">MainThreadDisposable</span> <span class=\"keyword\">implements</span> <span class=\"title\">View</span>.<span class=\"title\">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> View view;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompletableObserver observer;</span><br><span class=\"line\"></span><br><span class=\"line\">  Listener(View view, CompletableObserver observer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.view = view;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observer = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(View v)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDisposed()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//看到没看到没看到没？</span></span><br><span class=\"line\">      observer.onComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDispose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，我最近在想我们用协程其实也会有这样的问题呀：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClick &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>await</code> 返回结果之前我们就退出了当前的 <code>Activity</code> 那么，后面 <code>updateUI</code> 就要凉凉。这就尴尬了。不过问题不大，照猫画虎谁不会，我们也可以搞一个 <code>onClickAutoDisposable</code> 嘛。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> View.<span class=\"title\">onClickAutoDisposable</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        context: <span class=\"type\">CoroutineContext</span> = Dispatchers.Main,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        handler: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.(<span class=\"type\">v</span>: <span class=\"type\">android</span>.<span class=\"type\">view</span>.<span class=\"type\">View</span>?) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">    setOnClickListener &#123; v -&gt;</span><br><span class=\"line\">        GlobalScope.launch(context, CoroutineStart.DEFAULT) &#123;</span><br><span class=\"line\">            handler(v)</span><br><span class=\"line\">        &#125;.asAutoDisposable(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一步，不要脸的先抄 Anko 的 <code>onClick</code>，不同之处在于我们改了个名 XD。啊，还有我们加了个 <code>.asAutoDisposable(v)</code>，大家就假装有这个方法吧。。。</p>\n<blockquote>\n<p>(╬￣皿￣)=○ 假装个头啊，假装就完成功能的话还要程序员干什么。。让产品假装一下不就行了。。</p>\n</blockquote>\n<p>OK OK，咱们下面来实现它。。想想，<code>GlobalScope.launch</code> 其实返回的是一个 <code>Job</code>，所以嘛，我们给 <code>Job</code> 搞一个扩展方法不就得了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Job.<span class=\"title\">asAutoDisposable</span><span class=\"params\">(view: <span class=\"type\">View</span>)</span></span> = AutoDisposableJob(view, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第二步，我们再偷偷的创建一个类，叫 <code>AutoDisposableJob</code>，抄一下前面的 <code>Listener</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoDisposableJob</span></span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> view: View, <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> wrapped: Job)</span><br><span class=\"line\">    <span class=\"comment\">//我们实现了 Job 这个接口，但没有直接实现它的方法，而是用 wrapped 这个成员去代理这个接口</span></span><br><span class=\"line\">     : Job <span class=\"keyword\">by</span> wrapped, OnAttachStateChangeListener &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewAttachedToWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> = <span class=\"built_in\">Unit</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onViewDetachedFromWindow</span><span class=\"params\">(v: <span class=\"type\">View</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 View 被移除的时候，取消协程</span></span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isViewAttached</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; view.isAttachedToWindow || view.windowToken != <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isViewAttached()) &#123;</span><br><span class=\"line\">            view.addOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//协程执行完毕时要及时移除 listener 免得造成泄露</span></span><br><span class=\"line\">        invokeOnCompletion() &#123;</span><br><span class=\"line\">            view.removeOnAttachStateChangeListener(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们就可以使用这个扩展了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.onClickAutoDisposable&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> req = Request()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resp = async &#123; sendRequest(req) &#125;.await()</span><br><span class=\"line\">        updateUI(resp)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Exception) &#123;</span><br><span class=\"line\">        e.printStackTrace()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>button</code> 这个对象从 window 上撤下来的时候，我们的协程就会收到 cancel 的指令。</p>","popularPost_tmp_postPath":true},{"title":"用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏","date":"2018-12-16T16:00:00.000Z","_content":"\n我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 `CName` 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。\n\n后来，我发现根本不需要这么麻烦啊。\n\n<!--more-->\n\n我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：\n\n```\nJava_包名_类名_方法名\n```\n\n换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。\n\n那么假如我们有下面的 Java 类：\n\n```java\npublic class HelloJni extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ...\n    }\n\n    public native String  stringFromJNI();\n    \n    ...\n}\n```\n\n那么我们只要保证 so 库当中存在一个函数名为 `Java_com_example_hellojni_HelloJni_stringFromJNI` 并且返回 `jstring` 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。\n\n我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：\n\n```gradle\n...\nkotlin {\n    targets {\n        fromPreset(presets.androidNativeArm32, 'HelloWorld') // ① 配置为 Android 的工程\n\n        configure([HelloWorld]) {\n            compilations.main.outputKinds 'DYNAMIC' // ② 配置为动态链接库\n        }\n    }\n    ...\n}\n...\n```\n\n然后随便创建一个文件，写一个全局函数，并用 `CName` 进行标注如下：\n\n```kotlin\nimport kotlinx.cinterop.*\nimport platform.android.*\n\n@CName(\"Java_com_example_hellojni_HelloJni_stringFromJNI\")\nfun stringFromJNI(env: CPointer<JNIEnvVar>, thiz: jobject): jstring {\n    memScoped {\n        return env.pointed.pointed!!.NewStringUTF!!.invoke(env, \"This is from Kotlin Native!!\".cstr.ptr)!!\n    }\n}\n```\n\n我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 `jstring` 这样的类型。\n\n然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：\n\n```java\nstatic {\n    System.loadLibrary(\"knlib\");\n}\n```\n\n这样运行时就可以调用 `stringFromJNI` 这个方法啦。\n\n```java\nTextView tv = (TextView)findViewById(R.id.hello_textview);\ntv.setText(stringFromJNI());\n```\n\n接下来我再给大家看几个例子：\n\n首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：\n\n```kotlin\n@CName(\"Java_com_example_hellojni_HelloJni_sayHello\")\nfun sayHello(){\n    __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"Hello %s\", \"Native\")\n}\n```\n\n其次，在 Kotlin Native 当中调用 Java 的方法：\n\n```kotlin\n@CName(\"Java_com_example_hellojni_HelloJni_callLoop\")\nfun callLoop(env: CPointer<JNIEnvVar>, thiz: jobject): jstring {\n    memScoped {\n        val jniEnvVal = env.pointed.pointed!!\n        val jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)\n        val methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, \"callFromNative\".cstr.ptr, \"()Ljava/lang/String;\".cstr.ptr)\n        return jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, null) as jstring\n    }\n}\n```\n\n其中 `callFromNative` 的定义如下：\n    \n```java\npublic String callFromNative(){\n    return \"This is from Java!!\";\n}\n```\n    \n由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。\n\n本文涉及源码参见：[hello-kni](https://github.com/enbandari/hello-kni)\n\n---\n转载请注明出处：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n\n\n\n\n\n\n\n","source":"_posts/kotlin_native_jni.md","raw":"---\ntitle: 用 Kotlin Native 写 Jni，以后写 Android 基本上要没有别的语言什么事儿了的节奏\ndate: 2018/12/17\ntags:\n  - Kotlin\n  - Android\n  - Kotlin-Native\n---\n\n我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 `CName` 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。\n\n后来，我发现根本不需要这么麻烦啊。\n\n<!--more-->\n\n我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：\n\n```\nJava_包名_类名_方法名\n```\n\n换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。\n\n那么假如我们有下面的 Java 类：\n\n```java\npublic class HelloJni extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ...\n    }\n\n    public native String  stringFromJNI();\n    \n    ...\n}\n```\n\n那么我们只要保证 so 库当中存在一个函数名为 `Java_com_example_hellojni_HelloJni_stringFromJNI` 并且返回 `jstring` 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。\n\n我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：\n\n```gradle\n...\nkotlin {\n    targets {\n        fromPreset(presets.androidNativeArm32, 'HelloWorld') // ① 配置为 Android 的工程\n\n        configure([HelloWorld]) {\n            compilations.main.outputKinds 'DYNAMIC' // ② 配置为动态链接库\n        }\n    }\n    ...\n}\n...\n```\n\n然后随便创建一个文件，写一个全局函数，并用 `CName` 进行标注如下：\n\n```kotlin\nimport kotlinx.cinterop.*\nimport platform.android.*\n\n@CName(\"Java_com_example_hellojni_HelloJni_stringFromJNI\")\nfun stringFromJNI(env: CPointer<JNIEnvVar>, thiz: jobject): jstring {\n    memScoped {\n        return env.pointed.pointed!!.NewStringUTF!!.invoke(env, \"This is from Kotlin Native!!\".cstr.ptr)!!\n    }\n}\n```\n\n我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 `jstring` 这样的类型。\n\n然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：\n\n```java\nstatic {\n    System.loadLibrary(\"knlib\");\n}\n```\n\n这样运行时就可以调用 `stringFromJNI` 这个方法啦。\n\n```java\nTextView tv = (TextView)findViewById(R.id.hello_textview);\ntv.setText(stringFromJNI());\n```\n\n接下来我再给大家看几个例子：\n\n首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：\n\n```kotlin\n@CName(\"Java_com_example_hellojni_HelloJni_sayHello\")\nfun sayHello(){\n    __android_log_print(ANDROID_LOG_INFO.toInt(), \"Kn\", \"Hello %s\", \"Native\")\n}\n```\n\n其次，在 Kotlin Native 当中调用 Java 的方法：\n\n```kotlin\n@CName(\"Java_com_example_hellojni_HelloJni_callLoop\")\nfun callLoop(env: CPointer<JNIEnvVar>, thiz: jobject): jstring {\n    memScoped {\n        val jniEnvVal = env.pointed.pointed!!\n        val jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)\n        val methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, \"callFromNative\".cstr.ptr, \"()Ljava/lang/String;\".cstr.ptr)\n        return jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, null) as jstring\n    }\n}\n```\n\n其中 `callFromNative` 的定义如下：\n    \n```java\npublic String callFromNative(){\n    return \"This is from Java!!\";\n}\n```\n    \n由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。\n\n本文涉及源码参见：[hello-kni](https://github.com/enbandari/hello-kni)\n\n---\n转载请注明出处：微信公众号 Kotlin\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg)\n\n\n\n\n\n\n\n\n\n","slug":"kotlin_native_jni","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003n002jlduz1wy5ejof","content":"<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p>\n<p>后来，我发现根本不需要这么麻烦啊。</p>\n<span id=\"more\"></span>\n\n<p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure>\n\n<p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p>\n<p>那么假如我们有下面的 Java 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloJni</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String  <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p>\n<p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">kotlin &#123;</span><br><span class=\"line\">    targets &#123;</span><br><span class=\"line\">        fromPreset(presets.androidNativeArm32, <span class=\"string\">&#x27;HelloWorld&#x27;</span>) <span class=\"comment\">// ① 配置为 Android 的工程</span></span><br><span class=\"line\"></span><br><span class=\"line\">        configure([HelloWorld]) &#123;</span><br><span class=\"line\">            compilations.main.outputKinds <span class=\"string\">&#x27;DYNAMIC&#x27;</span> <span class=\"comment\">// ② 配置为动态链接库</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.cinterop.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> platform.android.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_stringFromJNI&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">stringFromJNI</span><span class=\"params\">(env: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JNIEnvVar</span>&gt;, thiz: <span class=\"type\">jobject</span>)</span></span>: jstring &#123;</span><br><span class=\"line\">    memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class=\"string\">&quot;This is from Kotlin Native!!&quot;</span>.cstr.ptr)!!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p>\n<p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;knlib&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class=\"line\">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure>\n\n<p>接下来我再给大家看几个例子：</p>\n<p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_sayHello&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;Hello %s&quot;</span>, <span class=\"string\">&quot;Native&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，在 Kotlin Native 当中调用 Java 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_callLoop&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">callLoop</span><span class=\"params\">(env: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JNIEnvVar</span>&gt;, thiz: <span class=\"type\">jobject</span>)</span></span>: jstring &#123;</span><br><span class=\"line\">    memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class=\"string\">&quot;callFromNative&quot;</span>.cstr.ptr, <span class=\"string\">&quot;()Ljava/lang/String;&quot;</span>.cstr.ptr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class=\"literal\">null</span>) <span class=\"keyword\">as</span> jstring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>callFromNative</code> 的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">callFromNative</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;This is from Java!!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p>\n<p>本文涉及源码参见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a></p>\n<hr>\n<p>转载请注明出处：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>\n","site":{"data":{}},"excerpt":"<p>我在之前写过一篇文章，讲如何用 Kotlin Native 编写 Native 代码通过 JNI 让 Java 调用。当时因为完全没有注意到 <code>CName</code> 这个神奇的东西的存在，所以那篇文章当中还是用 C wrapper 来做的调用。</p>\n<p>后来，我发现根本不需要这么麻烦啊。</p>","more":"<p>我们知道 JNI 如果不通过动态注册的话，Java native 方法与 C 函数的映射关系其实就是一个固定的命名规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java_包名_类名_方法名</span><br></pre></td></tr></table></figure>\n\n<p>换句话说，如果我们在 Java 中加载的 so 库的符号表里面有这么一个函数，它的名字按照标准的 C 函数命名修饰方法修饰，并且修饰之前符合上面的规则，那么 Java 的 native 方法就可以与之对应上。</p>\n<p>那么假如我们有下面的 Java 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloJni</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String  <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们只要保证 so 库当中存在一个函数名为 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 并且返回 <code>jstring</code> 函数就行，至于这个 so 库是由 C 还是 C++ 还是 golang，其实无所谓——自然，Kotlin Native也不在话下。</p>\n<p>我们可以用 CLion 创建一个 Kotlin Native 的工程，在 gradle 当中配置为 Android 的动态链接库：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">kotlin &#123;</span><br><span class=\"line\">    targets &#123;</span><br><span class=\"line\">        fromPreset(presets.androidNativeArm32, <span class=\"string\">&#x27;HelloWorld&#x27;</span>) <span class=\"comment\">// ① 配置为 Android 的工程</span></span><br><span class=\"line\"></span><br><span class=\"line\">        configure([HelloWorld]) &#123;</span><br><span class=\"line\">            compilations.main.outputKinds <span class=\"string\">&#x27;DYNAMIC&#x27;</span> <span class=\"comment\">// ② 配置为动态链接库</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后随便创建一个文件，写一个全局函数，并用 <code>CName</code> 进行标注如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.cinterop.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> platform.android.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_stringFromJNI&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">stringFromJNI</span><span class=\"params\">(env: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JNIEnvVar</span>&gt;, thiz: <span class=\"type\">jobject</span>)</span></span>: jstring &#123;</span><br><span class=\"line\">    memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.pointed.pointed!!.NewStringUTF!!.invoke(env, <span class=\"string\">&quot;This is from Kotlin Native!!&quot;</span>.cstr.ptr)!!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注意到，实际上 Kotlin Native 已经帮我们把 jni.h 这个头文件的互调用配置搞定了，因此我们可以直接导入 <code>jstring</code> 这样的类型。</p>\n<p>然后编译得到一个 so 库 libknlib.so（名字取决于我们的 gradle 工程名），我们可以把它放到我们的 Android 工程当中，在运行时加载它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;knlib&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样运行时就可以调用 <code>stringFromJNI</code> 这个方法啦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextView tv = (TextView)findViewById(R.id.hello_textview);</span><br><span class=\"line\">tv.setText(stringFromJNI());</span><br></pre></td></tr></table></figure>\n\n<p>接下来我再给大家看几个例子：</p>\n<p>首先，在 Kotlin Native 当中使用 Android 的日志 Api 打印日志：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_sayHello&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    __android_log_print(ANDROID_LOG_INFO.toInt(), <span class=\"string\">&quot;Kn&quot;</span>, <span class=\"string\">&quot;Hello %s&quot;</span>, <span class=\"string\">&quot;Native&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，在 Kotlin Native 当中调用 Java 的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CName(<span class=\"meta-string\">&quot;Java_com_example_hellojni_HelloJni_callLoop&quot;</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">callLoop</span><span class=\"params\">(env: <span class=\"type\">CPointer</span>&lt;<span class=\"type\">JNIEnvVar</span>&gt;, thiz: <span class=\"type\">jobject</span>)</span></span>: jstring &#123;</span><br><span class=\"line\">    memScoped &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jniEnvVal = env.pointed.pointed!!</span><br><span class=\"line\">        <span class=\"keyword\">val</span> jclass = jniEnvVal.GetObjectClass!!.invoke(env, thiz)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> methodId = jniEnvVal.GetMethodID!!.invoke(env, jclass, <span class=\"string\">&quot;callFromNative&quot;</span>.cstr.ptr, <span class=\"string\">&quot;()Ljava/lang/String;&quot;</span>.cstr.ptr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jniEnvVal.CallObjectMethodA!!.invoke(env, thiz, methodId, <span class=\"literal\">null</span>) <span class=\"keyword\">as</span> jstring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>callFromNative</code> 的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">callFromNative</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;This is from Java!!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 Kotlin Native 本身就是兼容 C 的，因此 C 能干的自然 Kotlin Native 也可以，这样一来我们其实可以使用 Kotlin 将 Android App 上到虚拟机下到 Native 的代码全部使用 Kotlin 来编写，真是不要太强大。</p>\n<p>本文涉及源码参见：<a href=\"https://github.com/enbandari/hello-kni\">hello-kni</a></p>\n<hr>\n<p>转载请注明出处：微信公众号 Kotlin</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/80f29e08-11ff-4c47-a6d1-6c4a4ae08ae8/arts/Kotlin.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"Kotlin、Swift、Scala 的延迟求值","keywords":"Kotlin Swift Property","date":"2020-05-22T16:00:00.000Z","description":null,"_content":"\n> “懒”是程序员最优秀的品质之一，程序也是如此。 \n\n\n\n<!-- more -->\n\n\n\n\n> 最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~\n\n## Kotlin 的延迟求值\n\nKotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。\n\n这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：\n\n```kotlin\n[Kotlin]\n\nval lazyValue by lazy { \n    complicatedComputing()\n}\n```\n\n除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：\n\n```kotlin\n[Kotlin]\n\nfun assertAllTrue(vararg conditions: Lazy<Boolean>): Boolean {\n    return conditions.all { it.value }\n}\n```\n\nassertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 `&&` 运算中的逻辑短路。代码中，it.value 的 it 是 `Lazy<Boolean>` 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。\n\n接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：\n\n```kotlin\n[Kotlin]\n\nfun returnFalse() = false.also { println(\"returnFalse called.\") }\nfun returnTrue() = true.also { println(\"returnTrue called.\") }\n```\n\n接下来我们调用 assertAllTrue 来看看会发生什么：\n\n```kotlin\n[Kotlin]\n\nval result = assertAllTrue(lazy { returnFalse() }, lazy { returnTrue() })\nprintln(result)\n```\n\n输出结果：\n\n```\nreturnFalse called.\nfalse\n```\n\n不意外吧？我们还可以模拟 `||` 再实现一个类似的函数：\n\n```kotlin\n[Kotlin]\n\nfun assertAnyTrue(vararg conditions: Lazy<Boolean>): Boolean {\n    return conditions.any { it.value }\n}\n```\n\n只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。\n\n简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。\n\n除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：\n\n```kotlin\n[Kotlin]\n\nfun assertAllTrue(vararg conditions: () -> Boolean): Boolean {\n    return conditions.all { it.invoke() }\n}\n```\n\n这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：\n\n```kotlin\n[Kotlin]\n\nval result = assertAllTrue({ returnFalse() }, ::returnTrue, ::returnFalse)\n```\n\n对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。\n\n## Scala 的延迟求值\n\n在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。\n\nKotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：\n\n```scala\n[Scala]\n\ndef timeConsumingWork(): Unit ={\n    ...\n}\n\n...\n\nlazy val stopTime = System.currentTimeMillis()\nval startTime = System.currentTimeMillis()\n\ntimeConsumingWork()\nprintln(stopTime - startTime)\n```\n\n我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 `System.currentTimeMillis()` 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。\n\n哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。\n\n我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：\n\n```scala\n[Scala]\n\ndef assertAllTrue(conditions: (() => Boolean)*): Boolean = {\n    conditions.forall(_.apply())\n}\n```\n\n其中 `() => Boolean` 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。\n\n用法如下：\n\n```scala\n[Scala]\n\nval result = assertAllTrue(returnFalse, returnTrue, () => returnFalse())\n```\n\n注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 `() => returnFalse()` 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。\n\nHmmm，这么看起来跟 Kotlin 真是一模一样啊。\n\n非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：\n\n```scala\n[Scala]\n\ndef assertBothTrue(left: => Boolean, right: => Boolean): Boolean = {\n    left && right\n}\n```\n\n可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。\n\n函数体内的最后一行就是函数的返回值，所以 `left && right` 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 `=>`，说它是函数类型吧， `=>` 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。\n\n接下来我们看下怎么使用：\n\n```scala\n[Scala]\n\nval result = assertBothTrue(returnFalse(), returnTrue())\nprintln(result)\n```\n\n我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。\n\n整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。\n\n哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）\n\n```scala\n[Scala]\n\nimplicit class BooleanByName(value: => Boolean) {\n    def valueByName: Boolean = value\n}\n\ndef assertAllTrue(conditions: BooleanByName*): Boolean = {\n    conditions.forall(_.valueByName)\n}\n```\n\n思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 `_.valueByName`），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。\n\n## Swift 的延迟求值\n\n最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。\n\nSwift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：\n\n```swift\n[Swift]\n\nclass LazyDemo {\n    lazy var value = complicatedComputing()\n    \n    func complicatedComputing() -> Int {\n        ... \n    }\n}\n```\n\n不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 `lazy let value = ...`，Swift 编译器会抱怨说 lazy 只能修饰 var。\n\n纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？\n\n其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？\n\n当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：\n\n```swift\n[Swift]\n\nprivate(set) lazy var value = ...\n```\n\n但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。\n\n接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：\n\n```swift\n[Swift]\n\nfunc assertAllTrue(_ conditions: () -> Bool ...) -> Bool {\n    conditions.allSatisfy { condition in condition() }\n}\n```\n\n大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。\n* 参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。\n* `() -> Bool` 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 ... 则表示这个参数为变长参数。\n* `{ condition in condition() }` 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 `{ (condition: () -> Bool) in condition() }`，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 `() -> Bool`。\n\n好，那我们下面调用一下这个函数试试看：\n\n```swift\n[Swift]\n\nlet result = assertAllTrue({ returnFalse() }, returnTrue, returnFalse)\n```\n\n第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。\n\n这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：\n\n```swift\n[Swift]\n\nfunc assertBothTrue(_ left: @autoclosure () -> Bool, _ right: @autoclosure () -> Bool) -> Bool {\n    left() && right()\n}\n```\n\n那调用时有什么不一样呢？\n\n```swift\n[Swift]\n\nlet result = assertBothTrue(returnFalse(), returnTrue())\n```\n\n我们直接传入表达式，Swift 会帮我们用 `{}` 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。\n\n简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。\n\n## 再来一个有趣的例子\n\n当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。\n\n常见的语言当中都有 `while` 循环，为什么没有 `whileNot` 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：\n\n```kotlin\n[Kotlin]\n\nfun whileNot(condition: () -> Boolean, action: () -> Unit) {\n    if(!condition()) {\n        action()\n        whileNot(condition, action)\n    }\n}\n```\n\n用法：\n\n```kotlin\n[Kotlin]\n\nvar i = 10\nwhileNot({ i < 0 }){\n    println(i)\n    i -= 1\n}\n```\n\n输出就是 10 9 ... 0\n\nScala 呢？\n\n```scala\n[Scala]\n\ndef whileNot(condition: => Boolean)(action: => Unit): Unit = {\n    if (!condition) {\n        action\n        whileNot(condition)(action)\n    }\n}\n```\n\n为了能让第二个参数用 `{ ... }` 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：\n\n```scala\n[Scala]\n\nvar i = 10\nwhileNot(i < 0) {\n    println(i)\n    i -= 1\n}\n```\n\n矮？是不是有那味了？这看着跟 while 已经没差了。\n\n下面是 Swift 的实现：\n\n```swift\n[Swift]\n\nfunc whileNot(_ condition: @autoclosure () -> Bool, _ action: () -> Void) {\n    if !condition() {\n        action()\n        whileNot(condition(), action)\n    }\n}\n```\n\n我似乎已经感觉到了那味儿~\n\n```swift\n[Swift]\n\nvar i = 10\nwhileNot(i < 0) {\n    print(i)\n    i -= 1\n}\n```\n\n怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。\n\n看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 `{}`，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 `{}` 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。\n\n其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。\n\n## 小结\n\n总结一下：\n\n1. Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点\n2. Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性\n3. Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。\n4. 他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。\n5. Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。\n6. Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/lazy-evaluation.md","raw":"---\ntitle:  Kotlin、Swift、Scala 的延迟求值 \nkeywords: Kotlin Swift Property \ndate: 2020/05/23\ndescription: \ntags: \n    - kotlin\n    - swift\n    - scala\n    - lazy \n---\n\n> “懒”是程序员最优秀的品质之一，程序也是如此。 \n\n\n\n<!-- more -->\n\n\n\n\n> 最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~\n\n## Kotlin 的延迟求值\n\nKotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。\n\n这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：\n\n```kotlin\n[Kotlin]\n\nval lazyValue by lazy { \n    complicatedComputing()\n}\n```\n\n除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：\n\n```kotlin\n[Kotlin]\n\nfun assertAllTrue(vararg conditions: Lazy<Boolean>): Boolean {\n    return conditions.all { it.value }\n}\n```\n\nassertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 `&&` 运算中的逻辑短路。代码中，it.value 的 it 是 `Lazy<Boolean>` 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。\n\n接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：\n\n```kotlin\n[Kotlin]\n\nfun returnFalse() = false.also { println(\"returnFalse called.\") }\nfun returnTrue() = true.also { println(\"returnTrue called.\") }\n```\n\n接下来我们调用 assertAllTrue 来看看会发生什么：\n\n```kotlin\n[Kotlin]\n\nval result = assertAllTrue(lazy { returnFalse() }, lazy { returnTrue() })\nprintln(result)\n```\n\n输出结果：\n\n```\nreturnFalse called.\nfalse\n```\n\n不意外吧？我们还可以模拟 `||` 再实现一个类似的函数：\n\n```kotlin\n[Kotlin]\n\nfun assertAnyTrue(vararg conditions: Lazy<Boolean>): Boolean {\n    return conditions.any { it.value }\n}\n```\n\n只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。\n\n简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。\n\n除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：\n\n```kotlin\n[Kotlin]\n\nfun assertAllTrue(vararg conditions: () -> Boolean): Boolean {\n    return conditions.all { it.invoke() }\n}\n```\n\n这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：\n\n```kotlin\n[Kotlin]\n\nval result = assertAllTrue({ returnFalse() }, ::returnTrue, ::returnFalse)\n```\n\n对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。\n\n## Scala 的延迟求值\n\n在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。\n\nKotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：\n\n```scala\n[Scala]\n\ndef timeConsumingWork(): Unit ={\n    ...\n}\n\n...\n\nlazy val stopTime = System.currentTimeMillis()\nval startTime = System.currentTimeMillis()\n\ntimeConsumingWork()\nprintln(stopTime - startTime)\n```\n\n我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 `System.currentTimeMillis()` 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。\n\n哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。\n\n我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：\n\n```scala\n[Scala]\n\ndef assertAllTrue(conditions: (() => Boolean)*): Boolean = {\n    conditions.forall(_.apply())\n}\n```\n\n其中 `() => Boolean` 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。\n\n用法如下：\n\n```scala\n[Scala]\n\nval result = assertAllTrue(returnFalse, returnTrue, () => returnFalse())\n```\n\n注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 `() => returnFalse()` 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。\n\nHmmm，这么看起来跟 Kotlin 真是一模一样啊。\n\n非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：\n\n```scala\n[Scala]\n\ndef assertBothTrue(left: => Boolean, right: => Boolean): Boolean = {\n    left && right\n}\n```\n\n可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。\n\n函数体内的最后一行就是函数的返回值，所以 `left && right` 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 `=>`，说它是函数类型吧， `=>` 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。\n\n接下来我们看下怎么使用：\n\n```scala\n[Scala]\n\nval result = assertBothTrue(returnFalse(), returnTrue())\nprintln(result)\n```\n\n我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。\n\n整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。\n\n哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）\n\n```scala\n[Scala]\n\nimplicit class BooleanByName(value: => Boolean) {\n    def valueByName: Boolean = value\n}\n\ndef assertAllTrue(conditions: BooleanByName*): Boolean = {\n    conditions.forall(_.valueByName)\n}\n```\n\n思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 `_.valueByName`），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。\n\n## Swift 的延迟求值\n\n最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。\n\nSwift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：\n\n```swift\n[Swift]\n\nclass LazyDemo {\n    lazy var value = complicatedComputing()\n    \n    func complicatedComputing() -> Int {\n        ... \n    }\n}\n```\n\n不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 `lazy let value = ...`，Swift 编译器会抱怨说 lazy 只能修饰 var。\n\n纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？\n\n其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？\n\n当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：\n\n```swift\n[Swift]\n\nprivate(set) lazy var value = ...\n```\n\n但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。\n\n接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：\n\n```swift\n[Swift]\n\nfunc assertAllTrue(_ conditions: () -> Bool ...) -> Bool {\n    conditions.allSatisfy { condition in condition() }\n}\n```\n\n大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。\n* 参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。\n* `() -> Bool` 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 ... 则表示这个参数为变长参数。\n* `{ condition in condition() }` 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 `{ (condition: () -> Bool) in condition() }`，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 `() -> Bool`。\n\n好，那我们下面调用一下这个函数试试看：\n\n```swift\n[Swift]\n\nlet result = assertAllTrue({ returnFalse() }, returnTrue, returnFalse)\n```\n\n第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。\n\n这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：\n\n```swift\n[Swift]\n\nfunc assertBothTrue(_ left: @autoclosure () -> Bool, _ right: @autoclosure () -> Bool) -> Bool {\n    left() && right()\n}\n```\n\n那调用时有什么不一样呢？\n\n```swift\n[Swift]\n\nlet result = assertBothTrue(returnFalse(), returnTrue())\n```\n\n我们直接传入表达式，Swift 会帮我们用 `{}` 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。\n\n简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。\n\n## 再来一个有趣的例子\n\n当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。\n\n常见的语言当中都有 `while` 循环，为什么没有 `whileNot` 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：\n\n```kotlin\n[Kotlin]\n\nfun whileNot(condition: () -> Boolean, action: () -> Unit) {\n    if(!condition()) {\n        action()\n        whileNot(condition, action)\n    }\n}\n```\n\n用法：\n\n```kotlin\n[Kotlin]\n\nvar i = 10\nwhileNot({ i < 0 }){\n    println(i)\n    i -= 1\n}\n```\n\n输出就是 10 9 ... 0\n\nScala 呢？\n\n```scala\n[Scala]\n\ndef whileNot(condition: => Boolean)(action: => Unit): Unit = {\n    if (!condition) {\n        action\n        whileNot(condition)(action)\n    }\n}\n```\n\n为了能让第二个参数用 `{ ... }` 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：\n\n```scala\n[Scala]\n\nvar i = 10\nwhileNot(i < 0) {\n    println(i)\n    i -= 1\n}\n```\n\n矮？是不是有那味了？这看着跟 while 已经没差了。\n\n下面是 Swift 的实现：\n\n```swift\n[Swift]\n\nfunc whileNot(_ condition: @autoclosure () -> Bool, _ action: () -> Void) {\n    if !condition() {\n        action()\n        whileNot(condition(), action)\n    }\n}\n```\n\n我似乎已经感觉到了那味儿~\n\n```swift\n[Swift]\n\nvar i = 10\nwhileNot(i < 0) {\n    print(i)\n    i -= 1\n}\n```\n\n怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。\n\n看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 `{}`，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 `{}` 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。\n\n其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。\n\n## 小结\n\n总结一下：\n\n1. Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点\n2. Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性\n3. Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。\n4. 他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。\n5. Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。\n6. Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"lazy-evaluation","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003n002mlduz502w8o0m","content":"<blockquote>\n<p>“懒”是程序员最优秀的品质之一，程序也是如此。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<blockquote>\n<p>最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~</p>\n</blockquote>\n<h2 id=\"Kotlin-的延迟求值\"><a href=\"#Kotlin-的延迟求值\" class=\"headerlink\" title=\"Kotlin 的延迟求值\"></a>Kotlin 的延迟求值</h2><p>Kotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。</p>\n<p>这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> lazyValue <span class=\"keyword\">by</span> lazy &#123; </span><br><span class=\"line\">    complicatedComputing()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAllTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: <span class=\"type\">Lazy</span>&lt;<span class=\"type\">Boolean</span>&gt;)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.all &#123; it.value &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>assertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 <code>&amp;&amp;</code> 运算中的逻辑短路。代码中，it.value 的 it 是 <code>Lazy&lt;Boolean&gt;</code> 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。</p>\n<p>接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnFalse</span><span class=\"params\">()</span></span> = <span class=\"literal\">false</span>.also &#123; println(<span class=\"string\">&quot;returnFalse called.&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnTrue</span><span class=\"params\">()</span></span> = <span class=\"literal\">true</span>.also &#123; println(<span class=\"string\">&quot;returnTrue called.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们调用 assertAllTrue 来看看会发生什么：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(lazy &#123; returnFalse() &#125;, lazy &#123; returnTrue() &#125;)</span><br><span class=\"line\">println(result)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returnFalse called.</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<p>不意外吧？我们还可以模拟 <code>||</code> 再实现一个类似的函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAnyTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: <span class=\"type\">Lazy</span>&lt;<span class=\"type\">Boolean</span>&gt;)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.any &#123; it.value &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。</p>\n<p>简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。</p>\n<p>除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAllTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: () -&gt; <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.all &#123; it.invoke() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(&#123; returnFalse() &#125;, ::returnTrue, ::returnFalse)</span><br></pre></td></tr></table></figure>\n\n<p>对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。</p>\n<h2 id=\"Scala-的延迟求值\"><a href=\"#Scala-的延迟求值\" class=\"headerlink\" title=\"Scala 的延迟求值\"></a>Scala 的延迟求值</h2><p>在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。</p>\n<p>Kotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">timeConsumingWork</span></span>(): <span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> stopTime = <span class=\"type\">System</span>.currentTimeMillis()</span><br><span class=\"line\"><span class=\"keyword\">val</span> startTime = <span class=\"type\">System</span>.currentTimeMillis()</span><br><span class=\"line\"></span><br><span class=\"line\">timeConsumingWork()</span><br><span class=\"line\">println(stopTime - startTime)</span><br></pre></td></tr></table></figure>\n\n<p>我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 <code>System.currentTimeMillis()</code> 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。</p>\n<p>哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。</p>\n<p>我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertAllTrue</span></span>(conditions: (() =&gt; <span class=\"type\">Boolean</span>)*): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    conditions.forall(_.apply())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>() =&gt; Boolean</code> 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。</p>\n<p>用法如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(returnFalse, returnTrue, () =&gt; returnFalse())</span><br></pre></td></tr></table></figure>\n\n<p>注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 <code>() =&gt; returnFalse()</code> 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。</p>\n<p>Hmmm，这么看起来跟 Kotlin 真是一模一样啊。</p>\n<p>非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertBothTrue</span></span>(left: =&gt; <span class=\"type\">Boolean</span>, right: =&gt; <span class=\"type\">Boolean</span>): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    left &amp;&amp; right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。</p>\n<p>函数体内的最后一行就是函数的返回值，所以 <code>left &amp;&amp; right</code> 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 <code>=&gt;</code>，说它是函数类型吧， <code>=&gt;</code> 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。</p>\n<p>接下来我们看下怎么使用：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br><span class=\"line\">println(result)</span><br></pre></td></tr></table></figure>\n\n<p>我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。</p>\n<p>整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。</p>\n<p>哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">implicit</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BooleanByName</span>(<span class=\"params\">value: =&gt; <span class=\"type\">Boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">valueByName</span></span>: <span class=\"type\">Boolean</span> = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertAllTrue</span></span>(conditions: <span class=\"type\">BooleanByName</span>*): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    conditions.forall(_.valueByName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 <code>_.valueByName</code>），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。</p>\n<h2 id=\"Swift-的延迟求值\"><a href=\"#Swift-的延迟求值\" class=\"headerlink\" title=\"Swift 的延迟求值\"></a>Swift 的延迟求值</h2><p>最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。</p>\n<p>Swift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> complicatedComputing()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">complicatedComputing</span>()</span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 <code>lazy let value = ...</code>，Swift 编译器会抱怨说 lazy 只能修饰 var。</p>\n<p>纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？</p>\n<p>其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？</p>\n<p>当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private(set)</span> <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> <span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。</p>\n<p>接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assertAllTrue</span>(<span class=\"keyword\">_</span> <span class=\"params\">conditions</span>: () -&gt; <span class=\"type\">Bool</span> <span class=\"operator\">...</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    conditions.allSatisfy &#123; condition <span class=\"keyword\">in</span> condition() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。</p>\n<ul>\n<li>参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。</li>\n<li><code>() -&gt; Bool</code> 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 … 则表示这个参数为变长参数。</li>\n<li><code>&#123; condition in condition() &#125;</code> 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 <code>&#123; (condition: () -&gt; Bool) in condition() &#125;</code>，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 <code>() -&gt; Bool</code>。</li>\n</ul>\n<p>好，那我们下面调用一下这个函数试试看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> assertAllTrue(&#123; returnFalse() &#125;, returnTrue, returnFalse)</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。</p>\n<p>这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assertBothTrue</span>(<span class=\"keyword\">_</span> <span class=\"params\">left</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>, <span class=\"keyword\">_</span> <span class=\"params\">right</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    left() <span class=\"operator\">&amp;&amp;</span> right()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那调用时有什么不一样呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> assertBothTrue(returnFalse(), returnTrue())</span><br></pre></td></tr></table></figure>\n\n<p>我们直接传入表达式，Swift 会帮我们用 <code>&#123;&#125;</code> 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。</p>\n<p>简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。</p>\n<h2 id=\"再来一个有趣的例子\"><a href=\"#再来一个有趣的例子\" class=\"headerlink\" title=\"再来一个有趣的例子\"></a>再来一个有趣的例子</h2><p>当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。</p>\n<p>常见的语言当中都有 <code>while</code> 循环，为什么没有 <code>whileNot</code> 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">whileNot</span><span class=\"params\">(condition: () -&gt; <span class=\"type\">Boolean</span>, action: () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!condition()) &#123;</span><br><span class=\"line\">        action()</span><br><span class=\"line\">        whileNot(condition, action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(&#123; i &lt; <span class=\"number\">0</span> &#125;)&#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出就是 10 9 … 0</p>\n<p>Scala 呢？</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">whileNot</span></span>(condition: =&gt; <span class=\"type\">Boolean</span>)(action: =&gt; <span class=\"type\">Unit</span>): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!condition) &#123;</span><br><span class=\"line\">        action</span><br><span class=\"line\">        whileNot(condition)(action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了能让第二个参数用 <code>&#123; ... &#125;</code> 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(i &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>矮？是不是有那味了？这看着跟 while 已经没差了。</p>\n<p>下面是 Swift 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">whileNot</span>(<span class=\"keyword\">_</span> <span class=\"params\">condition</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>, <span class=\"keyword\">_</span> <span class=\"params\">action</span>: () -&gt; <span class=\"type\">Void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"operator\">!</span>condition() &#123;</span><br><span class=\"line\">        action()</span><br><span class=\"line\">        whileNot(condition(), action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我似乎已经感觉到了那味儿~</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(i <span class=\"operator\">&lt;</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    i <span class=\"operator\">-=</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。</p>\n<p>看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 <code>&#123;&#125;</code>，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 <code>&#123;&#125;</code> 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。</p>\n<p>其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>总结一下：</p>\n<ol>\n<li>Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点</li>\n<li>Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性</li>\n<li>Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。</li>\n<li>他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。</li>\n<li>Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。</li>\n<li>Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。</li>\n</ol>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“懒”是程序员最优秀的品质之一，程序也是如此。 </p>\n</blockquote>","more":"<blockquote>\n<p>最近在探索相同特性在不同语言中实现的对比的文章写作思路，如果大家觉得有收获，别忘了点个赞让我感受一下；如果觉得这思路有问题，欢迎评论留言提建议 ~~</p>\n</blockquote>\n<h2 id=\"Kotlin-的延迟求值\"><a href=\"#Kotlin-的延迟求值\" class=\"headerlink\" title=\"Kotlin 的延迟求值\"></a>Kotlin 的延迟求值</h2><p>Kotlin 最初亮相的时候，基于属性代理实现的 Lazy 就是最吸引人的特性之一。只有使用时才会初始化，这个看上去简单的逻辑，通常我们在 Java 当中会写出来非常啰嗦，延迟初始化也经常因为各种原因变成“忘了”初始化，导致程序出现错误。</p>\n<p>这一切在 Kotlin 当中变得非常简单。Kotlin 的 Lazy 通过属性代理来实现，并没有引入额外的关键字，这一点似乎非常符合 Kotlin 的设计哲学（就像其他语言的协程都喜欢 async/await 关键字，而 Kotlin 只有一个 suspend 关键字就承载了及其复杂的逻辑一样）：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> lazyValue <span class=\"keyword\">by</span> lazy &#123; </span><br><span class=\"line\">    complicatedComputing()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了可以用于变量声明，Lazy 也同样适用于函数传参，这一点非常重要，我们来看个例子：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAllTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: <span class=\"type\">Lazy</span>&lt;<span class=\"type\">Boolean</span>&gt;)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.all &#123; it.value &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>assertAllTrue 这个函数的目的是判断所有参数的条件都为真，因此如果其中有一个为假，那么后面的条件就不用计算了，这个逻辑类似于我们常见的 <code>&amp;&amp;</code> 运算中的逻辑短路。代码中，it.value 的 it 是 <code>Lazy&lt;Boolean&gt;</code> 类型，value 是 Lazy 的属性，我们可以通过这个属性来触发 Lazy 逻辑的运算，并且返回这个结果 —— Lazy 用作属性代理时逻辑也是如此。</p>\n<p>接下来我们做下实验，首先定义两个函数用于提供条件值并通过打印输出来判断其是否被执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnFalse</span><span class=\"params\">()</span></span> = <span class=\"literal\">false</span>.also &#123; println(<span class=\"string\">&quot;returnFalse called.&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">returnTrue</span><span class=\"params\">()</span></span> = <span class=\"literal\">true</span>.also &#123; println(<span class=\"string\">&quot;returnTrue called.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们调用 assertAllTrue 来看看会发生什么：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(lazy &#123; returnFalse() &#125;, lazy &#123; returnTrue() &#125;)</span><br><span class=\"line\">println(result)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returnFalse called.</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<p>不意外吧？我们还可以模拟 <code>||</code> 再实现一个类似的函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAnyTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: <span class=\"type\">Lazy</span>&lt;<span class=\"type\">Boolean</span>&gt;)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.any &#123; it.value &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个为真就立即返回 true，后面的条件就不再计算了。大家可以自己试试给它传几个参数之后看看能得到什么结果。</p>\n<p>简单来说，Kotlin 的 Lazy 是一个很普通的类，它可以承载 Kotlin 当中各种对于延迟计算的需求的实现，用在属性定义上时借用了属性代理的语法，用作函数参数时就使用高阶函数 lazy 来构造或者直接传入函数作为参数即可。</p>\n<p>除了使用 Lazy 包装真实的值来实现延迟求值，我们当然也可以使用函数来做到这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">assertAllTrue</span><span class=\"params\">(<span class=\"keyword\">vararg</span> conditions: () -&gt; <span class=\"type\">Boolean</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conditions.all &#123; it.invoke() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，我们传入的参数就是一个函数，延迟计算的意图也更加明显：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(&#123; returnFalse() &#125;, ::returnTrue, ::returnFalse)</span><br></pre></td></tr></table></figure>\n\n<p>对于符合参数类型要求的 returnTrue 和 returnFalse 这两个函数，我们既可以直接传入函数引用，也可以构造一个 Lambda 表达式来包装对它们的调用。传入函数作为参数来实现延迟计算是最基本的手段，其他语言的处理也无非就是在此基础上增加一些友好的语法，后面我们在 Scala 和 Swift 部分就可以看到。</p>\n<h2 id=\"Scala-的延迟求值\"><a href=\"#Scala-的延迟求值\" class=\"headerlink\" title=\"Scala 的延迟求值\"></a>Scala 的延迟求值</h2><p>在 Scala 当中 lazy 是个关键字。而相比之下，在 Kotlin 当中我们提到 Lazy 是指类型，提到 lazy，则是指构造 Lazy 对象的高阶函数。</p>\n<p>Kotlin 当中的 Lazy 用在定义属性时，只支持只读属性或变量上（也就是 val 修饰的属性或变量），这一点 Scala 的用法比较类似，下面是一个比较无聊的例子，不过倒是能说明问题：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">timeConsumingWork</span></span>(): <span class=\"type\">Unit</span> =&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">lazy</span> <span class=\"keyword\">val</span> stopTime = <span class=\"type\">System</span>.currentTimeMillis()</span><br><span class=\"line\"><span class=\"keyword\">val</span> startTime = <span class=\"type\">System</span>.currentTimeMillis()</span><br><span class=\"line\"></span><br><span class=\"line\">timeConsumingWork()</span><br><span class=\"line\">println(stopTime - startTime)</span><br></pre></td></tr></table></figure>\n\n<p>我们想要统计下 timeConsumingWork 这个函数的调用耗时，stopTime 虽然先调用，但因为有 lazy 修饰，实际上等号右面的表达式 <code>System.currentTimeMillis()</code> 并没有立即执行，反而是后定义的 startTime 因为没有被 lazy 修饰而立即计算出值。所以这个程序还真能基本正确地输出 timeConsumingWork 函数执行的耗时。</p>\n<p>哇，这样看起来 Scala 使用 lazy 关键字定义属性的语法比起 Kotlin 要简单多了哎！不过换个角度，乍一看明明有一行代码放在前面却没有立即执行是不是会很怪呢？如果一时间没有注意到 lazy 关键字，代码阅读起来还真是有点儿令人迷惑呢。</p>\n<p>我们接着看看函数参数延迟求值的情况。在 Scala 当中同样存在高阶函数，因此我们几乎可以依样画葫芦写出 assertAllTrue 的 Scala 实现：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertAllTrue</span></span>(conditions: (() =&gt; <span class=\"type\">Boolean</span>)*): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    conditions.forall(_.apply())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>() =&gt; Boolean</code> 就是 Scala 中返回值为 Boolean 类型的函数类型，后面的 * 表示这是个变长参数；函数体当中我们对所有的条件进行遍历，并在 forall 当中调用 apply 来求出对应 condition 的值，这里的 forall 相当于 Kotlin 当中的 all，apply 相当于 Kotlin 当中函数的 invoke。</p>\n<p>用法如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertAllTrue(returnFalse, returnTrue, () =&gt; returnFalse())</span><br></pre></td></tr></table></figure>\n\n<p>注意到我们既可以直接把函数名作为值传入，这类似于 Kotlin 当中传入函数引用的做法，最后一个参数 <code>() =&gt; returnFalse()</code> 则是定义了一个 Lambda 表达式来包装到 returnFalse 函数的调用。</p>\n<p>Hmmm，这么看起来跟 Kotlin 真是一模一样啊。</p>\n<p>非也非也。Scala 的函数参数除了可以传递值以外，还有一种叫做传名参数，即仅在使用时才会触发求值的参数。我们还是以前面的 assertAllTrue 为例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertBothTrue</span></span>(left: =&gt; <span class=\"type\">Boolean</span>, right: =&gt; <span class=\"type\">Boolean</span>): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    left &amp;&amp; right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可惜的是，Scala 的传名参数不支持变长参数，所以例子有点儿缩水，不过不影响说明问题。</p>\n<p>函数体内的最后一行就是函数的返回值，所以 <code>left &amp;&amp; right</code> 的值就是 assertBothTrue 的返回值了；而 left 和 right 的参数类型长得有点儿奇怪，如果说它是 Boolean 吧，可它的类型前面还有个 <code>=&gt;</code>，说它是函数类型吧， <code>=&gt;</code> 前面也没有参数呀，而且用起来跟 Boolean 类型的变量看起来也没什么两样 —— 对喽，这就是传名参数，只有访问时才会计算参数的值，访问的方式与普通的变量没有什么区别，不过每次访问都会重新计算它的值，这一点又与函数的行为相同。</p>\n<p>接下来我们看下怎么使用：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> result = assertBothTrue(returnFalse(), returnTrue())</span><br><span class=\"line\">println(result)</span><br></pre></td></tr></table></figure>\n\n<p>我们看到传参时也没什么特别之处，直接传就好了，与我们通常的认知的不同之处在于，assertBothTrue 调用时不会立即对它的参数求值，所以其实这样看起来确实不太直观（这大概是 Kotlin 设计者最不喜欢 Scala 的地方了。。）。</p>\n<p>整体比较起来，Scala 对延迟求值做了语言级别的正式支持，因此语法上更省事儿，有些情况下代码显得也更自然。</p>\n<p>哦，对了，例子缩水的问题其实也是有办法解决的，哪有 Scala 解决不了的问题呢。。。：）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">implicit</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BooleanByName</span>(<span class=\"params\">value: =&gt; <span class=\"type\">Boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">valueByName</span></span>: <span class=\"type\">Boolean</span> = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">assertAllTrue</span></span>(conditions: <span class=\"type\">BooleanByName</span>*): <span class=\"type\">Boolean</span> = &#123;</span><br><span class=\"line\">    conditions.forall(_.valueByName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>思路也简单，既然 Scala 不支持把传名参数声明为变长参数，那么我们就换个其他类型，巧就巧在 Scala 还支持类型隐式转换，所以定义一个 BooleanByName 即可，这样我们调用 assertAllTrue 传的参数就可以是 Boolean 类型的表达式，编译器会帮我们自动转换为 BooleanByName 类型丢给 assertAllTrue 函数。BooleanByName 中的 valueByName 是一个函数，Scala 当中对于不修改类内部状态的无参函数通常声明成没有括号的样子，这样的函数调用时如同访问属性一样（ 如代码中的 <code>_.valueByName</code>），这在 Kotlin 当中的等价写法就是一个没有 backingfield 的只读属性的 getter。</p>\n<h2 id=\"Swift-的延迟求值\"><a href=\"#Swift-的延迟求值\" class=\"headerlink\" title=\"Swift 的延迟求值\"></a>Swift 的延迟求值</h2><p>最近比较喜欢 Swift，因为跟 Kotlin 长得像啊。不过随着了解的深入，发现二者虽然看起来很像，但用起来差异太大了，至少在延迟求值这个语法特性的设计上，Swift 形式上更像 Scala。</p>\n<p>Swift 的 lazy 也是一个关键字，可以修饰类的属性，不过它不支持修饰局部变量，因此我们只能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> complicatedComputing()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">complicatedComputing</span>()</span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"operator\">...</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难想到，只要第一次访问 value 时，complicatedComputing 才会被调用。从延迟求值的角度来讲与 Scala 是没什么差别的，不过大家仔细看会发现我们声明属性时用的是 var，也就是说 value 是可变的，这与 Scala、Kotlin 都不一样。更有趣的是，如果我们希望 value 是只读的，将它的声明改为 <code>lazy let value = ...</code>，Swift 编译器会抱怨说 lazy 只能修饰 var。</p>\n<p>纳尼？你们这些语言的设计者是怎么回事，意见居然这么不统一？</p>\n<p>其实 Swift 当中对于变量的读写有更严格的设计，这一点从 struct 与 class 的差异就可见一斑。而 lazy 之所以只能修饰 var，原因也很简单，声明的时候 value 虽然还没有初始化，但在后续访问的时候会触发求值，因此存在声明之后再赋值的逻辑。Hmmm，这个赋值行为从语言运行的角度来讲确实如此，可是这个逻辑不应该对开发者是透明的么，为什么要让开发者操心这么多？</p>\n<p>当然，如果想要保护 lazy 修饰的属性的写权限，可以考虑私有化 setter：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private(set)</span> <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> <span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>但类内部仍然可以修改 value 的值，所以这个方法的作用也很有限。</p>\n<p>接下来看下 Swift 当中函数参数的延迟求值。不难想到，我们将函数作为参数传入就可以实现这一点：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assertAllTrue</span>(<span class=\"keyword\">_</span> <span class=\"params\">conditions</span>: () -&gt; <span class=\"type\">Bool</span> <span class=\"operator\">...</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    conditions.allSatisfy &#123; condition <span class=\"keyword\">in</span> condition() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大体上写法与 Kotlin 类似，不过有几个细节我们来解释下。</p>\n<ul>\n<li>参数 conditions 前面的下划线，一般语言的参数都只有参数名，也就是 conditions，Swift 还有一个参数标签的概念，用于函数调用时指定（其实我们在 Kotlin 当中调用函数时也可以在参数前加参数名，但作为位置参数时不强制），用下划线可以省略掉这个标签。</li>\n<li><code>() -&gt; Bool</code> 表示 Swift 当中的函数类型，这与 Kotlin 的写法基本一致，后面的 … 则表示这个参数为变长参数。</li>\n<li><code>&#123; condition in condition() &#125;</code> 是 Swift 当中的 Lambda （在 Swift 当中称为 Closure，其实是一个东西），完整的写法是 <code>&#123; (condition: () -&gt; Bool) in condition() &#125;</code>，不难看出，in 是用来分隔参数列表和表达式体的，condition 是参数，它的类型是 <code>() -&gt; Bool</code>。</li>\n</ul>\n<p>好，那我们下面调用一下这个函数试试看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> assertAllTrue(&#123; returnFalse() &#125;, returnTrue, returnFalse)</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数使用 Lambda 表达式包装对 returnFalse 函数的调用；后面的两个参数直接使用函数名传入，这类似于 Kotlin 当中的函数引用的用法。结果不言而喻。</p>\n<p>这么看来 Swift 也可以通过传入函数来实现延迟求值。有了前面 Scala 的经验，我们就不免要想，函数参数延迟求值的写法上能否进一步简化呢？答案是能，通过 @autoclosure 来实现。不过不巧的是 @autoclosure 也不支持变长参数（嗯？？这句话好像在哪儿听到过？），所以我们的例子就又缩水成了下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assertBothTrue</span>(<span class=\"keyword\">_</span> <span class=\"params\">left</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>, <span class=\"keyword\">_</span> <span class=\"params\">right</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    left() <span class=\"operator\">&amp;&amp;</span> right()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那调用时有什么不一样呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> assertBothTrue(returnFalse(), returnTrue())</span><br></pre></td></tr></table></figure>\n\n<p>我们直接传入表达式，Swift 会帮我们用 <code>&#123;&#125;</code> 把它包装起来，换句话说，参数里面的 returnFalse 和 returnTrue 这两个函数只有用到的时候才会被调用。</p>\n<p>简单总结一下，Swift 通过 lazy 关键字来实现类属性的延迟求值，这一点写法上虽然与 Scala 很像，但只能修饰类或结构体的成员，而且是可读写的成员；Swift 同样可以通过传入函数的形式来支持函数参数的延迟求值，可以通过 @autoclosure 来简化调用过程中参数的写法，这一点其实从形式上与 Scala 的传名参数类似。</p>\n<h2 id=\"再来一个有趣的例子\"><a href=\"#再来一个有趣的例子\" class=\"headerlink\" title=\"再来一个有趣的例子\"></a>再来一个有趣的例子</h2><p>当语言设计地足够灵活，基于已有的语法经常也能造出“新特性”，接下来我们就造一个。</p>\n<p>常见的语言当中都有 <code>while</code> 循环，为什么没有 <code>whileNot</code> 呢？聪明的我们想到了这一点，于是就开始造语法了。先来看看 Kotlin 怎么实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">whileNot</span><span class=\"params\">(condition: () -&gt; <span class=\"type\">Boolean</span>, action: () -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!condition()) &#123;</span><br><span class=\"line\">        action()</span><br><span class=\"line\">        whileNot(condition, action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Kotlin]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(&#123; i &lt; <span class=\"number\">0</span> &#125;)&#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出就是 10 9 … 0</p>\n<p>Scala 呢？</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">whileNot</span></span>(condition: =&gt; <span class=\"type\">Boolean</span>)(action: =&gt; <span class=\"type\">Unit</span>): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!condition) &#123;</span><br><span class=\"line\">        action</span><br><span class=\"line\">        whileNot(condition)(action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了能让第二个参数用 <code>&#123; ... &#125;</code> 以类似于 Kotlin 的方式传入，我们用柯里化的方式声明了这个函数，来瞧瞧用法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Scala</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(i &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    println(i)</span><br><span class=\"line\">    i -= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>矮？是不是有那味了？这看着跟 while 已经没差了。</p>\n<p>下面是 Swift 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">whileNot</span>(<span class=\"keyword\">_</span> <span class=\"params\">condition</span>: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Bool</span>, <span class=\"keyword\">_</span> <span class=\"params\">action</span>: () -&gt; <span class=\"type\">Void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"operator\">!</span>condition() &#123;</span><br><span class=\"line\">        action()</span><br><span class=\"line\">        whileNot(condition(), action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我似乎已经感觉到了那味儿~</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"type\">Swift</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">whileNot(i <span class=\"operator\">&lt;</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    i <span class=\"operator\">-=</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么样，Swift 造出来的 whileNot 也几乎可以以假乱真了。</p>\n<p>看来真的只有你家 Kotlin “稍逊一筹” 啊，条件那里还必须加个 <code>&#123;&#125;</code>，没有语法糖可以将这个去掉。不过，（咳咳，官方口吻）Kotlin 一向不喜欢偷偷摸摸的，我们必须要保留 <code>&#123;&#125;</code> 让你一眼就能看出来那是个函数，而不像某些语言搞得那么暧昧。</p>\n<p>其实吧，单从这个例子的角度来讲，函数的参数类型声明还是挺清楚的，现在 IDE 这么牛逼，所以支持一下这样的特性算不算违反 Kotlin 的设计原则其实也不一定，不过目前看来这种不痛不痒的小特性还是算了吧，跨平台才是最牛逼的，加油 Kotlin，我等着 Android Studio 5.0 写 iOS 呢（zZZ）。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>总结一下：</p>\n<ol>\n<li>Kotlin 没有 lazy 关键字，通过属性代理实现只读属性的延迟求值，而 Scala 和 Swift 则通过 lazy 关键字来做到这一点</li>\n<li>Kotlin 和 Scala 对于属性的延迟求值只支持只读属性，Swift 只支持可变属性</li>\n<li>Kotlin 和 Scala 的延迟求值还支持局部变量，Swift 不支持。</li>\n<li>他们仨都支持通过传入函数的方式来实现函数参数的延迟求值。</li>\n<li>Scala 和 Swift 对函数参数延迟求值在语法上有更友好的支持，前者通过传名参数，后者通过 @autoclosure。</li>\n<li>Kotlin 是唯一一个通过其他特性顺带支持了一下延迟求值的，这很符合 Kotlin 设计者的一贯做法（(⊙o⊙)…）。</li>\n</ol>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"Kotlin、Swift、Scala 的延迟求值","path":"2020/05/23/lazy-evaluation/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>“懒”是程序员最优秀的品质之一，程序也是如此。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-05-22T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-05-22T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","swift","scala","lazy"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"== 与 equals 居然结果不一样！","date":"2019-03-22T16:00:00.000Z","_content":"\n### == 与 equals 意见不一致的情况\n\nKotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。\n\n一般情况下这种说法是没问题的，连 IDE 也都会提示你：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg)\n\n要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg)\n\n这回居然不提示我了！所以这里面一定有鬼！\n\n```kotlin\nprintln(equals)\nprintln(equals2)\n```\n\n你们猜猜结果如何？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg)\n我去，说好的 == 等价于 equals 呢？\n\n完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。\n\n<!--more-->\n\n以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？\n\n>NaN = Not a Number\n\nNaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。\n\n### Jvm 的为什么\n\n下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，\n\n== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg)\n\n而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：\n    \n```java\npublic boolean equals(Object obj) {\n    return (obj instanceof Float)\n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));\n}\n```\n    \n关于 `floatToIntBits` 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。\n\n### JavaScript 的为什么\n\n在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：\n\n```javascript\nvar equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;\nvar equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);\n```\n\n而 `kotlin_js_internal_FloatCompanionObject.NaN` 又等价于 `Number.NaN`，因此上面的代码其实就是：\n\n```js\nvar equals_0 = Number.NaN === Number.NaN;\nvar equals2 = equals(Number.NaN, Number.NaN);\n```\n\n对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：\n\n```js\n  Kotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n      return obj2 == null;\n    }\n    if (obj2 == null) {\n      return false;\n    }\n    if (obj1 !== obj1) {\n      return obj2 !== obj2;\n    }\n    if (typeof obj1 === 'object' && typeof obj1.equals === 'function') {\n      return obj1.equals(obj2);\n    }\n    if (typeof obj1 === 'number' && typeof obj2 === 'number') {\n      return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2);\n    }\n    return obj1 === obj2;\n  };\n```\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg)\n\n这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。\n\n### 其他情况的讨论\n\n对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。\n\n实际上对于基本类型，Kotlin 的 == 和  equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。\n\n\n---\n\n* Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~\n* 腾讯地图数据业务，坐标 **北京中关村**\n* 有兴趣的小伙伴可以发简历到 bennyhuo@kotliner.cn 哈~\n\n--- \n\n另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n\n\n\n\n","source":"_posts/nan-equals.md","raw":"---\ntitle: == 与 equals 居然结果不一样！\ndate: 2019/03/23\ntags:\n  - Kotlin\n---\n\n### == 与 equals 意见不一致的情况\n\nKotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。\n\n一般情况下这种说法是没问题的，连 IDE 也都会提示你：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg)\n\n要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg)\n\n这回居然不提示我了！所以这里面一定有鬼！\n\n```kotlin\nprintln(equals)\nprintln(equals2)\n```\n\n你们猜猜结果如何？\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg)\n我去，说好的 == 等价于 equals 呢？\n\n完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。\n\n<!--more-->\n\n以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？\n\n>NaN = Not a Number\n\nNaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。\n\n### Jvm 的为什么\n\n下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，\n\n== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg)\n\n而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：\n    \n```java\npublic boolean equals(Object obj) {\n    return (obj instanceof Float)\n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));\n}\n```\n    \n关于 `floatToIntBits` 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。\n\n### JavaScript 的为什么\n\n在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：\n\n```javascript\nvar equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;\nvar equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);\n```\n\n而 `kotlin_js_internal_FloatCompanionObject.NaN` 又等价于 `Number.NaN`，因此上面的代码其实就是：\n\n```js\nvar equals_0 = Number.NaN === Number.NaN;\nvar equals2 = equals(Number.NaN, Number.NaN);\n```\n\n对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：\n\n```js\n  Kotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n      return obj2 == null;\n    }\n    if (obj2 == null) {\n      return false;\n    }\n    if (obj1 !== obj1) {\n      return obj2 !== obj2;\n    }\n    if (typeof obj1 === 'object' && typeof obj1.equals === 'function') {\n      return obj1.equals(obj2);\n    }\n    if (typeof obj1 === 'number' && typeof obj2 === 'number') {\n      return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2);\n    }\n    return obj1 === obj2;\n  };\n```\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg)\n\n这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。\n\n### 其他情况的讨论\n\n对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。\n\n实际上对于基本类型，Kotlin 的 == 和  equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。\n\n\n---\n\n* Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~\n* 腾讯地图数据业务，坐标 **北京中关村**\n* 有兴趣的小伙伴可以发简历到 bennyhuo@kotliner.cn 哈~\n\n--- \n\n另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程啦！**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n\n\n\n\n","slug":"nan-equals","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi003o002nlduzht9od885","content":"<h3 id=\"与-equals-意见不一致的情况\"><a href=\"#与-equals-意见不一致的情况\" class=\"headerlink\" title=\"== 与 equals 意见不一致的情况\"></a>== 与 equals 意见不一致的情况</h3><p>Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。</p>\n<p>一般情况下这种说法是没问题的，连 IDE 也都会提示你：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg\"></p>\n<p>要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg\"></p>\n<p>这回居然不提示我了！所以这里面一定有鬼！</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(equals)</span><br><span class=\"line\">println(equals2)</span><br></pre></td></tr></table></figure>\n\n<p>你们猜猜结果如何？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg\"><br>我去，说好的 == 等价于 equals 呢？</p>\n<p>完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。</p>\n<span id=\"more\"></span>\n\n<p>以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？</p>\n<blockquote>\n<p>NaN = Not a Number</p>\n</blockquote>\n<p>NaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。</p>\n<h3 id=\"Jvm-的为什么\"><a href=\"#Jvm-的为什么\" class=\"headerlink\" title=\"Jvm 的为什么\"></a>Jvm 的为什么</h3><p>下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，</p>\n<p>== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg\"></p>\n<p>而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)</span><br><span class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于 <code>floatToIntBits</code> 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。</p>\n<h3 id=\"JavaScript-的为什么\"><a href=\"#JavaScript-的为什么\" class=\"headerlink\" title=\"JavaScript 的为什么\"></a>JavaScript 的为什么</h3><p>在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;</span><br><span class=\"line\"><span class=\"keyword\">var</span> equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);</span><br></pre></td></tr></table></figure>\n\n<p>而 <code>kotlin_js_internal_FloatCompanionObject.NaN</code> 又等价于 <code>Number.NaN</code>，因此上面的代码其实就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> equals_0 = <span class=\"built_in\">Number</span>.NaN === <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\"><span class=\"keyword\">var</span> equals2 = equals(<span class=\"built_in\">Number</span>.NaN, <span class=\"built_in\">Number</span>.NaN);</span><br></pre></td></tr></table></figure>\n\n<p>对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kotlin.equals = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj1, obj2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj2 == <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 !== obj1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj2 !== obj2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj1 === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj1.equals === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1.equals(obj2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj1 === <span class=\"string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj2 === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1 === obj2 &amp;&amp; (obj1 !== <span class=\"number\">0</span> || <span class=\"number\">1</span> / obj1 === <span class=\"number\">1</span> / obj2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj1 === obj2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg\"></p>\n<p>这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。</p>\n<h3 id=\"其他情况的讨论\"><a href=\"#其他情况的讨论\" class=\"headerlink\" title=\"其他情况的讨论\"></a>其他情况的讨论</h3><p>对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。</p>\n<p>实际上对于基本类型，Kotlin 的 == 和  equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。</p>\n<hr>\n<ul>\n<li>Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~</li>\n<li>腾讯地图数据业务，坐标 <strong>北京中关村</strong></li>\n<li>有兴趣的小伙伴可以发简历到 <a href=\"mailto:&#x62;&#x65;&#110;&#x6e;&#x79;&#x68;&#x75;&#111;&#x40;&#x6b;&#x6f;&#116;&#x6c;&#x69;&#110;&#101;&#114;&#x2e;&#x63;&#x6e;\">&#x62;&#x65;&#110;&#x6e;&#x79;&#x68;&#x75;&#111;&#x40;&#x6b;&#x6f;&#116;&#x6c;&#x69;&#110;&#101;&#114;&#x2e;&#x63;&#x6e;</a> 哈~</li>\n</ul>\n<hr>\n<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"与-equals-意见不一致的情况\"><a href=\"#与-equals-意见不一致的情况\" class=\"headerlink\" title=\"== 与 equals 意见不一致的情况\"></a>== 与 equals 意见不一致的情况</h3><p>Kotlin 当中 == 和 equals 是等价的，所以所有用 equals 的地方都可以用 == 来替换。</p>\n<p>一般情况下这种说法是没问题的，连 IDE 也都会提示你：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532962022762.jpg\"></p>\n<p>要不要换呢？这个就看哪种更有表现力了对不，对于这种情况，换了也就换了~但事情总是有例外，例如：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964071854.jpg\"></p>\n<p>这回居然不提示我了！所以这里面一定有鬼！</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(equals)</span><br><span class=\"line\">println(equals2)</span><br></pre></td></tr></table></figure>\n\n<p>你们猜猜结果如何？</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532964821915.jpg\"><br>我去，说好的 == 等价于 equals 呢？</p>\n<p>完了完了，这下说不好了。。扎心了老铁。。官方文档还能不能信啊。。。</p>","more":"<p>以上运行结果是 kotlin.jvm 的，那么我们试试 kotlin.js，结果一样。Kotlin Native 说，他们俩的立场并不能代码我的，但我的结果与他们一样。。。所以这个不是 bug 呵。大家意见这么一致，是不是也想告诉我们点儿什么呢？</p>\n<blockquote>\n<p>NaN = Not a Number</p>\n</blockquote>\n<p>NaN 说了，我可是一翻脸不认人的主，我翻脸了连我自己都不认！额这，，么尴尬么。</p>\n<h3 id=\"Jvm-的为什么\"><a href=\"#Jvm-的为什么\" class=\"headerlink\" title=\"Jvm 的为什么\"></a>Jvm 的为什么</h3><p>下面我们来剖析下在 Java 虚拟机上 == 和 equals 遇到 NaN 时都发生了什么吧。从字节码上来看，</p>\n<p>== 映射成了 Java 虚拟机的指令，也就是 Java 代码中的 ==，按照规定，NaN 是不等于任何数值包括自己的，也就是说这个指令在任何值与 NaN 作比较时都会返回 false。字节码如下图所示：</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532971508271.jpg\"></p>\n<p>而 equals 则映射成了 Java Float 的 equals 方法调用，我们来看下这个方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)</span><br><span class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于 <code>floatToIntBits</code> 的结果，主要返回浮点型的二进制表示，对于 NaN，那就是 0x7fc00000 了，这个是 IEEE 754 的规定。所以 equals 的执行 在 Java 虚拟机上就成了一个整数的比较，那么很显然会返回 true 了。</p>\n<h3 id=\"JavaScript-的为什么\"><a href=\"#JavaScript-的为什么\" class=\"headerlink\" title=\"JavaScript 的为什么\"></a>JavaScript 的为什么</h3><p>在 Js Target 上，我们很容易的就可以看到编译后的 JavaScript：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> equals_0 = kotlin_js_internal_FloatCompanionObject.NaN === kotlin_js_internal_FloatCompanionObject.NaN;</span><br><span class=\"line\"><span class=\"keyword\">var</span> equals2 = equals(kotlin_js_internal_FloatCompanionObject.NaN, kotlin_js_internal_FloatCompanionObject.NaN);</span><br></pre></td></tr></table></figure>\n\n<p>而 <code>kotlin_js_internal_FloatCompanionObject.NaN</code> 又等价于 <code>Number.NaN</code>，因此上面的代码其实就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> equals_0 = <span class=\"built_in\">Number</span>.NaN === <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\"><span class=\"keyword\">var</span> equals2 = equals(<span class=\"built_in\">Number</span>.NaN, <span class=\"built_in\">Number</span>.NaN);</span><br></pre></td></tr></table></figure>\n\n<p>对于第一行，JavaScript 与 Java 一样，规定 NaN 与自己不相等，所以返回 false，我们来看下第二行的 equals 函数的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kotlin.equals = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj1, obj2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj2 == <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 !== obj1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj2 !== obj2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj1 === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj1.equals === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1.equals(obj2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj1 === <span class=\"string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> obj2 === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1 === obj2 &amp;&amp; (obj1 !== <span class=\"number\">0</span> || <span class=\"number\">1</span> / obj1 === <span class=\"number\">1</span> / obj2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj1 === obj2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/1827dcb6-e1e0-4271-ba1c-622fad1448bb/post/media/15532983608746.jpg\"></p>\n<p>这一句其实就是为 NaN 量身定做的，如果 obj1 跟自己不相等，那么一定是 NaN，就剩下的就看 obj2 是不是 NaN了。</p>\n<h3 id=\"其他情况的讨论\"><a href=\"#其他情况的讨论\" class=\"headerlink\" title=\"其他情况的讨论\"></a>其他情况的讨论</h3><p>对于 NaN 在 == 与 equals 上表现出的不一致的情况，也是与平台相关的，而且 NaN 这个家伙本身的定义就是“六亲不认”，因此也讨论它的值的相等性是很无聊的一件事——除了看下 Kotlin 在各平台上的编译结果外。</p>\n<p>实际上对于基本类型，Kotlin 的 == 和  equals 确实会做出不同的编译映射处理，但这样的处理在除了 NaN 外的所有场景下结果都是一致的，因此这二者可以认为除了 NaN 之外的所有情形下都是等价的。</p>\n<hr>\n<ul>\n<li>Bennyhuo 所在的组招 Android 暑期实习生，有机会转正哦~</li>\n<li>腾讯地图数据业务，坐标 <strong>北京中关村</strong></li>\n<li>有兴趣的小伙伴可以发简历到 <a href=\"mailto:&#x62;&#x65;&#110;&#x6e;&#x79;&#x68;&#x75;&#111;&#x40;&#x6b;&#x6f;&#116;&#x6c;&#x69;&#110;&#101;&#114;&#x2e;&#x63;&#x6e;\">&#x62;&#x65;&#110;&#x6e;&#x79;&#x68;&#x75;&#111;&#x40;&#x6b;&#x6f;&#116;&#x6c;&#x69;&#110;&#101;&#114;&#x2e;&#x63;&#x6e;</a> 哈~</li>\n</ul>\n<hr>\n<p>另外，想要找到好 Offer、想要实现技术进阶的迷茫中的 Android 工程师们，推荐大家关注下我的新课《破解Android高级面试》，这门课已经更新完毕，涉及内容均非浅尝辄止，目前已经有200+同学在学习，你还在等什么(*≧∪≦)：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程啦！</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true},{"title":"父类返回子类类型的函数写法","date":"2019-02-17T16:00:00.000Z","_content":"\n今天的话题很简单，分享下也许对大家可以有帮助或者有启发。\n\n## 1. 背景\n\n一看题目，有点儿晕。看个例子马上就明白了：\n\n```kotlin\nabstract class EventBuilder() {\n    protected var retryLimit = 3\n\n    fun retryLimit(retryLimit: Int): EventBuilder {\n        this.retryLimit = retryLimit\n        return this\n    }\n\n    abstract fun build(): PollingEvent\n}\n```\n\n我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：\n\n```kotlin\nclass DisposableEventBuilder : EventBuilder() {\n    private var delay: Long = 0L\n    fun delay(delay: Long): DisposableEventBuilder {\n        this.delay = delay\n        return this\n    }\n\n    override fun build() = object: DisposableEvent(name, delay){\n        override fun onDisposableEvent() {\n            callback.onEvent(this)\n        }\n    }\n}\n```\n\n看上去也没啥大毛病，用一下吧：\n\n```kotlin\nDisposableEventBuilder().retryLimit(3)\n        .delay(60_000) // ERROR!! \n        .build()\n```\n我们调用完父类的 `retryLimit` 方法后，想要设置下 `delay`，结果发现没有这个方法。\n\n> “我 X，这什么玩意儿”，你嘟囔了一句。\n\n<!--more-->\n\n因为返回的是父类，所以链式调用掉链子了。这就尴尬了。\n\n## 2. Scala 的解法\n\n如果这段代码用 Scala 写，那么用 `this.type` 就简直完美的解决了这个问题：\n\n```scala\nabstract class SuperBuilder {\n    private var retryLimit: Int = 0\n\n    def retryLimit(retryLimit: Int): this.type = {\n        this.retryLimit = retryLimit\n        this\n    }\n}\n\nclass SubBuilder extends SuperBuilder {\n    private var delay: Long = 0\n\n    def delay(delay: Long): SubBuilder = {\n        this.delay = delay\n        this\n    }\n}\n```\n\n调用时：\n\n```scala\nnew SubBuilder().retryLimit(3).delay(60000)\n```\n\n一点儿毛病都么有。\n\nKotlin 有这个特性吗？并没有。\n\n## 3. Kotlin 的解法\n\nKotlin 倒也不是没有办法解决这个问题，用下泛型就好了：\n\n```kotlin\nabstract class EventBuilder<T : EventBuilder<T>>() {\n    protected var retryLimit = 3\n\n    fun retryLimit(retryLimit: Int): T {\n        this.retryLimit = retryLimit\n        return this as T\n    }\n\n    abstract fun build(): PollingEvent\n}\n```\n\n这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。\n\n子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：\n\n```kotlin\nclass DisposableEventBuilder : EventBuilder<DisposableEventBuilder>() {\n     ...\n}\n```\n\n其他的什么也不用动，这时候我们的链式调用就没啥问题了：\n\n```kotlin\nDisposableEventBuilder().retryLimit(3)\n        .delay(60_000) // OK!!\n        .build()\n```\n\n这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：\n\n```java\nabstract class SuperBuilder<T extends SuperBuilder<T>> {\n    private int retryLimit = 0;\n\n    T retryLimit(int retryLimit) {\n        this.retryLimit = retryLimit;\n        return (T) this;\n    }\n}\n\nclass SubBuilder extends SuperBuilder<SubBuilder> {\n    private long delay = 0;\n\n    SuperBuilder delay(long delay) {\n        this.delay = delay;\n        return this;\n    }\n}\n```\n\n好了，今天就先这样~~\n\n\n\n","source":"_posts/this-type.md","raw":"---\ntitle: 父类返回子类类型的函数写法\ndate: 2019/02/18\ntags:\n  - Kotlin\n  - SelfType\n---\n\n今天的话题很简单，分享下也许对大家可以有帮助或者有启发。\n\n## 1. 背景\n\n一看题目，有点儿晕。看个例子马上就明白了：\n\n```kotlin\nabstract class EventBuilder() {\n    protected var retryLimit = 3\n\n    fun retryLimit(retryLimit: Int): EventBuilder {\n        this.retryLimit = retryLimit\n        return this\n    }\n\n    abstract fun build(): PollingEvent\n}\n```\n\n我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：\n\n```kotlin\nclass DisposableEventBuilder : EventBuilder() {\n    private var delay: Long = 0L\n    fun delay(delay: Long): DisposableEventBuilder {\n        this.delay = delay\n        return this\n    }\n\n    override fun build() = object: DisposableEvent(name, delay){\n        override fun onDisposableEvent() {\n            callback.onEvent(this)\n        }\n    }\n}\n```\n\n看上去也没啥大毛病，用一下吧：\n\n```kotlin\nDisposableEventBuilder().retryLimit(3)\n        .delay(60_000) // ERROR!! \n        .build()\n```\n我们调用完父类的 `retryLimit` 方法后，想要设置下 `delay`，结果发现没有这个方法。\n\n> “我 X，这什么玩意儿”，你嘟囔了一句。\n\n<!--more-->\n\n因为返回的是父类，所以链式调用掉链子了。这就尴尬了。\n\n## 2. Scala 的解法\n\n如果这段代码用 Scala 写，那么用 `this.type` 就简直完美的解决了这个问题：\n\n```scala\nabstract class SuperBuilder {\n    private var retryLimit: Int = 0\n\n    def retryLimit(retryLimit: Int): this.type = {\n        this.retryLimit = retryLimit\n        this\n    }\n}\n\nclass SubBuilder extends SuperBuilder {\n    private var delay: Long = 0\n\n    def delay(delay: Long): SubBuilder = {\n        this.delay = delay\n        this\n    }\n}\n```\n\n调用时：\n\n```scala\nnew SubBuilder().retryLimit(3).delay(60000)\n```\n\n一点儿毛病都么有。\n\nKotlin 有这个特性吗？并没有。\n\n## 3. Kotlin 的解法\n\nKotlin 倒也不是没有办法解决这个问题，用下泛型就好了：\n\n```kotlin\nabstract class EventBuilder<T : EventBuilder<T>>() {\n    protected var retryLimit = 3\n\n    fun retryLimit(retryLimit: Int): T {\n        this.retryLimit = retryLimit\n        return this as T\n    }\n\n    abstract fun build(): PollingEvent\n}\n```\n\n这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。\n\n子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：\n\n```kotlin\nclass DisposableEventBuilder : EventBuilder<DisposableEventBuilder>() {\n     ...\n}\n```\n\n其他的什么也不用动，这时候我们的链式调用就没啥问题了：\n\n```kotlin\nDisposableEventBuilder().retryLimit(3)\n        .delay(60_000) // OK!!\n        .build()\n```\n\n这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：\n\n```java\nabstract class SuperBuilder<T extends SuperBuilder<T>> {\n    private int retryLimit = 0;\n\n    T retryLimit(int retryLimit) {\n        this.retryLimit = retryLimit;\n        return (T) this;\n    }\n}\n\nclass SubBuilder extends SuperBuilder<SubBuilder> {\n    private long delay = 0;\n\n    SuperBuilder delay(long delay) {\n        this.delay = delay;\n        return this;\n    }\n}\n```\n\n好了，今天就先这样~~\n\n\n\n","slug":"this-type","published":1,"updated":"2021-04-26T13:56:20.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0048006jlduzaobfgxe2","content":"<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p>\n<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBuilder</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">var</span> retryLimit = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retryLimit</span><span class=\"params\">(retryLimit: <span class=\"type\">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>: PollingEvent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisposableEventBuilder</span> : <span class=\"type\">EventBuilder</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> delay: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(delay: <span class=\"type\">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span> = <span class=\"keyword\">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDisposableEvent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            callback.onEvent(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上去也没啥大毛病，用一下吧：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableEventBuilder().retryLimit(<span class=\"number\">3</span>)</span><br><span class=\"line\">        .delay(<span class=\"number\">60_000</span>) <span class=\"comment\">// ERROR!! </span></span><br><span class=\"line\">        .build()</span><br></pre></td></tr></table></figure>\n<p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p>\n<blockquote>\n<p>“我 X，这什么玩意儿”，你嘟囔了一句。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p>\n<h2 id=\"2-Scala-的解法\"><a href=\"#2-Scala-的解法\" class=\"headerlink\" title=\"2. Scala 的解法\"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> retryLimit: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retryLimit</span></span>(retryLimit: <span class=\"type\">Int</span>): <span class=\"keyword\">this</span>.<span class=\"keyword\">type</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> delay: <span class=\"type\">Long</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delay</span></span>(delay: <span class=\"type\">Long</span>): <span class=\"type\">SubBuilder</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay</span><br><span class=\"line\">        <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">SubBuilder</span>().retryLimit(<span class=\"number\">3</span>).delay(<span class=\"number\">60000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>一点儿毛病都么有。</p>\n<p>Kotlin 有这个特性吗？并没有。</p>\n<h2 id=\"3-Kotlin-的解法\"><a href=\"#3-Kotlin-的解法\" class=\"headerlink\" title=\"3. Kotlin 的解法\"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBuilder</span>&lt;<span class=\"type\">T : EventBuilder&lt;T</span>&gt;&gt;</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">var</span> retryLimit = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retryLimit</span><span class=\"params\">(retryLimit: <span class=\"type\">Int</span>)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> T</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>: PollingEvent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p>\n<p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisposableEventBuilder</span> : <span class=\"type\">EventBuilder</span>&lt;<span class=\"type\">DisposableEventBuilder</span>&gt;</span>() &#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableEventBuilder().retryLimit(<span class=\"number\">3</span>)</span><br><span class=\"line\">        .delay(<span class=\"number\">60_000</span>) <span class=\"comment\">// OK!!</span></span><br><span class=\"line\">        .build()</span><br></pre></td></tr></table></figure>\n\n<p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">T</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> retryLimit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">retryLimit</span><span class=\"params\">(<span class=\"keyword\">int</span> retryLimit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">SubBuilder</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> delay = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SuperBuilder <span class=\"title\">delay</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，今天就先这样~~</p>\n","site":{"data":{}},"excerpt":"<p>今天的话题很简单，分享下也许对大家可以有帮助或者有启发。</p>\n<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>一看题目，有点儿晕。看个例子马上就明白了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBuilder</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">var</span> retryLimit = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retryLimit</span><span class=\"params\">(retryLimit: <span class=\"type\">Int</span>)</span></span>: EventBuilder &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>: PollingEvent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们有这么一个类，一看就是要写 Builder 模式。不过由于我们的这个 Event 的类型比较多，因此希望写一个父类，来一个子类感受下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisposableEventBuilder</span> : <span class=\"type\">EventBuilder</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> delay: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(delay: <span class=\"type\">Long</span>)</span></span>: DisposableEventBuilder &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span> = <span class=\"keyword\">object</span>: DisposableEvent(name, delay)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDisposableEvent</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            callback.onEvent(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上去也没啥大毛病，用一下吧：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableEventBuilder().retryLimit(<span class=\"number\">3</span>)</span><br><span class=\"line\">        .delay(<span class=\"number\">60_000</span>) <span class=\"comment\">// ERROR!! </span></span><br><span class=\"line\">        .build()</span><br></pre></td></tr></table></figure>\n<p>我们调用完父类的 <code>retryLimit</code> 方法后，想要设置下 <code>delay</code>，结果发现没有这个方法。</p>\n<blockquote>\n<p>“我 X，这什么玩意儿”，你嘟囔了一句。</p>\n</blockquote>","more":"<p>因为返回的是父类，所以链式调用掉链子了。这就尴尬了。</p>\n<h2 id=\"2-Scala-的解法\"><a href=\"#2-Scala-的解法\" class=\"headerlink\" title=\"2. Scala 的解法\"></a>2. Scala 的解法</h2><p>如果这段代码用 Scala 写，那么用 <code>this.type</code> 就简直完美的解决了这个问题：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> retryLimit: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retryLimit</span></span>(retryLimit: <span class=\"type\">Int</span>): <span class=\"keyword\">this</span>.<span class=\"keyword\">type</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> delay: <span class=\"type\">Long</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delay</span></span>(delay: <span class=\"type\">Long</span>): <span class=\"type\">SubBuilder</span> = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay</span><br><span class=\"line\">        <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用时：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">SubBuilder</span>().retryLimit(<span class=\"number\">3</span>).delay(<span class=\"number\">60000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>一点儿毛病都么有。</p>\n<p>Kotlin 有这个特性吗？并没有。</p>\n<h2 id=\"3-Kotlin-的解法\"><a href=\"#3-Kotlin-的解法\" class=\"headerlink\" title=\"3. Kotlin 的解法\"></a>3. Kotlin 的解法</h2><p>Kotlin 倒也不是没有办法解决这个问题，用下泛型就好了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBuilder</span>&lt;<span class=\"type\">T : EventBuilder&lt;T</span>&gt;&gt;</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">var</span> retryLimit = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retryLimit</span><span class=\"params\">(retryLimit: <span class=\"type\">Int</span>)</span></span>: T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> <span class=\"keyword\">as</span> T</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>: PollingEvent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个泛型给父类加了一个泛型参数，这个参数则必须是当前类的子类，那么这样的话我们就可以在返回自身类型的位置返回 T 这个类型了。</p>\n<p>子类的改动就很简单了，只需要给父类加一个泛型参数为自己的类型即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisposableEventBuilder</span> : <span class=\"type\">EventBuilder</span>&lt;<span class=\"type\">DisposableEventBuilder</span>&gt;</span>() &#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的什么也不用动，这时候我们的链式调用就没啥问题了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableEventBuilder().retryLimit(<span class=\"number\">3</span>)</span><br><span class=\"line\">        .delay(<span class=\"number\">60_000</span>) <span class=\"comment\">// OK!!</span></span><br><span class=\"line\">        .build()</span><br></pre></td></tr></table></figure>\n\n<p>这一点上 Kotlin 和 Java 其实是一致的，所以你也可以用 Java 写出类似的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">T</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> retryLimit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">retryLimit</span><span class=\"params\">(<span class=\"keyword\">int</span> retryLimit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.retryLimit = retryLimit;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperBuilder</span>&lt;<span class=\"title\">SubBuilder</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> delay = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SuperBuilder <span class=\"title\">delay</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，今天就先这样~~</p>","popularPost_tmp_postPath":true},{"title":"我写了一本书，《深入理解 Kotlin 协程》","keywords":"Kotlin 协程 书","date":"2020-06-22T16:00:00.000Z","description":null,"_content":"\n> 没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 \n\n\n\n<!-- more -->\n\n\n\n\n我研究 Kotlin 协程的过程其实主要分了三个阶段。\n\n**第一个阶段，深入理解 Kotlin 协程的三篇文章**。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章[深入理解 Kotlin Coroutine （一）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd)，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇[深入理解 Kotlin Coroutine (二）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd)，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章[深入理解 Kotlin Coroutine（三）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd)。\n\n**第二个阶段，[CoroutineLite](https://github.com/enbandari/CoroutineLite)**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作[基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计](https://coding.imooc.com/class/232.html) 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制[Kotlin从入门到精通](https://coding.imooc.com/class/398.html)和编写[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。\n\n**第三个阶段，破解 Kotlin 协程系列文章**。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：[Kotlin 协程文集](https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png)\n\n**<center>视频课程“Kotlin从入门到精通”中对协程的剖析</center>**\n\n现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。\n\n这本书主要回答了以下几个常见的问题：\n\n1. 协程是什么？Kotlin 协程又是什么？\n2. Kotlin 协程的工作机制是怎样的？\n3. 如何将 Kotlin 协程投入生产实践当中？\n\n不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。\n\n还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png)\n\n**<center>使用 JetBrains Mono 排版的代码效果</center>**\n\n书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png)\n\n**<center>《深入理解 Kotlin 协程》的插图制作</center>**\n\n环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。\n\n当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。\n\n可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。\n\n当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。\n\n感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/understanding-kotlin-coroutines.md","raw":"---\ntitle:  我写了一本书，《深入理解 Kotlin 协程》 \nkeywords: Kotlin 协程 书 \ndate: 2020/06/23\ndescription: \ntags: \n    - kotlin\n    - coroutines \n---\n\n> 没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 \n\n\n\n<!-- more -->\n\n\n\n\n我研究 Kotlin 协程的过程其实主要分了三个阶段。\n\n**第一个阶段，深入理解 Kotlin 协程的三篇文章**。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章[深入理解 Kotlin Coroutine （一）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd)，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇[深入理解 Kotlin Coroutine (二）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd)，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章[深入理解 Kotlin Coroutine（三）](https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd)。\n\n**第二个阶段，[CoroutineLite](https://github.com/enbandari/CoroutineLite)**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作[基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计](https://coding.imooc.com/class/232.html) 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制[Kotlin从入门到精通](https://coding.imooc.com/class/398.html)和编写[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。\n\n**第三个阶段，破解 Kotlin 协程系列文章**。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：[Kotlin 协程文集](https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196)。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png)\n\n**<center>视频课程“Kotlin从入门到精通”中对协程的剖析</center>**\n\n现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。\n\n这本书主要回答了以下几个常见的问题：\n\n1. 协程是什么？Kotlin 协程又是什么？\n2. Kotlin 协程的工作机制是怎样的？\n3. 如何将 Kotlin 协程投入生产实践当中？\n\n不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。\n\n还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png)\n\n**<center>使用 JetBrains Mono 排版的代码效果</center>**\n\n书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png)\n\n**<center>《深入理解 Kotlin 协程》的插图制作</center>**\n\n环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。\n\n当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。\n\n可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。\n\n当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。\n\n感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"understanding-kotlin-coroutines","published":1,"updated":"2021-05-09T18:14:47.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohi0048006klduzbtbl9u7s","content":"<blockquote>\n<p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 </p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n\n<p>我研究 Kotlin 协程的过程其实主要分了三个阶段。</p>\n<p><strong>第一个阶段，深入理解 Kotlin 协程的三篇文章</strong>。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine （一）</a>，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine (二）</a>，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine（三）</a>。</p>\n<p>**第二个阶段，<a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a>**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作<a href=\"https://coding.imooc.com/class/232.html\">基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计</a> 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制<a href=\"https://coding.imooc.com/class/398.html\">Kotlin从入门到精通</a>和编写<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。</p>\n<p><strong>第三个阶段，破解 Kotlin 协程系列文章</strong>。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：<a href=\"https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196\">Kotlin 协程文集</a>。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png\"></p>\n<p><strong><center>视频课程“Kotlin从入门到精通”中对协程的剖析</center></strong></p>\n<p>现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。</p>\n<p>这本书主要回答了以下几个常见的问题：</p>\n<ol>\n<li>协程是什么？Kotlin 协程又是什么？</li>\n<li>Kotlin 协程的工作机制是怎样的？</li>\n<li>如何将 Kotlin 协程投入生产实践当中？</li>\n</ol>\n<p>不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。</p>\n<p>还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png\"></p>\n<p><strong><center>使用 JetBrains Mono 排版的代码效果</center></strong></p>\n<p>书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png\"></p>\n<p><strong><center>《深入理解 Kotlin 协程》的插图制作</center></strong></p>\n<p>环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。</p>\n<p>当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。</p>\n<p>可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。</p>\n<p>当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。</p>\n<p>感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 </p>\n</blockquote>","more":"<p>我研究 Kotlin 协程的过程其实主要分了三个阶段。</p>\n<p><strong>第一个阶段，深入理解 Kotlin 协程的三篇文章</strong>。翻了翻过去的文章记录，我在 2017 年 1 月当时 Kotlin 1.1-beta 刚刚发布之时就发布了第一篇介绍协程的文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483875&idx=1&sn=b1b565f651ee1221d4bda19ab12009ce&chksm=e8a05ededfd7d7c878c1c483c577ec53bcf42ee4cb0fe5d13f29d12ff62a1e335c4afa616ffa&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine （一）</a>，主要介绍了协程的标准库的 API，以及简单的协程封装思路。随后在那年的春节发了第二篇<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247483878&idx=1&sn=710189e6e22a13fc7d1ea67bc2dd9270&chksm=e8a05edbdfd7d7cd163ee1a2d5769fc2bf003e2d5a6d3f9c6382531b7efc22a6ab75300bb906&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine (二）</a>，介绍协程的框架 kotlinx.coroutines 的一些功能，当时这个框架还非常的小，源码很容易就能够通读完，与现在简直不可同日而语了。期间也搞了一些线下的活动来分享协程的用法和作用，在 1.1 正式发布不久之后又写了一篇介绍协程的使用场景的文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484000&idx=1&sn=12f6a010c6fb554b94f68fd5ab6f941e&chksm=e8a05d5ddfd7d44b66c354041fd5f330a297c42b8d451f0b1f38676e83018263b2200c60be57&token=10610078&lang=zh_CN#rd\">深入理解 Kotlin Coroutine（三）</a>。</p>\n<p>**第二个阶段，<a href=\"https://github.com/enbandari/CoroutineLite\">CoroutineLite</a>**。这是我仿照官方协程框架 kotlinx.coroutines 的 API 自己实现的一套协程框架，目的主要是为了教学和研究，因此代码编写时主要考虑的目标是可读性，与官方框架追求性能的实现有着本质的不同。当然，这个框架的实现只包括了最基本的内容，像 Channel、Flow 这样更上层的组件便没有提供了。这个框架最初是在我在制作<a href=\"https://coding.imooc.com/class/232.html\">基于GitHub App业务 深度讲解 Kotlin高级特性与框架设计</a> 这门视频课程时开发的，由于当时 Kotlin 的版本是 1.2，因此视频当中提及的 CoroutineLite 还是一个雏形，直到我去年重制<a href=\"https://coding.imooc.com/class/398.html\">Kotlin从入门到精通</a>和编写<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>时，才为它添加了作用域、取消支持等功能，并进一步的完善很多细节上的设计。这个框架目前已经开源，希望它能够帮助各位读者更好的了解 Kotlin 协程的内部运行机制，这是必要的，也是必须的。</p>\n<p><strong>第三个阶段，破解 Kotlin 协程系列文章</strong>。这几年在帮助大家学习 Kotlin 的过程中，我发现大家对于协程逐渐产生不解、害怕甚至是不屑等各种各样的情绪，一方面是因为 Kotlin 的大部分受众源自于 Android 开发者群体，Android 开发者群体如果从一开始就在这个小圈子内成长的话，确实没有什么机会接触到协程。我自己也是 Android 开发，能够深刻的体会到 Android 技术圈子的局限性，只不过我有幸有机会多接触了几门语言和应用领域。这一系列文章就是想直接基于 Kotlin 1.3 以来已经成熟的生态和框架来介绍 Kotlin 协程，一写就是十几篇，我制作了一个文章合集，有兴趣的朋友可以参阅：<a href=\"https://mp.weixin.qq.com/mp/homepage?__biz=MzIzMTYzOTYzNA==&hid=4&sn=eb02d1dc6f5d92096f214688c6f87196\">Kotlin 协程文集</a>。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png\"></p>\n<p><strong><center>视频课程“Kotlin从入门到精通”中对协程的剖析</center></strong></p>\n<p>现在，我把前面的这些积累以及在于大家交流过程中发现的问题进行了分析和整理，参考了各家语言对于协程的实现，系统地剖析了 Kotlin 协程的方方面面，编撰成了这样一本《深入理解 Kotlin 协程》的书籍。</p>\n<p>这本书主要回答了以下几个常见的问题：</p>\n<ol>\n<li>协程是什么？Kotlin 协程又是什么？</li>\n<li>Kotlin 协程的工作机制是怎样的？</li>\n<li>如何将 Kotlin 协程投入生产实践当中？</li>\n</ol>\n<p>不仅如此，本书还致力于让大家能够自己尝试动手实现自己的协程框架，成为深谙 Kotlin 协程之道的高手，这样才配得上“深入理解”这个标题。</p>\n<p>还有一个小细节。本书印刷版中所有的代码都采用了 JetBrains Mono 这个字体，插图的文字也是如此。另外，本书代码缩进采用了 2 个空格的样式，目的也是为了减少折行，提高版面的空间利用率，进而提升阅读体验。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-07-06-10-23-25.png\"></p>\n<p><strong><center>使用 JetBrains Mono 排版的代码效果</center></strong></p>\n<p>书的编写过程也比较有意思。我是用 VSCode + Pandoc + graphviz + mermaid.js + plantUML + rx-marbles 等工具来编写的。其中，使用 VSCode 处理文字内容；使用 Pandoc 将 md 文件编译成 docx 文件；使用后面的四个工具来绘制插图 —— 它们实际上是将源码编译成图片的处理工具。</p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-39-57.png\"></p>\n<p><strong><center>《深入理解 Kotlin 协程》的插图制作</center></strong></p>\n<p>环境的配置，以及对这些工具的定制花去了我将近两个月的业余时间。除了使用 Haskell 编写的 Pandoc 的插件 cross-ref 我实在无法快速上手以外，我学习到了如何使用 Python 和 Lua 编写用来在编译过程中处理图片生成逻辑和文字预处理的 Pandoc 过滤器，以及如何通过修改源码解决 plantUML、mermaid.js、rx-marbles 的样式定制和字体的支持的问题，最后还借机学会了如何制作 docker 镜像。</p>\n<p>当然，我在本书写作过半之时，突发奇想开始学习双拼输入法，刚开始的那一段时间曾一度因为不知道如何打字而憋得着急上火，不过那时的感觉像极了十几年前在大学里刚买电脑之后连 QQ 都聊不明白的光景，自己似乎又年轻了一回。</p>\n<p>可以说，这一本书的编写过程，除了促使我对 Kotlin 协程有了一个更加宏观的概念把控之外，我还学到了非常多有意思的东西。</p>\n<p>当然，除了有意思之外，在写作的过程中我也确实无数次感觉到了对文字细节的疲惫，但一次次的修改和校对之后又觉得非常值得。</p>\n<p>感谢这样的一个机会，在这不平凡的 2020 年里，我写了一本书 ：）</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png","popularPost_tmp_gaData":{"updated":"Mon May 10 2021 02:14:47 GMT+0800 (China Standard Time)","title":"我写了一本书，《深入理解 Kotlin 协程》","path":"2020/06/23/understanding-kotlin-coroutines/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/2020-06-21-08-50-26.png","excerpt":"<blockquote>\n<p>没想到 Kotlin 的协程居然会成为一个有争议的话题，谁让官方材料太少呢。 </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2020-06-22T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2020-06-22T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","coroutines"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"重构代码的时候千万小心，SAM 转换可能会引发一个奇怪的运行时类不能访问的异常","keywords":"Java Kotlin SAM","date":"2021-06-03T16:00:00.000Z","description":null,"_content":"\n> SAM 转换是很香，不过还是要小心遇到坑 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1wB4y1g79W&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\nSAM 转换是一个非常有用的特性，这个特性不只在 Kotlin 当中有，Java 当中也有。\n\n从 Java 8 开始，Java 当中引入了对 Lambda 的支持，例如：\n\n```java\nView view = new View();\nview.setOnSizeChangedListener((width, height) -> {\n    System.out.println(\"w: \" + width + \", h: \" + height);\n});\n```\n\n这里 View 的定义如下：\n\n```java\npublic class View {\n    interface OnSizeChangedListener {\n        void onSizeChanged(int width, int height);\n    }\n\n    public void setOnSizeChangedListener(OnSizeChangedListener onSizeChangedListener) {\n        ...\n    }\n    ...\n}\n```\n\n对于形如 `OnSizeChangedListener` 这样具有单一方法的接口（注意，必须是接口），我们就可以用 Lambda 来简化调用处的写法，所以下面两种写法基本可以认为是等价的：\n\n```java\n// SAM 转换的写法\nview.setOnSizeChangedListener((width, height) -> {\n    System.out.println(\"w: \" + width + \", h: \" + height);\n});\n\n// 匿名内部类的写法\nview.setOnSizeChangedListener(new View.OnSizeChangedListener() {\n    @Override\n    public void onSizeChanged(int width, int height) {\n        System.out.println(\"w: \" + width + \", h: \" + height);\n    }\n});\n```\n\n当然它们不是完全等价的，区别主要是 `this` 的问题，这个我们就不展开了。\n\n既然 Java 可以，Kotlin 肯定不能落后的。所以就有了下面的写法：\n\n```kotlin\nView().setOnSizeChangedListener { width, height ->\n    println(\"w: $width, h: $height\")\n}\n```\n\n好的，了解了这些之后，我们就来看下今天我们想要讲的问题。\n\n## 包内可见的类？\n\n对于我这样一个写了 Kotlin 5 年以上的人来讲，这个问题实在是太令人困惑了。我们先来给大家看下代码的目录结构：\n\n```bash\nsamissue\n    ├── Java8Sam.java\n    ├── KotlinSam.kt\n    ├── View.java\n    └── sub\n         └── SubSam.kt\n```\n\nSubSam.kt 的内容如下：\n\n```kotlin\npackage com.bennyhuo.kotlin.samissue.sub\n\nimport com.bennyhuo.kotlin.samissue.View\n\nfun main() {\n    View().setOnSizeChangedListener { width, height ->\n        println(\"w: $width, h: $height\")\n    }\n}\n```\n\n我们再看下 View.java 的定义：\n\n```java\npackage com.bennyhuo.kotlin.samissue;\n\npublic class View {\n    interface OnSizeChangedListener {\n        void onSizeChanged(int width, int height);\n    }\n\n    public void setOnSizeChangedListener(OnSizeChangedListener onSizeChangedListener) {\n        ...\n    }\n    ...\n}\n```\n\n这代码有什么问题吗？这时候就需要各位发动自己脑子当中的编译器来反复找茬儿了。反正我第一眼看到这个代码的时候并没有意识到会有什么问题，编译也没什么毛病，就是运行时报错：\n\n```\nException in thread \"main\" java.lang.IllegalAccessError: class com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 cannot access its superinterface com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener (com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 and com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener are in unnamed module of loader 'app')\n\tat java.base/java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)\n\tat java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)\n\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt:6)\n\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt)\n```\n\n\n我一开始觉得可能是编译缓存导致的问题，于是花了十几分钟在 clean 和 reBuild 上，非常恼火。这代码怎么看都不像有问题，实际上我一开始没有能发现这个问题大概就是 Kotlin 写太久了，默认一切都是 public 的了。后来仔细看了下这个问题，又仔细看了下代码，瞬间捕捉到了这个细节：\n\n```java\ninterface OnSizeChangedListener {\n    void onSizeChanged(int width, int height);\n}\n```\n\n这个接口是包内可见！所以 SubSam.kt 这个文件自然是不应当能够访问到它的。\n\n可是问题又来了，为什么编译器没报错？因为 SAM 转换。注意这个类名：\n\n```kotlin\nclass com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1\n```\n\n这是错误信息当中提示我们的，这个类其实就是我们的 Lambda 表达式经过 SAM 转换之后生成的类。这个类在编译前不存在，编译之后才生成的，它生成的时机看来是晚于类的可见性检查的，于是就成了编译期的漏网之鱼。\n\n这，我觉得可以算是一个编译器的 BUG　吧。于是我去 YouTrack 提了个 BUG：https://youtrack.jetbrains.com/issue/KT-47104。\n\n解决办法其实很简单，接口改成 public 或者移入相同的包。实际上我们一般情况下也不会把接口约束成包内可见，这个问题并不会对我们造成代码设计上的影响，只是，万一遇到确实有点儿一时手足无措，发现了问题所在之后又着实尴尬。\n\n## 小结\n\nSAM 转换其实是 Kotlin 非常吸引人的一个特性，1.4 引入的 fun interface 则让它更加强大。不过，请大家千万注意，Lambda 不管是在 Java 还是 Kotlin 当中，编译时都大概率会生成一个类（有时候也会只生成几条指令），这往往也是引发问题的根源所在。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","source":"_posts/sam-meets-package-visibility.md","raw":"---\ntitle:  重构代码的时候千万小心，SAM 转换可能会引发一个奇怪的运行时类不能访问的异常 \nkeywords: Java Kotlin SAM \ndate: 2021/06/04\ndescription: \ntags: \n    - java\n    - kotlin\n    - sam \n---\n\n> SAM 转换是很香，不过还是要小心遇到坑 \n\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1wB4y1g79W&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<!-- more -->\n\n\n\n\nSAM 转换是一个非常有用的特性，这个特性不只在 Kotlin 当中有，Java 当中也有。\n\n从 Java 8 开始，Java 当中引入了对 Lambda 的支持，例如：\n\n```java\nView view = new View();\nview.setOnSizeChangedListener((width, height) -> {\n    System.out.println(\"w: \" + width + \", h: \" + height);\n});\n```\n\n这里 View 的定义如下：\n\n```java\npublic class View {\n    interface OnSizeChangedListener {\n        void onSizeChanged(int width, int height);\n    }\n\n    public void setOnSizeChangedListener(OnSizeChangedListener onSizeChangedListener) {\n        ...\n    }\n    ...\n}\n```\n\n对于形如 `OnSizeChangedListener` 这样具有单一方法的接口（注意，必须是接口），我们就可以用 Lambda 来简化调用处的写法，所以下面两种写法基本可以认为是等价的：\n\n```java\n// SAM 转换的写法\nview.setOnSizeChangedListener((width, height) -> {\n    System.out.println(\"w: \" + width + \", h: \" + height);\n});\n\n// 匿名内部类的写法\nview.setOnSizeChangedListener(new View.OnSizeChangedListener() {\n    @Override\n    public void onSizeChanged(int width, int height) {\n        System.out.println(\"w: \" + width + \", h: \" + height);\n    }\n});\n```\n\n当然它们不是完全等价的，区别主要是 `this` 的问题，这个我们就不展开了。\n\n既然 Java 可以，Kotlin 肯定不能落后的。所以就有了下面的写法：\n\n```kotlin\nView().setOnSizeChangedListener { width, height ->\n    println(\"w: $width, h: $height\")\n}\n```\n\n好的，了解了这些之后，我们就来看下今天我们想要讲的问题。\n\n## 包内可见的类？\n\n对于我这样一个写了 Kotlin 5 年以上的人来讲，这个问题实在是太令人困惑了。我们先来给大家看下代码的目录结构：\n\n```bash\nsamissue\n    ├── Java8Sam.java\n    ├── KotlinSam.kt\n    ├── View.java\n    └── sub\n         └── SubSam.kt\n```\n\nSubSam.kt 的内容如下：\n\n```kotlin\npackage com.bennyhuo.kotlin.samissue.sub\n\nimport com.bennyhuo.kotlin.samissue.View\n\nfun main() {\n    View().setOnSizeChangedListener { width, height ->\n        println(\"w: $width, h: $height\")\n    }\n}\n```\n\n我们再看下 View.java 的定义：\n\n```java\npackage com.bennyhuo.kotlin.samissue;\n\npublic class View {\n    interface OnSizeChangedListener {\n        void onSizeChanged(int width, int height);\n    }\n\n    public void setOnSizeChangedListener(OnSizeChangedListener onSizeChangedListener) {\n        ...\n    }\n    ...\n}\n```\n\n这代码有什么问题吗？这时候就需要各位发动自己脑子当中的编译器来反复找茬儿了。反正我第一眼看到这个代码的时候并没有意识到会有什么问题，编译也没什么毛病，就是运行时报错：\n\n```\nException in thread \"main\" java.lang.IllegalAccessError: class com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 cannot access its superinterface com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener (com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 and com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener are in unnamed module of loader 'app')\n\tat java.base/java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)\n\tat java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621)\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)\n\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt:6)\n\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt)\n```\n\n\n我一开始觉得可能是编译缓存导致的问题，于是花了十几分钟在 clean 和 reBuild 上，非常恼火。这代码怎么看都不像有问题，实际上我一开始没有能发现这个问题大概就是 Kotlin 写太久了，默认一切都是 public 的了。后来仔细看了下这个问题，又仔细看了下代码，瞬间捕捉到了这个细节：\n\n```java\ninterface OnSizeChangedListener {\n    void onSizeChanged(int width, int height);\n}\n```\n\n这个接口是包内可见！所以 SubSam.kt 这个文件自然是不应当能够访问到它的。\n\n可是问题又来了，为什么编译器没报错？因为 SAM 转换。注意这个类名：\n\n```kotlin\nclass com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1\n```\n\n这是错误信息当中提示我们的，这个类其实就是我们的 Lambda 表达式经过 SAM 转换之后生成的类。这个类在编译前不存在，编译之后才生成的，它生成的时机看来是晚于类的可见性检查的，于是就成了编译期的漏网之鱼。\n\n这，我觉得可以算是一个编译器的 BUG　吧。于是我去 YouTrack 提了个 BUG：https://youtrack.jetbrains.com/issue/KT-47104。\n\n解决办法其实很简单，接口改成 public 或者移入相同的包。实际上我们一般情况下也不会把接口约束成包内可见，这个问题并不会对我们造成代码设计上的影响，只是，万一遇到确实有点儿一时手足无措，发现了问题所在之后又着实尴尬。\n\n## 小结\n\nSAM 转换其实是 Kotlin 非常吸引人的一个特性，1.4 引入的 fun interface 则让它更加强大。不过，请大家千万注意，Lambda 不管是在 Java 还是 Kotlin 当中，编译时都大概率会生成一个类（有时候也会只生成几条指令），这往往也是引发问题的根源所在。\n\n---\n\n\nC 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：\n\n**扫描二维码或者点击链接[《C 语言系统精讲》](https://coding.imooc.com/class/463.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png)\n\n\n--- \n\nKotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：\n\n**扫描二维码或者点击链接[《深入理解 Kotlin 协程》](https://item.jd.com/12898592.html)购买本书**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png)\n\n---\n\n如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：\n\n**扫描二维码或者点击链接[《Kotlin 入门到精通》](https://coding.imooc.com/class/398.html)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png)\n\n---\n\nAndroid 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：\n\n**扫描二维码或者点击链接[《破解Android高级面试》](https://s.imooc.com/SBS30PR)即可进入课程**\n\n![](https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg)\n\n","slug":"sam-meets-package-visibility","published":1,"updated":"2021-06-03T23:34:49.265Z","_id":"ckphjb8tn0000a9uz8fb9bwgu","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>SAM 转换是很香，不过还是要小心遇到坑 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1wB4y1g79W&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<span id=\"more\"></span>\n\n\n\n\n<p>SAM 转换是一个非常有用的特性，这个特性不只在 Kotlin 当中有，Java 当中也有。</p>\n<p>从 Java 8 开始，Java 当中引入了对 Lambda 的支持，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View view = <span class=\"keyword\">new</span> View();</span><br><span class=\"line\">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里 View 的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnSizeChangedListener</span><span class=\"params\">(OnSizeChangedListener onSizeChangedListener)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于形如 <code>OnSizeChangedListener</code> 这样具有单一方法的接口（注意，必须是接口），我们就可以用 Lambda 来简化调用处的写法，所以下面两种写法基本可以认为是等价的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SAM 转换的写法</span></span><br><span class=\"line\">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名内部类的写法</span></span><br><span class=\"line\">view.setOnSizeChangedListener(<span class=\"keyword\">new</span> View.OnSizeChangedListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然它们不是完全等价的，区别主要是 <code>this</code> 的问题，这个我们就不展开了。</p>\n<p>既然 Java 可以，Kotlin 肯定不能落后的。所以就有了下面的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;w: <span class=\"variable\">$width</span>, h: <span class=\"variable\">$height</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好的，了解了这些之后，我们就来看下今天我们想要讲的问题。</p>\n<h2 id=\"包内可见的类？\"><a href=\"#包内可见的类？\" class=\"headerlink\" title=\"包内可见的类？\"></a>包内可见的类？</h2><p>对于我这样一个写了 Kotlin 5 年以上的人来讲，这个问题实在是太令人困惑了。我们先来给大家看下代码的目录结构：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">samissue</span><br><span class=\"line\">    ├── Java8Sam.java</span><br><span class=\"line\">    ├── KotlinSam.kt</span><br><span class=\"line\">    ├── View.java</span><br><span class=\"line\">    └── sub</span><br><span class=\"line\">         └── SubSam.kt</span><br></pre></td></tr></table></figure>\n\n<p>SubSam.kt 的内容如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bennyhuo.kotlin.samissue.sub</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bennyhuo.kotlin.samissue.View</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;w: <span class=\"variable\">$width</span>, h: <span class=\"variable\">$height</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再看下 View.java 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bennyhuo.kotlin.samissue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnSizeChangedListener</span><span class=\"params\">(OnSizeChangedListener onSizeChangedListener)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这代码有什么问题吗？这时候就需要各位发动自己脑子当中的编译器来反复找茬儿了。反正我第一眼看到这个代码的时候并没有意识到会有什么问题，编译也没什么毛病，就是运行时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalAccessError: class com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 cannot access its superinterface com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener (com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 and com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener are in unnamed module of loader &#39;app&#39;)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.defineClass(ClassLoader.java:1017)</span><br><span class=\"line\">\tat java.base&#x2F;java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.loadClass(ClassLoader.java:522)</span><br><span class=\"line\">\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt:6)</span><br><span class=\"line\">\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt)</span><br></pre></td></tr></table></figure>\n\n\n<p>我一开始觉得可能是编译缓存导致的问题，于是花了十几分钟在 clean 和 reBuild 上，非常恼火。这代码怎么看都不像有问题，实际上我一开始没有能发现这个问题大概就是 Kotlin 写太久了，默认一切都是 public 的了。后来仔细看了下这个问题，又仔细看了下代码，瞬间捕捉到了这个细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口是包内可见！所以 SubSam.kt 这个文件自然是不应当能够访问到它的。</p>\n<p>可是问题又来了，为什么编译器没报错？因为 SAM 转换。注意这个类名：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bennyhuo</span>.<span class=\"title\">kotlin</span>.<span class=\"title\">samissue</span>.<span class=\"title\">sub</span>.<span class=\"title\">SubSamKt</span>$<span class=\"title\">main</span>$1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是错误信息当中提示我们的，这个类其实就是我们的 Lambda 表达式经过 SAM 转换之后生成的类。这个类在编译前不存在，编译之后才生成的，它生成的时机看来是晚于类的可见性检查的，于是就成了编译期的漏网之鱼。</p>\n<p>这，我觉得可以算是一个编译器的 BUG　吧。于是我去 YouTrack 提了个 BUG：<a href=\"https://youtrack.jetbrains.com/issue/KT-47104%E3%80%82\">https://youtrack.jetbrains.com/issue/KT-47104。</a></p>\n<p>解决办法其实很简单，接口改成 public 或者移入相同的包。实际上我们一般情况下也不会把接口约束成包内可见，这个问题并不会对我们造成代码设计上的影响，只是，万一遇到确实有点儿一时手足无措，发现了问题所在之后又着实尴尬。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>SAM 转换其实是 Kotlin 非常吸引人的一个特性，1.4 引入的 fun interface 则让它更加强大。不过，请大家千万注意，Lambda 不管是在 Java 还是 Kotlin 当中，编译时都大概率会生成一个类（有时候也会只生成几条指令），这往往也是引发问题的根源所在。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>SAM 转换是很香，不过还是要小心遇到坑 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1wB4y1g79W&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","more":"<p>SAM 转换是一个非常有用的特性，这个特性不只在 Kotlin 当中有，Java 当中也有。</p>\n<p>从 Java 8 开始，Java 当中引入了对 Lambda 的支持，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View view = <span class=\"keyword\">new</span> View();</span><br><span class=\"line\">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里 View 的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnSizeChangedListener</span><span class=\"params\">(OnSizeChangedListener onSizeChangedListener)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于形如 <code>OnSizeChangedListener</code> 这样具有单一方法的接口（注意，必须是接口），我们就可以用 Lambda 来简化调用处的写法，所以下面两种写法基本可以认为是等价的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SAM 转换的写法</span></span><br><span class=\"line\">view.setOnSizeChangedListener((width, height) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名内部类的写法</span></span><br><span class=\"line\">view.setOnSizeChangedListener(<span class=\"keyword\">new</span> View.OnSizeChangedListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;w: &quot;</span> + width + <span class=\"string\">&quot;, h: &quot;</span> + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当然它们不是完全等价的，区别主要是 <code>this</code> 的问题，这个我们就不展开了。</p>\n<p>既然 Java 可以，Kotlin 肯定不能落后的。所以就有了下面的写法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;w: <span class=\"variable\">$width</span>, h: <span class=\"variable\">$height</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好的，了解了这些之后，我们就来看下今天我们想要讲的问题。</p>\n<h2 id=\"包内可见的类？\"><a href=\"#包内可见的类？\" class=\"headerlink\" title=\"包内可见的类？\"></a>包内可见的类？</h2><p>对于我这样一个写了 Kotlin 5 年以上的人来讲，这个问题实在是太令人困惑了。我们先来给大家看下代码的目录结构：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">samissue</span><br><span class=\"line\">    ├── Java8Sam.java</span><br><span class=\"line\">    ├── KotlinSam.kt</span><br><span class=\"line\">    ├── View.java</span><br><span class=\"line\">    └── sub</span><br><span class=\"line\">         └── SubSam.kt</span><br></pre></td></tr></table></figure>\n\n<p>SubSam.kt 的内容如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bennyhuo.kotlin.samissue.sub</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bennyhuo.kotlin.samissue.View</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    View().setOnSizeChangedListener &#123; width, height -&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;w: <span class=\"variable\">$width</span>, h: <span class=\"variable\">$height</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再看下 View.java 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.bennyhuo.kotlin.samissue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnSizeChangedListener</span><span class=\"params\">(OnSizeChangedListener onSizeChangedListener)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这代码有什么问题吗？这时候就需要各位发动自己脑子当中的编译器来反复找茬儿了。反正我第一眼看到这个代码的时候并没有意识到会有什么问题，编译也没什么毛病，就是运行时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalAccessError: class com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 cannot access its superinterface com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener (com.bennyhuo.kotlin.samissue.sub.SubSamKt$main$1 and com.bennyhuo.kotlin.samissue.View$OnSizeChangedListener are in unnamed module of loader &#39;app&#39;)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.defineClass(ClassLoader.java:1017)</span><br><span class=\"line\">\tat java.base&#x2F;java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579)</span><br><span class=\"line\">\tat java.base&#x2F;jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)</span><br><span class=\"line\">\tat java.base&#x2F;java.lang.ClassLoader.loadClass(ClassLoader.java:522)</span><br><span class=\"line\">\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt:6)</span><br><span class=\"line\">\tat com.bennyhuo.kotlin.samissue.sub.SubSamKt.main(SubSam.kt)</span><br></pre></td></tr></table></figure>\n\n\n<p>我一开始觉得可能是编译缓存导致的问题，于是花了十几分钟在 clean 和 reBuild 上，非常恼火。这代码怎么看都不像有问题，实际上我一开始没有能发现这个问题大概就是 Kotlin 写太久了，默认一切都是 public 的了。后来仔细看了下这个问题，又仔细看了下代码，瞬间捕捉到了这个细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSizeChangedListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSizeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口是包内可见！所以 SubSam.kt 这个文件自然是不应当能够访问到它的。</p>\n<p>可是问题又来了，为什么编译器没报错？因为 SAM 转换。注意这个类名：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">bennyhuo</span>.<span class=\"title\">kotlin</span>.<span class=\"title\">samissue</span>.<span class=\"title\">sub</span>.<span class=\"title\">SubSamKt</span>$<span class=\"title\">main</span>$1</span></span><br></pre></td></tr></table></figure>\n\n<p>这是错误信息当中提示我们的，这个类其实就是我们的 Lambda 表达式经过 SAM 转换之后生成的类。这个类在编译前不存在，编译之后才生成的，它生成的时机看来是晚于类的可见性检查的，于是就成了编译期的漏网之鱼。</p>\n<p>这，我觉得可以算是一个编译器的 BUG　吧。于是我去 YouTrack 提了个 BUG：<a href=\"https://youtrack.jetbrains.com/issue/KT-47104%E3%80%82\">https://youtrack.jetbrains.com/issue/KT-47104。</a></p>\n<p>解决办法其实很简单，接口改成 public 或者移入相同的包。实际上我们一般情况下也不会把接口约束成包内可见，这个问题并不会对我们造成代码设计上的影响，只是，万一遇到确实有点儿一时手足无措，发现了问题所在之后又着实尴尬。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>SAM 转换其实是 Kotlin 非常吸引人的一个特性，1.4 引入的 fun interface 则让它更加强大。不过，请大家千万注意，Lambda 不管是在 Java 还是 Kotlin 当中，编译时都大概率会生成一个类（有时候也会只生成几条指令），这往往也是引发问题的根源所在。</p>\n<hr>\n<p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/463.html\">《C 语言系统精讲》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png\"></p>\n<hr>\n<p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://item.jd.com/12898592.html\">《深入理解 Kotlin 协程》</a>购买本书</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png\"></p>\n<hr>\n<p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://coding.imooc.com/class/398.html\">《Kotlin 入门到精通》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png\"></p>\n<hr>\n<p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p>\n<p><strong>扫描二维码或者点击链接<a href=\"https://s.imooc.com/SBS30PR\">《破解Android高级面试》</a>即可进入课程</strong></p>\n<p><img src=\"https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg\"></p>","popularPost_tmp_postPath":true,"eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","popularPost_tmp_gaData":{"updated":"Fri Jun 04 2021 07:34:49 GMT+0800 (China Standard Time)","title":"重构代码的时候千万小心，SAM 转换可能会引发一个奇怪的运行时类不能访问的异常","path":"2021/06/04/sam-meets-package-visibility/","eyeCatchImage":"https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png","excerpt":"<blockquote>\n<p>SAM 转换是很香，不过还是要小心遇到坑 </p>\n</blockquote>\n<iframe class=\"bilibili\"  src=\"//player.bilibili.com/player.html?aid=290197027&bvid=BV1wB4y1g79W&cid=325923583&page=1&high_quality=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","date":{"_isAMomentObject":true,"_i":"2021-06-03T16:00:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-06-03T16:00:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["kotlin","java","sam"],"internalLinks":[],"keywords":[],"keywordsLength":0}}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckohi002q0001lduz5cxwam4m","tag_id":"ckohi002u0004lduzdgbe4v39","_id":"ckohi0030000flduzhar3f9f8"},{"post_id":"ckohi002q0001lduz5cxwam4m","tag_id":"ckohi002y000alduza0yu98vy","_id":"ckohi0031000hlduz07re0dq8"},{"post_id":"ckohi002t0003lduz1vj189rv","tag_id":"ckohi002z000dlduz7k62ap5d","_id":"ckohi0035000qlduzbmgo4dnz"},{"post_id":"ckohi002t0003lduz1vj189rv","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi0035000slduzb25n79x8"},{"post_id":"ckohi002t0003lduz1vj189rv","tag_id":"ckohi0032000llduzfomd42oe","_id":"ckohi0036000vlduzffb6dcny"},{"post_id":"ckohi003c0019lduz0jivddts","tag_id":"ckohi0035000plduzh2fq1hip","_id":"ckohi003e001glduz5k3v1bf5"},{"post_id":"ckohi003c0019lduz0jivddts","tag_id":"ckohi0036000ulduz8x1b8aw0","_id":"ckohi003e001ilduz98vc2y5j"},{"post_id":"ckohi003c0019lduz0jivddts","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003f001llduzeclv4j7j"},{"post_id":"ckohi003c0019lduz0jivddts","tag_id":"ckohi00380011lduz1th74u2j","_id":"ckohi003g001nlduzcio26rmx"},{"post_id":"ckohi003d001clduzd59dglg6","tag_id":"ckohi0035000plduzh2fq1hip","_id":"ckohi003g001qlduzgtlmg1bq"},{"post_id":"ckohi003d001clduzd59dglg6","tag_id":"ckohi0036000ulduz8x1b8aw0","_id":"ckohi003h001slduz2hl09d9a"},{"post_id":"ckohi003e001jlduz7sge1hpo","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003i001vlduzedzf4yki"},{"post_id":"ckohi003e001jlduz7sge1hpo","tag_id":"ckohi002y000alduza0yu98vy","_id":"ckohi003i001xlduzasxfc7nw"},{"post_id":"ckohi002x0008lduzhd5cbcxv","tag_id":"ckohi0035000plduzh2fq1hip","_id":"ckohi003j0020lduz9g0y8d00"},{"post_id":"ckohi002x0008lduzhd5cbcxv","tag_id":"ckohi0036000ulduz8x1b8aw0","_id":"ckohi003j0022lduz5il1bazo"},{"post_id":"ckohi002x0008lduzhd5cbcxv","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003k0025lduzetpohqdx"},{"post_id":"ckohi002x0008lduzhd5cbcxv","tag_id":"ckohi00380011lduz1th74u2j","_id":"ckohi003k0027lduz8k9scig9"},{"post_id":"ckohi002x0009lduzaxwd5jkg","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003l002alduzfbzf96fa"},{"post_id":"ckohi002x0009lduzaxwd5jkg","tag_id":"ckohi003h001ulduz1top4zjb","_id":"ckohi003l002clduzh6o19a7n"},{"post_id":"ckohi002y000blduz1s99alop","tag_id":"ckohi003i001zlduz9s7ybhu0","_id":"ckohi003m002glduz97oqh0aj"},{"post_id":"ckohi002y000blduz1s99alop","tag_id":"ckohi003j0024lduza4yrhf00","_id":"ckohi003n002ilduzbvffe2n8"},{"post_id":"ckohi002y000blduz1s99alop","tag_id":"ckohi003k0029lduz12eof56x","_id":"ckohi003n002llduz7lm53fch"},{"post_id":"ckohi002y000clduze10j7z6u","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003o002plduz5pqq4q1e"},{"post_id":"ckohi002y000clduze10j7z6u","tag_id":"ckohi003n002klduzadtyc76m","_id":"ckohi003o002qlduz208t7niv"},{"post_id":"ckohi003o002nlduzht9od885","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003o002slduz1h10gr7o"},{"post_id":"ckohi002z000elduz2l2r4lg1","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003p002ulduzdkio7prs"},{"post_id":"ckohi002z000elduz2l2r4lg1","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003p002vlduz84m17o1z"},{"post_id":"ckohi0030000glduz7qf84qgx","tag_id":"ckohi003p002tlduz9qtr4rp7","_id":"ckohi003p002ylduzfxrc5ie7"},{"post_id":"ckohi0030000glduz7qf84qgx","tag_id":"ckohi003p002wlduz9s8q4it4","_id":"ckohi003p002zlduzgh55evtv"},{"post_id":"ckohi0031000jlduzaalz74iu","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003q0033lduzbu18552b"},{"post_id":"ckohi0031000jlduzaalz74iu","tag_id":"ckohi003p0030lduzbrjl6651","_id":"ckohi003q0034lduz6zm45sg2"},{"post_id":"ckohi0031000jlduzaalz74iu","tag_id":"ckohi003q0031lduz9e7dfy69","_id":"ckohi003q0036lduz8fh04wjr"},{"post_id":"ckohi0031000klduzgk9b0pey","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003q0037lduz1ecl2y1q"},{"post_id":"ckohi0031000klduzgk9b0pey","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003q0039lduzhptdae8c"},{"post_id":"ckohi0032000mlduzdvynbshc","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003r003alduz85axdlmm"},{"post_id":"ckohi0032000mlduzdvynbshc","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003r003clduz6hoh0ex2"},{"post_id":"ckohi0033000nlduzf6h687ga","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003r003dlduz0hlp9f2i"},{"post_id":"ckohi0033000nlduzf6h687ga","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003r003flduz7s6fbmzq"},{"post_id":"ckohi0034000olduzgavghcti","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003r003glduz5c9f5zm0"},{"post_id":"ckohi0034000olduzgavghcti","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003r003ilduz64lib50w"},{"post_id":"ckohi0035000rlduzejso90o8","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003s003llduza5ky5896"},{"post_id":"ckohi0035000rlduzejso90o8","tag_id":"ckohi003r003hlduz3a982pcc","_id":"ckohi003s003mlduzh35hbjtc"},{"post_id":"ckohi0035000rlduzejso90o8","tag_id":"ckohi003r003jlduz4yqkg029","_id":"ckohi003s003olduzev9aavwn"},{"post_id":"ckohi0036000tlduzfunw7yyk","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003s003plduz68blagt4"},{"post_id":"ckohi0036000tlduzfunw7yyk","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003s003rlduz5nex8kv7"},{"post_id":"ckohi0036000wlduza9ro113g","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003t003ulduzhtflcv11"},{"post_id":"ckohi0036000wlduza9ro113g","tag_id":"ckohi003s003qlduzbvktgb52","_id":"ckohi003t003vlduz8psg43i8"},{"post_id":"ckohi0036000wlduza9ro113g","tag_id":"ckohi003s003slduz6ou2blds","_id":"ckohi003t003xlduzdh637b8w"},{"post_id":"ckohi0037000xlduzfht0b73q","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003t003ylduzf9o6cvca"},{"post_id":"ckohi0037000xlduzfht0b73q","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003t0040lduz832ldrww"},{"post_id":"ckohi0037000zlduzblrk5e3m","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003t0041lduzcbyden39"},{"post_id":"ckohi0037000zlduzblrk5e3m","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003u0043lduzgvgoftzu"},{"post_id":"ckohi00370010lduz3kk1e7wg","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003u0044lduz7qiuepp9"},{"post_id":"ckohi00370010lduz3kk1e7wg","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003u0046lduz157d0f3x"},{"post_id":"ckohi00380012lduzb6b527ri","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003u0047lduzhmqu4fg6"},{"post_id":"ckohi00380012lduzb6b527ri","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi003u0049lduz9uu27s1e"},{"post_id":"ckohi003a0013lduz7ojx9z9v","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003u004alduz8dy21kzy"},{"post_id":"ckohi003a0013lduz7ojx9z9v","tag_id":"ckohi003u0045lduz79fcgnbf","_id":"ckohi003v004clduzd4mu35b3"},{"post_id":"ckohi003a0014lduz3gb1g2kl","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003v004elduz73wjh08k"},{"post_id":"ckohi003a0014lduz3gb1g2kl","tag_id":"ckohi003q0031lduz9e7dfy69","_id":"ckohi003v004flduzcye8bxz8"},{"post_id":"ckohi003a0014lduz3gb1g2kl","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi003x004hlduzesawetzg"},{"post_id":"ckohi003c0017lduz9kq2g6aw","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003x004ilduz9eoibp64"},{"post_id":"ckohi003c0017lduz9kq2g6aw","tag_id":"ckohi003v004dlduzf3gfa7ig","_id":"ckohi003x004klduzdd3cca9i"},{"post_id":"ckohi003d001elduz4xb57cwf","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003x004llduzeb9o91af"},{"post_id":"ckohi003d001elduz4xb57cwf","tag_id":"ckohi003v004glduz4sgd2mxy","_id":"ckohi003x004nlduz77r70epm"},{"post_id":"ckohi003e001hlduzfzi125gi","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003y004plduz89pr6npp"},{"post_id":"ckohi003e001hlduzfzi125gi","tag_id":"ckohi003x004jlduz4n6r5u6n","_id":"ckohi003y004qlduz84t8g7b9"},{"post_id":"ckohi003e001hlduzfzi125gi","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi003y004slduzghw386ks"},{"post_id":"ckohi003f001mlduzew033abz","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003y004tlduzcz2zemv6"},{"post_id":"ckohi003f001mlduzew033abz","tag_id":"ckohi003y004olduz468828y2","_id":"ckohi003z004vlduzasvmasfe"},{"post_id":"ckohi003g001olduz1upe58yi","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi003z004wlduz0u00c5h3"},{"post_id":"ckohi003g001olduz1upe58yi","tag_id":"ckohi003y004olduz468828y2","_id":"ckohi003z004ylduz71akfd31"},{"post_id":"ckohi003g001rlduzbwew9i40","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi003z0050lduz7ar46g76"},{"post_id":"ckohi003g001rlduzbwew9i40","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi003z0051lduz9pfj2cyw"},{"post_id":"ckohi003g001rlduzbwew9i40","tag_id":"ckohi003z004xlduzh86rgfpu","_id":"ckohi00400053lduzb9xs0cll"},{"post_id":"ckohi003h001tlduz0v3shhan","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi00400054lduzaumhczsf"},{"post_id":"ckohi003h001tlduz0v3shhan","tag_id":"ckohi003z004zlduzhrs3di3u","_id":"ckohi00400056lduzfrpv97x7"},{"post_id":"ckohi003i001wlduzapwp12tw","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi00400057lduzdt7d3lx7"},{"post_id":"ckohi003i001wlduzapwp12tw","tag_id":"ckohi003z0052lduz1zubcxfs","_id":"ckohi00400059lduzavmx917h"},{"post_id":"ckohi003i001ylduz0f9xews0","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0042005blduz3ltw53ap"},{"post_id":"ckohi003i001ylduz0f9xews0","tag_id":"ckohi00400055lduzfks3csur","_id":"ckohi0042005clduzcepp9eq6"},{"post_id":"ckohi003i001ylduz0f9xews0","tag_id":"ckohi00400058lduzb5xlbu4d","_id":"ckohi0042005elduzcdex4b1z"},{"post_id":"ckohi003j0021lduzdhxu038t","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0042005flduzfk3u8k5m"},{"post_id":"ckohi003j0021lduzdhxu038t","tag_id":"ckohi0040005alduzg36scu4o","_id":"ckohi0042005hlduz6yyl1naw"},{"post_id":"ckohi003j0023lduzcp0e9j18","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi0043005ilduz66badyal"},{"post_id":"ckohi003j0023lduzcp0e9j18","tag_id":"ckohi0042005dlduz8q4f4m8o","_id":"ckohi0043005klduz38mghv2v"},{"post_id":"ckohi003k0026lduzej5c7qbb","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0043005llduz8ujdb4cv"},{"post_id":"ckohi003k0026lduzej5c7qbb","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi0043005nlduz7izkeu4s"},{"post_id":"ckohi003k0028lduzcfqe9emh","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0043005olduz3krl0wde"},{"post_id":"ckohi003k0028lduzcfqe9emh","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi0043005qlduzffdzen0e"},{"post_id":"ckohi003l002blduz3pdz47y1","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi0044005rlduzf0ec4uyz"},{"post_id":"ckohi003l002blduz3pdz47y1","tag_id":"ckohi0043005mlduz9hl0efjd","_id":"ckohi0044005tlduz6ws604q6"},{"post_id":"ckohi003l002dlduz38cc792m","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0044005vlduz0g48fh5v"},{"post_id":"ckohi003l002dlduz38cc792m","tag_id":"ckohi003u004blduzds6j7d61","_id":"ckohi0044005wlduz214j08p7"},{"post_id":"ckohi003l002dlduz38cc792m","tag_id":"ckohi0044005slduz5vqi22x9","_id":"ckohi0044005ylduz0vf9d5ao"},{"post_id":"ckohi003l002elduzegred8b9","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi00450060lduz92gl81si"},{"post_id":"ckohi003l002elduzegred8b9","tag_id":"ckohi0044005ulduzgqp1cn5h","_id":"ckohi00450061lduz4gwmbx2o"},{"post_id":"ckohi003l002elduzegred8b9","tag_id":"ckohi0044005xlduzbecl508v","_id":"ckohi00450063lduzedtha29j"},{"post_id":"ckohi003m002hlduzf7mphvtw","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi00460065lduzfzco63u0"},{"post_id":"ckohi003m002hlduzf7mphvtw","tag_id":"ckohi003o002rlduzfrni0gx0","_id":"ckohi00460066lduz6314hjwo"},{"post_id":"ckohi003m002hlduzf7mphvtw","tag_id":"ckohi003v004dlduzf3gfa7ig","_id":"ckohi00460068lduz1ykhe5er"},{"post_id":"ckohi003n002jlduz1wy5ejof","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi0046006alduzbkv9dvbl"},{"post_id":"ckohi003n002jlduz1wy5ejof","tag_id":"ckohi003v004dlduzf3gfa7ig","_id":"ckohi0046006blduz8sj36z7w"},{"post_id":"ckohi003n002jlduz1wy5ejof","tag_id":"ckohi0042005dlduz8q4f4m8o","_id":"ckohi0046006dlduzdtegaehx"},{"post_id":"ckohi003n002mlduz502w8o0m","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0047006flduzcenuh8fb"},{"post_id":"ckohi003n002mlduz502w8o0m","tag_id":"ckohi0044005ulduzgqp1cn5h","_id":"ckohi0047006glduz793ag108"},{"post_id":"ckohi003n002mlduz502w8o0m","tag_id":"ckohi0046006clduzf3ef8y68","_id":"ckohi0047006hlduz1m6vcnt4"},{"post_id":"ckohi003n002mlduz502w8o0m","tag_id":"ckohi0046006elduzauqvdt8r","_id":"ckohi0047006ilduzc6du9pba"},{"post_id":"ckohi0048006klduzbtbl9u7s","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckohi0049006mlduzho4n5xo4"},{"post_id":"ckohi0048006klduzbtbl9u7s","tag_id":"ckohi003s003qlduzbvktgb52","_id":"ckohi0049006nlduz0pt1d0ij"},{"post_id":"ckohi0048006jlduzaobfgxe2","tag_id":"ckohi0031000ilduz01sh5n78","_id":"ckohi0049006olduz011k6ebv"},{"post_id":"ckohi0048006jlduzaobfgxe2","tag_id":"ckohi0049006llduz6amq42kz","_id":"ckohi0049006plduzc77qev9g"},{"post_id":"ckphjb8tn0000a9uz8fb9bwgu","tag_id":"ckphjb8tp0001a9uz3g8367r2","_id":"ckphjb8tx0003a9uzc2dbb8jc"},{"post_id":"ckphjb8tn0000a9uz8fb9bwgu","tag_id":"ckohi0037000ylduzfhscgaw7","_id":"ckphjb8tx0004a9uzhq10h486"},{"post_id":"ckphjb8tn0000a9uz8fb9bwgu","tag_id":"ckphjb8tx0002a9uz9afsdnzb","_id":"ckphjb8ty0005a9uz3fuh7aj9"}],"Tag":[{"name":"JetBrains","_id":"ckohi002u0004lduzdgbe4v39"},{"name":"News","_id":"ckohi002y000alduza0yu98vy"},{"name":"NewYear","_id":"ckohi002z000dlduz7k62ap5d"},{"name":"Kotlin","_id":"ckohi0031000ilduz01sh5n78"},{"name":"Java","_id":"ckohi0032000llduzfomd42oe"},{"name":"gradle","_id":"ckohi0035000plduzh2fq1hip"},{"name":"groovy","_id":"ckohi0036000ulduz8x1b8aw0"},{"name":"kotlin","_id":"ckohi0037000ylduzfhscgaw7"},{"name":"kts","_id":"ckohi00380011lduz1th74u2j"},{"name":"PropertyDelegate","_id":"ckohi003h001ulduz1top4zjb"},{"name":"android studio","_id":"ckohi003i001zlduz9s7ybhu0"},{"name":"技巧","_id":"ckohi003j0024lduza4yrhf00"},{"name":"快捷键","_id":"ckohi003k0029lduz12eof56x"},{"name":"APT","_id":"ckohi003n002klduzadtyc76m"},{"name":"Coroutine","_id":"ckohi003o002rlduzfrni0gx0"},{"name":"c","_id":"ckohi003p002tlduz9qtr4rp7"},{"name":"macro","_id":"ckohi003p002wlduz9s8q4it4"},{"name":"coroutine","_id":"ckohi003p0030lduzbrjl6651"},{"name":"android","_id":"ckohi003q0031lduz9e7dfy69"},{"name":"flow","_id":"ckohi003r003hlduz3a982pcc"},{"name":"rxjava","_id":"ckohi003r003jlduz4yqkg029"},{"name":"coroutines","_id":"ckohi003s003qlduzbvktgb52"},{"name":"select","_id":"ckohi003s003slduz6ou2blds"},{"name":"dataclass","_id":"ckohi003u0045lduz79fcgnbf"},{"name":"news","_id":"ckohi003u004blduzds6j7d61"},{"name":"Android","_id":"ckohi003v004dlduzf3gfa7ig"},{"name":"协程","_id":"ckohi003v004glduz4sgd2mxy"},{"name":"release","_id":"ckohi003x004jlduz4n6r5u6n"},{"name":"Website","_id":"ckohi003y004olduz468828y2"},{"name":"inline class","_id":"ckohi003z004xlduzh86rgfpu"},{"name":"type","_id":"ckohi003z004zlduzhrs3di3u"},{"name":"map","_id":"ckohi003z0052lduz1zubcxfs"},{"name":"kotlin-native","_id":"ckohi00400055lduzfks3csur"},{"name":"mpp","_id":"ckohi00400058lduzb5xlbu4d"},{"name":"native","_id":"ckohi0040005alduzg36scu4o"},{"name":"Kotlin-Native","_id":"ckohi0042005dlduz8q4f4m8o"},{"name":"Kotlni-Js","_id":"ckohi0043005mlduz9hl0efjd"},{"name":"sealed interface","_id":"ckohi0044005slduz5vqi22x9"},{"name":"swift","_id":"ckohi0044005ulduzgqp1cn5h"},{"name":"property","_id":"ckohi0044005xlduzbecl508v"},{"name":"scala","_id":"ckohi0046006clduzf3ef8y68"},{"name":"lazy","_id":"ckohi0046006elduzauqvdt8r"},{"name":"SelfType","_id":"ckohi0049006llduz6amq42kz"},{"name":"java","_id":"ckphjb8tp0001a9uz3g8367r2"},{"name":"sam","_id":"ckphjb8tx0002a9uz9afsdnzb"}]}}