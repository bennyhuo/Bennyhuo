<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.bennyhuo.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gittalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写"><meta property="og:type" content="article"><meta property="og:title" content="快速迁移 Gradle 脚本至 KTS"><meta property="og:url" content="https://www.bennyhuo.com/2021/04/17/gradle-migrate-to-kts/index.html"><meta property="og:site_name" content="Benny Huo"><meta property="og:description" content="接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"><meta property="og:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"><meta property="article:published_time" content="2021-04-17T16:00:00.000Z"><meta property="article:modified_time" content="2023-04-24T09:39:51.360Z"><meta property="article:author" content="Benny Huo"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Gradle"><meta property="article:tag" content="Groovy"><meta property="article:tag" content="KTS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png"><link rel="canonical" href="https://www.bennyhuo.com/2021/04/17/gradle-migrate-to-kts/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.bennyhuo.com/2021/04/17/gradle-migrate-to-kts/","path":"2021/04/17/gradle-migrate-to-kts/","title":"快速迁移 Gradle 脚本至 KTS"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>快速迁移 Gradle 脚本至 KTS | Benny Huo</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?8158efd7e8cf52cfb7d8420b33755ca8"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Benny Huo</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">学海无涯，其乐无穷</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-house fa-fw"></i>首页</a></li><li class="menu-item menu-item-专栏"><a href="/book/" rel="section"><i class="fa fa-book fa-fw"></i>专栏</a></li><li class="menu-item menu-item-网盘"><a href="https://drive.bennyhuo.com/" rel="section" target="_blank"><i class="fa fa-hard-drive fa-fw"></i>网盘</a></li><li class="menu-item menu-item-项目"><a href="/project/" rel="section"><i class="fa fa-diagram-project fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">1. 处理字符串字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%99%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8A%A0%E4%B8%8A%E6%8B%AC%E5%8F%B7"><span class="nav-number">2.</span> <span class="nav-text">2. 给方法调用加上括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%80%E5%A7%8B%E8%BF%81%E7%A7%BB"><span class="nav-number">3.</span> <span class="nav-text">3. 开始迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%BF%81%E7%A7%BB-settings-gradle"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 迁移 settings.gradle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BF%81%E7%A7%BB%E6%A0%B9%E5%B7%A5%E7%A8%8B%E4%B8%8B%E7%9A%84-build-gradle"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 迁移根工程下的 build.gradle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%BF%81%E7%A7%BB-app-%E6%A8%A1%E5%9D%97%E7%9A%84-build-gradle"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 迁移 app 模块的 build.gradle</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">4.</span> <span class="nav-text">4. 依赖版本号的替代方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Kotlin-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AF%BB%E5%86%99"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Kotlin 风格的属性读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%9C%A8-buildSrc-%E5%BD%93%E4%B8%AD%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 在 buildSrc 当中定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5. 小结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Benny Huo" src="/assets/avatar.jpg"><p class="site-author-name" itemprop="name">Benny Huo</p><div class="site-description" itemprop="description">Google 开发者专家（GDE）<br>《深入理解 Kotlin 协程》作者</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">91</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/bennyhuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bennyhuo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:bennyhuo@kotliner.cn" title="E-Mail → mailto:bennyhuo@kotliner.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/28615855" title="Bilibli → https:&#x2F;&#x2F;space.bilibili.com&#x2F;28615855" rel="noopener me" target="_blank"><i class="fa fa-play fa-fw"></i>Bilibli</a> </span><span class="links-of-author-item"><a href="https://www.youtube.com/@bennyhuo" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;@bennyhuo" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a></span></div></div></div></div><div class="sidebar-inner sidebar-post-related"><div class="animated"><div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i> 相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><a class="popular-posts-link" href="/" rel="bookmark"></a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/" rel="bookmark"></a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/2019/03/11/kotlin-nodejs/" rel="bookmark"><time class="popular-posts-time">2019-03-11</time><br>基于 Node.js 环境的 KotlinJs 工程的完美搭建</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/2020/04/19/kotlin-native-android-mpp/" rel="bookmark"><time class="popular-posts-time">2020-04-19</time><br>Kotlin Native 写 Jni 第三弹：改造成 MPP 的工程结构</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.bennyhuo.com/2021/04/17/gradle-migrate-to-kts/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="Benny Huo"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Benny Huo"><meta itemprop="description" content="Google 开发者专家（GDE）<br>《深入理解 Kotlin 协程》作者"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="快速迁移 Gradle 脚本至 KTS | Benny Huo"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">快速迁移 Gradle 脚本至 KTS</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-17 16:00:00" itemprop="dateCreated datePublished" datetime="2021-04-17T16:00:00+00:00">2021-04-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-04-24 09:39:51" itemprop="dateModified" datetime="2023-04-24T09:39:51+00:00">2023-04-24</time> </span><span id="/2021/04/17/gradle-migrate-to-kts/" class="post-meta-item leancloud_visitors" data-flag-title="快速迁移 Gradle 脚本至 KTS" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>23 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>接下来我们就把这个示例工程的 Gradle 脚本用 KTS 改写</p></blockquote><iframe class="bilibili" src="//player.bilibili.com/player.html?bvid=BV1Kf4y1p7zq&autoplay=0&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><span id="more"></span><p>大家可以在我的 GitHub 页面找到这个工程：<a target="_blank" rel="noopener" href="https://github.com/bennyhuo/Android-LuaJavax">bennyhuo/Android-LuaJavax: Powerful Kotlin style API for Android Lua</a>，在提交记录当中可以看到 release 1.0 和 use kts 这两笔提交，前者使用 Groovy 编写 Gradle 脚本，后者使用 Kotlin 编写。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413070200151.png" alt="提交记录"></p><p>因此，大家如果想要跟着我一起做这个小练习，只需要 clone 这个工程，并 checkout release 1.0 这笔提交记录即可，练习的最终效果也可以在 use kts 这笔记录当中呈现。</p><p>接下来我简单介绍一下我们迁移的思路：Groovy 的语法和 Kotlin 的语法虽然相差不小，但在 Gradle DSL 的设计上，还是尽可能保持了统一性，这显然也是为了降低大家的学习和迁移成本。正因为如此，尽管我们还是要对两门语言的一些语法细节进行批量处理，迁移过程实际上并不复杂。</p><h2 id="1-处理字符串字面量"><a href="#1-处理字符串字面量" class="headerlink" title="1. 处理字符串字面量"></a>1. 处理字符串字面量</h2><p>我们需要修改的主要就是 settings.gradle 以及几个 build.gradle。经过之前的介绍，大家或多或少应该能了解到，Groovy 当中单引号引起来的也是字符串字面量，因此我们会面对大量这样的写法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&#x27;:app&#x27;</span>,<span class="string">&#x27;:luajava&#x27;</span>, <span class="string">&#x27;:luajavax&#x27;</span></span><br></pre></td></tr></table></figure><p>显然在 Kotlin 当中这是不可以的，因此我们要想办法把字符串字面量的单引号统一改成双引号。</p><p>我们很容易地想到使用 IntelliJ IDEA 或者 Android Studio 的全局正则替换（噗，你也可能根本没听说过）：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413072420709.png" alt="使用全局正则匹配替换单引号"></p><ol><li>匹配框输入正则表达式 <code>&#39;(.*?[^\\])&#39;</code>，替换框中填写 <code>&quot;$1&quot;</code>，这里的 <code>$1</code> 对应于正则表达式当中的第一个元组，如果有多个元组，可以用 <code>$n</code> 来表示，其中 <code>$0</code> 表示匹配到的整个字符</li><li>过滤文件后缀，我们只对 <code>*.gradle</code> 文件做替换</li><li>在文件后缀后面的漏斗当中选择 Excepts String literals and Comments，表示我们只匹配代码部分</li><li>在输入框后面选择 <code>.*</code>，蓝色高亮表示启用正则匹配</li></ol><p>你可以检查一下匹配框当中有没有错误匹配的内容，有的话，再调整一下正则表达式即可。至少在我们的这个示例当中，前面输入的这个正则表达式够用了。</p><p>至于这个正则表达式的含义，我就不多说了，你们可能也不想听（都是借口，哈哈）。</p><p>点击 Replace All，替换之后所有的单引号都就变成了双引号：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-给方法调用加上括号"><a href="#2-给方法调用加上括号" class="headerlink" title="2. 给方法调用加上括号"></a>2. 给方法调用加上括号</h2><p>还是以 settings.gradle 当中的这句为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span></span><br></pre></td></tr></table></figure><p>它实际上是一个方法调用，我们提到过在 Groovy 当中，只要没有歧义，就可以把方法调用的括号去掉，但这显然在 Kotlin 当中是不行的。因此我们还需要先对他们统一做一下加括号的处理。</p><p>处理方法，这时候你们应该很自然的就能想到全局正则匹配了：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210413074530145.png" alt="全局正则为方法调用加括号"></p><p>在这里，匹配框输入正则表达式 <code>(\w+) (([^=\&#123;\s]+)(.*))</code>，替换框中填写 <code>$1($2)</code>，其他配置与前面替换引号一样。</p><p>你可以检查一下有没有错误匹配的内容，如果有的话，就稍微调整一下正则表达式，或者手动对错误匹配的部分进行修改。</p><p>点击全部替换，这时候你就发现所有的方法调用都加上了括号：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="string">&quot;:app&quot;</span>,<span class="string">&quot;:luajava&quot;</span>, <span class="string">&quot;:luajavax&quot;</span>)</span><br></pre></td></tr></table></figure><p>实际上通过正则表达匹配替换的做法不是完美的做法，如果想要精确识别方法调用，还是需要解析 Groovy 的语法才行，但显然那样又没有多大必要。上面给出的正则表达式当然也不是完美的，对于多行的情况就会出现比较尴尬的问题，例如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被替换成了：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task(clean(<span class="attr">type:</span> Delete) &#123;)</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这些我们手动修改一下就好了，问题不大，好在这个正则表达式可以解决 90% 的问题。</p><h2 id="3-开始迁移"><a href="#3-开始迁移" class="headerlink" title="3. 开始迁移"></a>3. 开始迁移</h2><h3 id="3-1-迁移-settings-gradle"><a href="#3-1-迁移-settings-gradle" class="headerlink" title="3.1 迁移 settings.gradle"></a>3.1 迁移 settings.gradle</h3><p>迁移时，先把文件名改为 settings.gradle.kts，然后 sync gradle。</p><p>就完事儿了。因为经过前面两部操作，settings.gradle 当中的这一行代码已经是合法的 Kotlin 代码了。</p><h3 id="3-2-迁移根工程下的-build-gradle"><a href="#3-2-迁移根工程下的-build-gradle" class="headerlink" title="3.2 迁移根工程下的 build.gradle"></a>3.2 迁移根工程下的 build.gradle</h3><p>我们先贴出来原来的 groovy 版本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">&quot;1.4.30&quot;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span>)</span><br><span class="line"></span><br><span class="line">        classpath(<span class="string">&quot;com.vanniktech:gradle-maven-publish-plugin:0.14.2&quot;</span>)</span><br><span class="line">        <span class="comment">// For(Kotlin projects, you need to add Dokka.)</span></span><br><span class="line">        classpath(<span class="string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:0.10.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    it.afterEvaluate &#123;</span><br><span class="line">        it.with &#123;</span><br><span class="line">            <span class="keyword">if</span>(plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">                group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">                version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">                apply(<span class="attr">plugin:</span> <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task(clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么我们开始迁移，先给文件名增加后缀 kts，sync gradle 之后开始解决我们的第一个报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e: ...\Android-Luajavax\build.gradle.kts:3:5: Unresolved reference: ext</span><br></pre></td></tr></table></figure><p>说 ext 找不到。当然找不到了，因为过去我们是通过 ext 访问 project 对象的动态属性的（可以去参考前面的视频 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd">Project 的属性都是哪里来的？</a>），Groovy 的动态特性支持了这一语法，但 Kotlin 作为一门静态语言，这一做就不行了。因此如果我们想要访问 ext，就需要使用 extra 扩展，或者 <code>getProperties()[&quot;ext&quot;]</code>，所以：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext.kotlin_version = <span class="string">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra[<span class="string">&quot;kotlin_version&quot;</span>] = <span class="string">&quot;1.4.30&quot;</span></span><br></pre></td></tr></table></figure><p>接下来的问题就是对 kotlin_version 的访问了。与 ext 一样，我们不能直接访问，需要把它取出来再使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra</span><br><span class="line">...</span><br><span class="line">classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlin_version</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>有朋友肯定会说，kts 感觉不太行啊，不如 Groovy 用起来方便呢。这一点上来看，确实，毕竟我们希望 Gradle 脚本能够拥有静态语言的高亮和提示，有舍必有得嘛。实际上，我们使用 kts 编写 Gradle 时，有另外好用的办法来定义版本，这个我们后面再谈。</p><p>接下来遇到的问题应该就是 maven 的语法了，这个简单，直接修改成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后，我们会看到 afterEvaluate 之处的语法有些问题，实际上我们稍微分析一下就能知道正确的写法。</p><p>以下是 Groovy 原版：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.afterEvaluate &#123;</span><br><span class="line">        it.with &#123;</span><br><span class="line">            <span class="keyword">if</span>(plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>) || plugins.hasPlugin(<span class="string">&quot;java-library&quot;</span>)) &#123;</span><br><span class="line">                group = <span class="string">&quot;com.bennyhuo&quot;</span></span><br><span class="line">                version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">                apply(plugin: <span class="string">&quot;com.vanniktech.maven.publish&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 subprojects 的参数 Lambda 的 Receiver 就是 Project，因此 <code>it.afterEvaluate</code> 改成 <code>this.afterEvaluate</code>；<code>it.with</code> 在 Groovy 当中本来也是想要获取 Project 的 Receiver 的，而在这里 afterEvaluate 的参数 Lambda 自带 Project 作为 Receiver，因此直接删掉即可。</p><p>剩下的就是 <code>apply(plugin: &quot;com.vanniktech.maven.publish&quot;)</code> 这句了，这里映射到 kts 当中之后，所有这种通过 key-value 传递的参数基本上都改成了具名参数，因此改写为：<code>apply(plugin = &quot;com.vanniktech.maven.publish&quot;)</code>。</p><p>最后就是创建任务的代码了，其实很好改，想想我们上节的内容（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</a>），它等价于创建了一个叫 clean 的任务。我们翻一下 Gradle 的官方文档，不难看到现在创建任务的推荐使用 register，因此：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.register&lt;Delete&gt;(<span class="string">&quot;clean&quot;</span>) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，在 Groovy 当中 Delete 类型是作为参数通过 Key-Value 的形式传递的，Kotlin 当中直接把它当做泛型参数传入，这样设计是非常符合 Kotlin 的设计思想的。</p><p>至此根工程下面的 build.gradle 改造完毕。</p><p>不知道大家是否发现，改造的过程其实就是一个了解过去 Groovy 写法的本意，并在查阅 Gradle 官方 API 的基础上翻译成 Kotlin 调用的过程。如果你对 Groovy 了解不多，我相信这个过程对你来说还是会有不少的困扰。</p><h3 id="3-3-迁移-app-模块的-build-gradle"><a href="#3-3-迁移-app-模块的-build-gradle" class="headerlink" title="3.3 迁移 app 模块的 build.gradle"></a>3.3 迁移 app 模块的 build.gradle</h3><p>我们先把完整的待改造的版本贴出来：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">apply(<span class="attr">plugin:</span> <span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(<span class="number">28</span>)</span><br><span class="line">    buildToolsVersion(<span class="string">&quot;28.0.3&quot;</span>)</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId(<span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span>)</span><br><span class="line">        minSdkVersion(<span class="number">18</span>)</span><br><span class="line">        targetSdkVersion(<span class="number">28</span>)</span><br><span class="line">        versionCode(<span class="number">1</span>)</span><br><span class="line">        versionName(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled(<span class="literal">true</span>)</span><br><span class="line">            signingConfig(signingConfigs.debug)</span><br><span class="line">            proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        checkReleaseBuilds(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class="line">        <span class="comment">// but(continue the build even when errors are found:)</span></span><br><span class="line">        abortOnError(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(project(<span class="string">&quot;:luajavax&quot;</span>))</span><br><span class="line">    api(<span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span>)</span><br><span class="line"></span><br><span class="line">    api(<span class="string">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// workaround(issue #73)</span></span><br><span class="line">        exclude(<span class="attr">group:</span> <span class="string">&quot;com.google.android&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们给它加上 kts 后缀，并开始迁移。同样，我们通过 Gradle 的报错信息来各个击破。</p><p>首先报错的必然是开头的 apply plugin，因为不是合法的 Kotlin 语法。如果只是语法上做翻译，我们可以改成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply(plugin = <span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">apply(plugin = <span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">apply(plugin = <span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br></pre></td></tr></table></figure><p>但这样有个问题，通过这些插件引入的 extension 是无法直接访问的，这一点与 Groovy 有比较明显的区别。在这个例子当中，影响比较大的就是后面的 <code>android &#123; ... &#125;</code> 无法直接访问。具体原理可以参考前面的视频：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247484963&idx=1&sn=1f475e8f26b62df0c55bcf3418fb5f0a&chksm=e8a0591edfd7d0085bc1344f25613ae93aa9ef8a238dd4b01f52ca0a10d2fbb1bcefbe095c96&token=529021163&lang=zh_CN#rd">你的 Gradle 脚本是怎么运行起来的？</a>。</p><p>我们需要通过 <code>plugins &#123; ... &#125;</code> 来引入插件，确保在脚本运行的 classpath 阶段就能引入，方便 Gradle 帮我们合成对应的扩展。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apply(plugin = &quot;com.android.application&quot;)</span></span><br><span class="line"><span class="comment">//apply(plugin = &quot;kotlin-android&quot;)</span></span><br><span class="line"><span class="comment">//apply(plugin = &quot;kotlin-android-extensions&quot;)</span></span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;kotlin-android&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;kotlin-android-extensions&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改写完之后，sync gradle，并等待 IDE 建完索引，你就会发现 <code>android &#123; ... &#125;</code> 可以访问了。</p><p>接下来我们看到 Gradle 报错的是 defaultConfig 部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId(<span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span>) <span class="comment">// error</span></span><br><span class="line">    minSdkVersion(<span class="number">18</span>)</span><br><span class="line">    targetSdkVersion(<span class="number">28</span>) </span><br><span class="line">    versionCode(<span class="number">1</span>) <span class="comment">// error</span></span><br><span class="line">    versionName(<span class="string">&quot;1.0&quot;</span>) <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单，肯定是语法细节上的差异。有了代码提示，我们一点儿都不怂：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074737952.png" alt="使用代码提示查看 applicationId 的定义"></p><p>原来 applicationId 被识别成了通过 setter 和 getter 方法合成的属性，这个我们熟悉啊，用 Kotlin 代码调用 Java 代码的时候经常会遇到。所以改成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationId = <span class="string">&quot;com.bennyhuo.luajavax.sample&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414074956327.png" alt="使用代码提示查看 versionCode 的定义"></p><p>后面的 versionCode 和 versionName 也是如此。</p><p>接下来我们看 buildTypes 这一块儿。</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210414075334467.png" alt="buildTypes 中的报错"></p><p><code>release &#123; ... &#125;</code> 是一个方法调用，不过我们可以很确定的是，所在的作用域内的 Receiver 的类型 NamedDomainObjectContainer 没有这么个方法。而实际上我们也知道 release 其实是一种 BuildType 的名字，因此可以断定这不是一个正常的方法调用。</p><p>这时候，我们不难想到上一个视频 [Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？](<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485168&idx=1&sn=13210d9865f73d6001393c1514aab99c&chksm=e8a059cddfd7d0db01dcfde5ecbe1ac2f73da73213fdd3115c983a28a2b8d7d10a5b0a8dfce2&token=529021163&lang=zh_CN#rd">Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？ (qq.com)</a>)里面讲到的的 Task 的语法的问题，不过大家想想这是 Android 的插件，Gradle 怎么会为 Android 插件的配置添加特殊语法呢？所以这里只有一个可能，它就是一个合法的 Groovy 的语法。</p><p>实际上我们在更早的时候介绍 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&mid=2247485130&idx=1&sn=f6240d7b0cc24523e6061e9cbeeebdc6&chksm=e8a059f7dfd7d0e16427f1c21e96ddd5099a3e88c86a7f8ed60386e5d0fb4cd35f1282817d60&token=529021163&lang=zh_CN#rd">Project 的属性都是哪里来的？</a> 的时候就提到过，如果被访问的对象恰好是 <strong>GroovyObject</strong> 的实现类，那么对于找不到的属性，会通过 get/setProperty 来访问，而方法则是通过 <strong>invokeMethod</strong> 来访问。所以关键的问题来了，<code>release &#123; ... &#125;</code> 是调用了哪个类的 <strong>invokeMethod</strong> 呢？</p><p>是 <code>NamedDomainObjectContainerConfigureDelegate</code> 的。在 Groovy 版本的 Gradle 脚本当中，形如 <code>buildTypes &#123; ... &#125;</code> 这样的配置代码，实际上都是通过对应的 <strong>ConfigureDelegate</strong> 类来完成配置的，这里的细节大家可以单步调试一下看看为什么是这样。</p><p>总之，当我们在 Groovy 当中访问 buildTypes，如果这个配置已经存在，那么会走到以下逻辑：</p><p><strong>DefaultNamedDomainObjectCollection</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DynamicInvokeResult <span class="title function_">tryInvokeMethod</span><span class="params">(String name, Object... arguments)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isConfigureMethod(name, arguments)) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.found(ConfigureUtil.configure((Closure) arguments[<span class="number">0</span>], getByName(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release 是预定义的 BuildType，因此会走到这个逻辑。而如果我们想要自定义其他的 BuildType，那么就会走到创建 BuildType 的路径：</p><p><strong>NamedDomainObjectContainerConfigureDelegate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> DynamicInvokeResult <span class="title function_">_configure</span><span class="params">(String name, Object[] params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.length == <span class="number">1</span> &amp;&amp; params[<span class="number">0</span>] <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicInvokeResult.found(_container.create(name, (Closure) params[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DynamicInvokeResult.notFound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说了这么多，大家只需要记住对于已经存在的，可以使用 <strong>getByName</strong> 来获取，而不存在的，要使用 <strong>create</strong> 来创建。</p><p>因此改写成 Kotlin 以后，对于已经存在的 release，我们要这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    <span class="keyword">val</span> release = getByName(<span class="string">&quot;release&quot;</span>)</span><br><span class="line">    release.apply &#123;</span><br><span class="line">        isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">        signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">        proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Gradle 为 Kotlin 提供了更方便的 API 可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> release <span class="keyword">by</span> getting &#123;</span><br><span class="line">    isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">    signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要创建一个叫 beta 的 BuildType，可以使用 creating：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> beta <span class="keyword">by</span> creating &#123;</span><br><span class="line">    isMinifyEnabled = <span class="literal">false</span></span><br><span class="line">    signingConfig = signingConfigs.getByName(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    proguardFiles(getDefaultProguardFile(<span class="string">&quot;proguard-android.txt&quot;</span>), <span class="string">&quot;proguard-rules.pro&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415081145080.png" alt="添加新的 BuildType：beta"></p><p>好，关于 BuildType 我们就说这么多。</p><p>接下来报错的是 lintOptions，这个比较简单，修改如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lintOptions &#123;</span><br><span class="line">    isCheckReleaseBuilds = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// Or, if(you prefer, you can continue to check for errors in release builds,)</span></span><br><span class="line">    <span class="comment">// but(continue the build even when errors are found:)</span></span><br><span class="line">    isAbortOnError = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下看，是给 Java 编译器配置了一个编码，报错的内容如下：</p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/image-20210415080451856.png" alt="通过类型获取任务的报错信息"></p><p>根据 IDE 的提示，不难想到以下的改法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.withType(JavaCompile::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们有了前面迁移 Task 创建的经验，一猜就知道一定还可以把类型作为泛型参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.withType&lt;JavaCompile&gt; &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就剩 dependencies 里面的两个小问题了，kotlin_version 访问不到的问题我们前面已经提到，后面我们给出替代方案；另一个是 exclude 方法参数的写法问题，改成具名参数，结果为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(project(<span class="string">&quot;:luajavax&quot;</span>))</span><br><span class="line">    api(<span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.30&quot;</span>) <span class="comment">// 后续给出替代方案，这里先硬编码</span></span><br><span class="line"></span><br><span class="line">    api(<span class="string">&quot;org.slf4j:slf4j-api:1.7.21&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-core:1.1.1-6&quot;</span>)</span><br><span class="line">    api(<span class="string">&quot;com.github.tony19:logback-android-classic:1.1.1-6&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// workaround(issue #73)</span></span><br><span class="line">        exclude(group = <span class="string">&quot;com.google.android&quot;</span>, module = <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，app 模块当中的 build.gradle 迁移也已经完成。luajava 和 luajavax 两个模块的 build.gradle 是类似的，大家可以自己练习，我们就不再专门介绍。</p><h2 id="4-依赖版本号的替代方案"><a href="#4-依赖版本号的替代方案" class="headerlink" title="4. 依赖版本号的替代方案"></a>4. 依赖版本号的替代方案</h2><p>我们在 Groovy 版本的脚本中经常往 ext 当中添加一些值，以便于后续使用，其中最常见的场景就是依赖的管理，特别是版本号。Groovy 当中的这个动态属性固然好用，但同样的问题，我们经常在使用时搞不清楚究竟有哪些属性可以用，也经常搞不清楚属性究竟定义在了哪里。</p><p>Kotlin 就没有这个问题了，因为它的静态类型特性把这个动态读写属性的途径彻底禁止了。</p><h3 id="4-1-Kotlin-风格的属性读写"><a href="#4-1-Kotlin-风格的属性读写" class="headerlink" title="4.1 Kotlin 风格的属性读写"></a>4.1 Kotlin 风格的属性读写</h3><p>尽管不能像 Groovy 那样任性，Gradle 也尽可能地为 Kotlin 提供了一些相对易用的 API 供我们使用，除了通过 <code>extra[...]</code> 的形式定义属性，还可以采用下面的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinVersion <span class="keyword">by</span> extra(<span class="string">&quot;1.4.30&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> isRelease <span class="keyword">by</span> extra &#123;</span><br><span class="line">    getBooleanFromFile(<span class="string">&quot;config.properties&quot;</span>,<span class="string">&quot;buidType&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义之后，在当前变量所在的范围之内，还可以直接使用。</p><p>当然，在后续其他脚本当中想要使用这个属性，就还需要先把它读出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlin_version: String <span class="keyword">by</span> extra</span><br></pre></td></tr></table></figure><h3 id="4-2-在-buildSrc-当中定义"><a href="#4-2-在-buildSrc-当中定义" class="headerlink" title="4.2 在 buildSrc 当中定义"></a>4.2 在 buildSrc 当中定义</h3><p>buildSrc 当中的代码可以直接被 Gradle 脚本访问到，我们在工程当中创建 buildSrc 目录，并在其中添加 build.gradle.kts：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `kotlin-dsl`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    maven(<span class="string">&quot;https://mirrors.tencent.com/nexus/repository/maven-public/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在 src/main/kotlin 目录下编写需要的 Kotlin 代码了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinVersion = <span class="string">&quot;1.4.30&quot;</span></span><br><span class="line"><span class="keyword">val</span> slf4jVersion = <span class="string">&quot;1.7.21&quot;</span></span><br></pre></td></tr></table></figure><p>注意这文件没有包名，如果加了包名的话，后续脚本当中就需要导包，这个看实际情况决定是否需要。</p><p>使用也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath(<span class="string">&quot;com.android.tools.build:gradle:4.0.1&quot;</span>)</span><br><span class="line">    classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlinVersion</span>&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildSrc 的能力不只这么点儿了，大家有兴趣可以多多探索，也可以随时跟我交流。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>迁移的过程基本上就是 Groovy 与 Kotlin 语法的对照，所以需要大家对 Groovy 和 Kotlin 多少都要有些了解。视频讲这么细目的也是让大家知其然知其所以然，但如果只是单纯想要做个快速的迁移，可以试试 <a target="_blank" rel="noopener" href="https://github.com/bernaferrari/GradleKotlinConverter">bernaferrari/GradleKotlinConverter</a> 这个项目，其实它的原理就是正则表达式匹配和替换。</p><p>本来只是想做这样一个迁移的例子，没想到发散出这么多话题。整个过程当中我其实也发现了一些过去不知道的细节，还是非常有趣的。</p><p>希望对大家有帮助。谢谢大家。</p><hr><p>C 语言是所有程序员应当认真掌握的基础语言，不管你是 Java 还是 Python 开发者，欢迎大家关注我的新课 《C 语言系统精讲》：</p><p><strong>扫描二维码或者点击链接<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/463.html">《C 语言系统精讲》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/program_in_c.png"></p><hr><p>Kotlin 协程对大多数初学者来讲都是一个噩梦，即便是有经验的开发者，对于协程的理解也仍然是懵懵懂懂。如果大家有同样的问题，不妨阅读一下我的新书《深入理解 Kotlin 协程》，彻底搞懂 Kotlin 协程最难的知识点：</p><p><strong>扫描二维码或者点击链接<a target="_blank" rel="noopener" href="https://item.jd.com/12898592.html">《深入理解 Kotlin 协程》</a>购买本书</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9e300468-a645-433d-ae41-60b3eaa97f5a/media/understanding_kotlin_coroutines.png"></p><hr><p>如果大家想要快速上手 Kotlin 或者想要全面深入地学习 Kotlin 的相关知识，可以关注我基于 Kotlin 1.3.50 全新制作的入门课程：</p><p><strong>扫描二维码或者点击链接<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/398.html">《Kotlin 入门到精通》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/40b0da7d-0147-44b3-9d08-5755dbf33b0b/media/exported_qrcode_image_256.png"></p><hr><p>Android 工程师也可以关注下《破解Android高级面试》，这门课涉及内容均非浅尝辄止，除知识点讲解外更注重培养高级工程师意识：</p><p><strong>扫描二维码或者点击链接<a target="_blank" rel="noopener" href="https://s.imooc.com/SBS30PR">《破解Android高级面试》</a>即可进入课程</strong></p><p><img src="https://kotlinblog-1251218094.costj.myqcloud.com/9ab6e571-684b-4108-9600-a9e3981e7aca/media/15520936284634.jpg"></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/kotlin/" rel="tag"># Kotlin</a> <a href="/tags/gradle/" rel="tag"># Gradle</a> <a href="/tags/groovy/" rel="tag"># Groovy</a> <a href="/tags/kts/" rel="tag"># KTS</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/04/11/gradle-task-syntax/" rel="prev" title="Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？"><i class="fa fa-chevron-left"></i> Gradle 创建 Task 的写法不是 Groovy 的标准语法吧？</a></div><div class="post-nav-item"><a href="/2021/04/17/Add-extensions-to-build-scripts/" rel="next" title="如何为 Gradle 的 KTS 脚本添加扩展？">如何为 Gradle 的 KTS 脚本添加扩展？ <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Benny Huo</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">496k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">15:01</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"FicBFjnnYPST748WV6dmgumh-gzGzoHsz","app_key":"9GE81hTRn176FdLAdUrJBWON","server_url":null,"security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"bennyhuo","repo":"Bennyhuo","client_id":"7d2353275afc8d2a5ba3","client_secret":"b43a5cabf6064d62cd3fea35adde9609ca49887f","admin_user":"bennyhuo","distraction_free_mode":true,"proxy":"https://silent-lake-5dba.bennyhuo.workers.dev/?https://github.com/login/oauth/access_token","language":"zh-CN","owner":"bennyhuo","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"de0ebe910beb97902e246a0a1f7efd59"}</script><script src="/js/third-party/comments/gitalk.js"></script></body></html>